{
    "Math-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "return dim * FastMath.PI, - mean / 2) * 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-11/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\t2022-07-19 15:53:11.089857075 +0200\n+++ /tmp/tmpn6lqtjib.java\t2022-07-19 15:53:11.161856574 +0200\n@@ -178,11 +178,11 @@\n         final int dim = getDimension();\n         if (vals.length != dim) {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+return dim * FastMath.PI, - mean / 2) * 0;\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return dim * FastMath.PI, -dim / 2) * sign;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-11/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\t2022-07-19 15:53:13.709838946 +0200\n+++ /tmp/tmpwgtplpyu.java\t2022-07-19 15:53:13.725838835 +0200\n@@ -178,11 +178,11 @@\n         final int dim = getDimension();\n         if (vals.length != dim) {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+return dim * FastMath.PI, -dim / 2) * sign;\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return dim * FastMath.PI, -dim / 2) * 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-11/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\t2022-07-19 15:53:15.729824971 +0200\n+++ /tmp/tmpbplm8nlv.java\t2022-07-19 15:53:15.729824971 +0200\n@@ -178,11 +178,11 @@\n         final int dim = getDimension();\n         if (vals.length != dim) {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+return dim * FastMath.PI, -dim / 2) * 0;\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return dim * FastMath.PI, - mean / 2) * 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-11/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\t2022-07-19 15:53:17.773810827 +0200\n+++ /tmp/tmpqarkxvxg.java\t2022-07-19 15:53:17.773810827 +0200\n@@ -178,11 +178,11 @@\n         final int dim = getDimension();\n         if (vals.length != dim) {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+return dim * FastMath.PI, - mean / 2) * 1;\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return dim * FastMath.PI, -dim / 2 *",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-11/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\t2022-07-19 15:53:19.825796630 +0200\n+++ /tmp/tmpjevzw0b3.java\t2022-07-19 15:53:19.825796630 +0200\n@@ -178,11 +178,11 @@\n         final int dim = getDimension();\n         if (vals.length != dim) {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+return dim * FastMath.PI, -dim / 2 *\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return dim * FastMath.PI, - mean / 2) * sign;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-11/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\t2022-07-19 15:53:21.821782821 +0200\n+++ /tmp/tmp0k5qi4cv.java\t2022-07-19 15:53:21.821782821 +0200\n@@ -178,11 +178,11 @@\n         final int dim = getDimension();\n         if (vals.length != dim) {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+return dim * FastMath.PI, - mean / 2) * sign;\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return dim * FastMath.PI, -1, -1 *",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-11/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\t2022-07-19 15:53:23.825768955 +0200\n+++ /tmp/tmpew5ihalc.java\t2022-07-19 15:53:23.825768955 +0200\n@@ -178,11 +178,11 @@\n         final int dim = getDimension();\n         if (vals.length != dim) {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+return dim * FastMath.PI, -1, -1 *\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return dim * FastMath.PI, -dim / 2) *",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-11/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\t2022-07-19 15:53:25.805755256 +0200\n+++ /tmp/tmp5e6w17a8.java\t2022-07-19 15:53:25.805755256 +0200\n@@ -178,11 +178,11 @@\n         final int dim = getDimension();\n         if (vals.length != dim) {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+return dim * FastMath.PI, -dim / 2) *\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return dim * FastMath.PI, - mean / 2) *",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-11/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\t2022-07-19 15:53:27.837741196 +0200\n+++ /tmp/tmpfw0bkh96.java\t2022-07-19 15:53:27.837741196 +0200\n@@ -178,11 +178,11 @@\n         final int dim = getDimension();\n         if (vals.length != dim) {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+return dim * FastMath.PI, - mean / 2) *\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return dim * FastMath.PI, - mean / 2, 11 *",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-11/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\t2022-07-19 15:53:29.925726748 +0200\n+++ /tmp/tmp9djcw8dh.java\t2022-07-19 15:53:29.929726722 +0200\n@@ -178,11 +178,11 @@\n         final int dim = getDimension();\n         if (vals.length != dim) {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+return dim * FastMath.PI, - mean / 2, 11 *\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return FastMath.pow(2 * FastMath.PI, -dim / 2) *",
        "fixed_line": "return FastMath.pow(2 * FastMath.PI, -0.5 * dim) *"
    },
    "JacksonDatabind-49": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if (tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "// if (tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// throw new IllegalArgumentException(\"alwaysAsId\", // object (tatu: As per [JACKSON-407] -- allow disabling wrapping for POJO;",
                "patch_diff": "// throw new IllegalArgumentException(\"alwaysAsId\", // object (tatu: As per [JACKSON-407] -- allow disabling wrapping for POJO;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// throw new IllegalArgumentException(\"alwaysAsId\", // object (tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "// throw new IllegalArgumentException(\"alwaysAsId\", // object (tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// if (tatu:: declaredType.isAssignableFrom(tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "// if (tatu:: declaredType.isAssignableFrom(tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// if (tatu:: declaredType.isAssignableFrom(tatu: As per [JACKSON-407] -- allow disabling wrapping for POJO;",
                "patch_diff": "// if (tatu:: declaredType.isAssignableFrom(tatu: As per [JACKSON-407] -- allow disabling wrapping for POJO;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if (tatu: As per [JACKSON-407] -- allow disabling wrapping for POJO;",
                "patch_diff": "// if (tatu: As per [JACKSON-407] -- allow disabling wrapping for POJO;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// if (tatu: As per [JACKSON-407] -- allow disabling wrapping for \"alwaysAsId\", // object (forPojo)",
                "patch_diff": "// if (tatu: As per [JACKSON-407] -- allow disabling wrapping for \"alwaysAsId\", // object (forPojo)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// throw new IllegalArgumentException(\"alwaysAsId\", // object (tatu: As per [JACKSON-407] -- allow disabling wrapping for POJO; ) {",
                "patch_diff": "// throw new IllegalArgumentException(\"alwaysAsId\", // object (tatu: As per [JACKSON-407] -- allow disabling wrapping for POJO; ) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// throw new IllegalArgumentException(\"alwaysAsId\", // object (tatu: As per [JACKSON-407] -- allow disabling wrapping for \"alwaysAsId\",",
                "patch_diff": "// throw new IllegalArgumentException(\"alwaysAsId\", // object (tatu: As per [JACKSON-407] -- allow disabling wrapping for \"alwaysAsId\",",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// throw new IllegalArgumentException(\"alwaysAsId\", // object (tatu: As per [JACKSON-407] -- allow disabling wrapping for \"alwaysAsId\", // object (forPojo)",
                "patch_diff": "// throw new IllegalArgumentException(\"alwaysAsId\", // object (tatu: As per [JACKSON-407] -- allow disabling wrapping for \"alwaysAsId\", // object (forPojo)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (id == null) { id = generator.generateId(forPojo); }"
    },
    "Csv-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "public static final CSVFormat EXCEL = DEFAULT_IgnoreEmptyLines.withIgnoreEmptyLines(false);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-12/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 15:53:33.937698992 +0200\n+++ /tmp/tmp37o5_576.java\t2022-07-19 15:53:33.993698602 +0200\n@@ -214,11 +214,11 @@\n      * </ul>\n      * <p>\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n+public static final CSVFormat EXCEL = DEFAULT_IgnoreEmptyLines.withIgnoreEmptyLines(false);\n \n     /**\n      * Tab-delimited format.\n      *\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "public static final CSVFormat EXCEL = DEFAULT_NAMEIgnoreEmptyLines.withIgnoreEmptyLines(false);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-12/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 15:53:35.773686286 +0200\n+++ /tmp/tmpceal96up.java\t2022-07-19 15:53:35.777686260 +0200\n@@ -214,11 +214,11 @@\n      * </ul>\n      * <p>\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n+public static final CSVFormat EXCEL = DEFAULT_NAMEIgnoreEmptyLines.withIgnoreEmptyLines(false);\n \n     /**\n      * Tab-delimited format.\n      *\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "public static final CSVFormat EXCEL = DEFAULT_IgnoreEmptyLines.withIgnoreEmptyLines(valueType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-12/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 15:53:37.413674941 +0200\n+++ /tmp/tmp_pl8x555.java\t2022-07-19 15:53:37.413674941 +0200\n@@ -214,11 +214,11 @@\n      * </ul>\n      * <p>\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n+public static final CSVFormat EXCEL = DEFAULT_IgnoreEmptyLines.withIgnoreEmptyLines(valueType);\n \n     /**\n      * Tab-delimited format.\n      *\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "public static final CSVFormat EXCEL = DEFAULT_anyIgnoreEmptyLines.withIgnoreEmptyLines(valueType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-12/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 15:53:39.105663234 +0200\n+++ /tmp/tmpdt1l4uc2.java\t2022-07-19 15:53:39.105663234 +0200\n@@ -214,11 +214,11 @@\n      * </ul>\n      * <p>\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n+public static final CSVFormat EXCEL = DEFAULT_anyIgnoreEmptyLines.withIgnoreEmptyLines(valueType);\n \n     /**\n      * Tab-delimited format.\n      *\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "public static final CSVFormat EXCEL = DEFAULT_IgnoreEmptyLines.withIgnoreEmptyLines(true);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-12/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 15:53:40.725652026 +0200\n+++ /tmp/tmpy3w1kyk8.java\t2022-07-19 15:53:40.725652026 +0200\n@@ -214,11 +214,11 @@\n      * </ul>\n      * <p>\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n+public static final CSVFormat EXCEL = DEFAULT_IgnoreEmptyLines.withIgnoreEmptyLines(true);\n \n     /**\n      * Tab-delimited format.\n      *\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "public static final CSVFormat EXCEL = DEFAULT_ONEmptyLines.withIgnoreEmptyLines(false);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-12/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 15:53:42.305641092 +0200\n+++ /tmp/tmpjmua1wou.java\t2022-07-19 15:53:42.309641066 +0200\n@@ -214,11 +214,11 @@\n      * </ul>\n      * <p>\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n+public static final CSVFormat EXCEL = DEFAULT_ONEmptyLines.withIgnoreEmptyLines(false);\n \n     /**\n      * Tab-delimited format.\n      *\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "public static final CSVFormat EXCEL = DEFAULT_semEmptyEmptyLines.withIgnoreEmptyLines(false);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-12/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 15:53:43.985629468 +0200\n+++ /tmp/tmpqdka7r4d.java\t2022-07-19 15:53:43.985629468 +0200\n@@ -214,11 +214,11 @@\n      * </ul>\n      * <p>\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n+public static final CSVFormat EXCEL = DEFAULT_semEmptyEmptyLines.withIgnoreEmptyLines(false);\n \n     /**\n      * Tab-delimited format.\n      *\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "public static final CSVFormat EXCEL = DEFAULT_anyIgnoreEmptyLines.withIgnoreEmptyLines(true);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-12/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 15:53:45.581618426 +0200\n+++ /tmp/tmpcst9dcdz.java\t2022-07-19 15:53:45.581618426 +0200\n@@ -214,11 +214,11 @@\n      * </ul>\n      * <p>\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n+public static final CSVFormat EXCEL = DEFAULT_anyIgnoreEmptyLines.withIgnoreEmptyLines(true);\n \n     /**\n      * Tab-delimited format.\n      *\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "public static final CSVFormat EXCEL = DEFAULT_anyIgnoreEmptyLines.withIgnoreEmptyLines(false);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-12/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 15:53:47.249606887 +0200\n+++ /tmp/tmpg98a7s5a.java\t2022-07-19 15:53:47.249606887 +0200\n@@ -214,11 +214,11 @@\n      * </ul>\n      * <p>\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n+public static final CSVFormat EXCEL = DEFAULT_anyIgnoreEmptyLines.withIgnoreEmptyLines(false);\n \n     /**\n      * Tab-delimited format.\n      *\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "public static final CSVFormat EXCEL = DEFAULT_anyIgnoreEmptyLines.withIgnoreEmptyLinesIgnored;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-12/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 15:53:48.941595179 +0200\n+++ /tmp/tmpw2swbt1z.java\t2022-07-19 15:53:48.941595179 +0200\n@@ -214,11 +214,11 @@\n      * </ul>\n      * <p>\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n+public static final CSVFormat EXCEL = DEFAULT_anyIgnoreEmptyLines.withIgnoreEmptyLinesIgnored;\n \n     /**\n      * Tab-delimited format.\n      *\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);",
        "fixed_line": "public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true);"
    },
    "Closure-121": {
        "fixes": [
            {
                "k": 1,
                "patch": "referenceInfo.isAssignedOnceInLit = candidate.references;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-121/src/com/google/javascript/jscomp/InlineVariables.java\t2022-07-19 15:53:50.701583004 +0200\n+++ /tmp/tmp51n_it2q.java\t2022-07-19 15:53:50.725582835 +0200\n@@ -299,11 +299,11 @@\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+referenceInfo.isAssignedOnceInLit = candidate.references;\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "referenceInfo.isAssignedOnceInLit(candidate)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-121/src/com/google/javascript/jscomp/InlineVariables.java\t2022-07-19 15:53:56.245544643 +0200\n+++ /tmp/tmpej9khgi3.java\t2022-07-19 15:53:56.249544615 +0200\n@@ -299,11 +299,11 @@\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+referenceInfo.isAssignedOnceInLit(candidate)) {\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "referenceInfo.isAssignedOnceInLit(candidate) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-121/src/com/google/javascript/jscomp/InlineVariables.java\t2022-07-19 15:53:59.869519569 +0200\n+++ /tmp/tmpuy7gnyi3.java\t2022-07-19 15:53:59.869519569 +0200\n@@ -299,11 +299,11 @@\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+referenceInfo.isAssignedOnceInLit(candidate) {\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "referenceInfo.isAssignedOnceInLTA; {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-121/src/com/google/javascript/jscomp/InlineVariables.java\t2022-07-19 15:54:03.237496266 +0200\n+++ /tmp/tmp7btktzp6.java\t2022-07-19 15:54:03.237496266 +0200\n@@ -299,11 +299,11 @@\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+referenceInfo.isAssignedOnceInLTA; {\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "referenceInfo.isAssignedOnceInLit = candidate;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-121/src/com/google/javascript/jscomp/InlineVariables.java\t2022-07-19 15:54:06.609472936 +0200\n+++ /tmp/tmprdzvr799.java\t2022-07-19 15:54:06.609472936 +0200\n@@ -299,11 +299,11 @@\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+referenceInfo.isAssignedOnceInLit = candidate;\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "referenceInfo.isAssignedOnceInLTA;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-121/src/com/google/javascript/jscomp/InlineVariables.java\t2022-07-19 15:54:09.973449661 +0200\n+++ /tmp/tmpwhxgiofv.java\t2022-07-19 15:54:09.977449633 +0200\n@@ -299,11 +299,11 @@\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+referenceInfo.isAssignedOnceInLTA;\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "referenceInfo.isAssignedOnceInLit = candidate.references; {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-121/src/com/google/javascript/jscomp/InlineVariables.java\t2022-07-19 15:54:13.309426579 +0200\n+++ /tmp/tmp_63lkt8m.java\t2022-07-19 15:54:13.313426551 +0200\n@@ -299,11 +299,11 @@\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+referenceInfo.isAssignedOnceInLit = candidate.references; {\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "referenceInfo.isAssignedOnceInLifetime()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-121/src/com/google/javascript/jscomp/InlineVariables.java\t2022-07-19 15:54:16.857402031 +0200\n+++ /tmp/tmp4py4m6kl.java\t2022-07-19 15:54:16.857402031 +0200\n@@ -299,11 +299,11 @@\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+referenceInfo.isAssignedOnceInLifetime()) {\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "referenceInfo.isAssignedOnceInLit()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-121/src/com/google/javascript/jscomp/InlineVariables.java\t2022-07-19 15:55:08.457045016 +0200\n+++ /tmp/tmpo7vdef5a.java\t2022-07-19 15:55:08.457045016 +0200\n@@ -299,11 +299,11 @@\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+referenceInfo.isAssignedOnceInLit()) {\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "referenceInfo.isAssignedOnceInLvisible;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-121/src/com/google/javascript/jscomp/InlineVariables.java\t2022-07-19 15:55:12.061020080 +0200\n+++ /tmp/tmpq2izdmrs.java\t2022-07-19 15:55:12.061020080 +0200\n@@ -299,11 +299,11 @@\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+referenceInfo.isAssignedOnceInLvisible;\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "referenceInfo.isAssignedOnceInLifetime()) {",
        "fixed_line": "referenceInfo.isAssignedOnceInLifetime() && // Inlining the variable based solely on well-defined and assigned // once is *NOT* correct. We relax the correctness requirement if // the variable is declared constant. (isInlineableDeclaredConstant(v, referenceInfo) || referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) {"
    },
    "Gson-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if it's do implicit re-parse",
                "patch_diff": "// if it's do implicit re-parse",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// no minutes,'s do implicit re-parse",
                "patch_diff": "// no minutes,'s do implicit re-parse",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if it's do implicit re-initialized or EMPTY",
                "patch_diff": "// if it's do implicit re-initialized or EMPTY",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// no minutes, need to check",
                "patch_diff": "// no minutes, need to check",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// no minutes,'s do implicit re-initialized or EMPTY",
                "patch_diff": "// no minutes,'s do implicit re-initialized or EMPTY",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// no minutes, need to do this",
                "patch_diff": "// no minutes, need to do this",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// no minutes, need to do a marker to indicate explicit disabling of",
                "patch_diff": "// no minutes, need to do a marker to indicate explicit disabling of",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// no minutes, need to do a marker to indicate explicit disabling of \"+0000\". return; }",
                "patch_diff": "// no minutes, need to do a marker to indicate explicit disabling of \"+0000\". return; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// no minutes, need to do a marker to indicate explicit disabling of \"+varOffset); }",
                "patch_diff": "// no minutes, need to do a marker to indicate explicit disabling of \"+varOffset); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// no minutes, need to do a marker to indicate explicit disabling of \"+varOffset;",
                "patch_diff": "// no minutes, need to do a marker to indicate explicit disabling of \"+varOffset;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "timezoneOffset = timezoneOffset.length() >= 5 ? timezoneOffset : timezoneOffset + \"00\";"
    },
    "Closure-10": {
        "fixes": [
            {
                "k": 1,
                "patch": "return allResultsMatch(lhs, n, recurse);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-10/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 15:55:17.188984599 +0200\n+++ /tmp/tmpbuwaaz7k.java\t2022-07-19 15:55:17.212984433 +0200\n@@ -1412,11 +1412,11 @@\n     return mayBeString(n, true);\n   }\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+return allResultsMatch(lhs, n, recurse);\n     } else {\n       return mayBeStringHelper(n);\n     }\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return allResultsMatch(lhs, n, recurse;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-10/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 15:55:22.172950115 +0200\n+++ /tmp/tmpczu75irp.java\t2022-07-19 15:55:22.176950089 +0200\n@@ -1412,11 +1412,11 @@\n     return mayBeString(n, true);\n   }\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+return allResultsMatch(lhs, n, recurse;\n     } else {\n       return mayBeStringHelper(n);\n     }\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return allResultsMatch(lhs, n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-10/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 15:55:25.704925677 +0200\n+++ /tmp/tmp836bbkrw.java\t2022-07-19 15:55:25.708925651 +0200\n@@ -1412,11 +1412,11 @@\n     return mayBeString(n, true);\n   }\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+return allResultsMatch(lhs, n);\n     } else {\n       return mayBeStringHelper(n);\n     }\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return allResultsMatch(n, recurse;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-10/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 15:55:29.240901213 +0200\n+++ /tmp/tmp0ysuvlw0.java\t2022-07-19 15:55:29.244901184 +0200\n@@ -1412,11 +1412,11 @@\n     return mayBeString(n, true);\n   }\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+return allResultsMatch(n, recurse;\n     } else {\n       return mayBeStringHelper(n);\n     }\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return allResultsMatch(file, n, recurse);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-10/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 15:55:32.768876804 +0200\n+++ /tmp/tmpn8euopo5.java\t2022-07-19 15:55:32.772876776 +0200\n@@ -1412,11 +1412,11 @@\n     return mayBeString(n, true);\n   }\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+return allResultsMatch(file, n, recurse);\n     } else {\n       return mayBeStringHelper(n);\n     }\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return allResultsMatch(n, recurse);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-10/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 15:55:36.324852199 +0200\n+++ /tmp/tmp6_jj_ap6.java\t2022-07-19 15:55:36.328852171 +0200\n@@ -1412,11 +1412,11 @@\n     return mayBeString(n, true);\n   }\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+return allResultsMatch(n, recurse);\n     } else {\n       return mayBeStringHelper(n);\n     }\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return allResultsMatch( can, n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-10/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 15:55:39.796828177 +0200\n+++ /tmp/tmprlvr0dzw.java\t2022-07-19 15:55:39.800828148 +0200\n@@ -1412,11 +1412,11 @@\n     return mayBeString(n, true);\n   }\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+return allResultsMatch( can, n);\n     } else {\n       return mayBeStringHelper(n);\n     }\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return allResultsMatch( n, recurse);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-10/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 15:55:43.312803851 +0200\n+++ /tmp/tmpjwed4umd.java\t2022-07-19 15:55:43.316803823 +0200\n@@ -1412,11 +1412,11 @@\n     return mayBeString(n, true);\n   }\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+return allResultsMatch( n, recurse);\n     } else {\n       return mayBeStringHelper(n);\n     }\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return quadrantMatch(n, recurse);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-10/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 15:55:46.988778416 +0200\n+++ /tmp/tmpy1hb3new.java\t2022-07-19 15:55:46.988778416 +0200\n@@ -1412,11 +1412,11 @@\n     return mayBeString(n, true);\n   }\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+return quadrantMatch(n, recurse);\n     } else {\n       return mayBeStringHelper(n);\n     }\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return allResultsMatch( n, recurse;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-10/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 15:55:50.548753785 +0200\n+++ /tmp/tmpw8nqqwtk.java\t2022-07-19 15:55:50.548753785 +0200\n@@ -1412,11 +1412,11 @@\n     return mayBeString(n, true);\n   }\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+return allResultsMatch( n, recurse;\n     } else {\n       return mayBeStringHelper(n);\n     }\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return allResultsMatch(n, MAY_BE_STRING_PREDICATE);",
        "fixed_line": "return anyResultsMatch(n, MAY_BE_STRING_PREDICATE);"
    },
    "Csv-15": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (c < 0x20 || c > 0x23 || c < 0x23 || c > 0x2D || c < 0x7E)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-15/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 15:55:54.276727992 +0200\n+++ /tmp/tmpv_9u49wq.java\t2022-07-19 15:55:54.308727772 +0200\n@@ -1184,13 +1184,11 @@\n                     quote = true;\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n+if (c < 0x20 || c > 0x23 || c < 0x23 || c > 0x2D || c < 0x7E)) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n                     quote = true;\n                 } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (c < 0x20 || c > 0x23 || c < 0x2B || c > 0x7E)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-15/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 15:55:55.980716202 +0200\n+++ /tmp/tmpfce0zmoh.java\t2022-07-19 15:55:56.004716037 +0200\n@@ -1184,13 +1184,11 @@\n                     quote = true;\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n+if (c < 0x20 || c > 0x23 || c < 0x2B || c > 0x7E)) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n                     quote = true;\n                 } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (c < 0x20 || c > 0x2 || c < 0x23 || c > 0x2D || c < 0x7E)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-15/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 15:55:57.492705740 +0200\n+++ /tmp/tmpyjan0alu.java\t2022-07-19 15:55:57.492705740 +0200\n@@ -1184,13 +1184,11 @@\n                     quote = true;\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n+if (c < 0x20 || c > 0x2 || c < 0x23 || c > 0x2D || c < 0x7E)) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n                     quote = true;\n                 } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (c < 0x20 || c > 0x1 && c < 0x2B || c > 0x2D || c < 0x7E)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-15/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 15:55:59.076694780 +0200\n+++ /tmp/tmphnq5k3lw.java\t2022-07-19 15:55:59.080694754 +0200\n@@ -1184,13 +1184,11 @@\n                     quote = true;\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n+if (c < 0x20 || c > 0x1 && c < 0x2B || c > 0x2D || c < 0x7E)) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n                     quote = true;\n                 } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (c < 0x20 || c > 0x23 || c < 0x07 || c > 0x2D || c < 0x7E)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-15/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 15:56:00.616684126 +0200\n+++ /tmp/tmpgzu5p1rv.java\t2022-07-19 15:56:00.616684126 +0200\n@@ -1184,13 +1184,11 @@\n                     quote = true;\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n+if (c < 0x20 || c > 0x23 || c < 0x07 || c > 0x2D || c < 0x7E)) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n                     quote = true;\n                 } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (c < 0x20 || c > 0x07 || c < 0x2B || c > 0x7E)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-15/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 15:56:02.172673361 +0200\n+++ /tmp/tmprp20mmsi.java\t2022-07-19 15:56:02.172673361 +0200\n@@ -1184,13 +1184,11 @@\n                     quote = true;\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n+if (c < 0x20 || c > 0x07 || c < 0x2B || c > 0x7E)) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n                     quote = true;\n                 } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (c < 0x20 || c > 0x07 || c < 0x3D || c > 0x7E)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-15/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 15:56:03.764662344 +0200\n+++ /tmp/tmpr7kzicfc.java\t2022-07-19 15:56:03.764662344 +0200\n@@ -1184,13 +1184,11 @@\n                     quote = true;\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n+if (c < 0x20 || c > 0x07 || c < 0x3D || c > 0x7E)) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n                     quote = true;\n                 } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (c < 0x20 || c > 0x23 || c < 0x2B && c > 0x7E)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-15/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 15:56:05.324651553 +0200\n+++ /tmp/tmp1_05yk77.java\t2022-07-19 15:56:05.324651553 +0200\n@@ -1184,13 +1184,11 @@\n                     quote = true;\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n+if (c < 0x20 || c > 0x23 || c < 0x2B && c > 0x7E)) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n                     quote = true;\n                 } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (c < 0x20 || c > 0x07 || c < 0x2B && c > 0x7E)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-15/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 15:56:06.936640399 +0200\n+++ /tmp/tmpgknba5m9.java\t2022-07-19 15:56:06.940640371 +0200\n@@ -1184,13 +1184,11 @@\n                     quote = true;\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n+if (c < 0x20 || c > 0x07 || c < 0x2B && c > 0x7E)) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n                     quote = true;\n                 } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (c < 0x20 || c > 0x23 || c < 0x3D || c > 0x7E)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-15/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 15:56:08.396630297 +0200\n+++ /tmp/tmpwz5fnnqw.java\t2022-07-19 15:56:08.396630297 +0200\n@@ -1184,13 +1184,11 @@\n                     quote = true;\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n+if (c < 0x20 || c > 0x23 || c < 0x3D || c > 0x7E)) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n                     quote = true;\n                 } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) { quote = true; } else if (c <= COMMENT) {",
        "fixed_line": "if (c <= COMMENT) {"
    },
    "Lang-14": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (checkNext == null || cs2 == null) { return false; }",
                "patch_diff": "} else if (checkNext == null || cs2 == null) { return false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (c == null || cs2 == null) { return false; }",
                "patch_diff": "} else if (c == null || cs2 == null) { return false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (c == null || cs2 == null || cs2.equals(cs2); }",
                "patch_diff": "} else if (c == null || cs2 == null || cs2.equals(cs2); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (c == null || cs2 == null) { return cs2.equals(cs2); } else { return false; }",
                "patch_diff": "} else if (c == null || cs2 == null) { return cs2.equals(cs2); } else { return false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (c == null || cs2 == null) { return cs1.equals(cs2); } else { return false; }",
                "patch_diff": "} else if (c == null || cs2 == null) { return cs1.equals(cs2); } else { return false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = 0; i < null || cs2 == null || cs2.equals(m2); }",
                "patch_diff": "for (int i = 0; i < null || cs2 == null || cs2.equals(m2); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (checkNext == null || cs2 == null) { return cs1.equals(cs2); } else { return false; }",
                "patch_diff": "} else if (checkNext == null || cs2 == null) { return cs1.equals(cs2); } else { return false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = 0; i!= null && cs2!= null) {",
                "patch_diff": "for (int i = 0; i!= null && cs2!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (c == null || cs2 == null) { return cs1.equals(cs2); }",
                "patch_diff": "} else if (c == null || cs2 == null) { return cs1.equals(cs2); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (checkNext == null || cs2 == null) {",
                "patch_diff": "} else if (checkNext == null || cs2 == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));"
    },
    "Jsoup-38": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if ( tb.equals(\"image\")) {",
                "patch_diff": "} else if ( tb.equals(\"image\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (this.equals(\"image\")) {",
                "patch_diff": "} else if (this.equals(\"image\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (name.equals(\"image\")) {",
                "patch_diff": "} else if (name.equals(\"image\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (source.equals(\"image\")) {",
                "patch_diff": "} else if (source.equals(\"image\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (q.equals(\"image\")) {",
                "patch_diff": "} else if (q.equals(\"image\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if ( tb.getFormElement() == null) {",
                "patch_diff": "} else if ( tb.getFormElement() == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (this.name.equals(\"image\")) {",
                "patch_diff": "} else if (this.name.equals(\"image\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (this.name.equals(\"OVER\")) {",
                "patch_diff": "} else if (this.name.equals(\"OVER\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (name.equals(\"OVER\")) {",
                "patch_diff": "} else if (name.equals(\"OVER\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if ( tb.name(\"img\")) {",
                "patch_diff": "} else if ( tb.name(\"img\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (tb.getFromStack(\"svg\") == null) return tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg else tb.insert(startTag);"
    },
    "Chart-4": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (a instanceof XYAnnotation) {",
                "patch_diff": "if (a instanceof XYAnnotation) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (a instanceof XYAnnotation) {",
                "patch_diff": "} else if (a instanceof XYAnnotation) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0; i < a.length; i++) {",
                "patch_diff": "for (int i = 0; i < a.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = 0; i < num.length; i++) {",
                "patch_diff": "for (int i = 0; i < num.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (i = 0; it.hasNext();) {",
                "patch_diff": "for (i = 0; it.hasNext();) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (a instanceof XYAnnotationBounds) {",
                "patch_diff": "if (a instanceof XYAnnotationBounds) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = 0; i < i; ++i) {",
                "patch_diff": "for (int i = 0; i < i; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = 0; i < i; i++) {",
                "patch_diff": "for (int i = 0; i < i; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int i = 0; i < c.length; i++) {",
                "patch_diff": "for (int i = 0; i < c.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = 0; i < a.length; i++) { if (i.hasNext()) {",
                "patch_diff": "for (int i = 0; i < a.length; i++) { if (i.hasNext()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (r != null) { Collection c = r.getAnnotations(); Iterator i = c.iterator(); while (i.hasNext()) { XYAnnotation a = (XYAnnotation) i.next(); if (a instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(a); } } }"
    },
    "Closure-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "boolean hasExceptionHandler(cfgNode, cfgNode, ReachingUses) {",
                "patch_diff": "boolean hasExceptionHandler(cfgNode, cfgNode, ReachingUses) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} private boolean hasExceptionHandler(cfgNode, cfgNode, ReachingUses output);",
                "patch_diff": "} private boolean hasExceptionHandler(cfgNode, cfgNode, ReachingUses output);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "boolean hasExceptionHandler(cfgNode, cfgNode, ReachingUses output);",
                "patch_diff": "boolean hasExceptionHandler(cfgNode, cfgNode, ReachingUses output);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "boolean hasExceptionHandler(cfgNode, cfgNode, ReachingUses);",
                "patch_diff": "boolean hasExceptionHandler(cfgNode, cfgNode, ReachingUses);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private boolean hasExceptionHandler(cfgNode, cfgNode, ReachingUses output);",
                "patch_diff": "private boolean hasExceptionHandler(cfgNode, cfgNode, ReachingUses output);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} private boolean hasExceptionHandler(cfgNode, cfgNode, ReachingUses output, conditional);",
                "patch_diff": "} private boolean hasExceptionHandler(cfgNode, cfgNode, ReachingUses output, conditional);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private boolean hasExceptionHandler(cfgNode, cfgNode, ReachingUses) {",
                "patch_diff": "private boolean hasExceptionHandler(cfgNode, cfgNode, ReachingUses) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} private boolean hasExceptionHandler(cfgNode, cfgNode, ReachingUses) {",
                "patch_diff": "} private boolean hasExceptionHandler(cfgNode, cfgNode, ReachingUses) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private boolean hasExceptionHandler(cfgNode, cfgNode, ReachingUses);",
                "patch_diff": "private boolean hasExceptionHandler(cfgNode, cfgNode, ReachingUses);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "boolean hasExceptionHandler(cfgNode, cfgNode, ReachingUses output, conditional);",
                "patch_diff": "boolean hasExceptionHandler(cfgNode, cfgNode, ReachingUses output, conditional);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode); for (DiGraphEdge<Node, Branch> edge : branchEdges) { if (edge.getValue() == Branch.ON_EX) { return true; } }"
    },
    "Math-8": {
        "fixes": [
            {
                "k": 1,
                "patch": "public T[] sampleSize = this.numberOfArgsPositiveException;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\t2022-07-19 15:56:16.776572319 +0200\n+++ /tmp/tmpdjx_rvet.java\t2022-07-19 15:56:16.836571903 +0200\n@@ -176,17 +176,11 @@\n      * @param sampleSize the number of random values to generate.\n      * @return an array representing the random sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n-        if (sampleSize <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n-                    sampleSize);\n-        }\n-\n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+public T[] sampleSize = this.numberOfArgsPositiveException;\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "public T[] sampleSize = new NotStrictlyPositiveException(Constants.MILLIS_OF_DAYS_OUT_OF_WEEK;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\t2022-07-19 15:56:19.444553857 +0200\n+++ /tmp/tmp9aa1j4io.java\t2022-07-19 15:56:19.444553857 +0200\n@@ -176,17 +176,11 @@\n      * @param sampleSize the number of random values to generate.\n      * @return an array representing the random sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n-        if (sampleSize <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n-                    sampleSize);\n-        }\n-\n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+public T[] sampleSize = new NotStrictlyPositiveException(Constants.MILLIS_OF_DAYS_OUT_OF_WEEK;\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "public T[] sampleSize = new NotStrictlyPositiveException(Constants.MILLIS_OF_DAYS_PER_WEEK;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\t2022-07-19 15:56:21.420540186 +0200\n+++ /tmp/tmpc96ib8mj.java\t2022-07-19 15:56:21.420540186 +0200\n@@ -176,17 +176,11 @@\n      * @param sampleSize the number of random values to generate.\n      * @return an array representing the random sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n-        if (sampleSize <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n-                    sampleSize);\n-        }\n-\n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+public T[] sampleSize = new NotStrictlyPositiveException(Constants.MILLIS_OF_DAYS_PER_WEEK;\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "public T[] sampleSize = new NotStrictlyPositiveException(Constants.MILLIS_OF_DAYS_OUT_OF_MONTH;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\t2022-07-19 15:56:23.400526486 +0200\n+++ /tmp/tmpo_o2r6ag.java\t2022-07-19 15:56:23.400526486 +0200\n@@ -176,17 +176,11 @@\n      * @param sampleSize the number of random values to generate.\n      * @return an array representing the random sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n-        if (sampleSize <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n-                    sampleSize);\n-        }\n-\n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+public T[] sampleSize = new NotStrictlyPositiveException(Constants.MILLIS_OF_DAYS_OUT_OF_MONTH;\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "public T[] sampleSize = new NotStrictlyPositiveException(Constants.MILLIS_OF_DAYS_EXTENDED_OF_MONTH;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\t2022-07-19 15:56:25.400512649 +0200\n+++ /tmp/tmpu95_wzl8.java\t2022-07-19 15:56:25.400512649 +0200\n@@ -176,17 +176,11 @@\n      * @param sampleSize the number of random values to generate.\n      * @return an array representing the random sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n-        if (sampleSize <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n-                    sampleSize);\n-        }\n-\n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+public T[] sampleSize = new NotStrictlyPositiveException(Constants.MILLIS_OF_DAYS_EXTENDED_OF_MONTH;\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "public T[] sampleSize = this.serialDate;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\t2022-07-19 15:56:27.336499252 +0200\n+++ /tmp/tmp6hifn2lm.java\t2022-07-19 15:56:27.336499252 +0200\n@@ -176,17 +176,11 @@\n      * @param sampleSize the number of random values to generate.\n      * @return an array representing the random sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n-        if (sampleSize <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n-                    sampleSize);\n-        }\n-\n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+public T[] sampleSize = this.serialDate;\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "public T[] sampleSize = this.fixedStricts;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\t2022-07-19 15:56:29.260485940 +0200\n+++ /tmp/tmp60wyf_zm.java\t2022-07-19 15:56:29.260485940 +0200\n@@ -176,17 +176,11 @@\n      * @param sampleSize the number of random values to generate.\n      * @return an array representing the random sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n-        if (sampleSize <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n-                    sampleSize);\n-        }\n-\n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+public T[] sampleSize = this.fixedStricts;\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "public T[] sampleSize = new NotStrictlyPositiveException(Constants.MILLIS_OF_DAYS_OUT_OF_DAYS_OUT_OF_WEEK;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\t2022-07-19 15:56:31.260472103 +0200\n+++ /tmp/tmpyb6r5q8j.java\t2022-07-19 15:56:31.260472103 +0200\n@@ -176,17 +176,11 @@\n      * @param sampleSize the number of random values to generate.\n      * @return an array representing the random sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n-        if (sampleSize <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n-                    sampleSize);\n-        }\n-\n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+public T[] sampleSize = new NotStrictlyPositiveException(Constants.MILLIS_OF_DAYS_OUT_OF_DAYS_OUT_OF_WEEK;\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "public T[] sampleSize = this.fontSize;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\t2022-07-19 15:56:33.340457712 +0200\n+++ /tmp/tmp6eci7wyb.java\t2022-07-19 15:56:33.344457683 +0200\n@@ -176,17 +176,11 @@\n      * @param sampleSize the number of random values to generate.\n      * @return an array representing the random sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n-        if (sampleSize <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n-                    sampleSize);\n-        }\n-\n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+public T[] sampleSize = this.fontSize;\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "public T[] sampleSize = new NotStrictlyPositiveException(Constants.MILLIS_OF_DAYS_EXTENDED_OF_WEEK;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\t2022-07-19 15:56:35.400443459 +0200\n+++ /tmp/tmp15pfqvkx.java\t2022-07-19 15:56:35.400443459 +0200\n@@ -176,17 +176,11 @@\n      * @param sampleSize the number of random values to generate.\n      * @return an array representing the random sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n-        if (sampleSize <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n-                    sampleSize);\n-        }\n-\n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+public T[] sampleSize = new NotStrictlyPositiveException(Constants.MILLIS_OF_DAYS_EXTENDED_OF_WEEK;\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "public T[] sample(int sampleSize) throws NotStrictlyPositiveException { if (sampleSize <= 0) { throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize); } final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);",
        "fixed_line": "public Object[] sample(int sampleSize) throws NotStrictlyPositiveException { if (sampleSize <= 0) { throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize); } final Object[] out = new Object[sampleSize];"
    },
    "Closure-124": {
        "fixes": [
            {
                "k": 1,
                "patch": "node = node.isGetProp;",
                "patch_diff": "node = node.isGetProp;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "node = node.isGetProp(node.getString(), replacement;",
                "patch_diff": "node = node.isGetProp(node.getString(), replacement;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (node.isGetProp) && isNameAssignedTo(node.getString(), replacement)) {",
                "patch_diff": "if (node.isGetProp) && isNameAssignedTo(node.getString(), replacement)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (node.isGetProp(node.getString(), replacement)) {",
                "patch_diff": "if (node.isGetProp(node.getString(), replacement)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (node.isGetProp) && isNameAssignedTo(node.getString(), replacement;",
                "patch_diff": "if (node.isGetProp) && isNameAssignedTo(node.getString(), replacement;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return node.isGetProp(node.getString(), replacement;",
                "patch_diff": "return node.isGetProp(node.getString(), replacement;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (node.isGetProp) && isNameAssignedTo(node.getString(), replacement)) {",
                "patch_diff": "} else if (node.isGetProp) && isNameAssignedTo(node.getString(), replacement)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "node = node.isGetProp());",
                "patch_diff": "node = node.isGetProp());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (node.isGetProp(node.getString(), replacement)) {",
                "patch_diff": "} else if (node.isGetProp(node.getString(), replacement)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (node.isGetProp) && isNameAssignedTo(node.getString(), replacement;",
                "patch_diff": "} else if (node.isGetProp) && isNameAssignedTo(node.getString(), replacement;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "while (node.isGetProp()) { node = node.getFirstChild(); }"
    },
    "Math-52": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (u1!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\t2022-07-19 15:56:39.188417251 +0200\n+++ /tmp/tmpsvy0_ckd.java\t2022-07-19 15:56:39.216417057 +0200\n@@ -339,26 +339,11 @@\n   Vector3D v1Su1 = v1.subtract(u1);\n   Vector3D v2Su2 = v2.subtract(u2);\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);;\n-      c = k.dotProduct(u2.crossProduct(u3));;\n-\n-      if (c == 0) {\n+if (u1!= 0) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n         q1 = 0.0;\n         q2 = 0.0;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (u1 == v2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\t2022-07-19 15:56:41.508401198 +0200\n+++ /tmp/tmpwk9wbm80.java\t2022-07-19 15:56:41.508401198 +0200\n@@ -339,26 +339,11 @@\n   Vector3D v1Su1 = v1.subtract(u1);\n   Vector3D v2Su2 = v2.subtract(u2);\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);;\n-      c = k.dotProduct(u2.crossProduct(u3));;\n-\n-      if (c == 0) {\n+if (u1 == v2) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n         q1 = 0.0;\n         q2 = 0.0;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (c1!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\t2022-07-19 15:56:43.468387638 +0200\n+++ /tmp/tmpvsouez_9.java\t2022-07-19 15:56:43.472387610 +0200\n@@ -339,26 +339,11 @@\n   Vector3D v1Su1 = v1.subtract(u1);\n   Vector3D v2Su2 = v2.subtract(u2);\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);;\n-      c = k.dotProduct(u2.crossProduct(u3));;\n-\n-      if (c == 0) {\n+if (c1!= 0) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n         q1 = 0.0;\n         q2 = 0.0;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (k1!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\t2022-07-19 15:56:45.404374243 +0200\n+++ /tmp/tmpkcvx93dr.java\t2022-07-19 15:56:45.408374215 +0200\n@@ -339,26 +339,11 @@\n   Vector3D v1Su1 = v1.subtract(u1);\n   Vector3D v2Su2 = v2.subtract(u2);\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);;\n-      c = k.dotProduct(u2.crossProduct(u3));;\n-\n-      if (c == 0) {\n+if (k1!= 0) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n         q1 = 0.0;\n         q2 = 0.0;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (k1 == v2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\t2022-07-19 15:56:47.436360184 +0200\n+++ /tmp/tmp48w6mmgl.java\t2022-07-19 15:56:47.436360184 +0200\n@@ -339,26 +339,11 @@\n   Vector3D v1Su1 = v1.subtract(u1);\n   Vector3D v2Su2 = v2.subtract(u2);\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);;\n-      c = k.dotProduct(u2.crossProduct(u3));;\n-\n-      if (c == 0) {\n+if (k1 == v2) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n         q1 = 0.0;\n         q2 = 0.0;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (c1 == v2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\t2022-07-19 15:56:49.496345930 +0200\n+++ /tmp/tmpep0nl2na.java\t2022-07-19 15:56:49.496345930 +0200\n@@ -339,26 +339,11 @@\n   Vector3D v1Su1 = v1.subtract(u1);\n   Vector3D v2Su2 = v2.subtract(u2);\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);;\n-      c = k.dotProduct(u2.crossProduct(u3));;\n-\n-      if (c == 0) {\n+if (c1 == v2) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n         q1 = 0.0;\n         q2 = 0.0;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (k1 == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\t2022-07-19 15:56:51.524331899 +0200\n+++ /tmp/tmppaiyibtf.java\t2022-07-19 15:56:51.528331870 +0200\n@@ -339,26 +339,11 @@\n   Vector3D v1Su1 = v1.subtract(u1);\n   Vector3D v2Su2 = v2.subtract(u2);\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);;\n-      c = k.dotProduct(u2.crossProduct(u3));;\n-\n-      if (c == 0) {\n+if (k1 == 0) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n         q1 = 0.0;\n         q2 = 0.0;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (v1 == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\t2022-07-19 15:56:53.596317562 +0200\n+++ /tmp/tmptwqm4aj0.java\t2022-07-19 15:56:53.596317562 +0200\n@@ -339,26 +339,11 @@\n   Vector3D v1Su1 = v1.subtract(u1);\n   Vector3D v2Su2 = v2.subtract(u2);\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);;\n-      c = k.dotProduct(u2.crossProduct(u3));;\n-\n-      if (c == 0) {\n+if (v1 == 0) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n         q1 = 0.0;\n         q2 = 0.0;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (k1 > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\t2022-07-19 15:56:55.648303366 +0200\n+++ /tmp/tmpjmhmybte.java\t2022-07-19 15:56:55.648303366 +0200\n@@ -339,26 +339,11 @@\n   Vector3D v1Su1 = v1.subtract(u1);\n   Vector3D v2Su2 = v2.subtract(u2);\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);;\n-      c = k.dotProduct(u2.crossProduct(u3));;\n-\n-      if (c == 0) {\n+if (k1 > 0) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n         q1 = 0.0;\n         q2 = 0.0;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (k == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\t2022-07-19 15:56:57.720289029 +0200\n+++ /tmp/tmp_vxcn1jh.java\t2022-07-19 15:56:57.724289003 +0200\n@@ -339,26 +339,11 @@\n   Vector3D v1Su1 = v1.subtract(u1);\n   Vector3D v2Su2 = v2.subtract(u2);\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);;\n-      c = k.dotProduct(u2.crossProduct(u3));;\n-\n-      if (c == 0) {\n+if (k == 0) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n         q1 = 0.0;\n         q2 = 0.0;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (c == 0) { // the (q1, q2, q3) vector is close to the (u1, u2) plane // we try other vectors Vector3D v3 = Vector3D.crossProduct(v1, v2); Vector3D v3Su3 = v3.subtract(u3); k = v1Su1.crossProduct(v3Su3); Vector3D u2Prime = u1.crossProduct(u3); c = k.dotProduct(u2Prime); if (c == 0) { // the (q1, q2, q3) vector is also close to the (u1, u3) plane, // it is almost aligned with u1: we try (u2, u3) and (v2, v3) k = v2Su2.crossProduct(v3Su3);; c = k.dotProduct(u2.crossProduct(u3));; if (c == 0) {",
        "fixed_line": "final double inPlaneThreshold = 0.001; if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) { // the (q1, q2, q3) vector is close to the (u1, u2) plane // we try other vectors Vector3D v3 = Vector3D.crossProduct(v1, v2); Vector3D v3Su3 = v3.subtract(u3); k = v1Su1.crossProduct(v3Su3); Vector3D u2Prime = u1.crossProduct(u3); c = k.dotProduct(u2Prime); if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) { // the (q1, q2, q3) vector is also close to the (u1, u3) plane, // it is almost aligned with u1: we try (u2, u3) and (v2, v3) k = v2Su2.crossProduct(v3Su3);; c = k.dotProduct(u2.crossProduct(u3));; if (c <= 0) {"
    },
    "Lang-39": {
        "fixes": [
            {
                "k": 1,
                "patch": "// for (int i = 0; i < str.length; i++) { if (searchList[i].length() > 0) { break; } } }",
                "patch_diff": "// for (int i = 0; i < str.length; i++) { if (searchList[i].length() > 0) { break; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// if (searchList[i].length() > 0) {",
                "patch_diff": "// if (searchList[i].length() > 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// for (int i = 0; i < str.length; i++) { if (searchList[i] > 0) { break; } } }",
                "patch_diff": "// for (int i = 0; i < str.length; i++) { if (searchList[i] > 0) { break; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// for (int i = 0; i < str.length; i++) { if (searchList[i].length() > 0) { return; } } }",
                "patch_diff": "// for (int i = 0; i < str.length; i++) { if (searchList[i].length() > 0) { return; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// for (int i = 0; i < str.length; i++) { if (searchList[i].length() > 0) { break; } }",
                "patch_diff": "// for (int i = 0; i < str.length; i++) { if (searchList[i].length() > 0) { break; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if (searchList[i].length() - searchList[i].length() - 1].length;",
                "patch_diff": "// if (searchList[i].length() - searchList[i].length() - 1].length;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// for (int i = 0; i < month; i++) { if (searchList[i].length() > 0) { break; } } }",
                "patch_diff": "// for (int i = 0; i < month; i++) { if (searchList[i].length() > 0) { break; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// for (int i = 0; i < str.length; i++) { if (searchList[i].length() == 0) { break; } } }",
                "patch_diff": "// for (int i = 0; i < str.length; i++) { if (searchList[i].length() == 0) { break; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// for (int i = 0; i < str.length; i++) { if (searchList[i].length() > 0) { continue; } } }",
                "patch_diff": "// for (int i = 0; i < str.length; i++) { if (searchList[i].length() > 0) { continue; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// for (int i = 0; i < str.length; i++) { if (searchList[i].length() == 0) { return; } } }",
                "patch_diff": "// for (int i = 0; i < str.length; i++) { if (searchList[i].length() == 0) { return; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (searchList[i] == null || replacementList[i] == null) { continue; }"
    },
    "Cli-2": {
        "fixes": [
            {
                "k": 1,
                "patch": "tokens.add(\"-\" + ch ch = str; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-2/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 15:57:01.676261658 +0200\n+++ /tmp/tmpixsdmp8x.java\t2022-07-19 15:57:01.752261133 +0200\n@@ -300,10 +300,6 @@\n             {\n                 process(token.substring(i));\n             }\n             else\n             {\n-                tokens.add(\"-\" + ch);\n-            }\n-        }\n-    }\n-}\n+tokens.add(\"-\" + ch ch = str; }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "tokens.add(\"-\" + ch ch); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-2/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 15:57:03.516248928 +0200\n+++ /tmp/tmp8n5wg21b.java\t2022-07-19 15:57:03.516248928 +0200\n@@ -300,10 +300,6 @@\n             {\n                 process(token.substring(i));\n             }\n             else\n             {\n-                tokens.add(\"-\" + ch);\n-            }\n-        }\n-    }\n-}\n+tokens.add(\"-\" + ch ch); }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "tokens.add(\"-\" + ch0; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-2/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 15:57:05.108237914 +0200\n+++ /tmp/tmp6fwz28r3.java\t2022-07-19 15:57:05.112237885 +0200\n@@ -300,10 +300,6 @@\n             {\n                 process(token.substring(i));\n             }\n             else\n             {\n-                tokens.add(\"-\" + ch);\n-            }\n-        }\n-    }\n-}\n+tokens.add(\"-\" + ch0; }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "tokens.add(\"-\" + ch ch; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-2/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 15:57:06.616227480 +0200\n+++ /tmp/tmphn7zl0e4.java\t2022-07-19 15:57:06.616227480 +0200\n@@ -300,10 +300,6 @@\n             {\n                 process(token.substring(i));\n             }\n             else\n             {\n-                tokens.add(\"-\" + ch);\n-            }\n-        }\n-    }\n-}\n+tokens.add(\"-\" + ch ch; }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "tokens.add(\"-\" + ch, tokens); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-2/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 15:57:08.264216078 +0200\n+++ /tmp/tmp10qjarrz.java\t2022-07-19 15:57:08.264216078 +0200\n@@ -300,10 +300,6 @@\n             {\n                 process(token.substring(i));\n             }\n             else\n             {\n-                tokens.add(\"-\" + ch);\n-            }\n-        }\n-    }\n-}\n+tokens.add(\"-\" + ch, tokens); }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "tokens.add(\"-\" + ch = str; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-2/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 15:57:09.704206115 +0200\n+++ /tmp/tmpxf581bw9.java\t2022-07-19 15:57:09.704206115 +0200\n@@ -300,10 +300,6 @@\n             {\n                 process(token.substring(i));\n             }\n             else\n             {\n-                tokens.add(\"-\" + ch);\n-            }\n-        }\n-    }\n-}\n+tokens.add(\"-\" + ch = str; }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "tokens.add(\"-\" + ch00, }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-2/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 15:57:11.252195404 +0200\n+++ /tmp/tmp7wrmv9we.java\t2022-07-19 15:57:11.252195404 +0200\n@@ -300,10 +300,6 @@\n             {\n                 process(token.substring(i));\n             }\n             else\n             {\n-                tokens.add(\"-\" + ch);\n-            }\n-        }\n-    }\n-}\n+tokens.add(\"-\" + ch00, }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "tokens.add(\"-\" + ch); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-2/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 15:57:12.772184887 +0200\n+++ /tmp/tmp58sgidu1.java\t2022-07-19 15:57:12.776184858 +0200\n@@ -300,10 +300,6 @@\n             {\n                 process(token.substring(i));\n             }\n             else\n             {\n-                tokens.add(\"-\" + ch);\n-            }\n-        }\n-    }\n-}\n+tokens.add(\"-\" + ch); }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "tokens.add(\"-\" + chType); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-2/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 15:57:14.196175035 +0200\n+++ /tmp/tmp06o4s7n1.java\t2022-07-19 15:57:14.200175007 +0200\n@@ -300,10 +300,6 @@\n             {\n                 process(token.substring(i));\n             }\n             else\n             {\n-                tokens.add(\"-\" + ch);\n-            }\n-        }\n-    }\n-}\n+tokens.add(\"-\" + chType); }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "tokens.add(\"-\" + ch; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-2/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 15:57:15.644165014 +0200\n+++ /tmp/tmpost2joix.java\t2022-07-19 15:57:15.644165014 +0200\n@@ -300,10 +300,6 @@\n             {\n                 process(token.substring(i));\n             }\n             else\n             {\n-                tokens.add(\"-\" + ch);\n-            }\n-        }\n-    }\n-}\n+tokens.add(\"-\" + ch; }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "tokens.add(\"-\" + ch); } } } }",
        "fixed_line": "tokens.add(token); break; } } } }"
    },
    "Mockito-21": {
        "fixes": [
            {
                "k": 1,
                "patch": "return cls;T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-21/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\t2022-07-19 15:57:17.424152703 +0200\n+++ /tmp/tmp0y37plmm.java\t2022-07-19 15:57:17.444152562 +0200\n@@ -12,19 +12,11 @@\n \n     public <T> T newInstance(Class<T> cls) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withOuterClass(cls);\n-    }\n-\n-    private <T> T withOuterClass(Class<T> cls) {\n-        try {\n-            //this is kind of overengineered because we don't need to support more params\n-            //however, I know we will be needing it :)\n-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n-            return c.newInstance(outerClassInstance);\n+return cls;T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T;\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return cls;T withOuterClass<T withOuterClass<T withOuterClass<T;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-21/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\t2022-07-19 15:57:30.540061951 +0200\n+++ /tmp/tmpn1rc237_.java\t2022-07-19 15:57:30.544061925 +0200\n@@ -12,19 +12,11 @@\n \n     public <T> T newInstance(Class<T> cls) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withOuterClass(cls);\n-    }\n-\n-    private <T> T withOuterClass(Class<T> cls) {\n-        try {\n-            //this is kind of overengineered because we don't need to support more params\n-            //however, I know we will be needing it :)\n-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n-            return c.newInstance(outerClassInstance);\n+return cls;T withOuterClass<T withOuterClass<T withOuterClass<T;\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return cls;T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-21/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\t2022-07-19 15:57:38.972003613 +0200\n+++ /tmp/tmp0eeec_ko.java\t2022-07-19 15:57:38.972003613 +0200\n@@ -12,19 +12,11 @@\n \n     public <T> T newInstance(Class<T> cls) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withOuterClass(cls);\n-    }\n-\n-    private <T> T withOuterClass(Class<T> cls) {\n-        try {\n-            //this is kind of overengineered because we don't need to support more params\n-            //however, I know we will be needing it :)\n-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n-            return c.newInstance(outerClassInstance);\n+return cls;T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T;\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return cls;T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T>(cls) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-21/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\t2022-07-19 15:57:47.551944248 +0200\n+++ /tmp/tmpbdu29onv.java\t2022-07-19 15:57:47.551944248 +0200\n@@ -12,19 +12,11 @@\n \n     public <T> T newInstance(Class<T> cls) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withOuterClass(cls);\n-    }\n-\n-    private <T> T withOuterClass(Class<T> cls) {\n-        try {\n-            //this is kind of overengineered because we don't need to support more params\n-            //however, I know we will be needing it :)\n-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n-            return c.newInstance(outerClassInstance);\n+return cls;T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T>(cls) {\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return cls;T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T>(cls;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-21/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\t2022-07-19 15:57:56.847879930 +0200\n+++ /tmp/tmp6iic9ai7.java\t2022-07-19 15:57:56.895879596 +0200\n@@ -12,19 +12,11 @@\n \n     public <T> T newInstance(Class<T> cls) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withOuterClass(cls);\n-    }\n-\n-    private <T> T withOuterClass(Class<T> cls) {\n-        try {\n-            //this is kind of overengineered because we don't need to support more params\n-            //however, I know we will be needing it :)\n-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n-            return c.newInstance(outerClassInstance);\n+return cls;T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T>(cls;\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return cls;T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-21/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\t2022-07-19 15:58:08.859796820 +0200\n+++ /tmp/tmp4g20jr_r.java\t2022-07-19 15:58:08.863796791 +0200\n@@ -12,19 +12,11 @@\n \n     public <T> T newInstance(Class<T> cls) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withOuterClass(cls);\n-    }\n-\n-    private <T> T withOuterClass(Class<T> cls) {\n-        try {\n-            //this is kind of overengineered because we don't need to support more params\n-            //however, I know we will be needing it :)\n-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n-            return c.newInstance(outerClassInstance);\n+return cls;T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T;\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return cls;T withOuterClass<T withOuterClass<T withOuterClass<T>(cls) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-21/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\t2022-07-19 15:58:20.723714736 +0200\n+++ /tmp/tmp8u5crx3j.java\t2022-07-19 15:58:20.723714736 +0200\n@@ -12,19 +12,11 @@\n \n     public <T> T newInstance(Class<T> cls) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withOuterClass(cls);\n-    }\n-\n-    private <T> T withOuterClass(Class<T> cls) {\n-        try {\n-            //this is kind of overengineered because we don't need to support more params\n-            //however, I know we will be needing it :)\n-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n-            return c.newInstance(outerClassInstance);\n+return cls;T withOuterClass<T withOuterClass<T withOuterClass<T>(cls) {\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return cls;T withOuterClass<T withOuterClass<T withOuterClass<T>(cls;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-21/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\t2022-07-19 15:58:32.159635611 +0200\n+++ /tmp/tmpx3ld9qdw.java\t2022-07-19 15:58:32.159635611 +0200\n@@ -12,19 +12,11 @@\n \n     public <T> T newInstance(Class<T> cls) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withOuterClass(cls);\n-    }\n-\n-    private <T> T withOuterClass(Class<T> cls) {\n-        try {\n-            //this is kind of overengineered because we don't need to support more params\n-            //however, I know we will be needing it :)\n-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n-            return c.newInstance(outerClassInstance);\n+return cls;T withOuterClass<T withOuterClass<T withOuterClass<T>(cls;\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return cls;T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T>(cls;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-21/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\t2022-07-19 15:58:43.119559778 +0200\n+++ /tmp/tmpx7bs4rg3.java\t2022-07-19 15:58:43.123559753 +0200\n@@ -12,19 +12,11 @@\n \n     public <T> T newInstance(Class<T> cls) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withOuterClass(cls);\n-    }\n-\n-    private <T> T withOuterClass(Class<T> cls) {\n-        try {\n-            //this is kind of overengineered because we don't need to support more params\n-            //however, I know we will be needing it :)\n-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n-            return c.newInstance(outerClassInstance);\n+return cls;T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T>(cls;\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return cls;T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T>(cls) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-21/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\t2022-07-19 15:58:53.551487603 +0200\n+++ /tmp/tmpns7fq3j4.java\t2022-07-19 15:58:53.551487603 +0200\n@@ -12,19 +12,11 @@\n \n     public <T> T newInstance(Class<T> cls) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withOuterClass(cls);\n-    }\n-\n-    private <T> T withOuterClass(Class<T> cls) {\n-        try {\n-            //this is kind of overengineered because we don't need to support more params\n-            //however, I know we will be needing it :)\n-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n-            return c.newInstance(outerClassInstance);\n+return cls;T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T>(cls) {\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return withOuterClass(cls); } private <T> T withOuterClass(Class<T> cls) { try { //this is kind of overengineered because we don't need to support more params //however, I know we will be needing it :) Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass()); return c.newInstance(outerClassInstance);",
        "fixed_line": "return withParams(cls, outerClassInstance); } private static <T> T withParams(Class<T> cls, Object... params) { try { //this is kind of overengineered because we don't need to support more params //however, I know we will be needing it :) for (Constructor<?> constructor : cls.getDeclaredConstructors()) { Class<?>[] types = constructor.getParameterTypes(); if (paramsMatch(types, params)) { return (T) constructor.newInstance(params); } } } catch (Exception e) { throw paramsException(cls, e); } throw paramsException(cls, null); } private static <T> InstantationException paramsException(Class<T> cls, Exception e) { return new InstantationException(\"Unable to create mock instance of '\" + cls.getSimpleName() + \"'.\\nPlease ensure that the outer instance has correct type and that the target class has parameter-less constructor.\", e); } private static boolean paramsMatch(Class<?>[] types, Object[] params) { if (params.length != types.length) { return false; } for (int i = 0; i < params.length; i++) { if (!types[i].isInstance(params[i])) { return false; } } return true; }"
    },
    "Lang-10": {
        "fixes": [
            {
                "k": 1,
                "patch": "boolean wasWhite= false; if if ifNode<value.charAt(i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-10/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\t2022-07-19 15:59:04.619411025 +0200\n+++ /tmp/tmpng4moaqm.java\t2022-07-19 15:59:04.871409287 +0200\n@@ -299,21 +299,11 @@\n      * @param value The source field\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n-            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n+boolean wasWhite= false; if if ifNode<value.charAt(i++) {\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n                     if(++i==value.length()) {\n                         return regex;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "boolean wasWhite= false; if if if (value.charAt(i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-10/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\t2022-07-19 15:59:07.579390544 +0200\n+++ /tmp/tmpbwzpavwb.java\t2022-07-19 15:59:07.579390544 +0200\n@@ -299,21 +299,11 @@\n      * @param value The source field\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n-            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n+boolean wasWhite= false; if if if (value.charAt(i++) {\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n                     if(++i==value.length()) {\n                         return regex;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "boolean wasWhite= false; if if if if (value.charAt(i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-10/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\t2022-07-19 15:59:10.203372387 +0200\n+++ /tmp/tmp70wsbzmg.java\t2022-07-19 15:59:10.203372387 +0200\n@@ -299,21 +299,11 @@\n      * @param value The source field\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n-            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n+boolean wasWhite= false; if if if if (value.charAt(i++) {\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n                     if(++i==value.length()) {\n                         return regex;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "boolean wasWhite= false; if ifNode<value.charAt(i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-10/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\t2022-07-19 15:59:13.283351079 +0200\n+++ /tmp/tmppf3uhrik.java\t2022-07-19 15:59:13.283351079 +0200\n@@ -299,21 +299,11 @@\n      * @param value The source field\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n-            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n+boolean wasWhite= false; if ifNode<value.charAt(i++) {\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n                     if(++i==value.length()) {\n                         return regex;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "boolean wasWhite= false; if if if(value.charAt(i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-10/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\t2022-07-19 15:59:16.087331677 +0200\n+++ /tmp/tmpgy7snkul.java\t2022-07-19 15:59:16.091331651 +0200\n@@ -299,21 +299,11 @@\n      * @param value The source field\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n-            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n+boolean wasWhite= false; if if if(value.charAt(i++) {\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n                     if(++i==value.length()) {\n                         return regex;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "boolean wasWhite= false; if if if if(value.charAt(i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-10/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\t2022-07-19 15:59:18.807312860 +0200\n+++ /tmp/tmpjtzeh2fq.java\t2022-07-19 15:59:18.807312860 +0200\n@@ -299,21 +299,11 @@\n      * @param value The source field\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n-            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n+boolean wasWhite= false; if if if if(value.charAt(i++) {\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n                     if(++i==value.length()) {\n                         return regex;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "boolean wasWhite= false; if if if ifNode<value.charAt(i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-10/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\t2022-07-19 15:59:21.443294621 +0200\n+++ /tmp/tmp_j0t62cv.java\t2022-07-19 15:59:21.471294427 +0200\n@@ -299,21 +299,11 @@\n      * @param value The source field\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n-            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n+boolean wasWhite= false; if if if ifNode<value.charAt(i++) {\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n                     if(++i==value.length()) {\n                         return regex;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "boolean wasWhite= false; if if if if if (value.charAt(i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-10/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\t2022-07-19 15:59:24.975270184 +0200\n+++ /tmp/tmp2wfv6aex.java\t2022-07-19 15:59:24.979270154 +0200\n@@ -299,21 +299,11 @@\n      * @param value The source field\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n-            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n+boolean wasWhite= false; if if if if if (value.charAt(i++) {\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n                     if(++i==value.length()) {\n                         return regex;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "boolean wasWhite= false; if if(value.charAt(i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-10/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\t2022-07-19 15:59:27.107255433 +0200\n+++ /tmp/tmpdk7aytuv.java\t2022-07-19 15:59:27.107255433 +0200\n@@ -299,21 +299,11 @@\n      * @param value The source field\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n-            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n+boolean wasWhite= false; if if(value.charAt(i++) {\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n                     if(++i==value.length()) {\n                         return regex;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "boolean wasWhite= false; if if (value.charAt(i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-10/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\t2022-07-19 15:59:29.671237691 +0200\n+++ /tmp/tmphc_5jmf9.java\t2022-07-19 15:59:29.671237691 +0200\n@@ -299,21 +299,11 @@\n      * @param value The source field\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n-            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n+boolean wasWhite= false; if if (value.charAt(i++) {\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n                     if(++i==value.length()) {\n                         return regex;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\s*+\"); } continue; } wasWhite= false;",
        "fixed_line": ""
    },
    "Cli-40": {
        "fixes": [
            {
                "k": 1,
                "patch": "return last;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-40/src/main/java/org/apache/commons/cli/TypeHandler.java\t2022-07-19 15:59:32.655217044 +0200\n+++ /tmp/tmprgpuaima.java\t2022-07-19 15:59:32.775216217 +0200\n@@ -98,11 +98,11 @@\n         {\n             return (T) createURL(str);\n         }\n         else\n         {\n-            return null;\n+return last;\n         }\n     }\n \n     /**\n       * Create an Object from the classname and empty constructor.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return root;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-40/src/main/java/org/apache/commons/cli/TypeHandler.java\t2022-07-19 15:59:34.679203044 +0200\n+++ /tmp/tmp_8eatu_1.java\t2022-07-19 15:59:34.683203015 +0200\n@@ -98,11 +98,11 @@\n         {\n             return (T) createURL(str);\n         }\n         else\n         {\n-            return null;\n+return root;\n         }\n     }\n \n     /**\n       * Create an Object from the classname and empty constructor.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return NONE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-40/src/main/java/org/apache/commons/cli/TypeHandler.java\t2022-07-19 15:59:36.295191862 +0200\n+++ /tmp/tmpo6dopouf.java\t2022-07-19 15:59:36.295191862 +0200\n@@ -98,11 +98,11 @@\n         {\n             return (T) createURL(str);\n         }\n         else\n         {\n-            return null;\n+return NONE;\n         }\n     }\n \n     /**\n       * Create an Object from the classname and empty constructor.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return current;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-40/src/main/java/org/apache/commons/cli/TypeHandler.java\t2022-07-19 15:59:37.859181042 +0200\n+++ /tmp/tmpyo29xrhq.java\t2022-07-19 15:59:37.859181042 +0200\n@@ -98,11 +98,11 @@\n         {\n             return (T) createURL(str);\n         }\n         else\n         {\n-            return null;\n+return current;\n         }\n     }\n \n     /**\n       * Create an Object from the classname and empty constructor.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return valueType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-40/src/main/java/org/apache/commons/cli/TypeHandler.java\t2022-07-19 15:59:39.439170107 +0200\n+++ /tmp/tmpfcu17g10.java\t2022-07-19 15:59:39.443170082 +0200\n@@ -98,11 +98,11 @@\n         {\n             return (T) createURL(str);\n         }\n         else\n         {\n-            return null;\n+return valueType;\n         }\n     }\n \n     /**\n       * Create an Object from the classname and empty constructor.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return parent;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-40/src/main/java/org/apache/commons/cli/TypeHandler.java\t2022-07-19 15:59:41.079158760 +0200\n+++ /tmp/tmpv3olml4k.java\t2022-07-19 15:59:41.079158760 +0200\n@@ -98,11 +98,11 @@\n         {\n             return (T) createURL(str);\n         }\n         else\n         {\n-            return null;\n+return parent;\n         }\n     }\n \n     /**\n       * Create an Object from the classname and empty constructor.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return coll;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-40/src/main/java/org/apache/commons/cli/TypeHandler.java\t2022-07-19 15:59:42.699147553 +0200\n+++ /tmp/tmp1wxamxwa.java\t2022-07-19 15:59:42.699147553 +0200\n@@ -98,11 +98,11 @@\n         {\n             return (T) createURL(str);\n         }\n         else\n         {\n-            return null;\n+return coll;\n         }\n     }\n \n     /**\n       * Create an Object from the classname and empty constructor.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return empty;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-40/src/main/java/org/apache/commons/cli/TypeHandler.java\t2022-07-19 15:59:44.367136011 +0200\n+++ /tmp/tmp7tzjf9m7.java\t2022-07-19 15:59:44.371135986 +0200\n@@ -98,11 +98,11 @@\n         {\n             return (T) createURL(str);\n         }\n         else\n         {\n-            return null;\n+return empty;\n         }\n     }\n \n     /**\n       * Create an Object from the classname and empty constructor.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return result;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-40/src/main/java/org/apache/commons/cli/TypeHandler.java\t2022-07-19 15:59:46.011124638 +0200\n+++ /tmp/tmp8u8aginq.java\t2022-07-19 15:59:46.011124638 +0200\n@@ -98,11 +98,11 @@\n         {\n             return (T) createURL(str);\n         }\n         else\n         {\n-            return null;\n+return result;\n         }\n     }\n \n     /**\n       * Create an Object from the classname and empty constructor.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-40/src/main/java/org/apache/commons/cli/TypeHandler.java\t2022-07-19 15:59:47.683113070 +0200\n+++ /tmp/tmp2056unbs.java\t2022-07-19 15:59:47.683113070 +0200\n@@ -98,11 +98,11 @@\n         {\n             return (T) createURL(str);\n         }\n         else\n         {\n-            return null;\n+return null;\n         }\n     }\n \n     /**\n       * Create an Object from the classname and empty constructor.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return null;",
        "fixed_line": "throw new ParseException(\"Unable to handle the class: \" + clazz);"
    },
    "JxPath-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "return equalStrings(namespaceURI, nodeNS = nodeNS;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-12/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-19 15:59:50.551093227 +0200\n+++ /tmp/tmpmv7x8kar.java\t2022-07-19 15:59:50.599092895 +0200\n@@ -103,11 +103,11 @@\n             }\n             if (wildcard\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS);\n+return equalStrings(namespaceURI, nodeNS = nodeNS;\n             }\n             return false;\n         }\n         if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return equalStrings(namespaceURI, nodeNS = nodeNS, nodeNS);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-12/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-19 15:59:52.511079666 +0200\n+++ /tmp/tmpk3r4kd06.java\t2022-07-19 15:59:52.511079666 +0200\n@@ -103,11 +103,11 @@\n             }\n             if (wildcard\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS);\n+return equalStrings(namespaceURI, nodeNS = nodeNS, nodeNS);\n             }\n             return false;\n         }\n         if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return equalStrings(namespaceURI, nodeNS = nodeNS.namespaceURI;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-12/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-19 15:59:54.679064665 +0200\n+++ /tmp/tmpo3fo6dux.java\t2022-07-19 15:59:54.679064665 +0200\n@@ -103,11 +103,11 @@\n             }\n             if (wildcard\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS);\n+return equalStrings(namespaceURI, nodeNS = nodeNS.namespaceURI;\n             }\n             return false;\n         }\n         if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return equalStrings(namespaceURI, nodeNS = nodeNS);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-12/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-19 15:59:56.159054425 +0200\n+++ /tmp/tmpg_apigca.java\t2022-07-19 15:59:56.163054396 +0200\n@@ -103,11 +103,11 @@\n             }\n             if (wildcard\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS);\n+return equalStrings(namespaceURI, nodeNS = nodeNS);\n             }\n             return false;\n         }\n         if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return equalStrings(namespaceURI, nodeNS_namespaceURI);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-12/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-19 16:00:01.195019582 +0200\n+++ /tmp/tmpkod8w1gu.java\t2022-07-19 16:00:01.195019582 +0200\n@@ -103,11 +103,11 @@\n             }\n             if (wildcard\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS);\n+return equalStrings(namespaceURI, nodeNS_namespaceURI);\n             }\n             return false;\n         }\n         if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return equalStrings(namespaceURI, nodeNS, nodeNS);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-12/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-19 16:00:02.991007156 +0200\n+++ /tmp/tmpxpdvvd34.java\t2022-07-19 16:00:02.991007156 +0200\n@@ -103,11 +103,11 @@\n             }\n             if (wildcard\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS);\n+return equalStrings(namespaceURI, nodeNS, nodeNS);\n             }\n             return false;\n         }\n         if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return equalStrings(namespaceURI, nodeNSNS);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-12/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-19 16:00:04.794994672 +0200\n+++ /tmp/tmpnvmw299s.java\t2022-07-19 16:00:04.794994672 +0200\n@@ -103,11 +103,11 @@\n             }\n             if (wildcard\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS);\n+return equalStrings(namespaceURI, nodeNSNS);\n             }\n             return false;\n         }\n         if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return equalStrings(namespaceURI, nodeNS;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-12/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-19 16:00:06.502982858 +0200\n+++ /tmp/tmpolrm345d.java\t2022-07-19 16:00:06.502982858 +0200\n@@ -103,11 +103,11 @@\n             }\n             if (wildcard\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS);\n+return equalStrings(namespaceURI, nodeNS;\n             }\n             return false;\n         }\n         if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return equalStrings(namespaceURI, nodeNS)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-12/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-19 16:00:08.070972008 +0200\n+++ /tmp/tmpezhohun3.java\t2022-07-19 16:00:08.070972008 +0200\n@@ -103,11 +103,11 @@\n             }\n             if (wildcard\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS);\n+return equalStrings(namespaceURI, nodeNS)) {\n             }\n             return false;\n         }\n         if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return equalStrings(namespaceURI, nodeNS);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-12/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-19 16:00:09.750960385 +0200\n+++ /tmp/tmpxavb3s2h.java\t2022-07-19 16:00:09.750960385 +0200\n@@ -103,11 +103,11 @@\n             }\n             if (wildcard\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS);\n+return equalStrings(namespaceURI, nodeNS);\n             }\n             return false;\n         }\n         if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return equalStrings(namespaceURI, nodeNS);",
        "fixed_line": "return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node));"
    },
    "JacksonCore-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "_names = Arrays.copyOf(_names, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "_names = Arrays.copyOf(_names, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "_names = Arrays.copyOf(_names, _hashShared = false;",
                "patch_diff": "_names = Arrays.copyOf(_names, _hashShared = false;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "_names = Arrays.copyOf(_names, tatu: As per [JACKSON-core#216], also need to ensure",
                "patch_diff": "_names = Arrays.copyOf(_names, tatu: As per [JACKSON-core#216], also need to ensure",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "_names = Arrays.copyOf(_names, _hashShared = false; // only strings can't really modify it was non-literal characters that might be valid (empty be",
                "patch_diff": "_names = Arrays.copyOf(_names, _hashShared = false; // only strings can't really modify it was non-literal characters that might be valid (empty be",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "_names = Arrays.copyOf(_names, _hashShared = false; // only strings can't really modify it was non-literal characters that might be valid (empty be valid)",
                "patch_diff": "_names = Arrays.copyOf(_names, _hashShared = false; // only strings can't really modify it was non-literal characters that might be valid (empty be valid)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "_names = Arrays.copyOf(_names, _hashShared = false; // to ensure that might be valid (tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "_names = Arrays.copyOf(_names, _hashShared = false; // to ensure that might be valid (tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "_names = Arrays.copyOf(_names, _hashShared = false; // only strings can't really modify it's do implicit re-parse",
                "patch_diff": "_names = Arrays.copyOf(_names, _hashShared = false; // only strings can't really modify it's do implicit re-parse",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "_names = Arrays.copyOf(_names, tatu: As per [JACKSON-631], also need to ensure",
                "patch_diff": "_names = Arrays.copyOf(_names, tatu: As per [JACKSON-631], also need to ensure",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "_names = Arrays.copyOf(_names, _hashShared = false; // only strings can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "patch_diff": "_names = Arrays.copyOf(_names, _hashShared = false; // only strings can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "_names = Arrays.copyOf(_names, _hashShared = false; // only strings can't really modify it was non-empty's do implicit re-parse",
                "patch_diff": "_names = Arrays.copyOf(_names, _hashShared = false; // only strings can't really modify it was non-empty's do implicit re-parse",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "_verifyNeedForRehash();"
    },
    "Csv-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "final boolean emptyHeader = header.trim().isEmptysHeader;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-11/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 16:00:16.006917102 +0200\n+++ /tmp/tmphglw0bl5.java\t2022-07-19 16:00:16.030916934 +0200\n@@ -379,11 +379,11 @@\n             // build the name to index mappings\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+final boolean emptyHeader = header.trim().isEmptysHeader;\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n                     }\n                     hdrMap.put(header, Integer.valueOf(i));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "final boolean emptyHeader = header.trim().isEmptyTable;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-11/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 16:00:17.802904674 +0200\n+++ /tmp/tmpnyraidr_.java\t2022-07-19 16:00:17.806904644 +0200\n@@ -379,11 +379,11 @@\n             // build the name to index mappings\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+final boolean emptyHeader = header.trim().isEmptyTable;\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n                     }\n                     hdrMap.put(header, Integer.valueOf(i));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "final boolean emptyHeader = header.trim().isEmptys;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-11/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 16:00:19.394893660 +0200\n+++ /tmp/tmpyrlzrtl1.java\t2022-07-19 16:00:19.394893660 +0200\n@@ -379,11 +379,11 @@\n             // build the name to index mappings\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+final boolean emptyHeader = header.trim().isEmptys;\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n                     }\n                     hdrMap.put(header, Integer.valueOf(i));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "final boolean emptyHeader = header.trim().isEmptyType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-11/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 16:00:21.022882395 +0200\n+++ /tmp/tmp1hea_ufh.java\t2022-07-19 16:00:21.022882395 +0200\n@@ -379,11 +379,11 @@\n             // build the name to index mappings\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+final boolean emptyHeader = header.trim().isEmptyType;\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n                     }\n                     hdrMap.put(header, Integer.valueOf(i));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "final boolean emptyHeader = header.trim().isEmptyss;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-11/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 16:00:22.698870799 +0200\n+++ /tmp/tmpu2k7xjoq.java\t2022-07-19 16:00:22.698870799 +0200\n@@ -379,11 +379,11 @@\n             // build the name to index mappings\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+final boolean emptyHeader = header.trim().isEmptyss;\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n                     }\n                     hdrMap.put(header, Integer.valueOf(i));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "final boolean emptyHeader = header.trim().isEmpty()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-11/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 16:00:24.354859339 +0200\n+++ /tmp/tmpuwebgd8n.java\t2022-07-19 16:00:24.354859339 +0200\n@@ -379,11 +379,11 @@\n             // build the name to index mappings\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+final boolean emptyHeader = header.trim().isEmpty()) {\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n                     }\n                     hdrMap.put(header, Integer.valueOf(i));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "final boolean emptyHeader = header.trim().isEmpty - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-11/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 16:00:25.862848908 +0200\n+++ /tmp/tmpd1iu_hin.java\t2022-07-19 16:00:25.862848908 +0200\n@@ -379,11 +379,11 @@\n             // build the name to index mappings\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+final boolean emptyHeader = header.trim().isEmpty - 1;\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n                     }\n                     hdrMap.put(header, Integer.valueOf(i));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "final boolean emptyHeader = header.trim().isEmptys()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-11/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 16:00:27.462837838 +0200\n+++ /tmp/tmp3fokcb1t.java\t2022-07-19 16:00:27.466837810 +0200\n@@ -379,11 +379,11 @@\n             // build the name to index mappings\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+final boolean emptyHeader = header.trim().isEmptys()) {\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n                     }\n                     hdrMap.put(header, Integer.valueOf(i));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "final boolean emptyHeader = header.trim().isEmptyssHeader;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-11/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 16:00:28.942827598 +0200\n+++ /tmp/tmpx7ygmc18.java\t2022-07-19 16:00:28.942827598 +0200\n@@ -379,11 +379,11 @@\n             // build the name to index mappings\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+final boolean emptyHeader = header.trim().isEmptyssHeader;\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n                     }\n                     hdrMap.put(header, Integer.valueOf(i));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "final boolean emptyHeader = header.trim().isEmpty;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-11/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 16:00:30.546816497 +0200\n+++ /tmp/tmps8l75hw_.java\t2022-07-19 16:00:30.546816497 +0200\n@@ -379,11 +379,11 @@\n             // build the name to index mappings\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+final boolean emptyHeader = header.trim().isEmpty;\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n                     }\n                     hdrMap.put(header, Integer.valueOf(i));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "final boolean emptyHeader = header.trim().isEmpty();",
        "fixed_line": "final boolean emptyHeader = header == null || header.trim().isEmpty();"
    },
    "Closure-91": {
        "fixes": [
            {
                "k": 1,
                "patch": "// Don't traverse a prototype, as per RFC 46 property name;",
                "patch_diff": "// Don't traverse a prototype, as per RFC 46 property name;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// Don't traverse a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "patch_diff": "// Don't traverse a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// Don't traverse a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "patch_diff": "// Don't traverse a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// Don't traverse a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "patch_diff": "// Don't traverse a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// Don't traverse a prototype, as per RFC 46 property-inExterns && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "patch_diff": "// Don't traverse a prototype, as per RFC 46 property-inExterns && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// Don't traverse functions that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "patch_diff": "// Don't traverse functions that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// Don't traverse a prototype, as per RFC 46 property-inExterns && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "patch_diff": "// Don't traverse a prototype, as per RFC 46 property-inExterns && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// Don't traverse functions that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "patch_diff": "// Don't traverse functions that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// Don't traverse a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not a prototype, as per RFC 46 property name;",
                "patch_diff": "// Don't traverse a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not a prototype, as per RFC 46 property name;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// Don't traverse the type is not a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "patch_diff": "// Don't traverse the type is not a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "Node gramps = parent.getParent(); if (NodeUtil.isObjectLitKey(parent, gramps)) { JSDocInfo maybeLends = gramps.getJSDocInfo(); if (maybeLends != null && maybeLends.getLendsName() != null && maybeLends.getLendsName().endsWith(\".prototype\")) { return false; } }"
    },
    "Math-2": {
        "fixes": [
            {
                "k": 1,
                "patch": "return (double) ('Successes * getNumberOfSuccesses()) / (double) getPopulationSize();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-2/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\t2022-07-19 16:00:34.634788214 +0200\n+++ /tmp/tmp18njukws.java\t2022-07-19 16:00:34.686787854 +0200\n@@ -263,11 +263,11 @@\n      *\n      * For population size {@code N}, number of successes {@code m}, and sample\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+return (double) ('Successes * getNumberOfSuccesses()) / (double) getPopulationSize();\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return (double)sig.getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-2/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\t2022-07-19 16:00:37.070771361 +0200\n+++ /tmp/tmp325rqnpg.java\t2022-07-19 16:00:37.070771361 +0200\n@@ -263,11 +263,11 @@\n      *\n      * For population size {@code N}, number of successes {@code m}, and sample\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+return (double)sig.getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-2/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\t2022-07-19 16:00:39.142757023 +0200\n+++ /tmp/tmpxnxj7lrj.java\t2022-07-19 16:00:39.142757023 +0200\n@@ -263,11 +263,11 @@\n      *\n      * For population size {@code N}, number of successes {@code m}, and sample\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return (double)sig.getSampleSize() * getNumberOfSuccesses()) / (double) -1opulationSize();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-2/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\t2022-07-19 16:01:23.022453425 +0200\n+++ /tmp/tmprp1ng04v.java\t2022-07-19 16:01:23.022453425 +0200\n@@ -263,11 +263,11 @@\n      *\n      * For population size {@code N}, number of successes {@code m}, and sample\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+return (double)sig.getSampleSize() * getNumberOfSuccesses()) / (double) -1opulationSize();\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return (double) (getSampleSize * getNumberOfSuccesses()) / (double) getPopulationSize();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-2/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\t2022-07-19 16:01:25.966433054 +0200\n+++ /tmp/tmp0pixbkjq.java\t2022-07-19 16:01:25.966433054 +0200\n@@ -263,11 +263,11 @@\n      *\n      * For population size {@code N}, number of successes {@code m}, and sample\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+return (double) (getSampleSize * getNumberOfSuccesses()) / (double) getPopulationSize();\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) -1opulationSize();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-2/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\t2022-07-19 16:01:28.978412216 +0200\n+++ /tmp/tmp46rj8gz4.java\t2022-07-19 16:01:28.982412187 +0200\n@@ -263,11 +263,11 @@\n      *\n      * For population size {@code N}, number of successes {@code m}, and sample\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) -1opulationSize();\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return (double) (getSampleSize * getNumberOfSuccesses()) / (double) -1opulationSize();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-2/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\t2022-07-19 16:01:31.638393812 +0200\n+++ /tmp/tmp5o_z_aof.java\t2022-07-19 16:01:31.646393757 +0200\n@@ -263,11 +263,11 @@\n      *\n      * For population size {@code N}, number of successes {@code m}, and sample\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+return (double) (getSampleSize * getNumberOfSuccesses()) / (double) -1opulationSize();\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return (double) ('Successes()) / (double) getPopulationSize();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-2/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\t2022-07-19 16:01:34.810371864 +0200\n+++ /tmp/tmp_soffu1_.java\t2022-07-19 16:01:34.810371864 +0200\n@@ -263,11 +263,11 @@\n      *\n      * For population size {@code N}, number of successes {@code m}, and sample\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+return (double) ('Successes()) / (double) getPopulationSize();\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return (double) // no getNumberOfSuccesses()) / (double) getPopulationSize();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-2/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\t2022-07-19 16:01:37.826350999 +0200\n+++ /tmp/tmpyc9q2ys6.java\t2022-07-19 16:01:37.826350999 +0200\n@@ -263,11 +263,11 @@\n      *\n      * For population size {@code N}, number of successes {@code m}, and sample\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+return (double) // no getNumberOfSuccesses()) / (double) getPopulationSize();\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return (double) // no getNumberOfSuccesses()) / (double) -1opulationSize();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-2/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\t2022-07-19 16:01:41.006328997 +0200\n+++ /tmp/tmpbzx_csky.java\t2022-07-19 16:01:41.006328997 +0200\n@@ -263,11 +263,11 @@\n      *\n      * For population size {@code N}, number of successes {@code m}, and sample\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+return (double) // no getNumberOfSuccesses()) / (double) -1opulationSize();\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();",
        "fixed_line": "return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize());"
    },
    "JacksonCore-4": {
        "fixes": [
            {
                "k": 1,
                "patch": "int newLen = (len == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-4/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 16:01:44.954301681 +0200\n+++ /tmp/tmpmb_hi8dt.java\t2022-07-19 16:01:45.874295319 +0200\n@@ -581,11 +581,11 @@\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n         // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+int newLen = (len == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n     /**\n      * Method called to expand size of the current segment, to\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int newLen = (_currentSegment.length == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-4/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 16:01:55.226230611 +0200\n+++ /tmp/tmpb6a4p61_.java\t2022-07-19 16:01:55.226230611 +0200\n@@ -581,11 +581,11 @@\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n         // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+int newLen = (_currentSegment.length == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n     /**\n      * Method called to expand size of the current segment, to\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int newLen = (_currentSegment.length == MAX_SEGMENT_LEN? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-4/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 16:02:03.290174818 +0200\n+++ /tmp/tmpevpp239f.java\t2022-07-19 16:02:03.290174818 +0200\n@@ -581,11 +581,11 @@\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n         // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+int newLen = (_currentSegment.length == MAX_SEGMENT_LEN? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n     /**\n      * Method called to expand size of the current segment, to\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int newLen = (len == MAX_SEGMENT_LEN? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-4/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 16:02:06.438153036 +0200\n+++ /tmp/tmp8qkfn1dk.java\t2022-07-19 16:02:07.226147585 +0200\n@@ -581,11 +581,11 @@\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n         // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+int newLen = (len == MAX_SEGMENT_LEN? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n     /**\n      * Method called to expand size of the current segment, to\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int newLen = (_type == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-4/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 16:02:10.326126133 +0200\n+++ /tmp/tmp2oidonow.java\t2022-07-19 16:02:10.326126133 +0200\n@@ -581,11 +581,11 @@\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n         // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+int newLen = (_type == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n     /**\n      * Method called to expand size of the current segment, to\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int newLen = (len == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len % 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-4/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 16:02:13.478104327 +0200\n+++ /tmp/tmppbsp9uk6.java\t2022-07-19 16:02:13.482104297 +0200\n@@ -581,11 +581,11 @@\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n         // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+int newLen = (len == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len % 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n     /**\n      * Method called to expand size of the current segment, to\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int newLen = (_currentSegment.length == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len % 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-4/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 16:02:20.438056172 +0200\n+++ /tmp/tmp_5mcczvz.java\t2022-07-19 16:02:20.438056172 +0200\n@@ -581,11 +581,11 @@\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n         // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+int newLen = (_currentSegment.length == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len % 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n     /**\n      * Method called to expand size of the current segment, to\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int newLen = (len == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 5) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-4/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 16:02:26.502014216 +0200\n+++ /tmp/tmpvqvel7s1.java\t2022-07-19 16:02:26.502014216 +0200\n@@ -581,11 +581,11 @@\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n         // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+int newLen = (len == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 5) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n     /**\n      * Method called to expand size of the current segment, to\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int newLen = (_currentSegment.length == MAX_SEGMENT_LEN? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len % 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-4/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 16:02:35.253953662 +0200\n+++ /tmp/tmp5zomwmn1.java\t2022-07-19 16:02:35.253953662 +0200\n@@ -581,11 +581,11 @@\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n         // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+int newLen = (_currentSegment.length == MAX_SEGMENT_LEN? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len % 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n     /**\n      * Method called to expand size of the current segment, to\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int newLen = (len == MAX_SEGMENT_LEN? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len % 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-4/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 16:02:38.081934096 +0200\n+++ /tmp/tmpis0a4a4k.java\t2022-07-19 16:02:38.081934096 +0200\n@@ -581,11 +581,11 @@\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n         // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+int newLen = (len == MAX_SEGMENT_LEN? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len % 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n     /**\n      * Method called to expand size of the current segment, to\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));",
        "fixed_line": "int newLen = len + (len >> 1); // but above intended maximum, slow to increase by 25% if (newLen > MAX_SEGMENT_LEN) { newLen = len + (len >> 2); }"
    },
    "Mockito-38": {
        "fixes": [
            {
                "k": 1,
                "patch": "return StringDescription.toString(m).equals < arg.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\t2022-07-19 16:02:40.797915305 +0200\n+++ /tmp/tmpsfznd09u.java\t2022-07-19 16:02:41.041913613 +0200\n@@ -43,8 +43,8 @@\n             return false;\n         }\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+return StringDescription.toString(m).equals < arg.toString());\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return StringDescription.toString(m).equals == arg.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\t2022-07-19 16:02:43.693895267 +0200\n+++ /tmp/tmpo39e20ab.java\t2022-07-19 16:02:43.705895184 +0200\n@@ -43,8 +43,8 @@\n             return false;\n         }\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+return StringDescription.toString(m).equals == arg.toString());\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return StringDescription.toString(m).equals(arg == arg.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\t2022-07-19 16:02:45.497882786 +0200\n+++ /tmp/tmph_pm02r7.java\t2022-07-19 16:02:45.497882786 +0200\n@@ -43,8 +43,8 @@\n             return false;\n         }\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+return StringDescription.toString(m).equals(arg == arg.toString());\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return StringDescription.toString(m + arg.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\t2022-07-19 16:03:00.333780137 +0200\n+++ /tmp/tmpqw6omr43.java\t2022-07-19 16:03:00.333780137 +0200\n@@ -43,8 +43,8 @@\n             return false;\n         }\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+return StringDescription.toString(m + arg.toString());\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return StringDescription.toString(m).equals(argarg.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\t2022-07-19 16:03:02.661764030 +0200\n+++ /tmp/tmpy6wwr17i.java\t2022-07-19 16:03:02.665764002 +0200\n@@ -43,8 +43,8 @@\n             return false;\n         }\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+return StringDescription.toString(m).equals(argarg.toString());\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return StringDescription.toString(m).equals(arg.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\t2022-07-19 16:03:04.865748782 +0200\n+++ /tmp/tmpdht27r6k.java\t2022-07-19 16:03:04.865748782 +0200\n@@ -43,8 +43,8 @@\n             return false;\n         }\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+return StringDescription.toString(m).equals(arg.toString());\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return StringDescription.toString(m).equals(arg;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\t2022-07-19 16:03:19.625646658 +0200\n+++ /tmp/tmposjkqklj.java\t2022-07-19 16:03:19.625646658 +0200\n@@ -43,8 +43,8 @@\n             return false;\n         }\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+return StringDescription.toString(m).equals(arg;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return StringDescription.toString(m).equals(arg);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\t2022-07-19 16:03:21.417634260 +0200\n+++ /tmp/tmpnjli873i.java\t2022-07-19 16:03:21.421634232 +0200\n@@ -43,8 +43,8 @@\n             return false;\n         }\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+return StringDescription.toString(m).equals(arg);\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return StringDescription.toString(m).equals(argName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\t2022-07-19 16:03:36.277531445 +0200\n+++ /tmp/tmpf3qy3rmv.java\t2022-07-19 16:03:36.281531419 +0200\n@@ -43,8 +43,8 @@\n             return false;\n         }\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+return StringDescription.toString(m).equals(argName);\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return StringDescription.toString(m).equals());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\t2022-07-19 16:03:38.653515007 +0200\n+++ /tmp/tmp3dfy3p6u.java\t2022-07-19 16:03:38.653515007 +0200\n@@ -43,8 +43,8 @@\n             return false;\n         }\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+return StringDescription.toString(m).equals());\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return StringDescription.toString(m).equals(arg.toString());",
        "fixed_line": "return StringDescription.toString(m).equals(arg == null? \"null\" : arg.toString());"
    },
    "JacksonCore-15": {
        "fixes": [
            {
                "k": 1,
                "patch": "// return null; can't really modify it was non-literal characters that might be valid (empty be // need to check",
                "patch_diff": "// return null; can't really modify it was non-literal characters that might be valid (empty be // need to check",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// return null; can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "// return null; can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// return null; can't really modify it was non-literal characters that might be valid (empty be valid)",
                "patch_diff": "// return null; can't really modify it was non-literal characters that might be valid (empty be valid)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// return null; can't really modify it was non-literal characters that might be valid (e if it's == null) { // as per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "// return null; can't really modify it was non-literal characters that might be valid (e if it's == null) { // as per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// return null; can't really modify it was non-literal characters that might be valid (empty be",
                "patch_diff": "// return null; can't really modify it was non-literal characters that might be valid (empty be",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// return null; can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-631], could also just be valid (empty)",
                "patch_diff": "// return null; can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-631], could also just be valid (empty)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// if (t == JsonToken.VALUE_STRING) { // let's do implicit re-parse",
                "patch_diff": "// if (t == JsonToken.VALUE_STRING) { // let's do implicit re-parse",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// return null; can't really modify it was non-literal characters that might be valid (e if it was -->",
                "patch_diff": "// return null; can't really modify it was non-literal characters that might be valid (e if it was -->",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// return null; can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-631], could also just be valid (empty be // need to check",
                "patch_diff": "// return null; can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-631], could also just be valid (empty be // need to check",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// return null; can't really modify it was non-literal characters that might be valid (e if it's == null) { // as per [JACKSON-631], could also just be valid (empty)",
                "patch_diff": "// return null; can't really modify it was non-literal characters that might be valid (e if it's == null) { // as per [JACKSON-631], could also just be valid (empty)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if(!_allowMultipleMatches && _currToken != null && _exposedContext == null){ //if not scalar and ended successfully, then return null if((_currToken.isStructEnd() && _headContext.isStartHandled()) ){ return (_currToken = null); } //else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once // then return null else if(_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath && _itemFilter == TokenFilter.INCLUDE_ALL) { return (_currToken = null); } }"
    },
    "Math-51": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if (f0 *= (f1 * (x0 + x1) * (x0 + point1.x0 = x1);",
                "patch_diff": "// if (f0 *= (f1 * (x0 + x1) * (x0 + point1.x0 = x1);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// if (x0 = x1) * (f1 + point1.x0 = x1);",
                "patch_diff": "// if (x0 = x1) * (f1 + point1.x0 = x1);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if (f0 *= (f1 * (x0 + x1) * (x0 + point1.x1 = x0);",
                "patch_diff": "// if (f0 *= (f1 * (x0 + x1) * (x0 + point1.x1 = x0);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// if (f0 *= (f1 * (x0 + point1.x1 = x0);",
                "patch_diff": "// if (f0 *= (f1 * (x0 + point1.x1 = x0);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// Should never happen. }",
                "patch_diff": "// Should never happen. }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if (x0 = x1) * (f0 + point1.x0 = x1);",
                "patch_diff": "// if (x0 = x1) * (f0 + point1.x0 = x1);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// if (f0 *= (f1 * (x0 + point1.x0 = x1);",
                "patch_diff": "// if (f0 *= (f1 * (x0 + point1.x0 = x1);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// if (x0 = x1 - x0) * (f1 = x0 - f1;",
                "patch_diff": "// if (x0 = x1 - x0) * (f1 = x0 - f1;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// if (f0 *= (f1 * (x0 + x1) * (x0 + point1.x1 = x0); }",
                "patch_diff": "// if (f0 *= (f1 * (x0 + x1) * (x0 + point1.x1 = x0); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if (f0 *= (f1 * (x0 + x1) * (x0 + point1.x0 = x0); }",
                "patch_diff": "// if (f0 *= (f1 * (x0 + x1) * (x0 + point1.x0 = x0); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "case REGULA_FALSI: if (x == x1) { final double delta = FastMath.max(rtol * FastMath.abs(x1), atol); // Update formula cannot make any progress: Update the // search interval. x0 = 0.5 * (x0 + x1 - delta); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError();"
    },
    "Chart-8": {
        "fixes": [
            {
                "k": 1,
                "patch": "this(timetime, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-8/source/org/jfree/data/time/Week.java\t2022-07-19 16:03:44.385475349 +0200\n+++ /tmp/tmp4qyqwdr5.java\t2022-07-19 16:03:44.421475099 +0200\n@@ -170,11 +170,11 @@\n      *\n      * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+this(timetime, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n     }\n \n     /**\n      * Creates a time period for the week in which the specified date/time\n      * falls, calculated relative to the specified time zone.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault().getDefault());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-8/source/org/jfree/data/time/Week.java\t2022-07-19 16:03:46.929457747 +0200\n+++ /tmp/tmptc88oajt.java\t2022-07-19 16:03:46.929457747 +0200\n@@ -170,11 +170,11 @@\n      *\n      * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault().getDefault());\n     }\n \n     /**\n      * Creates a time period for the week in which the specified date/time\n      * falls, calculated relative to the specified time zone.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "this(timeToTimePeriod, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault().getDefault());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-8/source/org/jfree/data/time/Week.java\t2022-07-19 16:03:56.617390717 +0200\n+++ /tmp/tmpefy9gx3a.java\t2022-07-19 16:03:56.617390717 +0200\n@@ -170,11 +170,11 @@\n      *\n      * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+this(timeToTimePeriod, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault().getDefault());\n     }\n \n     /**\n      * Creates a time period for the week in which the specified date/time\n      * falls, calculated relative to the specified time zone.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "this(timetime, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault().getDefault());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-8/source/org/jfree/data/time/Week.java\t2022-07-19 16:03:58.361378650 +0200\n+++ /tmp/tmpy_lqcyf_.java\t2022-07-19 16:03:58.365378622 +0200\n@@ -170,11 +170,11 @@\n      *\n      * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+this(timetime, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault().getDefault());\n     }\n \n     /**\n      * Creates a time period for the week in which the specified date/time\n      * falls, calculated relative to the specified time zone.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "this(timeToTimePeriod, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-8/source/org/jfree/data/time/Week.java\t2022-07-19 16:04:00.097366638 +0200\n+++ /tmp/tmp1gyxm9ui.java\t2022-07-19 16:04:00.097366638 +0200\n@@ -170,11 +170,11 @@\n      *\n      * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+this(timeToTimePeriod, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n     }\n \n     /**\n      * Creates a time period for the week in which the specified date/time\n      * falls, calculated relative to the specified time zone.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-8/source/org/jfree/data/time/Week.java\t2022-07-19 16:04:01.789354933 +0200\n+++ /tmp/tmpbxzufs5t.java\t2022-07-19 16:04:01.789354933 +0200\n@@ -170,11 +170,11 @@\n      *\n      * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n     }\n \n     /**\n      * Creates a time period for the week in which the specified date/time\n      * falls, calculated relative to the specified time zone.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "this(timeTimePeriod, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault().getDefault());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-8/source/org/jfree/data/time/Week.java\t2022-07-19 16:04:09.737299940 +0200\n+++ /tmp/tmpz5x6pdgb.java\t2022-07-19 16:04:09.737299940 +0200\n@@ -170,11 +170,11 @@\n      *\n      * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+this(timeTimePeriod, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault().getDefault());\n     }\n \n     /**\n      * Creates a time period for the week in which the specified date/time\n      * falls, calculated relative to the specified time zone.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "this(DEFAULT_TIME_ZONE, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-8/source/org/jfree/data/time/Week.java\t2022-07-19 16:04:11.569287266 +0200\n+++ /tmp/tmpdowm3bpm.java\t2022-07-19 16:04:11.569287266 +0200\n@@ -170,11 +170,11 @@\n      *\n      * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+this(DEFAULT_TIME_ZONE, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n     }\n \n     /**\n      * Creates a time period for the week in which the specified date/time\n      * falls, calculated relative to the specified time zone.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "this(timeTimePeriod, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-8/source/org/jfree/data/time/Week.java\t2022-07-19 16:04:13.329275088 +0200\n+++ /tmp/tmpv851xffd.java\t2022-07-19 16:04:13.329275088 +0200\n@@ -170,11 +170,11 @@\n      *\n      * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+this(timeTimePeriod, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n     }\n \n     /**\n      * Creates a time period for the week in which the specified date/time\n      * falls, calculated relative to the specified time zone.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "this(timeZone, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault().getDefault());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-8/source/org/jfree/data/time/Week.java\t2022-07-19 16:04:15.149262495 +0200\n+++ /tmp/tmpqds65g3h.java\t2022-07-19 16:04:15.153262469 +0200\n@@ -170,11 +170,11 @@\n      *\n      * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+this(timeZone, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault().getDefault());\n     }\n \n     /**\n      * Creates a time period for the week in which the specified date/time\n      * falls, calculated relative to the specified time zone.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());",
        "fixed_line": "this(time, zone, Locale.getDefault());"
    },
    "JacksonCore-23": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (PrettyPrinter createInstance) { return new DefaultPrettyPrinter(this); }",
                "patch_diff": "for (PrettyPrinter createInstance) { return new DefaultPrettyPrinter(this); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = 0; i < _PrettyPrinter.length; ++i) { return new DefaultPrettyPrinter(this); }",
                "patch_diff": "for (int i = 0; i < _PrettyPrinter.length; ++i) { return new DefaultPrettyPrinter(this); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0; i < _PrettyPrinter.length; i++) { for (int j = 0; j < _array[i].length; j++) { return this.getPrettyPrinter(this); } }",
                "patch_diff": "for (int i = 0; i < _PrettyPrinter.length; i++) { for (int j = 0; j < _array[i].length; j++) { return this.getPrettyPrinter(this); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = 0; i < _PrettyPrinter; ++i) { return new DefaultPrettyPrinter(this); }",
                "patch_diff": "for (int i = 0; i < _PrettyPrinter; ++i) { return new DefaultPrettyPrinter(this); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = 0; i < _PrettyPrinter.length; i++) { for (int j = 0; j < _array[i].length; j++) { if (this.getPrettyPrinter(this); } } }",
                "patch_diff": "for (int i = 0; i < _PrettyPrinter.length; i++) { for (int j = 0; j < _array[i].length; j++) { if (this.getPrettyPrinter(this); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = 0; i < _PrettyPrinter.length; i++) { for (int j = 0; j < _array[i].length; j++) { for (int j = 0; j < _array[i].length; j++) { if (this.getPrettyPrinter(this); } } }",
                "patch_diff": "for (int i = 0; i < _PrettyPrinter.length; i++) { for (int j = 0; j < _array[i].length; j++) { for (int j = 0; j < _array[i].length; j++) { if (this.getPrettyPrinter(this); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = 0; i < _PrettyPrinter.length; i++) { for (int j = 0; j < _array[i].length; j++) { for (int j = 0; j < _array[i].length; j++) { if (this.getPrettyPrinter(this); } } } }",
                "patch_diff": "for (int i = 0; i < _PrettyPrinter.length; i++) { for (int j = 0; j < _array[i].length; j++) { for (int j = 0; j < _array[i].length; j++) { if (this.getPrettyPrinter(this); } } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = 0; i < _PrettyPrinter.length; i++) { for (int j = 0; j < _array[i].length; j++) { for (int j = 0; j < _tokens.length; j++) { if (this.getPrettyPrinter(this); } } }",
                "patch_diff": "for (int i = 0; i < _PrettyPrinter.length; i++) { for (int j = 0; j < _array[i].length; j++) { for (int j = 0; j < _tokens.length; j++) { if (this.getPrettyPrinter(this); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int i = 0; i < _PrettyPrinter.length; i++) { for (int j = 0; j < _array[i].length; j++) { return this.getPrettyPrinter(this); } } }",
                "patch_diff": "for (int i = 0; i < _PrettyPrinter.length; i++) { for (int j = 0; j < _array[i].length; j++) { return this.getPrettyPrinter(this); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = 0; i < _PrettyPrinter.length; i++) { for (int j = 0; j < _array[i].length; j++) { for (int j = 0; j < _tokens.length; j++) { if (this.getPrettyPrinter(this); } } } }",
                "patch_diff": "for (int i = 0; i < _PrettyPrinter.length; i++) { for (int j = 0; j < _array[i].length; j++) { for (int j = 0; j < _tokens.length; j++) { if (this.getPrettyPrinter(this); } } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (getClass() != DefaultPrettyPrinter.class) { // since 2.10 throw new IllegalStateException(\"Failed `createInstance()`: \"+getClass().getName() +\" does not override method; it has to\"); }"
    },
    "Math-13": {
        "fixes": [
            {
                "k": 1,
                "patch": "// } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); }",
                "patch_diff": "// } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new IllegalArgumentException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); }",
                "patch_diff": "// } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new IllegalArgumentException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new IllegalArgumentException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); }",
                "patch_diff": "// } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new IllegalArgumentException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new IllegalArgumentException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); }",
                "patch_diff": "// } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new IllegalArgumentException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new IllegalArgumentException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); }",
                "patch_diff": "// } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new IllegalArgumentException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new IllegalArgumentException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); }",
                "patch_diff": "// } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new IllegalArgumentException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); }",
                "patch_diff": "// } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception ex) { throw new EException(e); }",
                "patch_diff": "// } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception ex) { throw new EException(e); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new IllegalArgumentException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); }",
                "patch_diff": "// } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new IllegalArgumentException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new IllegalArgumentException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); }",
                "patch_diff": "// } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new IllegalArgumentException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); } catch (Exception e) { throw new EException(e); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (m instanceof DiagonalMatrix) { final int dim = m.getRowDimension(); final RealMatrix sqrtM = new DiagonalMatrix(dim); for (int i = 0; i < dim; i++) { sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i))); } return sqrtM; } else { final EigenDecomposition dec = new EigenDecomposition(m); return dec.getSquareRoot(); }"
    },
    "Closure-33": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if ( constraintObj) {",
                "patch_diff": "// if ( constraintObj) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// else if ( constraintObj instanceof ObjectType) {",
                "patch_diff": "// else if ( constraintObj instanceof ObjectType) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// else if ( constraintObj) {",
                "patch_diff": "// else if ( constraintObj) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// if ( constraint constraintObj) {",
                "patch_diff": "// if ( constraint constraintObj) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// else if (type.equals( constraintObj)) {",
                "patch_diff": "// else if (type.equals( constraintObj)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// }",
                "patch_diff": "// }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// else if (type.equals(constraint.class)) {",
                "patch_diff": "// else if (type.equals(constraint.class)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// else if (type.equals(constraintObj) {",
                "patch_diff": "// else if (type.equals(constraintObj) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// else if (type.equals( constraintObj) {",
                "patch_diff": "// else if (type.equals( constraintObj) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// else if (type.equals(constraintObj)) {",
                "patch_diff": "// else if (type.equals(constraintObj)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (hasReferenceName()) { return; }"
    },
    "Time-7": {
        "fixes": [
            {
                "k": 1,
                "patch": "int defaultYear = ichrono.year().get(instantLocal;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-7/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 16:04:22.901208860 +0200\n+++ /tmp/tmpxfgorr4q.java\t2022-07-19 16:04:22.933208641 +0200\n@@ -705,11 +705,11 @@\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+int defaultYear = ichrono.year().get(instantLocal;\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int defaultYear = iLocals.year().get(instantLocal;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-7/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 16:04:25.789188879 +0200\n+++ /tmp/tmps16hnb_a.java\t2022-07-19 16:04:25.793188853 +0200\n@@ -705,11 +705,11 @@\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+int defaultYear = iLocals.year().get(instantLocal;\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int defaultYear = iLocals.year().get(instantLocal);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-7/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 16:04:28.305171473 +0200\n+++ /tmp/tmpwzot_i8a.java\t2022-07-19 16:04:28.309171445 +0200\n@@ -705,11 +705,11 @@\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+int defaultYear = iLocals.year().get(instantLocal);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int defaultYear = instantLocal.year().get(instantLocal);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-7/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 16:04:31.265150993 +0200\n+++ /tmp/tmppekl46bn.java\t2022-07-19 16:04:31.265150993 +0200\n@@ -705,11 +705,11 @@\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+int defaultYear = instantLocal.year().get(instantLocal);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int defaultYear = ichrono.year().get(instantLocal);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-7/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 16:04:34.069131592 +0200\n+++ /tmp/tmpn_lfaqy6.java\t2022-07-19 16:04:34.069131592 +0200\n@@ -705,11 +705,11 @@\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+int defaultYear = ichrono.year().get(instantLocal);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int defaultYear = iChronology.year().get(instantLocal;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-7/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 16:04:36.797112716 +0200\n+++ /tmp/tmpy7ocbbnp.java\t2022-07-19 16:04:36.797112716 +0200\n@@ -705,11 +705,11 @@\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+int defaultYear = iChronology.year().get(instantLocal;\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int defaultYear = iChronology.year().get(instantLocal);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-7/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 16:04:39.385094812 +0200\n+++ /tmp/tmppw31cf9p.java\t2022-07-19 16:04:39.389094783 +0200\n@@ -705,11 +705,11 @@\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+int defaultYear = iChronology.year().get(instantLocal);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int defaultYear = instantLocal.year().get(instantLocal;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-7/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 16:04:42.125075853 +0200\n+++ /tmp/tmp42zk6b2a.java\t2022-07-19 16:04:42.125075853 +0200\n@@ -705,11 +705,11 @@\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+int defaultYear = instantLocal.year().get(instantLocal;\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int defaultYear = instantLocal - chrono.year().get(instantLocal;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-7/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 16:04:44.681058168 +0200\n+++ /tmp/tmp_70fd995.java\t2022-07-19 16:04:44.681058168 +0200\n@@ -705,11 +705,11 @@\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+int defaultYear = instantLocal - chrono.year().get(instantLocal;\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int defaultYear = instantLocal - chrono.year().get(instantLocal);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-7/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 16:04:47.181040872 +0200\n+++ /tmp/tmpbur7zmep.java\t2022-07-19 16:04:47.181040872 +0200\n@@ -705,11 +705,11 @@\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+int defaultYear = instantLocal - chrono.year().get(instantLocal);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "int defaultYear = chrono.year().get(instantLocal);",
        "fixed_line": "int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);"
    },
    "Csv-9": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (final Entry<String, Integer> entry : mapping.entrySet()) {",
                "patch_diff": "for (final Entry<String, Integer> entry : mapping.entrySet()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "map.put(entry.getKey(), entry.getValue().intValue();",
                "patch_diff": "map.put(entry.getKey(), entry.getValue().intValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getValue().intValue(); for (int i = 0; i < values.length; i++) {",
                "patch_diff": "for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getValue().intValue(); for (int i = 0; i < values.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getValue().intValue(); for (int i = 0; i < values.length; i++) { final int col = entry.getValue().intValue(); for (int i = 0; i < values.length; i++) {",
                "patch_diff": "for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getValue().intValue(); for (int i = 0; i < values.length; i++) { final int col = entry.getValue().intValue(); for (int i = 0; i < values.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getKey().intValue(); for (int i = 0; i < values.length; i++) {",
                "patch_diff": "for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getKey().intValue(); for (int i = 0; i < values.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getValue().intValue(); for (int i = 0; i < values.length; i++) { map.put(entry.getKey(), entry.getValue().intValue(); } }",
                "patch_diff": "for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getValue().intValue(); for (int i = 0; i < values.length; i++) { map.put(entry.getKey(), entry.getValue().intValue(); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (final Entry<String, Integer> entry : mapping.entrySet()) { int col = entry.getValue().intValue(); for (int i = 0; i < values.length; i++) {",
                "patch_diff": "for (final Entry<String, Integer> entry : mapping.entrySet()) { int col = entry.getValue().intValue(); for (int i = 0; i < values.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getValue().intValue(); for (int i = 0; i < values.length; i++) { map.put(entry.getKey(), entry.getValue().intValue()); } }",
                "patch_diff": "for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getValue().intValue(); for (int i = 0; i < values.length; i++) { map.put(entry.getKey(), entry.getValue().intValue()); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (final Entry<String, Integer> entry : mapping.entrySet()) { if (entry.getValue().intValue() < values.length) {",
                "patch_diff": "for (final Entry<String, Integer> entry : mapping.entrySet()) { if (entry.getValue().intValue() < values.length) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getValue().intValue(); for (int i = 0; i < values.length; i++) { entry.getValue().intValue(); } }",
                "patch_diff": "for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getValue().intValue(); for (int i = 0; i < values.length; i++) { entry.getValue().intValue(); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (mapping == null) { return map; }"
    },
    "JacksonDatabind-8": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (oldOne == newOne.class) { // as per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-8/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\t2022-07-19 16:04:52.301005448 +0200\n+++ /tmp/tmpop1wfwv_.java\t2022-07-19 16:04:52.385004866 +0200\n@@ -289,11 +289,11 @@\n                 // both explicit: verify\n                 // otherwise only verify if neither explicitly annotated.\n             }\n \n             // one more thing: ok to override in sub-class\n-            if (oldOne.getClass() == newOne.getClass()) {\n+if (oldOne == newOne.class) { // as per [JACKSON-407] -- allow disabling wrapping for\n                 // [databind#667]: avoid one particular class of bogus problems\n \n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                 // otherwise, which one to choose?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (oldOne.getClass() == newOne; // to use it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-8/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\t2022-07-19 16:04:54.600989535 +0200\n+++ /tmp/tmpbquou6me.java\t2022-07-19 16:04:54.600989535 +0200\n@@ -289,11 +289,11 @@\n                 // both explicit: verify\n                 // otherwise only verify if neither explicitly annotated.\n             }\n \n             // one more thing: ok to override in sub-class\n-            if (oldOne.getClass() == newOne.getClass()) {\n+if (oldOne.getClass() == newOne; // to use it's do implicit re-parse\n                 // [databind#667]: avoid one particular class of bogus problems\n \n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                 // otherwise, which one to choose?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (oldOne.getClass() == newOne; // to normalize it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-8/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\t2022-07-19 16:04:56.208978409 +0200\n+++ /tmp/tmpulrjefsp.java\t2022-07-19 16:04:56.208978409 +0200\n@@ -289,11 +289,11 @@\n                 // both explicit: verify\n                 // otherwise only verify if neither explicitly annotated.\n             }\n \n             // one more thing: ok to override in sub-class\n-            if (oldOne.getClass() == newOne.getClass()) {\n+if (oldOne.getClass() == newOne; // to normalize it's do implicit re-parse\n                 // [databind#667]: avoid one particular class of bogus problems\n \n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                 // otherwise, which one to choose?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (oldOne == newOne; // to use it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-8/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\t2022-07-19 16:04:57.788967477 +0200\n+++ /tmp/tmp_5she7h5.java\t2022-07-19 16:04:57.788967477 +0200\n@@ -289,11 +289,11 @@\n                 // both explicit: verify\n                 // otherwise only verify if neither explicitly annotated.\n             }\n \n             // one more thing: ok to override in sub-class\n-            if (oldOne.getClass() == newOne.getClass()) {\n+if (oldOne == newOne; // to use it's do implicit re-parse\n                 // [databind#667]: avoid one particular class of bogus problems\n \n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                 // otherwise, which one to choose?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (oldOne.getClass() == newOne.class) { // as per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-8/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\t2022-07-19 16:04:59.380956462 +0200\n+++ /tmp/tmp_1qzy49g.java\t2022-07-19 16:04:59.380956462 +0200\n@@ -289,11 +289,11 @@\n                 // both explicit: verify\n                 // otherwise only verify if neither explicitly annotated.\n             }\n \n             // one more thing: ok to override in sub-class\n-            if (oldOne.getClass() == newOne.getClass()) {\n+if (oldOne.getClass() == newOne.class) { // as per [JACKSON-407] -- allow disabling wrapping for\n                 // [databind#667]: avoid one particular class of bogus problems\n \n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                 // otherwise, which one to choose?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (oldOne.getClass() == newOne.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-8/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\t2022-07-19 16:05:01.048944922 +0200\n+++ /tmp/tmp7rz8r7vt.java\t2022-07-19 16:05:01.048944922 +0200\n@@ -289,11 +289,11 @@\n                 // both explicit: verify\n                 // otherwise only verify if neither explicitly annotated.\n             }\n \n             // one more thing: ok to override in sub-class\n-            if (oldOne.getClass() == newOne.getClass()) {\n+if (oldOne.getClass() == newOne.class) {\n                 // [databind#667]: avoid one particular class of bogus problems\n \n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                 // otherwise, which one to choose?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (oldOne.getClass() == newOne.class;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-8/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\t2022-07-19 16:05:02.772932992 +0200\n+++ /tmp/tmpjwczx87k.java\t2022-07-19 16:05:02.772932992 +0200\n@@ -289,11 +289,11 @@\n                 // both explicit: verify\n                 // otherwise only verify if neither explicitly annotated.\n             }\n \n             // one more thing: ok to override in sub-class\n-            if (oldOne.getClass() == newOne.getClass()) {\n+if (oldOne.getClass() == newOne.class;\n                 // [databind#667]: avoid one particular class of bogus problems\n \n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                 // otherwise, which one to choose?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (oldOne == newOne) { // as per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-8/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\t2022-07-19 16:05:04.428921536 +0200\n+++ /tmp/tmp8yk5eqlm.java\t2022-07-19 16:05:04.432921508 +0200\n@@ -289,11 +289,11 @@\n                 // both explicit: verify\n                 // otherwise only verify if neither explicitly annotated.\n             }\n \n             // one more thing: ok to override in sub-class\n-            if (oldOne.getClass() == newOne.getClass()) {\n+if (oldOne == newOne) { // as per [JACKSON-407] -- allow disabling wrapping for\n                 // [databind#667]: avoid one particular class of bogus problems\n \n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                 // otherwise, which one to choose?\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (oldOne.getClass() == newOne; // to add",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-8/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\t2022-07-19 16:05:35.004709985 +0200\n+++ /tmp/tmppzm__xaj.java\t2022-07-19 16:05:35.004709985 +0200\n@@ -289,11 +289,11 @@\n                 // both explicit: verify\n                 // otherwise only verify if neither explicitly annotated.\n             }\n \n             // one more thing: ok to override in sub-class\n-            if (oldOne.getClass() == newOne.getClass()) {\n+if (oldOne.getClass() == newOne; // to add\n                 // [databind#667]: avoid one particular class of bogus problems\n \n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                 // otherwise, which one to choose?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (oldOne.getClass() == newOne;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-8/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\t2022-07-19 16:05:36.620698805 +0200\n+++ /tmp/tmp5nhzqjgv.java\t2022-07-19 16:05:36.620698805 +0200\n@@ -289,11 +289,11 @@\n                 // both explicit: verify\n                 // otherwise only verify if neither explicitly annotated.\n             }\n \n             // one more thing: ok to override in sub-class\n-            if (oldOne.getClass() == newOne.getClass()) {\n+if (oldOne.getClass() == newOne;\n                 // [databind#667]: avoid one particular class of bogus problems\n \n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                 // otherwise, which one to choose?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (oldOne.getClass() == newOne.getClass()) {",
        "fixed_line": "boolean verify; if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is // but skip, if new one not annotated if (!explicit) { return; } // both explicit: verify verify = true; } else { // otherwise only verify if neither explicitly annotated. verify = !explicit; } // one more thing: ok to override in sub-class if (verify && (oldOne.getClass() == newOne.getClass())) { // [databind#667]: avoid one particular class of bogus problems Class<?> oldType = oldOne.getRawParameterType(0); Class<?> newType = newOne.getRawParameterType(0); if (oldType == newType) { throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex] +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne); } // otherwise, which one to choose? if (newType.isAssignableFrom(oldType)) { // new type more generic, use old return; }"
    },
    "Closure-14": {
        "fixes": [
            {
                "k": 1,
                "patch": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode = finallyNode.UNCOND, finallyNode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\t2022-07-19 16:05:38.560685382 +0200\n+++ /tmp/tmpgd_kwm2s.java\t2022-07-19 16:05:38.612685020 +0200\n@@ -762,11 +762,11 @@\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+cfa.createEdge(fromNode, Branch.UNCOND, finallyNode = finallyNode.UNCOND, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode = finallyNode.UNCOND, finallyNode.UNCOND, finallyNode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\t2022-07-19 16:05:43.536650953 +0200\n+++ /tmp/tmpwi7u9bgn.java\t2022-07-19 16:05:43.540650924 +0200\n@@ -762,11 +762,11 @@\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+cfa.createEdge(fromNode, Branch.UNCOND, finallyNode = finallyNode.UNCOND, finallyNode.UNCOND, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode.UNCOND, finallyNode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\t2022-07-19 16:05:47.040626710 +0200\n+++ /tmp/tmpflk0z6_z.java\t2022-07-19 16:05:47.040626710 +0200\n@@ -762,11 +762,11 @@\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+cfa.createEdge(fromNode, Branch.UNCOND, finallyNode.UNCOND, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode, finallyNode.UNCOND, finallyNode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\t2022-07-19 16:05:50.664601634 +0200\n+++ /tmp/tmpl6q4jdpm.java\t2022-07-19 16:05:50.664601634 +0200\n@@ -762,11 +762,11 @@\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+cfa.createEdge(fromNode, Branch.UNCOND, finallyNode, finallyNode.UNCOND, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode.UNCOND, finallyNode.UNCOND, finallyNode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\t2022-07-19 16:05:54.332576258 +0200\n+++ /tmp/tmpdsq0tay2.java\t2022-07-19 16:05:54.336576229 +0200\n@@ -762,11 +762,11 @@\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+cfa.createEdge(fromNode, Branch.UNCOND, finallyNode.UNCOND, finallyNode.UNCOND, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode.UNCOND, finallyNode = finallyNode.UNCOND, finallyNode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\t2022-07-19 16:05:57.992550934 +0200\n+++ /tmp/tmpl5g_ndih.java\t2022-07-19 16:05:57.992550934 +0200\n@@ -762,11 +762,11 @@\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+cfa.createEdge(fromNode, Branch.UNCOND, finallyNode.UNCOND, finallyNode = finallyNode.UNCOND, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNodeUtil.UNCOND, finallyNode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\t2022-07-19 16:06:01.728525084 +0200\n+++ /tmp/tmp1igrpl43.java\t2022-07-19 16:06:01.728525084 +0200\n@@ -762,11 +762,11 @@\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+cfa.createEdge(fromNode, Branch.UNCOND, finallyNodeUtil.UNCOND, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode = finallyNode.UNCOND;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\t2022-07-19 16:06:05.380499817 +0200\n+++ /tmp/tmpqvbr_404.java\t2022-07-19 16:06:05.384499791 +0200\n@@ -762,11 +762,11 @@\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+cfa.createEdge(fromNode, Branch.UNCOND, finallyNode = finallyNode.UNCOND;\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode, finallyNode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\t2022-07-19 16:06:08.664477095 +0200\n+++ /tmp/tmpvikk5nr7.java\t2022-07-19 16:06:08.664477095 +0200\n@@ -762,11 +762,11 @@\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+cfa.createEdge(fromNode, Branch.UNCOND, finallyNode, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode = finallyNode.UNCOND, finallyNode.UNCOND, finallyNode.UNCOND, finallyNode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\t2022-07-19 16:06:12.216452521 +0200\n+++ /tmp/tmpfglrthcv.java\t2022-07-19 16:06:12.220452493 +0200\n@@ -762,11 +762,11 @@\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+cfa.createEdge(fromNode, Branch.UNCOND, finallyNode = finallyNode.UNCOND, finallyNode.UNCOND, finallyNode.UNCOND, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);",
        "fixed_line": "cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);"
    },
    "Cli-19": {
        "fixes": [
            {
                "k": 1,
                "patch": "tokens.add(tokenPropertyAtNonOption) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-19/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 16:06:15.888427117 +0200\n+++ /tmp/tmpndb_xupi.java\t2022-07-19 16:06:15.916426922 +0200\n@@ -227,16 +227,11 @@\n     private void processOptionToken(String token, boolean stopAtNonOption)\n     {\n         if (options.hasOption(token))\n         {\n             currentOption = options.getOption(token);\n-            tokens.add(token);\n-        }\n-        else if (stopAtNonOption)\n-        {\n-            eatTheRest = true;\n-            tokens.add(token);\n+tokens.add(tokenPropertyAtNonOption) {\n         }\n     }\n \n     /**\n      * <p>Breaks <code>token</code> into its constituent parts\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "tokens.add(token; if (tokentokenIncompleteOption) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-19/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 16:06:17.576415435 +0200\n+++ /tmp/tmpgeitss_v.java\t2022-07-19 16:06:17.580415409 +0200\n@@ -227,16 +227,11 @@\n     private void processOptionToken(String token, boolean stopAtNonOption)\n     {\n         if (options.hasOption(token))\n         {\n             currentOption = options.getOption(token);\n-            tokens.add(token);\n-        }\n-        else if (stopAtNonOption)\n-        {\n-            eatTheRest = true;\n-            tokens.add(token);\n+tokens.add(token; if (tokentokenIncompleteOption) {\n         }\n     }\n \n     /**\n      * <p>Breaks <code>token</code> into its constituent parts\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "tokens.add(token); } else if (tokentokenIncompleteOption) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-19/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 16:06:19.100404892 +0200\n+++ /tmp/tmpus2ucxz1.java\t2022-07-19 16:06:19.100404892 +0200\n@@ -227,16 +227,11 @@\n     private void processOptionToken(String token, boolean stopAtNonOption)\n     {\n         if (options.hasOption(token))\n         {\n             currentOption = options.getOption(token);\n-            tokens.add(token);\n-        }\n-        else if (stopAtNonOption)\n-        {\n-            eatTheRest = true;\n-            tokens.add(token);\n+tokens.add(token); } else if (tokentokenIncompleteOption) {\n         }\n     }\n \n     /**\n      * <p>Breaks <code>token</code> into its constituent parts\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "tokens.add(tokenLen =stopAtNonOption; {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-19/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 16:06:20.784393241 +0200\n+++ /tmp/tmp8ztm1f37.java\t2022-07-19 16:06:20.784393241 +0200\n@@ -227,16 +227,11 @@\n     private void processOptionToken(String token, boolean stopAtNonOption)\n     {\n         if (options.hasOption(token))\n         {\n             currentOption = options.getOption(token);\n-            tokens.add(token);\n-        }\n-        else if (stopAtNonOption)\n-        {\n-            eatTheRest = true;\n-            tokens.add(token);\n+tokens.add(tokenLen =stopAtNonOption; {\n         }\n     }\n \n     /**\n      * <p>Breaks <code>token</code> into its constituent parts\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "tokens.add(token; if (stopAtNonOption) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-19/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 16:06:22.380382198 +0200\n+++ /tmp/tmp6wexmdvr.java\t2022-07-19 16:06:22.384382170 +0200\n@@ -227,16 +227,11 @@\n     private void processOptionToken(String token, boolean stopAtNonOption)\n     {\n         if (options.hasOption(token))\n         {\n             currentOption = options.getOption(token);\n-            tokens.add(token);\n-        }\n-        else if (stopAtNonOption)\n-        {\n-            eatTheRest = true;\n-            tokens.add(token);\n+tokens.add(token; if (stopAtNonOption) {\n         }\n     }\n \n     /**\n      * <p>Breaks <code>token</code> into its constituent parts\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "tokens.add(token; } else if (tokentokenIncompleteOption) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-19/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 16:06:23.952371322 +0200\n+++ /tmp/tmpr1qaet1e.java\t2022-07-19 16:06:24.032370768 +0200\n@@ -227,16 +227,11 @@\n     private void processOptionToken(String token, boolean stopAtNonOption)\n     {\n         if (options.hasOption(token))\n         {\n             currentOption = options.getOption(token);\n-            tokens.add(token);\n-        }\n-        else if (stopAtNonOption)\n-        {\n-            eatTheRest = true;\n-            tokens.add(token);\n+tokens.add(token; } else if (tokentokenIncompleteOption) {\n         }\n     }\n \n     /**\n      * <p>Breaks <code>token</code> into its constituent parts\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "tokens.add(tokentokenIncompleteOption = false;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-19/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 16:06:25.484360722 +0200\n+++ /tmp/tmp1_5b1puc.java\t2022-07-19 16:06:25.488360694 +0200\n@@ -227,16 +227,11 @@\n     private void processOptionToken(String token, boolean stopAtNonOption)\n     {\n         if (options.hasOption(token))\n         {\n             currentOption = options.getOption(token);\n-            tokens.add(token);\n-        }\n-        else if (stopAtNonOption)\n-        {\n-            eatTheRest = true;\n-            tokens.add(token);\n+tokens.add(tokentokenIncompleteOption = false;\n         }\n     }\n \n     /**\n      * <p>Breaks <code>token</code> into its constituent parts\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "tokens.add(token); } else if (stopAtNonOption) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-19/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 16:06:26.904350896 +0200\n+++ /tmp/tmpy0k86nsp.java\t2022-07-19 16:06:26.908350870 +0200\n@@ -227,16 +227,11 @@\n     private void processOptionToken(String token, boolean stopAtNonOption)\n     {\n         if (options.hasOption(token))\n         {\n             currentOption = options.getOption(token);\n-            tokens.add(token);\n-        }\n-        else if (stopAtNonOption)\n-        {\n-            eatTheRest = true;\n-            tokens.add(token);\n+tokens.add(token); } else if (stopAtNonOption) {\n         }\n     }\n \n     /**\n      * <p>Breaks <code>token</code> into its constituent parts\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "tokens.add(token; } else if (stopAtNonOption) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-19/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 16:06:29.156335314 +0200\n+++ /tmp/tmp1exsqttt.java\t2022-07-19 16:06:29.156335314 +0200\n@@ -227,16 +227,11 @@\n     private void processOptionToken(String token, boolean stopAtNonOption)\n     {\n         if (options.hasOption(token))\n         {\n             currentOption = options.getOption(token);\n-            tokens.add(token);\n-        }\n-        else if (stopAtNonOption)\n-        {\n-            eatTheRest = true;\n-            tokens.add(token);\n+tokens.add(token; } else if (stopAtNonOption) {\n         }\n     }\n \n     /**\n      * <p>Breaks <code>token</code> into its constituent parts\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "tokens.add(token); if (tokentokenIncompleteOption) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-19/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 16:06:30.584325435 +0200\n+++ /tmp/tmp11890iqw.java\t2022-07-19 16:06:30.584325435 +0200\n@@ -227,16 +227,11 @@\n     private void processOptionToken(String token, boolean stopAtNonOption)\n     {\n         if (options.hasOption(token))\n         {\n             currentOption = options.getOption(token);\n-            tokens.add(token);\n-        }\n-        else if (stopAtNonOption)\n-        {\n-            eatTheRest = true;\n-            tokens.add(token);\n+tokens.add(token); if (tokentokenIncompleteOption) {\n         }\n     }\n \n     /**\n      * <p>Breaks <code>token</code> into its constituent parts\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "tokens.add(token); } else if (stopAtNonOption) { eatTheRest = true; tokens.add(token);",
        "fixed_line": "tokens.add(token);"
    },
    "Math-87": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (row.equals(endIndex, 0.0, col, col = 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-87/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 16:06:32.168314474 +0200\n+++ /tmp/tmp6_kehq3_.java\t2022-07-19 16:06:32.248313924 +0200\n@@ -270,16 +270,11 @@\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n-                if (row == null) {\n-                row = i;\n-                } else {\n-                return null;\n-                }\n+if (row.equals(endIndex, 0.0, col, col = 0;\n             }\n         }\n         return row;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (i.equals(endIndex, 0.0, col, null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-87/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 16:06:34.592297705 +0200\n+++ /tmp/tmp_dyox7l3.java\t2022-07-19 16:06:34.592297705 +0200\n@@ -270,16 +270,11 @@\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n-                if (row == null) {\n-                row = i;\n-                } else {\n-                return null;\n-                }\n+if (i.equals(endIndex, 0.0, col, null) {\n             }\n         }\n         return row;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (i.equals(row, col), 0.0, column)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-87/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 16:06:36.528284310 +0200\n+++ /tmp/tmpz2ld6mon.java\t2022-07-19 16:06:36.528284310 +0200\n@@ -270,16 +270,11 @@\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n-                if (row == null) {\n-                row = i;\n-                } else {\n-                return null;\n-                }\n+if (i.equals(row, col), 0.0, column)) {\n             }\n         }\n         return row;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (i.equals(endIndex, 0.0, col, column)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-87/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 16:06:38.500270666 +0200\n+++ /tmp/tmpd0f9tmra.java\t2022-07-19 16:06:38.500270666 +0200\n@@ -270,16 +270,11 @@\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n-                if (row == null) {\n-                row = i;\n-                } else {\n-                return null;\n-                }\n+if (i.equals(endIndex, 0.0, col, column)) {\n             }\n         }\n         return row;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (i.equals(endIndex, 0.0, col, col = 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-87/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 16:06:40.744255139 +0200\n+++ /tmp/tmpovicdno3.java\t2022-07-19 16:06:40.744255139 +0200\n@@ -270,16 +270,11 @@\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n-                if (row == null) {\n-                row = i;\n-                } else {\n-                return null;\n-                }\n+if (i.equals(endIndex, 0.0, col, col = 0;\n             }\n         }\n         return row;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (calendar.equals(endIndex, 0.0, col, col = 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-87/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 16:06:42.652241939 +0200\n+++ /tmp/tmp84hf6cto.java\t2022-07-19 16:06:42.652241939 +0200\n@@ -270,16 +270,11 @@\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n-                if (row == null) {\n-                row = i;\n-                } else {\n-                return null;\n-                }\n+if (calendar.equals(endIndex, 0.0, col, col = 0;\n             }\n         }\n         return row;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (i.equals(endIndex, 0.0, col, col, col = 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-87/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 16:06:44.572228655 +0200\n+++ /tmp/tmptj6yp95n.java\t2022-07-19 16:06:44.572228655 +0200\n@@ -270,16 +270,11 @@\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n-                if (row == null) {\n-                row = i;\n-                } else {\n-                return null;\n-                }\n+if (i.equals(endIndex, 0.0, col, col, col = 0;\n             }\n         }\n         return row;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (i.equals(endIndex, 0.0, col, col) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-87/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 16:06:46.588214706 +0200\n+++ /tmp/tmpat8ekqaf.java\t2022-07-19 16:06:46.588214706 +0200\n@@ -270,16 +270,11 @@\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n-                if (row == null) {\n-                row = i;\n-                } else {\n-                return null;\n-                }\n+if (i.equals(endIndex, 0.0, col, col) {\n             }\n         }\n         return row;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (i.equals(subMatrix, col), 0.0, null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-87/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 16:06:48.692200149 +0200\n+++ /tmp/tmp_auo74l2.java\t2022-07-19 16:06:48.692200149 +0200\n@@ -270,16 +270,11 @@\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n-                if (row == null) {\n-                row = i;\n-                } else {\n-                return null;\n-                }\n+if (i.equals(subMatrix, col), 0.0, null) {\n             }\n         }\n         return row;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (i.equals(value, col), 0.0, null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-87/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 16:06:50.736186006 +0200\n+++ /tmp/tmp7cb61mka.java\t2022-07-19 16:06:50.736186006 +0200\n@@ -270,16 +270,11 @@\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n-                if (row == null) {\n-                row = i;\n-                } else {\n-                return null;\n-                }\n+if (i.equals(value, col), 0.0, null) {\n             }\n         }\n         return row;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) { if (row == null) { row = i; } else { return null; }",
        "fixed_line": "if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) { row = i; } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {"
    },
    "Closure-123": {
        "fixes": [
            {
                "k": 1,
                "patch": "Context.OTHER = context.OTHER;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-123/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 16:06:52.772171921 +0200\n+++ /tmp/tmpohzpfg2e.java\t2022-07-19 16:06:52.796171754 +0200\n@@ -280,11 +280,11 @@\n       }\n \n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+Context.OTHER = context.OTHER;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n         cc.addOp(\":\", true);\n         addExpr(last, 1, rhsContext);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "Context.OTHER = context;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-123/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 16:06:57.948136108 +0200\n+++ /tmp/tmp9e_6qvdj.java\t2022-07-19 16:06:57.948136108 +0200\n@@ -280,11 +280,11 @@\n       }\n \n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+Context.OTHER = context;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n         cc.addOp(\":\", true);\n         addExpr(last, 1, rhsContext);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "Context.OTHER = p.OTHER;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-123/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 16:07:01.428112031 +0200\n+++ /tmp/tmp9kw8q4wl.java\t2022-07-19 16:07:01.432112002 +0200\n@@ -280,11 +280,11 @@\n       }\n \n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+Context.OTHER = p.OTHER;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n         cc.addOp(\":\", true);\n         addExpr(last, 1, rhsContext);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "Context rhsContext = context.OTHER;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-123/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 16:07:04.932087788 +0200\n+++ /tmp/tmpxmppf_t6.java\t2022-07-19 16:07:04.936087759 +0200\n@@ -280,11 +280,11 @@\n       }\n \n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+Context rhsContext = context.OTHER;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n         cc.addOp(\":\", true);\n         addExpr(last, 1, rhsContext);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "Context rhsContext = p.OTHER;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-123/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 16:07:56.691729668 +0200\n+++ /tmp/tmpvvhj_yh6.java\t2022-07-19 16:07:56.691729668 +0200\n@@ -280,11 +280,11 @@\n       }\n \n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+Context rhsContext = p.OTHER;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n         cc.addOp(\":\", true);\n         addExpr(last, 1, rhsContext);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "Context.OTHER = Context.OTHER;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-123/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 16:08:00.219705256 +0200\n+++ /tmp/tmp002u1ui4.java\t2022-07-19 16:08:00.219705256 +0200\n@@ -280,11 +280,11 @@\n       }\n \n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+Context.OTHER = Context.OTHER;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n         cc.addOp(\":\", true);\n         addExpr(last, 1, rhsContext);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "Context rhsContext = context;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-123/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 16:08:03.747680849 +0200\n+++ /tmp/tmpri5uoex9.java\t2022-07-19 16:08:03.747680849 +0200\n@@ -280,11 +280,11 @@\n       }\n \n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+Context rhsContext = context;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n         cc.addOp(\":\", true);\n         addExpr(last, 1, rhsContext);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "Context.OTHER = 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-123/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 16:08:52.603342822 +0200\n+++ /tmp/tmpte3abt_x.java\t2022-07-19 16:08:52.603342822 +0200\n@@ -280,11 +280,11 @@\n       }\n \n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+Context.OTHER = 1;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n         cc.addOp(\":\", true);\n         addExpr(last, 1, rhsContext);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "Context rhsContext = Context.OTHER;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-123/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 16:08:56.091318689 +0200\n+++ /tmp/tmpul9ho6fp.java\t2022-07-19 16:08:56.091318689 +0200\n@@ -280,11 +280,11 @@\n       }\n \n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+Context rhsContext = Context.OTHER;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n         cc.addOp(\":\", true);\n         addExpr(last, 1, rhsContext);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "Context rhsContext = p;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-123/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 16:09:45.270978420 +0200\n+++ /tmp/tmp_r42zh26.java\t2022-07-19 16:09:45.270978420 +0200\n@@ -280,11 +280,11 @@\n       }\n \n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+Context rhsContext = p;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n         cc.addOp(\":\", true);\n         addExpr(last, 1, rhsContext);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "Context rhsContext = Context.OTHER;",
        "fixed_line": "Context rhsContext = getContextForNoInOperator(context);"
    },
    "JacksonDatabind-33": {
        "fixes": [
            {
                "k": 1,
                "patch": "|| _hasAnnotation(a, JsonRawValue.class = _hasArg;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-33/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\t2022-07-19 16:09:49.014952516 +0200\n+++ /tmp/tmppizlemu_.java\t2022-07-19 16:09:49.102951907 +0200\n@@ -743,11 +743,11 @@\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n             } else if (_hasAnnotation(a, JsonSerialize.class)\n                     || _hasAnnotation(a, JsonView.class)\n-                    || _hasAnnotation(a, JsonRawValue.class)) {\n+|| _hasAnnotation(a, JsonRawValue.class = _hasArg;\n                 name = \"\";\n             } else {\n                 return null;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "|| _hasAnnotation;a, JsonRawValue.class == JsonRawValue.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-33/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\t2022-07-19 16:09:50.978938928 +0200\n+++ /tmp/tmppfh4qbkm.java\t2022-07-19 16:09:50.978938928 +0200\n@@ -743,11 +743,11 @@\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n             } else if (_hasAnnotation(a, JsonSerialize.class)\n                     || _hasAnnotation(a, JsonView.class)\n-                    || _hasAnnotation(a, JsonRawValue.class)) {\n+|| _hasAnnotation;a, JsonRawValue.class == JsonRawValue.class) {\n                 name = \"\";\n             } else {\n                 return null;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "|| _hasAnnotation(a, JsonRawValue.class == JsonRawValue.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-33/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\t2022-07-19 16:09:52.558927993 +0200\n+++ /tmp/tmpabt5k014.java\t2022-07-19 16:09:52.558927993 +0200\n@@ -743,11 +743,11 @@\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n             } else if (_hasAnnotation(a, JsonSerialize.class)\n                     || _hasAnnotation(a, JsonView.class)\n-                    || _hasAnnotation(a, JsonRawValue.class)) {\n+|| _hasAnnotation(a, JsonRawValue.class == JsonRawValue.class) {\n                 name = \"\";\n             } else {\n                 return null;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "|| _hasAnnotation;a, JsonRawValue.class!= JsonRawValue.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-33/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\t2022-07-19 16:09:54.138917064 +0200\n+++ /tmp/tmp734vxr3_.java\t2022-07-19 16:09:54.138917064 +0200\n@@ -743,11 +743,11 @@\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n             } else if (_hasAnnotation(a, JsonSerialize.class)\n                     || _hasAnnotation(a, JsonView.class)\n-                    || _hasAnnotation(a, JsonRawValue.class)) {\n+|| _hasAnnotation;a, JsonRawValue.class!= JsonRawValue.class) {\n                 name = \"\";\n             } else {\n                 return null;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "|| _hasAnnotation;a, JsonRawValue.class = _hasAnnotation;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-33/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\t2022-07-19 16:09:55.702906243 +0200\n+++ /tmp/tmp6guh0b5z.java\t2022-07-19 16:09:55.706906215 +0200\n@@ -743,11 +743,11 @@\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n             } else if (_hasAnnotation(a, JsonSerialize.class)\n                     || _hasAnnotation(a, JsonView.class)\n-                    || _hasAnnotation(a, JsonRawValue.class)) {\n+|| _hasAnnotation;a, JsonRawValue.class = _hasAnnotation;\n                 name = \"\";\n             } else {\n                 return null;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "|| _hasAnnotation(a, JsonRawValue.class!= JsonRawValue.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-33/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\t2022-07-19 16:09:57.242895586 +0200\n+++ /tmp/tmpbpcabd5p.java\t2022-07-19 16:09:57.242895586 +0200\n@@ -743,11 +743,11 @@\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n             } else if (_hasAnnotation(a, JsonSerialize.class)\n                     || _hasAnnotation(a, JsonView.class)\n-                    || _hasAnnotation(a, JsonRawValue.class)) {\n+|| _hasAnnotation(a, JsonRawValue.class!= JsonRawValue.class) {\n                 name = \"\";\n             } else {\n                 return null;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "|| _hasAnnotation;a, JsonRawValue.class = _hasArg;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-33/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\t2022-07-19 16:09:58.846884490 +0200\n+++ /tmp/tmpu0l17wt9.java\t2022-07-19 16:09:58.846884490 +0200\n@@ -743,11 +743,11 @@\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n             } else if (_hasAnnotation(a, JsonSerialize.class)\n                     || _hasAnnotation(a, JsonView.class)\n-                    || _hasAnnotation(a, JsonRawValue.class)) {\n+|| _hasAnnotation;a, JsonRawValue.class = _hasArg;\n                 name = \"\";\n             } else {\n                 return null;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "|| _hasAnnotation(a, JsonRawValue.class = _hasAnnotation;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-33/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\t2022-07-19 16:10:00.370873944 +0200\n+++ /tmp/tmp9tkc0l5w.java\t2022-07-19 16:10:00.370873944 +0200\n@@ -743,11 +743,11 @@\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n             } else if (_hasAnnotation(a, JsonSerialize.class)\n                     || _hasAnnotation(a, JsonView.class)\n-                    || _hasAnnotation(a, JsonRawValue.class)) {\n+|| _hasAnnotation(a, JsonRawValue.class = _hasAnnotation;\n                 name = \"\";\n             } else {\n                 return null;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "|| _hasAnnotation;a, JsonRawValue.class)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-33/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\t2022-07-19 16:10:01.938863095 +0200\n+++ /tmp/tmpxiu2gjdb.java\t2022-07-19 16:10:01.938863095 +0200\n@@ -743,11 +743,11 @@\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n             } else if (_hasAnnotation(a, JsonSerialize.class)\n                     || _hasAnnotation(a, JsonView.class)\n-                    || _hasAnnotation(a, JsonRawValue.class)) {\n+|| _hasAnnotation;a, JsonRawValue.class)) {\n                 name = \"\";\n             } else {\n                 return null;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "|| _hasAnnotation(a, JsonRawValue.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-33/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\t2022-07-19 16:10:03.518852165 +0200\n+++ /tmp/tmpsmazg0w7.java\t2022-07-19 16:10:03.522852135 +0200\n@@ -743,11 +743,11 @@\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n             } else if (_hasAnnotation(a, JsonSerialize.class)\n                     || _hasAnnotation(a, JsonView.class)\n-                    || _hasAnnotation(a, JsonRawValue.class)) {\n+|| _hasAnnotation(a, JsonRawValue.class) {\n                 name = \"\";\n             } else {\n                 return null;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "|| _hasAnnotation(a, JsonRawValue.class)) {",
        "fixed_line": "|| _hasAnnotation(a, JsonRawValue.class) || _hasAnnotation(a, JsonUnwrapped.class) || _hasAnnotation(a, JsonBackReference.class) || _hasAnnotation(a, JsonManagedReference.class)) {"
    },
    "Closure-39": {
        "fixes": [
            {
                "k": 1,
                "patch": "sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE_PRETTY_PRINTED_TYPE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-39/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2022-07-19 16:10:05.362839407 +0200\n+++ /tmp/tmpbu65_j1d.java\t2022-07-19 16:10:05.434838910 +0200\n@@ -375,25 +375,11 @@\n           sb.append(\", \");\n         }\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n-\n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n-      }\n-\n-      sb.append(\"}\");\n-\n-      prettyPrint = true;\n-      return sb.toString();\n-    } else {\n-      return \"{...}\";\n+sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE_PRETTY_PRINTED_TYPE;\n     }\n   }\n \n   void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE_TYPE_PRETTY_PRINTED_TYPE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-39/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2022-07-19 16:10:10.350804896 +0200\n+++ /tmp/tmpk0sgcclc.java\t2022-07-19 16:10:10.350804896 +0200\n@@ -375,25 +375,11 @@\n           sb.append(\", \");\n         }\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n-\n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n-      }\n-\n-      sb.append(\"}\");\n-\n-      prettyPrint = true;\n-      return sb.toString();\n-    } else {\n-      return \"{...}\";\n+sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE_TYPE_PRETTY_PRINTED_TYPE;\n     }\n   }\n \n   void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE_PRETTY_PRINTED_TYPE_TYPE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-39/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2022-07-19 16:10:13.794781065 +0200\n+++ /tmp/tmpx6wmq3hs.java\t2022-07-19 16:10:13.794781065 +0200\n@@ -375,25 +375,11 @@\n           sb.append(\", \");\n         }\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n-\n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n-      }\n-\n-      sb.append(\"}\");\n-\n-      prettyPrint = true;\n-      return sb.toString();\n-    } else {\n-      return \"{...}\";\n+sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE_PRETTY_PRINTED_TYPE_TYPE;\n     }\n   }\n \n   void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE_TYPE_ERROR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-39/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2022-07-19 16:10:17.022758733 +0200\n+++ /tmp/tmpk3kb61dj.java\t2022-07-19 16:10:17.022758733 +0200\n@@ -375,25 +375,11 @@\n           sb.append(\", \");\n         }\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n-\n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n-      }\n-\n-      sb.append(\"}\");\n-\n-      prettyPrint = true;\n-      return sb.toString();\n-    } else {\n-      return \"{...}\";\n+sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE_TYPE_ERROR;\n     }\n   }\n \n   void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE_TYPE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-39/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2022-07-19 16:10:20.374735539 +0200\n+++ /tmp/tmplew_1bpu.java\t2022-07-19 16:10:20.374735539 +0200\n@@ -375,25 +375,11 @@\n           sb.append(\", \");\n         }\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n-\n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n-      }\n-\n-      sb.append(\"}\");\n-\n-      prettyPrint = true;\n-      return sb.toString();\n-    } else {\n-      return \"{...}\";\n+sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE_TYPE;\n     }\n   }\n \n   void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE_PRETTY_PRINTED_TYPE_PRETTY_PRINTED_TYPE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-39/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2022-07-19 16:10:23.610713152 +0200\n+++ /tmp/tmp634fipur.java\t2022-07-19 16:10:23.610713152 +0200\n@@ -375,25 +375,11 @@\n           sb.append(\", \");\n         }\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n-\n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n-      }\n-\n-      sb.append(\"}\");\n-\n-      prettyPrint = true;\n-      return sb.toString();\n-    } else {\n-      return \"{...}\";\n+sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE_PRETTY_PRINTED_TYPE_PRETTY_PRINTED_TYPE;\n     }\n   }\n \n   void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE_TYPE_PRETTY_PRINTED_TYPE_TYPE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-39/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2022-07-19 16:10:27.026689517 +0200\n+++ /tmp/tmpscaxw96o.java\t2022-07-19 16:10:27.030689487 +0200\n@@ -375,25 +375,11 @@\n           sb.append(\", \");\n         }\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n-\n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n-      }\n-\n-      sb.append(\"}\");\n-\n-      prettyPrint = true;\n-      return sb.toString();\n-    } else {\n-      return \"{...}\";\n+sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE_TYPE_PRETTY_PRINTED_TYPE_TYPE;\n     }\n   }\n \n   void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE_ERROR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-39/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2022-07-19 16:10:30.598664802 +0200\n+++ /tmp/tmpipka2qkj.java\t2022-07-19 16:10:30.598664802 +0200\n@@ -375,25 +375,11 @@\n           sb.append(\", \");\n         }\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n-\n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n-      }\n-\n-      sb.append(\"}\");\n-\n-      prettyPrint = true;\n-      return sb.toString();\n-    } else {\n-      return \"{...}\";\n+sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE_ERROR;\n     }\n   }\n \n   void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE_PRETTY_PRINTED_TYPE_ERROR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-39/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2022-07-19 16:10:33.934641721 +0200\n+++ /tmp/tmpfl00ftpc.java\t2022-07-19 16:10:33.938641692 +0200\n@@ -375,25 +375,11 @@\n           sb.append(\", \");\n         }\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n-\n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n-      }\n-\n-      sb.append(\"}\");\n-\n-      prettyPrint = true;\n-      return sb.toString();\n-    } else {\n-      return \"{...}\";\n+sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE_PRETTY_PRINTED_TYPE_ERROR;\n     }\n   }\n \n   void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE_PRINTED_TYPE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-39/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2022-07-19 16:10:37.250623398 +0200\n+++ /tmp/tmp3z3xv8at.java\t2022-07-19 16:10:37.250623398 +0200\n@@ -375,25 +375,11 @@\n           sb.append(\", \");\n         }\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n-\n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n-      }\n-\n-      sb.append(\"}\");\n-\n-      prettyPrint = true;\n-      return sb.toString();\n-    } else {\n-      return \"{...}\";\n+sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE_PRINTED_TYPE;\n     }\n   }\n \n   void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "sb.append(getPropertyType(property).toString()); ++i; if (i == MAX_PRETTY_PRINTED_PROPERTIES) { sb.append(\", ...\"); break; } } sb.append(\"}\"); prettyPrint = true; return sb.toString(); } else { return \"{...}\";",
        "fixed_line": "sb.append(getPropertyType(property).toStringHelper(forAnnotations)); ++i; if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) { sb.append(\", ...\"); break; } } sb.append(\"}\"); prettyPrint = true; return sb.toString(); } else { return forAnnotations ? \"?\" : \"{...}\";"
    },
    "JacksonDatabind-112": {
        "fixes": [
            {
                "k": 1,
                "patch": "AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator!= _valueInstantiator.getDelegateCreator) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-112/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\t2022-07-19 16:10:41.010610826 +0200\n+++ /tmp/tmp8u0bv2hv.java\t2022-07-19 16:10:41.046610708 +0200\n@@ -102,11 +102,11 @@\n     {\n         // May need to resolve types for delegate-based creators:\n         JsonDeserializer<Object> delegate = null;\n         if (_valueInstantiator != null) {\n             // [databind#2324]: check both array-delegating and delegating\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator!= _valueInstantiator.getDelegateCreator) {\n             if (delegateCreator != null) {\n                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                 delegate = findDeserializer(ctxt, delegateType, property);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator!= _valueInstantiator.getDelegateCreator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-112/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\t2022-07-19 16:10:42.982604201 +0200\n+++ /tmp/tmp45f5n18n.java\t2022-07-19 16:10:42.982604201 +0200\n@@ -102,11 +102,11 @@\n     {\n         // May need to resolve types for delegate-based creators:\n         JsonDeserializer<Object> delegate = null;\n         if (_valueInstantiator != null) {\n             // [databind#2324]: check both array-delegating and delegating\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator!= _valueInstantiator.getDelegateCreator;\n             if (delegateCreator != null) {\n                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                 delegate = findDeserializer(ctxt, delegateType, property);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator - _valueInstantiator.getDelegateCreator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-112/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\t2022-07-19 16:10:44.838597939 +0200\n+++ /tmp/tmpoqog7bw2.java\t2022-07-19 16:10:44.838597939 +0200\n@@ -102,11 +102,11 @@\n     {\n         // May need to resolve types for delegate-based creators:\n         JsonDeserializer<Object> delegate = null;\n         if (_valueInstantiator != null) {\n             // [databind#2324]: check both array-delegating and delegating\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator - _valueInstantiator.getDelegateCreator;\n             if (delegateCreator != null) {\n                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                 delegate = findDeserializer(ctxt, delegateType, property);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator!= _valueInstantiator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-112/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\t2022-07-19 16:10:46.534592201 +0200\n+++ /tmp/tmpns_ae1dl.java\t2022-07-19 16:10:46.534592201 +0200\n@@ -102,11 +102,11 @@\n     {\n         // May need to resolve types for delegate-based creators:\n         JsonDeserializer<Object> delegate = null;\n         if (_valueInstantiator != null) {\n             // [databind#2324]: check both array-delegating and delegating\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator!= _valueInstantiator;\n             if (delegateCreator != null) {\n                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                 delegate = findDeserializer(ctxt, delegateType, property);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator - _valueInstantiator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-112/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\t2022-07-19 16:10:48.166586664 +0200\n+++ /tmp/tmph7cz1dbj.java\t2022-07-19 16:10:48.170586654 +0200\n@@ -102,11 +102,11 @@\n     {\n         // May need to resolve types for delegate-based creators:\n         JsonDeserializer<Object> delegate = null;\n         if (_valueInstantiator != null) {\n             // [databind#2324]: check both array-delegating and delegating\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator - _valueInstantiator;\n             if (delegateCreator != null) {\n                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                 delegate = findDeserializer(ctxt, delegateType, property);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator - _valueInstantiatorCreator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-112/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\t2022-07-19 16:10:49.858580910 +0200\n+++ /tmp/tmp65t6r4qk.java\t2022-07-19 16:10:49.858580910 +0200\n@@ -102,11 +102,11 @@\n     {\n         // May need to resolve types for delegate-based creators:\n         JsonDeserializer<Object> delegate = null;\n         if (_valueInstantiator != null) {\n             // [databind#2324]: check both array-delegating and delegating\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator - _valueInstantiatorCreator;\n             if (delegateCreator != null) {\n                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                 delegate = findDeserializer(ctxt, delegateType, property);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "AnnotatedWithParams delegateType = _valueInstantiator.getDelegateCreator!= _valueInstantiator.getDelegateCreator) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-112/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\t2022-07-19 16:10:51.546575149 +0200\n+++ /tmp/tmpuola4jap.java\t2022-07-19 16:10:51.546575149 +0200\n@@ -102,11 +102,11 @@\n     {\n         // May need to resolve types for delegate-based creators:\n         JsonDeserializer<Object> delegate = null;\n         if (_valueInstantiator != null) {\n             // [databind#2324]: check both array-delegating and delegating\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+AnnotatedWithParams delegateType = _valueInstantiator.getDelegateCreator!= _valueInstantiator.getDelegateCreator) {\n             if (delegateCreator != null) {\n                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                 delegate = findDeserializer(ctxt, delegateType, property);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "AnnotatedWithParams delegateType = _valueInstantiator.getDelegateCreator!= _valueInstantiator.getDelegateCreator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-112/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\t2022-07-19 16:10:53.082569893 +0200\n+++ /tmp/tmp8cywapf_.java\t2022-07-19 16:10:53.082569893 +0200\n@@ -102,11 +102,11 @@\n     {\n         // May need to resolve types for delegate-based creators:\n         JsonDeserializer<Object> delegate = null;\n         if (_valueInstantiator != null) {\n             // [databind#2324]: check both array-delegating and delegating\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+AnnotatedWithParams delegateType = _valueInstantiator.getDelegateCreator!= _valueInstantiator.getDelegateCreator;\n             if (delegateCreator != null) {\n                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                 delegate = findDeserializer(ctxt, delegateType, property);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator!= _valueInstantiatorCreator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-112/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\t2022-07-19 16:10:54.762564125 +0200\n+++ /tmp/tmpbpjshz40.java\t2022-07-19 16:10:54.762564125 +0200\n@@ -102,11 +102,11 @@\n     {\n         // May need to resolve types for delegate-based creators:\n         JsonDeserializer<Object> delegate = null;\n         if (_valueInstantiator != null) {\n             // [databind#2324]: check both array-delegating and delegating\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator!= _valueInstantiatorCreator;\n             if (delegateCreator != null) {\n                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                 delegate = findDeserializer(ctxt, delegateType, property);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "AnnotatedWithParams delegateType = _valueInstantiator.getDelegateCreator!= _valueInstantiator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-112/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\t2022-07-19 16:10:56.430558387 +0200\n+++ /tmp/tmprrnv7rj0.java\t2022-07-19 16:10:56.430558387 +0200\n@@ -102,11 +102,11 @@\n     {\n         // May need to resolve types for delegate-based creators:\n         JsonDeserializer<Object> delegate = null;\n         if (_valueInstantiator != null) {\n             // [databind#2324]: check both array-delegating and delegating\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+AnnotatedWithParams delegateType = _valueInstantiator.getDelegateCreator!= _valueInstantiator;\n             if (delegateCreator != null) {\n                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                 delegate = findDeserializer(ctxt, delegateType, property);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();",
        "fixed_line": "AnnotatedWithParams delegateCreator = _valueInstantiator.getArrayDelegateCreator(); if (delegateCreator != null) { JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig()); delegate = findDeserializer(ctxt, delegateType, property); } else if ((delegateCreator = _valueInstantiator.getDelegateCreator()) != null) {"
    },
    "JacksonDatabind-96": {
        "fixes": [
            {
                "k": 1,
                "patch": "paramName = candidate.findImplicitParamNameName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-96/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 16:10:58.278552009 +0200\n+++ /tmp/tmpvx7klfy2.java\t2022-07-19 16:10:58.314551886 +0200\n@@ -730,11 +730,11 @@\n             // or field, we'll consider it property-based as well\n \n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+paramName = candidate.findImplicitParamNameName);\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "paramName = candidate.findImplicitParamName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-96/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 16:11:00.274545098 +0200\n+++ /tmp/tmptga532j1.java\t2022-07-19 16:11:00.278545083 +0200\n@@ -730,11 +730,11 @@\n             // or field, we'll consider it property-based as well\n \n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+paramName = candidate.findImplicitParamName);\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "paramName = candidate.findImplicitParamNameName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-96/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 16:11:01.838539665 +0200\n+++ /tmp/tmpn8xen56b.java\t2022-07-19 16:11:01.842539649 +0200\n@@ -730,11 +730,11 @@\n             // or field, we'll consider it property-based as well\n \n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+paramName = candidate.findImplicitParamNameName;\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "paramName = candidate.findImplicitParamNameNameName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-96/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 16:11:03.950532307 +0200\n+++ /tmp/tmpzztxbtok.java\t2022-07-19 16:11:03.950532307 +0200\n@@ -730,11 +730,11 @@\n             // or field, we'll consider it property-based as well\n \n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+paramName = candidate.findImplicitParamNameNameName;\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "paramName = candidate.findImplicitParamName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-96/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 16:11:05.790525876 +0200\n+++ /tmp/tmpi6r18e4w.java\t2022-07-19 16:11:05.790525876 +0200\n@@ -730,11 +730,11 @@\n             // or field, we'll consider it property-based as well\n \n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+paramName = candidate.findImplicitParamName;\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "paramName = t.findImplicitParamName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-96/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 16:11:07.662519314 +0200\n+++ /tmp/tmpbsv_hlq8.java\t2022-07-19 16:11:07.662519314 +0200\n@@ -730,11 +730,11 @@\n             // or field, we'll consider it property-based as well\n \n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+paramName = t.findImplicitParamName;\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "paramName = candidateDef.findImplicitParamName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-96/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 16:11:09.582512562 +0200\n+++ /tmp/tmpsupnfoa3.java\t2022-07-19 16:11:09.586512548 +0200\n@@ -730,11 +730,11 @@\n             // or field, we'll consider it property-based as well\n \n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+paramName = candidateDef.findImplicitParamName;\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "paramName = candidate.findImplicitParamName(0);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-96/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 16:11:11.454505957 +0200\n+++ /tmp/tmpt40775oc.java\t2022-07-19 16:11:11.458505942 +0200\n@@ -730,11 +730,11 @@\n             // or field, we'll consider it property-based as well\n \n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+paramName = candidate.findImplicitParamName(0);\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "paramName = candidate.findImplicitParamNameNameName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-96/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 16:12:08.810294347 +0200\n+++ /tmp/tmpxot3opbx.java\t2022-07-19 16:12:08.826294285 +0200\n@@ -730,11 +730,11 @@\n             // or field, we'll consider it property-based as well\n \n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+paramName = candidate.findImplicitParamNameNameName);\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "paramName = candidate.findImplicitParamName(1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-96/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 16:12:10.522287764 +0200\n+++ /tmp/tmpaeo6hnd9.java\t2022-07-19 16:12:10.526287752 +0200\n@@ -730,11 +730,11 @@\n             // or field, we'll consider it property-based as well\n \n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+paramName = candidate.findImplicitParamName(1);\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "paramName = candidate.findImplicitParamName(0);",
        "fixed_line": "paramName = candidate.paramName(0);"
    },
    "Mockito-37": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (answer instanceof DoesNothing) {",
                "patch_diff": "if (answer instanceof DoesNothing) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (answer instanceof DoesNothing) {",
                "patch_diff": "} else if (answer instanceof DoesNothing) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "private static final /*day*/int[] EASTER = {",
                "patch_diff": "private static final /*day*/int[] EASTER = {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "private static final /*day*/int[] EASTER = this.yearyear;",
                "patch_diff": "private static final /*day*/int[] EASTER = this.yearyear;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private static final /*day*/int[] EASTER = new DoesNothing(invocation;",
                "patch_diff": "private static final /*day*/int[] EASTER = new DoesNothing(invocation;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "private static final /*day*/int[] p = new DoesNothing(invocation;",
                "patch_diff": "private static final /*day*/int[] p = new DoesNothing(invocation;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private static final /*day*/int[] items = new DoesNothing(invocation;",
                "patch_diff": "private static final /*day*/int[] items = new DoesNothing(invocation;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "private static final /*day*/int[] EASTER = this.year - invocation;",
                "patch_diff": "private static final /*day*/int[] EASTER = this.year - invocation;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private static final /*day*/int[] EASTER = this.year;",
                "patch_diff": "private static final /*day*/int[] EASTER = this.year;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "private static final /*day*/int[] EASTER = new DoesNothing;",
                "patch_diff": "private static final /*day*/int[] EASTER = new DoesNothing;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (answer instanceof CallsRealMethods) { validateMockingConcreteClass((CallsRealMethods) answer, invocation); } } private void validateMockingConcreteClass(CallsRealMethods answer, Invocation invocation) { if (invocation.getMethod().getDeclaringClass().isInterface()) { reporter.cannotCallRealMethodOnInterface(); } }"
    },
    "Closure-92": {
        "fixes": [
            {
                "k": 1,
                "patch": "int indexOfDot = nsNode.indexOf('.');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-92/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 16:13:06.150066110 +0200\n+++ /tmp/tmp224emmzn.java\t2022-07-19 16:13:06.178065989 +0200\n@@ -784,11 +784,11 @@\n         if (firstModule == minimumModule) {\n           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+int indexOfDot = nsNode.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n                 .addChildToBack(replacementNode);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int indexOfDot = Node.indexOf('.');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-92/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 16:13:08.630055887 +0200\n+++ /tmp/tmpv86iovzl.java\t2022-07-19 16:13:08.646055824 +0200\n@@ -784,11 +784,11 @@\n         if (firstModule == minimumModule) {\n           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+int indexOfDot = Node.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n                 .addChildToBack(replacementNode);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int indexOfDot = info.indexOf('.');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-92/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 16:13:10.378048667 +0200\n+++ /tmp/tmpwi3g4dg8.java\t2022-07-19 16:13:10.378048667 +0200\n@@ -784,11 +784,11 @@\n         if (firstModule == minimumModule) {\n           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+int indexOfDot = info.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n                 .addChildToBack(replacementNode);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int indexOfDot = fn.indexOf('.');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-92/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 16:13:12.102041533 +0200\n+++ /tmp/tmp9ftc6rza.java\t2022-07-19 16:13:12.102041533 +0200\n@@ -784,11 +784,11 @@\n         if (firstModule == minimumModule) {\n           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+int indexOfDot = fn.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n                 .addChildToBack(replacementNode);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int indexOfDot = this.rawNode.indexOf('.');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-92/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 16:13:13.938033923 +0200\n+++ /tmp/tmp71mv6gro.java\t2022-07-19 16:13:13.938033923 +0200\n@@ -784,11 +784,11 @@\n         if (firstModule == minimumModule) {\n           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+int indexOfDot = this.rawNode.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n                 .addChildToBack(replacementNode);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int indexOfDot = NodeUtil.indexOf('.');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-92/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 16:13:15.686026658 +0200\n+++ /tmp/tmpgy2dxzc0.java\t2022-07-19 16:13:15.686026658 +0200\n@@ -784,11 +784,11 @@\n         if (firstModule == minimumModule) {\n           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+int indexOfDot = NodeUtil.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n                 .addChildToBack(replacementNode);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int indexOfDot = this.namespaceNode.indexOf('.');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-92/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 16:13:17.430019399 +0200\n+++ /tmp/tmp5_u238xq.java\t2022-07-19 16:13:17.430019399 +0200\n@@ -784,11 +784,11 @@\n         if (firstModule == minimumModule) {\n           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+int indexOfDot = this.namespaceNode.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n                 .addChildToBack(replacementNode);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int indexOfDot = code.indexOf('.');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-92/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 16:13:19.226011913 +0200\n+++ /tmp/tmp3_x7wmmb.java\t2022-07-19 16:13:19.226011913 +0200\n@@ -784,11 +784,11 @@\n         if (firstModule == minimumModule) {\n           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+int indexOfDot = code.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n                 .addChildToBack(replacementNode);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int indexOfDot = map.indexOf('.');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-92/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 16:13:20.934004778 +0200\n+++ /tmp/tmpo6t1fyw2.java\t2022-07-19 16:13:20.938004758 +0200\n@@ -784,11 +784,11 @@\n         if (firstModule == minimumModule) {\n           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+int indexOfDot = map.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n                 .addChildToBack(replacementNode);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int indexOfDot = classNode.indexOf('.');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-92/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 16:13:22.697997393 +0200\n+++ /tmp/tmplrkuq9pu.java\t2022-07-19 16:13:22.697997393 +0200\n@@ -784,11 +784,11 @@\n         if (firstModule == minimumModule) {\n           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+int indexOfDot = classNode.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n                 .addChildToBack(replacementNode);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "int indexOfDot = namespace.indexOf('.');",
        "fixed_line": "int indexOfDot = namespace.lastIndexOf('.');"
    },
    "Mockito-27": {
        "fixes": [
            {
                "k": 1,
                "patch": "MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito; newMockHandler.mockito.Mockito.MockitoURNS_DEFAULTS));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-27/src/org/mockito/internal/util/MockUtil.java\t2022-07-19 16:13:24.813988520 +0200\n+++ /tmp/tmpxij1aq1d.java\t2022-07-19 16:13:24.865988302 +0200\n@@ -59,12 +59,11 @@\n         return mock;\n     }\n \n     public <T> void resetMock(T mock) {\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito; newMockHandler.mockito.Mockito.MockitoURNS_DEFAULTS));\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito; newMockHandler.mockito.MockitoURNS_DEFAULTS));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-27/src/org/mockito/internal/util/MockUtil.java\t2022-07-19 16:13:27.665976529 +0200\n+++ /tmp/tmpbzdg044d.java\t2022-07-19 16:13:27.665976529 +0200\n@@ -59,12 +59,11 @@\n         return mock;\n     }\n \n     public <T> void resetMock(T mock) {\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito; newMockHandler.mockito.MockitoURNS_DEFAULTS));\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito; newMockHandler.mockito.Mockito.Mockito.MockitoURNS_DEFAULTS));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-27/src/org/mockito/internal/util/MockUtil.java\t2022-07-19 16:13:29.477968890 +0200\n+++ /tmp/tmpr5je5sfj.java\t2022-07-19 16:13:29.477968890 +0200\n@@ -59,12 +59,11 @@\n         return mock;\n     }\n \n     public <T> void resetMock(T mock) {\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito; newMockHandler.mockito.Mockito.Mockito.MockitoURNS_DEFAULTS));\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito.Mockito; newMockHandler.mockito.MockitoURNS_DEFAULTS));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-27/src/org/mockito/internal/util/MockUtil.java\t2022-07-19 16:13:31.317961121 +0200\n+++ /tmp/tmpjvm_aquu.java\t2022-07-19 16:13:31.317961121 +0200\n@@ -59,12 +59,11 @@\n         return mock;\n     }\n \n     public <T> void resetMock(T mock) {\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito.Mockito; newMockHandler.mockito.MockitoURNS_DEFAULTS));\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito.Mockito; newMockHandler.mockito.Mockito.MockitoURNS_DEFAULTS));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-27/src/org/mockito/internal/util/MockUtil.java\t2022-07-19 16:13:33.153953354 +0200\n+++ /tmp/tmph_aj_5_l.java\t2022-07-19 16:13:33.153953354 +0200\n@@ -59,12 +59,11 @@\n         return mock;\n     }\n \n     public <T> void resetMock(T mock) {\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito.Mockito; newMockHandler.mockito.Mockito.MockitoURNS_DEFAULTS));\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito; newMockHandler.mockito.Mockito.MockitoURNS_DEFAULTS;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-27/src/org/mockito/internal/util/MockUtil.java\t2022-07-19 16:13:34.937945792 +0200\n+++ /tmp/tmp4dppb8j6.java\t2022-07-19 16:13:34.941945776 +0200\n@@ -59,12 +59,11 @@\n         return mock;\n     }\n \n     public <T> void resetMock(T mock) {\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito; newMockHandler.mockito.Mockito.MockitoURNS_DEFAULTS;\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito; newMockHandler.mockito.MockitoURNS_DEFAULTS;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-27/src/org/mockito/internal/util/MockUtil.java\t2022-07-19 16:13:36.709938268 +0200\n+++ /tmp/tmp2bopgq2h.java\t2022-07-19 16:13:36.709938268 +0200\n@@ -59,12 +59,11 @@\n         return mock;\n     }\n \n     public <T> void resetMock(T mock) {\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito; newMockHandler.mockito.MockitoURNS_DEFAULTS;\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito; newMockHandler.mockito.Mockito.Mockito.Mockito.MockitoURNS_DEFAULTS));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-27/src/org/mockito/internal/util/MockUtil.java\t2022-07-19 16:13:38.613930169 +0200\n+++ /tmp/tmpkhe8_if9.java\t2022-07-19 16:13:38.617930151 +0200\n@@ -59,12 +59,11 @@\n         return mock;\n     }\n \n     public <T> void resetMock(T mock) {\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito; newMockHandler.mockito.Mockito.Mockito.Mockito.MockitoURNS_DEFAULTS));\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito.Mockito; newMockHandler.mockito.Mockito.Mockito.MockitoURNS_DEFAULTS));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-27/src/org/mockito/internal/util/MockUtil.java\t2022-07-19 16:13:40.413922497 +0200\n+++ /tmp/tmp_vtqt2t5.java\t2022-07-19 16:13:40.413922497 +0200\n@@ -59,12 +59,11 @@\n         return mock;\n     }\n \n     public <T> void resetMock(T mock) {\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito.Mockito; newMockHandler.mockito.Mockito.Mockito.MockitoURNS_DEFAULTS));\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito; newMockHandler.mockito.Mockito.Mockito.MockitoURNS_DEFAULTS;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-27/src/org/mockito/internal/util/MockUtil.java\t2022-07-19 16:13:42.205914847 +0200\n+++ /tmp/tmpxqvd643e.java\t2022-07-19 16:13:42.205914847 +0200\n@@ -59,12 +59,11 @@\n         return mock;\n     }\n \n     public <T> void resetMock(T mock) {\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito; newMockHandler.mockito.Mockito.Mockito.MockitoURNS_DEFAULTS;\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));",
        "fixed_line": "MethodInterceptorFilter newFilter = newMethodInterceptorFilter(oldMockHandler.getMockSettings());"
    },
    "Math-43": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (meanImpl instanceof Mean; double meanImpl.increment) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-43/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\t2022-07-19 16:13:44.177906414 +0200\n+++ /tmp/tmpfmuzfuai.java\t2022-07-19 16:13:44.205906292 +0200\n@@ -153,17 +153,11 @@\n         maxImpl.increment(value);\n         sumLogImpl.increment(value);\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n-            meanImpl.increment(value);\n-        }\n-        if (!(varianceImpl instanceof Variance)) {\n-            varianceImpl.increment(value);\n-        }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+if (meanImpl instanceof Mean; double meanImpl.increment) {\n             geoMeanImpl.increment(value);\n         }\n         n++;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (meanImpl.increment(meanImpl instanceof Mean)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-43/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\t2022-07-19 16:13:46.641895850 +0200\n+++ /tmp/tmpund9lcpx.java\t2022-07-19 16:13:46.641895850 +0200\n@@ -153,17 +153,11 @@\n         maxImpl.increment(value);\n         sumLogImpl.increment(value);\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n-            meanImpl.increment(value);\n-        }\n-        if (!(varianceImpl instanceof Variance)) {\n-            varianceImpl.increment(value);\n-        }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+if (meanImpl.increment(meanImpl instanceof Mean)) {\n             geoMeanImpl.increment(value);\n         }\n         n++;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (meanImpl instanceof Mean)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-43/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\t2022-07-19 16:13:48.909886105 +0200\n+++ /tmp/tmpzv3196fm.java\t2022-07-19 16:13:48.913886088 +0200\n@@ -153,17 +153,11 @@\n         maxImpl.increment(value);\n         sumLogImpl.increment(value);\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n-            meanImpl.increment(value);\n-        }\n-        if (!(varianceImpl instanceof Variance)) {\n-            varianceImpl.increment(value);\n-        }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+if (meanImpl instanceof Mean)) {\n             geoMeanImpl.increment(value);\n         }\n         n++;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (meanImpl instanceof Mean) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-43/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\t2022-07-19 16:13:50.909877495 +0200\n+++ /tmp/tmpbv01lwhv.java\t2022-07-19 16:13:50.909877495 +0200\n@@ -153,17 +153,11 @@\n         maxImpl.increment(value);\n         sumLogImpl.increment(value);\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n-            meanImpl.increment(value);\n-        }\n-        if (!(varianceImpl instanceof Variance)) {\n-            varianceImpl.increment(value);\n-        }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+if (meanImpl instanceof Mean) {\n             geoMeanImpl.increment(value);\n         }\n         n++;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (meanImpl!= null) meanImpl.increment) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-43/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\t2022-07-19 16:14:09.125798310 +0200\n+++ /tmp/tmpe9phg3in.java\t2022-07-19 16:14:09.125798310 +0200\n@@ -153,17 +153,11 @@\n         maxImpl.increment(value);\n         sumLogImpl.increment(value);\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n-            meanImpl.increment(value);\n-        }\n-        if (!(varianceImpl instanceof Variance)) {\n-            varianceImpl.increment(value);\n-        }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+if (meanImpl!= null) meanImpl.increment) {\n             geoMeanImpl.increment(value);\n         }\n         n++;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (meanImpl instanceof Mean;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-43/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\t2022-07-19 16:14:11.145789446 +0200\n+++ /tmp/tmp6u22p4ku.java\t2022-07-19 16:14:11.145789446 +0200\n@@ -153,17 +153,11 @@\n         maxImpl.increment(value);\n         sumLogImpl.increment(value);\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n-            meanImpl.increment(value);\n-        }\n-        if (!(varianceImpl instanceof Variance)) {\n-            varianceImpl.increment(value);\n-        }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+if (meanImpl instanceof Mean;\n             geoMeanImpl.increment(value);\n         }\n         n++;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (meanImpl instanceof Mean; meanImpl.increment) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-43/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\t2022-07-19 16:14:13.173780531 +0200\n+++ /tmp/tmp_jhtop5o.java\t2022-07-19 16:14:13.177780513 +0200\n@@ -153,17 +153,11 @@\n         maxImpl.increment(value);\n         sumLogImpl.increment(value);\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n-            meanImpl.increment(value);\n-        }\n-        if (!(varianceImpl instanceof Variance)) {\n-            varianceImpl.increment(value);\n-        }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+if (meanImpl instanceof Mean; meanImpl.increment) {\n             geoMeanImpl.increment(value);\n         }\n         n++;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (meanImpl.increment(meanImpl.increment) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-43/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\t2022-07-19 16:14:15.133771900 +0200\n+++ /tmp/tmp0ttqi9l1.java\t2022-07-19 16:14:15.133771900 +0200\n@@ -153,17 +153,11 @@\n         maxImpl.increment(value);\n         sumLogImpl.increment(value);\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n-            meanImpl.increment(value);\n-        }\n-        if (!(varianceImpl instanceof Variance)) {\n-            varianceImpl.increment(value);\n-        }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+if (meanImpl.increment(meanImpl.increment) {\n             geoMeanImpl.increment(value);\n         }\n         n++;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (meanImpl.increment) { meanImpl.increment; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-43/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\t2022-07-19 16:14:17.145763020 +0200\n+++ /tmp/tmpxs1k5fxc.java\t2022-07-19 16:14:17.149763002 +0200\n@@ -153,17 +153,11 @@\n         maxImpl.increment(value);\n         sumLogImpl.increment(value);\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n-            meanImpl.increment(value);\n-        }\n-        if (!(varianceImpl instanceof Variance)) {\n-            varianceImpl.increment(value);\n-        }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+if (meanImpl.increment) { meanImpl.increment; }\n             geoMeanImpl.increment(value);\n         }\n         n++;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (meanImpl instanceof Mean) { meanImpl.increment; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-43/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\t2022-07-19 16:14:19.205753916 +0200\n+++ /tmp/tmp_mikqb2k.java\t2022-07-19 16:14:19.205753916 +0200\n@@ -153,17 +153,11 @@\n         maxImpl.increment(value);\n         sumLogImpl.increment(value);\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n-            meanImpl.increment(value);\n-        }\n-        if (!(varianceImpl instanceof Variance)) {\n-            varianceImpl.increment(value);\n-        }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+if (meanImpl instanceof Mean) { meanImpl.increment; }\n             geoMeanImpl.increment(value);\n         }\n         n++;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (!(meanImpl instanceof Mean)) { meanImpl.increment(value); } if (!(varianceImpl instanceof Variance)) { varianceImpl.increment(value); } if (!(geoMeanImpl instanceof GeometricMean)) {",
        "fixed_line": "if (meanImpl != mean) { meanImpl.increment(value); } if (varianceImpl != variance) { varianceImpl.increment(value); } if (geoMeanImpl != geoMean) {"
    },
    "Closure-105": {
        "fixes": [
            {
                "k": 1,
                "patch": "StringBuilder sb = new StringBuilder(elem = arrayNode.length() > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-105/src/com/google/javascript/jscomp/FoldConstants.java\t2022-07-19 16:14:21.413744139 +0200\n+++ /tmp/tmp6gt9s7om.java\t2022-07-19 16:14:21.429744068 +0200\n@@ -1472,34 +1472,11 @@\n       return;\n     }\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n-    int foldedSize = 0;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb.length() > 0) {\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb.length() > 0) {\n+StringBuilder sb = new StringBuilder(elem = arrayNode.length() > 0) {\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n     }\n     // one for each comma.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "StringBuilder sb = new StringBuilder(elem = arrayNode.length() > 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-105/src/com/google/javascript/jscomp/FoldConstants.java\t2022-07-19 16:14:23.421735229 +0200\n+++ /tmp/tmp0jjepkl_.java\t2022-07-19 16:14:23.421735229 +0200\n@@ -1472,34 +1472,11 @@\n       return;\n     }\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n-    int foldedSize = 0;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb.length() > 0) {\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb.length() > 0) {\n+StringBuilder sb = new StringBuilder(elem = arrayNode.length() > 0;\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n     }\n     // one for each comma.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "StringBuilder sb = new StringBuilder(elem.length() > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-105/src/com/google/javascript/jscomp/FoldConstants.java\t2022-07-19 16:14:25.065727924 +0200\n+++ /tmp/tmpofsrpgrg.java\t2022-07-19 16:14:25.069727907 +0200\n@@ -1472,34 +1472,11 @@\n       return;\n     }\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n-    int foldedSize = 0;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb.length() > 0) {\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb.length() > 0) {\n+StringBuilder sb = new StringBuilder(elem.length() > 0) {\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n     }\n     // one for each comma.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "StringBuilder sb = new StringBuilder.length() > 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-105/src/com/google/javascript/jscomp/FoldConstants.java\t2022-07-19 16:14:26.661720823 +0200\n+++ /tmp/tmpsxrx5r_x.java\t2022-07-19 16:14:26.661720823 +0200\n@@ -1472,34 +1472,11 @@\n       return;\n     }\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n-    int foldedSize = 0;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb.length() > 0) {\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb.length() > 0) {\n+StringBuilder sb = new StringBuilder.length() > 0;\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n     }\n     // one for each comma.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "StringBuilder sb = new StringBuilder(16.length() > 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-105/src/com/google/javascript/jscomp/FoldConstants.java\t2022-07-19 16:14:28.241713781 +0200\n+++ /tmp/tmpyhpw7f0k.java\t2022-07-19 16:14:28.241713781 +0200\n@@ -1472,34 +1472,11 @@\n       return;\n     }\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n-    int foldedSize = 0;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb.length() > 0) {\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb.length() > 0) {\n+StringBuilder sb = new StringBuilder(16.length() > 0;\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n     }\n     // one for each comma.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "StringBuilder sb = new StringBuilder(16);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-105/src/com/google/javascript/jscomp/FoldConstants.java\t2022-07-19 16:14:29.869706517 +0200\n+++ /tmp/tmpu1j20lw3.java\t2022-07-19 16:14:29.869706517 +0200\n@@ -1472,34 +1472,11 @@\n       return;\n     }\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n-    int foldedSize = 0;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb.length() > 0) {\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb.length() > 0) {\n+StringBuilder sb = new StringBuilder(16);\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n     }\n     // one for each comma.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "StringBuilder sb = new StringBuilder(elem;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-105/src/com/google/javascript/jscomp/FoldConstants.java\t2022-07-19 16:14:31.389699726 +0200\n+++ /tmp/tmpv4csynf0.java\t2022-07-19 16:14:31.389699726 +0200\n@@ -1472,34 +1472,11 @@\n       return;\n     }\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n-    int foldedSize = 0;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb.length() > 0) {\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb.length() > 0) {\n+StringBuilder sb = new StringBuilder(elem;\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n     }\n     // one for each comma.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "StringBuilder sb = new StringBuilder(elem; // the type",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-105/src/com/google/javascript/jscomp/FoldConstants.java\t2022-07-19 16:14:32.953692728 +0200\n+++ /tmp/tmpbji4spw1.java\t2022-07-19 16:14:32.957692711 +0200\n@@ -1472,34 +1472,11 @@\n       return;\n     }\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n-    int foldedSize = 0;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb.length() > 0) {\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb.length() > 0) {\n+StringBuilder sb = new StringBuilder(elem; // the type\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n     }\n     // one for each comma.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "StringBuilder sb = new StringBuilder(\"{\") > 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-105/src/com/google/javascript/jscomp/FoldConstants.java\t2022-07-19 16:14:34.545685595 +0200\n+++ /tmp/tmpgt2n0yg3.java\t2022-07-19 16:14:34.545685595 +0200\n@@ -1472,34 +1472,11 @@\n       return;\n     }\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n-    int foldedSize = 0;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb.length() > 0) {\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb.length() > 0) {\n+StringBuilder sb = new StringBuilder(\"{\") > 0;\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n     }\n     // one for each comma.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "StringBuilder sb = new StringBuilder(16;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-105/src/com/google/javascript/jscomp/FoldConstants.java\t2022-07-19 16:14:36.113678560 +0200\n+++ /tmp/tmpbo8thu4m.java\t2022-07-19 16:14:36.113678560 +0200\n@@ -1472,34 +1472,11 @@\n       return;\n     }\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n-    int foldedSize = 0;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb.length() > 0) {\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb.length() > 0) {\n+StringBuilder sb = new StringBuilder(16;\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n     }\n     // one for each comma.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "StringBuilder sb = new StringBuilder(); int foldedSize = 0; Node elem = arrayNode.getFirstChild(); // Merges adjacent String nodes. while (elem != null) { if (NodeUtil.isImmutableValue(elem)) { if (sb.length() > 0) { sb.append(joinString); } sb.append(NodeUtil.getStringValue(elem)); } else { if (sb.length() > 0) { // + 2 for the quotes. foldedSize += sb.length() + 2; arrayFoldedChildren.add(Node.newString(sb.toString())); sb = new StringBuilder(); } foldedSize += InlineCostEstimator.getCost(elem); arrayFoldedChildren.add(elem); } elem = elem.getNext(); } if (sb.length() > 0) {",
        "fixed_line": "StringBuilder sb = null; int foldedSize = 0; Node elem = arrayNode.getFirstChild(); // Merges adjacent String nodes. while (elem != null) { if (NodeUtil.isImmutableValue(elem)) { if (sb == null) { sb = new StringBuilder(); } else { sb.append(joinString); } sb.append(NodeUtil.getStringValue(elem)); } else { if (sb != null) { // + 2 for the quotes. foldedSize += sb.length() + 2; arrayFoldedChildren.add(Node.newString(sb.toString())); sb = null; } foldedSize += InlineCostEstimator.getCost(elem); arrayFoldedChildren.add(elem); } elem = elem.getNext(); } if (sb != null) {"
    },
    "Closure-95": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if (scopeToDeclareIn.isDeclared(variableName, false) {",
                "patch_diff": "// if (scopeToDeclareIn.isDeclared(variableName, false) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// We's do implicit re-parse",
                "patch_diff": "// We's do implicit re-parse",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if (scopeToDeclareIn.isDeclared(name, false) {",
                "patch_diff": "// if (scopeToDeclareIn.isDeclared(name, false) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// if (scopeToDeclareIn.isDeclared(variableName, false || scopeToDeclareIn.",
                "patch_diff": "// if (scopeToDeclareIn.isDeclared(variableName, false || scopeToDeclareIn.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// if (scopeToDeclareIn.isDeclared(variableName, n, fnTypeToDeclareIn.",
                "patch_diff": "// if (scopeToDeclareIn.isDeclared(variableName, n, fnTypeToDeclareIn.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if (scopeToDeclareIn.isDeclared(variableName, false || scopeToDeclareIn.scopeToDeclareIn.",
                "patch_diff": "// if (scopeToDeclareIn.isDeclared(variableName, false || scopeToDeclareIn.scopeToDeclareIn.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// if (scopeToDeclareIn.isDeclared(qName, false) {",
                "patch_diff": "// if (scopeToDeclareIn.isDeclared(qName, false) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// if (scopeToDeclareIn.isDeclared(variableName, false || scopeToDeclareInferred) {",
                "patch_diff": "// if (scopeToDeclareIn.isDeclared(variableName, false || scopeToDeclareInferred) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// We's do implicit re-initialized or EMPTY",
                "patch_diff": "// We's do implicit re-initialized or EMPTY",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if (scopeToDeclareIn.isDeclared(scope, false) {",
                "patch_diff": "// if (scopeToDeclareIn.isDeclared(scope, false) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (n.getType() == Token.GETPROP && !scope.isGlobal() && isQnameRootedInGlobalScope(n)) { Scope globalScope = scope.getGlobalScope(); // don't try to declare in the global scope if there's // already a symbol there with this name. if (!globalScope.isDeclared(variableName, false)) { scopeToDeclareIn = scope.getGlobalScope(); } }"
    },
    "JacksonCore-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "char c = input.charAt(i++++i++);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-5/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 16:14:39.589662933 +0200\n+++ /tmp/tmp89aj6xs3.java\t2022-07-19 16:14:39.609662843 +0200\n@@ -188,11 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+char c = input.charAt(i++++i++);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "char c = str.charAt(i++++i++) - '0') * 10;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-5/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 16:14:41.489654372 +0200\n+++ /tmp/tmp6339st0k.java\t2022-07-19 16:14:41.517654245 +0200\n@@ -188,11 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+char c = str.charAt(i++++i++) - '0') * 10;\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "char c = str.charAt(i++++i++i++);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-5/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 16:14:43.033647404 +0200\n+++ /tmp/tmpb2lc4g51.java\t2022-07-19 16:14:43.033647404 +0200\n@@ -188,11 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+char c = str.charAt(i++++i++i++);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "char c = text.charAt(i++++i++);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-5/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 16:14:44.657640067 +0200\n+++ /tmp/tmp9p7vzyyz.java\t2022-07-19 16:14:44.657640067 +0200\n@@ -188,11 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+char c = text.charAt(i++++i++);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "char c = str.charAt(i++) - '0') * 10;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-5/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 16:14:46.205633063 +0200\n+++ /tmp/tmpl_6dzt8l.java\t2022-07-19 16:14:46.205633063 +0200\n@@ -188,11 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+char c = str.charAt(i++) - '0') * 10;\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "char c = str.charAt(i++++i++);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-5/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 16:14:47.693626323 +0200\n+++ /tmp/tmp8ulapl1y.java\t2022-07-19 16:14:47.693626323 +0200\n@@ -188,11 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+char c = str.charAt(i++++i++);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "char c = s.charAt(i++++i++);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-5/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 16:14:49.249619265 +0200\n+++ /tmp/tmp57wwydw_.java\t2022-07-19 16:14:49.249619265 +0200\n@@ -188,11 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+char c = s.charAt(i++++i++);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "char c = input.charAt(i++);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-5/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 16:14:50.741612490 +0200\n+++ /tmp/tmph2l58du5.java\t2022-07-19 16:14:50.741612490 +0200\n@@ -188,11 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+char c = input.charAt(i++);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "char c = key.charAt(i++++i++);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-5/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 16:14:52.345605195 +0200\n+++ /tmp/tmpes2isin1.java\t2022-07-19 16:14:52.345605195 +0200\n@@ -188,11 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+char c = key.charAt(i++++i++);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "char c = text.charAt(i++);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-5/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 16:14:53.901598111 +0200\n+++ /tmp/tmpsljekuan.java\t2022-07-19 16:14:53.901598111 +0200\n@@ -188,11 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+char c = text.charAt(i++);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "char c = str.charAt(i++);",
        "fixed_line": "char c = str.charAt(i);"
    },
    "Jsoup-43": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (element.equals(element)) return element.search;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-43/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 16:14:55.729589778 +0200\n+++ /tmp/tmpe5cklm6w.java\t2022-07-19 16:14:55.757589649 +0200\n@@ -569,11 +569,11 @@\n         Validate.notNull(search);\n         Validate.notNull(elements);\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+if (element.equals(element)) return element.search;\n                 return i;\n         }\n         return null;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (element.equals(search)) return element.search;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-43/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 16:14:57.625581121 +0200\n+++ /tmp/tmp7ljhroz0.java\t2022-07-19 16:14:57.625581121 +0200\n@@ -569,11 +569,11 @@\n         Validate.notNull(search);\n         Validate.notNull(elements);\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+if (element.equals(search)) return element.search;\n                 return i;\n         }\n         return null;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (element.equals(search)) return element;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-43/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 16:14:59.325573347 +0200\n+++ /tmp/tmpkxs7lkdo.java\t2022-07-19 16:14:59.325573347 +0200\n@@ -569,11 +569,11 @@\n         Validate.notNull(search);\n         Validate.notNull(elements);\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+if (element.equals(search)) return element;\n                 return i;\n         }\n         return null;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (element.equals(element)) return element;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-43/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 16:15:01.081565307 +0200\n+++ /tmp/tmp1z67uant.java\t2022-07-19 16:15:01.081565307 +0200\n@@ -569,11 +569,11 @@\n         Validate.notNull(search);\n         Validate.notNull(elements);\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+if (element.equals(element)) return element;\n                 return i;\n         }\n         return null;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (element.equals(element)) return element.get(i);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-43/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 16:15:02.785557495 +0200\n+++ /tmp/tmpnkgjpfxs.java\t2022-07-19 16:15:02.789557476 +0200\n@@ -569,11 +569,11 @@\n         Validate.notNull(search);\n         Validate.notNull(elements);\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+if (element.equals(element)) return element.get(i);\n                 return i;\n         }\n         return null;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (element.equals(search)) return element.class;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-43/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 16:15:04.501549616 +0200\n+++ /tmp/tmpncj1vuww.java\t2022-07-19 16:15:04.501549616 +0200\n@@ -569,11 +569,11 @@\n         Validate.notNull(search);\n         Validate.notNull(elements);\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+if (element.equals(search)) return element.class;\n                 return i;\n         }\n         return null;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (element.equals(element)) return element.class;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-43/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 16:15:06.177541911 +0200\n+++ /tmp/tmp670f8af0.java\t2022-07-19 16:15:06.177541911 +0200\n@@ -569,11 +569,11 @@\n         Validate.notNull(search);\n         Validate.notNull(elements);\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+if (element.equals(element)) return element.class;\n                 return i;\n         }\n         return null;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (element.equals(element.search)) return element;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-43/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 16:15:07.865534141 +0200\n+++ /tmp/tmpvi01kmp5.java\t2022-07-19 16:15:07.869534122 +0200\n@@ -569,11 +569,11 @@\n         Validate.notNull(search);\n         Validate.notNull(elements);\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+if (element.equals(element.search)) return element;\n                 return i;\n         }\n         return null;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (element.equals(element);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-43/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 16:15:09.613526084 +0200\n+++ /tmp/tmpt738dfsv.java\t2022-07-19 16:15:09.613526084 +0200\n@@ -569,11 +569,11 @@\n         Validate.notNull(search);\n         Validate.notNull(elements);\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+if (element.equals(element);\n                 return i;\n         }\n         return null;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (element.equals(element)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-43/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 16:15:11.157518957 +0200\n+++ /tmp/tmpli5genwa.java\t2022-07-19 16:15:11.157518957 +0200\n@@ -569,11 +569,11 @@\n         Validate.notNull(search);\n         Validate.notNull(elements);\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+if (element.equals(element)) {\n                 return i;\n         }\n         return null;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (element.equals(search))",
        "fixed_line": "if (element == search)"
    },
    "Math-82": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (MathUtils.compareTo(S, 0, epsilon) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2022-07-19 16:15:12.869511049 +0200\n+++ /tmp/tmpweow51s5.java\t2022-07-19 16:15:12.889510955 +0200\n@@ -77,11 +77,11 @@\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+if (MathUtils.compareTo(S, 0, epsilon) > 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (MathUtils.compareTo(loopIndex, 0, epsilon) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2022-07-19 16:15:15.233500105 +0200\n+++ /tmp/tmpr8j_o0f5.java\t2022-07-19 16:15:15.237500088 +0200\n@@ -77,11 +77,11 @@\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+if (MathUtils.compareTo(loopIndex, 0, epsilon) > 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (MathUtils.compareTo(y, 0, epsilon) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2022-07-19 16:15:17.281490612 +0200\n+++ /tmp/tmpmacouyaq.java\t2022-07-19 16:15:17.281490612 +0200\n@@ -77,11 +77,11 @@\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+if (MathUtils.compareTo(y, 0, epsilon) > 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (MathUtils.compareTo(S, 0, epsilon) <= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2022-07-19 16:15:19.385480842 +0200\n+++ /tmp/tmpq6vkdmrg.java\t2022-07-19 16:15:19.389480825 +0200\n@@ -77,11 +77,11 @@\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+if (MathUtils.compareTo(S, 0, epsilon) <= 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (MathUtils.compareTo(files, 0, epsilon) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2022-07-19 16:15:21.521470908 +0200\n+++ /tmp/tmpeyfqx1ve.java\t2022-07-19 16:15:21.521470908 +0200\n@@ -77,11 +77,11 @@\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+if (MathUtils.compareTo(files, 0, epsilon) > 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (MathUtils.compareTo(value, 0, epsilon) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2022-07-19 16:15:23.585461295 +0200\n+++ /tmp/tmp1ed4q967.java\t2022-07-19 16:15:23.585461295 +0200\n@@ -77,11 +77,11 @@\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+if (MathUtils.compareTo(value, 0, epsilon) > 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (MathUtils.compareTo(element, 0, epsilon) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2022-07-19 16:15:25.653451646 +0200\n+++ /tmp/tmpznrcaknb.java\t2022-07-19 16:15:25.653451646 +0200\n@@ -77,11 +77,11 @@\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+if (MathUtils.compareTo(element, 0, epsilon) > 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (MathUtils.compareTo(current, 0, epsilon) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2022-07-19 16:15:27.737441910 +0200\n+++ /tmp/tmpq2b70t10.java\t2022-07-19 16:15:27.737441910 +0200\n@@ -77,11 +77,11 @@\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+if (MathUtils.compareTo(current, 0, epsilon) > 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (MathUtils.compareTo(entry, 0, epsilon) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2022-07-19 16:15:29.881431877 +0200\n+++ /tmp/tmpvfnn35gl.java\t2022-07-19 16:15:29.881431877 +0200\n@@ -77,11 +77,11 @@\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 10,
                "patch": "if (MathUtils.compareTo(y, 0, epsilon) <= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2022-07-19 16:15:37.037398277 +0200\n+++ /tmp/tmpxo_v0195.java\t2022-07-19 16:15:37.037398277 +0200\n@@ -77,11 +77,11 @@\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+if (MathUtils.compareTo(y, 0, epsilon) <= 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {",
        "fixed_line": "if (MathUtils.compareTo(entry, 0, epsilon) > 0) {"
    },
    "Math-104": {
        "fixes": [
            {
                "k": 1,
                "patch": "private static final double DEFAULT_EPSILON = 10e Replace;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-104/src/java/org/apache/commons/math/special/Gamma.java\t2022-07-19 16:15:39.321387514 +0200\n+++ /tmp/tmpvr1ymowq.java\t2022-07-19 16:15:39.341387421 +0200\n@@ -32,11 +32,11 @@\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-9;\n+private static final double DEFAULT_EPSILON = 10e Replace;\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n     {\n         0.99999999999999709182,\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "private static final double DEFAULT_EPSILON = 10eRET;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-104/src/java/org/apache/commons/math/special/Gamma.java\t2022-07-19 16:15:42.941370425 +0200\n+++ /tmp/tmpozd5rs5m.java\t2022-07-19 16:15:42.941370425 +0200\n@@ -32,11 +32,11 @@\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-9;\n+private static final double DEFAULT_EPSILON = 10eRET;\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n     {\n         0.99999999999999709182,\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "private static final double DEFAULT_EPSILON = 10e\";",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-104/src/java/org/apache/commons/math/special/Gamma.java\t2022-07-19 16:15:45.953356170 +0200\n+++ /tmp/tmpppzdqh7n.java\t2022-07-19 16:15:45.957356151 +0200\n@@ -32,11 +32,11 @@\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-9;\n+private static final double DEFAULT_EPSILON = 10e\";\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n     {\n         0.99999999999999709182,\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "private static final double DEFAULT_EPSILON = 10e609;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-104/src/java/org/apache/commons/math/special/Gamma.java\t2022-07-19 16:15:48.941342001 +0200\n+++ /tmp/tmp2b19hoxm.java\t2022-07-19 16:15:48.945341982 +0200\n@@ -32,11 +32,11 @@\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-9;\n+private static final double DEFAULT_EPSILON = 10e609;\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n     {\n         0.99999999999999709182,\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private static final double DEFAULT_EPSILON = 10e-9;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-104/src/java/org/apache/commons/math/special/Gamma.java\t2022-07-19 16:15:51.985327534 +0200\n+++ /tmp/tmpnh0k02w2.java\t2022-07-19 16:15:51.985327534 +0200\n@@ -32,11 +32,11 @@\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-9;\n+private static final double DEFAULT_EPSILON = 10e-9;\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n     {\n         0.99999999999999709182,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "private static final double DEFAULT_EPSILON = 1024;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-104/src/java/org/apache/commons/math/special/Gamma.java\t2022-07-19 16:16:00.953284740 +0200\n+++ /tmp/tmpb9t3gtah.java\t2022-07-19 16:16:00.953284740 +0200\n@@ -32,11 +32,11 @@\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-9;\n+private static final double DEFAULT_EPSILON = 1024;\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n     {\n         0.99999999999999709182,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private static final double DEFAULT_EPSILON = 10e;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-104/src/java/org/apache/commons/math/special/Gamma.java\t2022-07-19 16:16:09.437244016 +0200\n+++ /tmp/tmped4vf9kx.java\t2022-07-19 16:16:09.437244016 +0200\n@@ -32,11 +32,11 @@\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-9;\n+private static final double DEFAULT_EPSILON = 10e;\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n     {\n         0.99999999999999709182,\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "private static final double DEFAULT_EPSILON = 10eNames;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-104/src/java/org/apache/commons/math/special/Gamma.java\t2022-07-19 16:16:12.437229562 +0200\n+++ /tmp/tmpys4pc9u4.java\t2022-07-19 16:16:12.441229543 +0200\n@@ -32,11 +32,11 @@\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-9;\n+private static final double DEFAULT_EPSILON = 10eNames;\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n     {\n         0.99999999999999709182,\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private static final double DEFAULT_EPSILON = 8;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-104/src/java/org/apache/commons/math/special/Gamma.java\t2022-07-19 16:16:15.489214828 +0200\n+++ /tmp/tmpxecuf0q8.java\t2022-07-19 16:16:15.489214828 +0200\n@@ -32,11 +32,11 @@\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-9;\n+private static final double DEFAULT_EPSILON = 8;\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n     {\n         0.99999999999999709182,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "private static final double DEFAULT_EPSILON = 9;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-104/src/java/org/apache/commons/math/special/Gamma.java\t2022-07-19 16:16:23.813174492 +0200\n+++ /tmp/tmphj9ljl4g.java\t2022-07-19 16:16:23.813174492 +0200\n@@ -32,11 +32,11 @@\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-9;\n+private static final double DEFAULT_EPSILON = 9;\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n     {\n         0.99999999999999709182,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "private static final double DEFAULT_EPSILON = 10e-9;",
        "fixed_line": "private static final double DEFAULT_EPSILON = 10e-15;"
    },
    "Time-27": {
        "fixes": [
            {
                "k": 1,
                "patch": "return new PeriodFormatter(elementPairs.subList(2, size), notPrinter, notParser);",
                "patch_diff": "return new PeriodFormatter(elementPairs.subList(2, size), notPrinter, notParser);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (size >= 2 && elementPairs.size() - 1) {",
                "patch_diff": "} else if (size >= 2 && elementPairs.size() - 1) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return new PeriodFormatter(sep, sep = elementPairs.subList(2, size), notPrinter, notParser);",
                "patch_diff": "return new PeriodFormatter(sep, sep = elementPairs.subList(2, size), notPrinter, notParser);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (size == 2) {",
                "patch_diff": "} else if (size == 2) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (f.subList(2, size) {",
                "patch_diff": "} else if (f.subList(2, size) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (size >= 2 && elementPairs.subList(2, size) {",
                "patch_diff": "} else if (size >= 2 && elementPairs.subList(2, size) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (elementPairs.subList(2, size) {",
                "patch_diff": "} else if (elementPairs.subList(2, size) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (size >= 2 && elementPairs.size() == 2) {",
                "patch_diff": "} else if (size >= 2 && elementPairs.size() == 2) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (size >= 2 && elementPairs.size) {",
                "patch_diff": "} else if (size >= 2 && elementPairs.size) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (size >= 2 && elementPairs.size() > 2) {",
                "patch_diff": "} else if (size >= 2 && elementPairs.size() > 2) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (sep.iAfterParser == null && sep.iAfterPrinter == null) { PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); sep = sep.finish(f.getPrinter(), f.getParser()); return new PeriodFormatter(sep, sep); }"
    },
    "JacksonCore-25": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (i <= maxCode) { // identifier, just needs 2 byte output",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-25/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\t2022-07-19 16:16:34.029124699 +0200\n+++ /tmp/tmpdryczeeq.java\t2022-07-19 16:16:34.049124600 +0200\n@@ -1958,11 +1958,11 @@\n                     break;\n                 }\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+if (i <= maxCode) { // identifier, just needs 2 byte output\n                 if (codes[i] != 0) {\n                     break;\n                 }\n             } else if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (i <= maxCode) { // identifier, skip for a digit after the end",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-25/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\t2022-07-19 16:16:43.657077483 +0200\n+++ /tmp/tmp42qy0_95.java\t2022-07-19 16:16:43.661077464 +0200\n@@ -1958,11 +1958,11 @@\n                     break;\n                 }\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+if (i <= maxCode) { // identifier, skip for a digit after the end\n                 if (codes[i] != 0) {\n                     break;\n                 }\n             } else if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (i <= maxCode) { // followed by other number; return",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-25/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\t2022-07-19 16:16:52.373034503 +0200\n+++ /tmp/tmp5yfcjf8y.java\t2022-07-19 16:16:52.373034503 +0200\n@@ -1958,11 +1958,11 @@\n                     break;\n                 }\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+if (i <= maxCode) { // followed by other number; return\n                 if (codes[i] != 0) {\n                     break;\n                 }\n             } else if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (i <= maxCode) { // don't really need 6",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-25/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\t2022-07-19 16:17:01.096991261 +0200\n+++ /tmp/tmp9yfm2nej.java\t2022-07-19 16:17:01.100991241 +0200\n@@ -1958,11 +1958,11 @@\n                     break;\n                 }\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+if (i <= maxCode) { // don't really need 6\n                 if (codes[i] != 0) {\n                     break;\n                 }\n             } else if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (i <= maxCode) { // yup, skip for now",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-25/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\t2022-07-19 16:17:09.892947443 +0200\n+++ /tmp/tmpdflnyg7a.java\t2022-07-19 16:17:09.892947443 +0200\n@@ -1958,11 +1958,11 @@\n                     break;\n                 }\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+if (i <= maxCode) { // yup, skip for now\n                 if (codes[i] != 0) {\n                     break;\n                 }\n             } else if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (i <= maxCode) { // '9't really need 6",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-25/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\t2022-07-19 16:17:18.520904250 +0200\n+++ /tmp/tmpd2cyb3t8.java\t2022-07-19 16:17:18.524904229 +0200\n@@ -1958,11 +1958,11 @@\n                     break;\n                 }\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+if (i <= maxCode) { // '9't really need 6\n                 if (codes[i] != 0) {\n                     break;\n                 }\n             } else if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (i <= maxCode) { // identifier, just needs 2 byte/allowed chars",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-25/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\t2022-07-19 16:17:27.228860446 +0200\n+++ /tmp/tmpaikncang.java\t2022-07-19 16:17:27.228860446 +0200\n@@ -1958,11 +1958,11 @@\n                     break;\n                 }\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+if (i <= maxCode) { // identifier, just needs 2 byte/allowed chars\n                 if (codes[i] != 0) {\n                     break;\n                 }\n             } else if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (i < maxCode) { // identifier, just needs 2 byte/allowed chars",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-25/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\t2022-07-19 16:17:35.996816134 +0200\n+++ /tmp/tmpiyxswqfm.java\t2022-07-19 16:17:36.000816115 +0200\n@@ -1958,11 +1958,11 @@\n                     break;\n                 }\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+if (i < maxCode) { // identifier, just needs 2 byte/allowed chars\n                 if (codes[i] != 0) {\n                     break;\n                 }\n             } else if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 9,
                "patch": "if (i <= maxCode) { // identifier, just needs 2 triplets",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-25/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\t2022-07-19 16:17:44.548772715 +0200\n+++ /tmp/tmp7p7jg295.java\t2022-07-19 16:17:44.552772696 +0200\n@@ -1958,11 +1958,11 @@\n                     break;\n                 }\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+if (i <= maxCode) { // identifier, just needs 2 triplets\n                 if (codes[i] != 0) {\n                     break;\n                 }\n             } else if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (i < maxCode) { // identifier, just needs 2 byte output",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-25/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\t2022-07-19 16:17:53.400727572 +0200\n+++ /tmp/tmpdhge09vu.java\t2022-07-19 16:17:53.400727572 +0200\n@@ -1958,11 +1958,11 @@\n                     break;\n                 }\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+if (i < maxCode) { // identifier, just needs 2 byte output\n                 if (codes[i] != 0) {\n                     break;\n                 }\n             } else if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            }
        ],
        "buggy_line": "if (i <= maxCode) {",
        "fixed_line": "if (i < maxCode) {"
    },
    "Closure-107": {
        "fixes": [
            {
                "k": 1,
                "patch": "// for (int i = 0; i < options.getMsgCount; i++) { for (int j = 0; j < options.getMsg(); ++i) { char c = options.get(i); if (options.message!= null) { return options.getMsg(); } } return options. But; }",
                "patch_diff": "// for (int i = 0; i < options.getMsgCount; i++) { for (int j = 0; j < options.getMsg(); ++i) { char c = options.get(i); if (options.message!= null) { return options.getMsg(); } } return options. But; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// for (int i = 0; i < options.getMsgCount; i++) { for (int j = 0; j < options.getMsg(); ++i) { char c = options.get(i); if (options.message!= null) { return options.getMsg(); } } return options. But; } }",
                "patch_diff": "// for (int i = 0; i < options.getMsgCount; i++) { for (int j = 0; j < options.getMsg(); ++i) { char c = options.get(i); if (options.message!= null) { return options.getMsg(); } } return options. But; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// for (int i = 0; i < options.getMsgCount; i++) { for (int j = 0; j < options.getMsg(); ++i) { char c = options.get(i); if (options.message!= null) { return options.getMsg(); } } }",
                "patch_diff": "// for (int i = 0; i < options.getMsgCount; i++) { for (int j = 0; j < options.getMsg(); ++i) { char c = options.get(i); if (options.message!= null) { return options.getMsg(); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// for (int i = 0; i < options.getMsgCount; i++) { for (int j = 0; j < options.getMsg().length; j++) { if (options.message(mode)) { return options.getMsg(); } } }",
                "patch_diff": "// for (int i = 0; i < options.getMsgCount; i++) { for (int j = 0; j < options.getMsg().length; j++) { if (options.message(mode)) { return options.getMsg(); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// for (int i = 0; i < options.getMsgCount; i++) { for (int j = 0; j < options.getMsg(); ++i) { char c = options.get(i); if (options.message!= null) { return options.getMsg(); } } } }",
                "patch_diff": "// for (int i = 0; i < options.getMsgCount; i++) { for (int j = 0; j < options.getMsg(); ++i) { char c = options.get(i); if (options.message!= null) { return options.getMsg(); } } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if (options.messageId = options.getMsg is going to be renamed)",
                "patch_diff": "// if (options.messageId = options.getMsg is going to be renamed)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// for (int i = 0; i < options.getMsgCount; i++) { for (int j = 0; j < options.getMsg().length; j++) { if (options.message(mode)) { return options.getMsg(); } } return options. But; }",
                "patch_diff": "// for (int i = 0; i < options.getMsgCount; i++) { for (int j = 0; j < options.getMsg().length; j++) { if (options.message(mode)) { return options.getMsg(); } } return options. But; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// for (int i = 0; i < options.getMsgCount; i++) { for (int j = 0; j < options.getMsg().length; j++) { if (options.message(mode)) { return options.getMsg(); } } return options. But; } }",
                "patch_diff": "// for (int i = 0; i < options.getMsgCount; i++) { for (int j = 0; j < options.getMsg().length; j++) { if (options.message(mode)) { return options.getMsg(); } } return options. But; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// for (int i = 0; i < options.getMsgCount; i++) { for (int j = 0; j < options.getMsg(); ++i) { char c = options.get(i); if (options.getN() > 1) { return options.getMsg(); } } return options. But; }",
                "patch_diff": "// for (int i = 0; i < options.getMsgCount; i++) { for (int j = 0; j < options.getMsg(); ++i) { char c = options.get(i); if (options.getN() > 1) { return options.getMsg(); } } return options. But; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// for (int i = 0; i < options.getMsgCount; i++) { for (int j = 0; j < options.getMsg().length; j++) { if (options.message(mode)) { return options.getMsg(); } } } }",
                "patch_diff": "// for (int i = 0; i < options.getMsgCount; i++) { for (int j = 0; j < options.getMsg().length; j++) { if (options.message(mode)) { return options.getMsg(); } } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "options.setWarningLevel(JsMessageVisitor.MSG_CONVENTIONS, CheckLevel.OFF);"
    },
    "Math-103": {
        "fixes": [
            {
                "k": 1,
                "patch": "return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * x) / n;",
                "patch_diff": "return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * x) / n;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// if (x + Erf.erf((x - mean) / (standardDeviation * x) / n;",
                "patch_diff": "// if (x + Erf.erf((x - mean) / (standardDeviation * x) / n;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * flagDeviation) / ex;",
                "patch_diff": "return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * flagDeviation) / ex;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * x))));",
                "patch_diff": "return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * x))));",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * accum))));",
                "patch_diff": "return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * accum))));",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if (x0 = 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * x) / n;",
                "patch_diff": "// if (x0 = 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * x) / n;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// if (x) { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * x) / n; }",
                "patch_diff": "// if (x) { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * x) / n; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * x) / n; }",
                "patch_diff": "return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * x) / n; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// if (x + Erf.erf((x - mean) / (standardDeviation * flagDeviation) / ex;",
                "patch_diff": "// if (x + Erf.erf((x - mean) / (standardDeviation * flagDeviation) / ex;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if (x + Erf.erf((x - mean) / (standardDeviation * x) / n; }",
                "patch_diff": "// if (x + Erf.erf((x - mean) / (standardDeviation * x) / n; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "try { return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(2.0)))); } catch (MaxIterationsExceededException ex) { if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38 return 0.0d; } else if (x > (mean + 20 * standardDeviation)) { return 1.0d; } else { throw ex; } }"
    },
    "Math-33": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (entry.compareTo(entry, 0d, maximalIterationCount) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2022-07-19 16:18:06.352661152 +0200\n+++ /tmp/tmpk_e2ne1r.java\t2022-07-19 16:18:06.412660845 +0200\n@@ -333,11 +333,11 @@\n         columnsToDrop.add(0);\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+if (entry.compareTo(entry, 0d, maximalIterationCount) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n \n         // non-basic artificial variables\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (mCol.compareTo(entry, 0d, maximalIterationCount) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2022-07-19 16:18:08.940647830 +0200\n+++ /tmp/tmpa1xcrvmv.java\t2022-07-19 16:18:08.940647830 +0200\n@@ -333,11 +333,11 @@\n         columnsToDrop.add(0);\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+if (mCol.compareTo(entry, 0d, maximalIterationCount) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n \n         // non-basic artificial variables\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (ret.compareTo(entry, 0d, maximalIterationCount) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2022-07-19 16:18:11.144636471 +0200\n+++ /tmp/tmpr9e5aomu.java\t2022-07-19 16:18:11.144636471 +0200\n@@ -333,11 +333,11 @@\n         columnsToDrop.add(0);\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+if (ret.compareTo(entry, 0d, maximalIterationCount) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n \n         // non-basic artificial variables\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (entry.compareTo(this.entry, 0d, maximalIterationCount) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2022-07-19 16:18:13.240625658 +0200\n+++ /tmp/tmpb80fuxq2.java\t2022-07-19 16:18:13.240625658 +0200\n@@ -333,11 +333,11 @@\n         columnsToDrop.add(0);\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+if (entry.compareTo(this.entry, 0d, maximalIterationCount) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n \n         // non-basic artificial variables\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (entry.compareTo(entry, 0d, 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2022-07-19 16:18:15.364614689 +0200\n+++ /tmp/tmp2zfqskic.java\t2022-07-19 16:18:15.364614689 +0200\n@@ -333,11 +333,11 @@\n         columnsToDrop.add(0);\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+if (entry.compareTo(entry, 0d, 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n \n         // non-basic artificial variables\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (font.compareTo(this.entry, 0d, maximalIterationCount) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2022-07-19 16:18:17.336604494 +0200\n+++ /tmp/tmpxju05a84.java\t2022-07-19 16:18:17.336604494 +0200\n@@ -333,11 +333,11 @@\n         columnsToDrop.add(0);\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+if (font.compareTo(this.entry, 0d, maximalIterationCount) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n \n         // non-basic artificial variables\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (mCol.compareTo(entry, 0d, 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2022-07-19 16:18:19.416593732 +0200\n+++ /tmp/tmp32fdrd8f.java\t2022-07-19 16:18:19.416593732 +0200\n@@ -333,11 +333,11 @@\n         columnsToDrop.add(0);\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+if (mCol.compareTo(entry, 0d, 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n \n         // non-basic artificial variables\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (ret.compareTo(entry, 0d, 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2022-07-19 16:18:21.372583599 +0200\n+++ /tmp/tmpggdvvuue.java\t2022-07-19 16:18:21.372583599 +0200\n@@ -333,11 +333,11 @@\n         columnsToDrop.add(0);\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+if (ret.compareTo(entry, 0d, 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n \n         // non-basic artificial variables\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (entry.compareTo(this.entry, 0d, 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2022-07-19 16:18:23.452572815 +0200\n+++ /tmp/tmp7vd30qk5.java\t2022-07-19 16:18:23.452572815 +0200\n@@ -333,11 +333,11 @@\n         columnsToDrop.add(0);\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+if (entry.compareTo(this.entry, 0d, 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n \n         // non-basic artificial variables\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (font.compareTo(this.entry, 0d, 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2022-07-19 16:18:25.464562376 +0200\n+++ /tmp/tmpx8h0z9s7.java\t2022-07-19 16:18:25.464562376 +0200\n@@ -333,11 +333,11 @@\n         columnsToDrop.add(0);\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+if (font.compareTo(this.entry, 0d, 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n \n         // non-basic artificial variables\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (Precision.compareTo(entry, 0d, maxUlps) > 0) {",
        "fixed_line": "if (Precision.compareTo(entry, 0d, epsilon) > 0) {"
    },
    "Lang-40": {
        "fixes": [
            {
                "k": 1,
                "patch": "return containsStr.toUpper(), searchStr.toUpperCase());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-40/src/java/org/apache/commons/lang/StringUtils.java\t2022-07-19 16:18:27.580551383 +0200\n+++ /tmp/tmp4d_7i7wp.java\t2022-07-19 16:18:27.632551119 +0200\n@@ -1043,11 +1043,11 @@\n      */\n     public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+return containsStr.toUpper(), searchStr.toUpperCase());\n     }\n \n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return str.toUpperCasetoUpperCase(), searchStr.toUpperCase());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-40/src/java/org/apache/commons/lang/StringUtils.java\t2022-07-19 16:18:29.432541754 +0200\n+++ /tmp/tmpug0syalj.java\t2022-07-19 16:18:29.432541754 +0200\n@@ -1043,11 +1043,11 @@\n      */\n     public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+return str.toUpperCasetoUpperCase(), searchStr.toUpperCase());\n     }\n \n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return contains(str.toUpperCase(), searchStr.toUpperCase());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-40/src/java/org/apache/commons/lang/StringUtils.java\t2022-07-19 16:18:30.988533659 +0200\n+++ /tmp/tmp3r7fuyf3.java\t2022-07-19 16:18:30.992533637 +0200\n@@ -1043,11 +1043,11 @@\n      */\n     public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+return contains(str.toUpperCase(), searchStr.toUpperCase());\n     }\n \n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return containsStr.toUpperCase(), searchStr.toUpperCase());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-40/src/java/org/apache/commons/lang/StringUtils.java\t2022-07-19 16:18:39.356490018 +0200\n+++ /tmp/tmpa91dtie1.java\t2022-07-19 16:18:39.360489997 +0200\n@@ -1043,11 +1043,11 @@\n      */\n     public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+return containsStr.toUpperCase(), searchStr.toUpperCase());\n     }\n \n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return searchStr.toUpperCase(), searchStr.toUpperCase());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-40/src/java/org/apache/commons/lang/StringUtils.java\t2022-07-19 16:18:40.964481614 +0200\n+++ /tmp/tmpna1i0jrv.java\t2022-07-19 16:18:40.964481614 +0200\n@@ -1043,11 +1043,11 @@\n      */\n     public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+return searchStr.toUpperCase(), searchStr.toUpperCase());\n     }\n \n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return str.toUpperCaseINGINGstr.toUpperCase());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-40/src/java/org/apache/commons/lang/StringUtils.java\t2022-07-19 16:18:42.492473621 +0200\n+++ /tmp/tmpkmddoiyx.java\t2022-07-19 16:18:42.492473621 +0200\n@@ -1043,11 +1043,11 @@\n      */\n     public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+return str.toUpperCaseINGINGstr.toUpperCase());\n     }\n \n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return contains(str.toUpperCase(), searchStr;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-40/src/java/org/apache/commons/lang/StringUtils.java\t2022-07-19 16:18:44.056465436 +0200\n+++ /tmp/tmp4egmashx.java\t2022-07-19 16:18:44.060465415 +0200\n@@ -1043,11 +1043,11 @@\n      */\n     public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+return contains(str.toUpperCase(), searchStr;\n     }\n \n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return str.toUpperCase - searchStr.toUpperCase());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-40/src/java/org/apache/commons/lang/StringUtils.java\t2022-07-19 16:18:45.648457095 +0200\n+++ /tmp/tmpspqwjn3x.java\t2022-07-19 16:18:45.652457076 +0200\n@@ -1043,11 +1043,11 @@\n      */\n     public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+return str.toUpperCase - searchStr.toUpperCase());\n     }\n \n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return containsStr.toUpperCase(), searchStr;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-40/src/java/org/apache/commons/lang/StringUtils.java\t2022-07-19 16:18:47.172449107 +0200\n+++ /tmp/tmpokcnzrso.java\t2022-07-19 16:18:47.172449107 +0200\n@@ -1043,11 +1043,11 @@\n      */\n     public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+return containsStr.toUpperCase(), searchStr;\n     }\n \n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return str.toUpperCase(), searchStr.toUpperCase());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-40/src/java/org/apache/commons/lang/StringUtils.java\t2022-07-19 16:18:48.680441199 +0200\n+++ /tmp/tmp56gvgnb9.java\t2022-07-19 16:18:48.684441178 +0200\n@@ -1043,11 +1043,11 @@\n      */\n     public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+return str.toUpperCase(), searchStr.toUpperCase());\n     }\n \n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return contains(str.toUpperCase(), searchStr.toUpperCase());",
        "fixed_line": "int len = searchStr.length(); int max = str.length() - len; for (int i = 0; i <= max; i++) { if (str.regionMatches(true, i, searchStr, 0, len)) { return true; } } return false;"
    },
    "Jsoup-33": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if (el.tagName()));",
                "patch_diff": "// if (el.tagName()));",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// if (el.tagName().equals(tag)) {",
                "patch_diff": "// if (el.tagName().equals(tag)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if (el.tagName!= null) {",
                "patch_diff": "// if (el.tagName!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// }",
                "patch_diff": "// }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// if (el.tagName() == false) {",
                "patch_diff": "// if (el.tagName() == false) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if (el.tagName().equals(bodyTag)) {",
                "patch_diff": "// if (el.tagName().equals(bodyTag)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// if (el.tagName() == null) {",
                "patch_diff": "// if (el.tagName() == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// if (el.tagName() == Token.NAME) {",
                "patch_diff": "// if (el.tagName() == Token.NAME) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// if (el.tagName() == this) {",
                "patch_diff": "// if (el.tagName() == this) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if (el.tagName() > 0) {",
                "patch_diff": "// if (el.tagName() > 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data"
    },
    "Chart-1": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (dataset == null) { // block == null; non-empty's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2022-07-19 16:18:51.992423808 +0200\n+++ /tmp/tmpb3f90jye.java\t2022-07-19 16:18:52.032423600 +0200\n@@ -1792,11 +1792,11 @@\n         if (this.plot == null) {\n             return result;\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+if (dataset == null) { // block == null; non-empty's do implicit re-parse\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 2,
                "patch": "if (dataset == null) { // block == null; non-empty's after name; return result; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2022-07-19 16:19:03.712362068 +0200\n+++ /tmp/tmpj_j45i11.java\t2022-07-19 16:19:03.712362068 +0200\n@@ -1792,11 +1792,11 @@\n         if (this.plot == null) {\n             return result;\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+if (dataset == null) { // block == null; non-empty's after name; return result; }\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 3,
                "patch": "if (dataset == null) { // block only override if the dataset with 0x result; return result; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2022-07-19 16:19:12.992312959 +0200\n+++ /tmp/tmpd7ehyzdj.java\t2022-07-19 16:19:12.996312938 +0200\n@@ -1792,11 +1792,11 @@\n         if (this.plot == null) {\n             return result;\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+if (dataset == null) { // block only override if the dataset with 0x result; return result; }\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 4,
                "patch": "if (dataset == null) { // block == null; non-empty enables",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2022-07-19 16:19:22.048264854 +0200\n+++ /tmp/tmpx2ul4e_w.java\t2022-07-19 16:19:22.048264854 +0200\n@@ -1792,11 +1792,11 @@\n         if (this.plot == null) {\n             return result;\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+if (dataset == null) { // block == null; non-empty enables\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 5,
                "patch": "if (dataset == null) { // block == null; non-empty's after name; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2022-07-19 16:19:31.152216314 +0200\n+++ /tmp/tmp7p235g3e.java\t2022-07-19 16:19:31.152216314 +0200\n@@ -1792,11 +1792,11 @@\n         if (this.plot == null) {\n             return result;\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+if (dataset == null) { // block == null; non-empty's after name; }\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 6,
                "patch": "if (dataset == null) { // block only override if more specific",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2022-07-19 16:19:40.252167619 +0200\n+++ /tmp/tmp5x22wplp.java\t2022-07-19 16:19:40.252167619 +0200\n@@ -1792,11 +1792,11 @@\n         if (this.plot == null) {\n             return result;\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+if (dataset == null) { // block only override if more specific\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 7,
                "patch": "if (dataset == null) { // add a dataset with 0x result; non-empty enables",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2022-07-19 16:19:49.268119202 +0200\n+++ /tmp/tmpcl4ghslp.java\t2022-07-19 16:19:49.268119202 +0200\n@@ -1792,11 +1792,11 @@\n         if (this.plot == null) {\n             return result;\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+if (dataset == null) { // add a dataset with 0x result; non-empty enables\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 8,
                "patch": "if (this.dataset == null) { // block == null; non-empty enables",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2022-07-19 16:19:58.412069928 +0200\n+++ /tmp/tmp5rxxstde.java\t2022-07-19 16:19:58.412069928 +0200\n@@ -1792,11 +1792,11 @@\n         if (this.plot == null) {\n             return result;\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+if (this.dataset == null) { // block == null; non-empty enables\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (dataset == null) { // block only override if the dataset with 0x result; non-empty enables",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2022-07-19 16:20:00.356059430 +0200\n+++ /tmp/tmpkznc60jv.java\t2022-07-19 16:20:00.356059430 +0200\n@@ -1792,11 +1792,11 @@\n         if (this.plot == null) {\n             return result;\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+if (dataset == null) { // block only override if the dataset with 0x result; non-empty enables\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 10,
                "patch": "if (dataset == null) { // add a dataset with 0x result; return result; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2022-07-19 16:20:09.640009189 +0200\n+++ /tmp/tmp58vb5oai.java\t2022-07-19 16:20:09.644009168 +0200\n@@ -1792,11 +1792,11 @@\n         if (this.plot == null) {\n             return result;\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+if (dataset == null) { // add a dataset with 0x result; return result; }\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            }
        ],
        "buggy_line": "if (dataset != null) {",
        "fixed_line": "if (dataset == null) {"
    },
    "Codec-9": {
        "fixes": [
            {
                "k": 1,
                "patch": "long len = getEncodeLength(binaryData, byteLen, CHUNK_SEPARATOR);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-9/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 16:20:18.863959106 +0200\n+++ /tmp/tmp5hphupvv.java\t2022-07-19 16:20:18.907958869 +0200\n@@ -822,11 +822,11 @@\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+long len = getEncodeLength(binaryData, byteLen, CHUNK_SEPARATOR);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "long len = getEncodeLength(binaryData, movedData, CHUNK_SEPARATOR);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-9/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 16:20:20.823948442 +0200\n+++ /tmp/tmpd55rff6d.java\t2022-07-19 16:20:20.823948442 +0200\n@@ -822,11 +822,11 @@\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+long len = getEncodeLength(binaryData, movedData, CHUNK_SEPARATOR);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "long len = getEncodeLength(binaryData, Encoder_CHUNK_SIZE, CHUNK_SEPARATOR);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-9/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 16:20:22.487939384 +0200\n+++ /tmp/tmp9ndnr2nw.java\t2022-07-19 16:20:22.491939363 +0200\n@@ -822,11 +822,11 @@\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+long len = getEncodeLength(binaryData, Encoder_CHUNK_SIZE, CHUNK_SEPARATOR);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "long len = getEncodeLength(binaryData, needResult, CHUNK_SEPARATOR);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-9/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 16:20:24.175930188 +0200\n+++ /tmp/tmp0_mv0o2g.java\t2022-07-19 16:20:24.175930188 +0200\n@@ -822,11 +822,11 @@\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+long len = getEncodeLength(binaryData, needResult, CHUNK_SEPARATOR);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "long len = getEncodeLength(binaryData, byteLen, CHUNK_SEPARATORLength);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-9/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 16:20:25.827921184 +0200\n+++ /tmp/tmpdodofjtm.java\t2022-07-19 16:20:25.827921184 +0200\n@@ -822,11 +822,11 @@\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+long len = getEncodeLength(binaryData, byteLen, CHUNK_SEPARATORLength);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "long len = getEncodeLength(binaryData, binaryData, CHUNK_SEPARATOR);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-9/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 16:20:27.503912043 +0200\n+++ /tmp/tmpi_uoqzbq.java\t2022-07-19 16:20:27.503912043 +0200\n@@ -822,11 +822,11 @@\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+long len = getEncodeLength(binaryData, binaryData, CHUNK_SEPARATOR);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "long len = getEncodeLength(binaryData, elementType, CHUNK_SEPARATOR);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-9/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 16:20:29.167902962 +0200\n+++ /tmp/tmpj7y3nmuh.java\t2022-07-19 16:20:29.167902962 +0200\n@@ -822,11 +822,11 @@\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+long len = getEncodeLength(binaryData, elementType, CHUNK_SEPARATOR);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "long len = getEncodeLength(binaryData, cursor, CHUNK_SEPARATOR);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-9/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 16:20:30.803894032 +0200\n+++ /tmp/tmpuf0m2xp8.java\t2022-07-19 16:20:30.803894032 +0200\n@@ -822,11 +822,11 @@\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+long len = getEncodeLength(binaryData, cursor, CHUNK_SEPARATOR);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "long len = getEncodeLength(binaryData, elementType, CHUNK_SEPARATOR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-9/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 16:20:32.403885291 +0200\n+++ /tmp/tmpsi_cer2a.java\t2022-07-19 16:20:32.407885267 +0200\n@@ -822,11 +822,11 @@\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+long len = getEncodeLength(binaryData, elementType, CHUNK_SEPARATOR;\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "long len = getEncodeLength(binaryData, elementType, elementData);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-9/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 16:20:33.907877068 +0200\n+++ /tmp/tmpeong_5cf.java\t2022-07-19 16:20:33.907877068 +0200\n@@ -822,11 +822,11 @@\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+long len = getEncodeLength(binaryData, elementType, elementData);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);",
        "fixed_line": "long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);"
    },
    "JacksonCore-13": {
        "fixes": [
            {
                "k": 1,
                "patch": "_cfgUnqNames =!Feature.QUOTE_FIELD_NAMES.enabledIn(newFeatureFlags, changedFeatures);",
                "patch_diff": "_cfgUnqNames =!Feature.QUOTE_FIELD_NAMES.enabledIn(newFeatureFlags, changedFeatures);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "_cfgUnqNames =!Feature.QUOTE_FIELD_NAMES;",
                "patch_diff": "_cfgUnqNames =!Feature.QUOTE_FIELD_NAMES;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "_cfgUnqNames = newFeatureFlags, changedFeatures);",
                "patch_diff": "_cfgUnqNames = newFeatureFlags, changedFeatures);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "_cfgUnqNames =!Feature.QUOTE_FIELD_NAMES.enabledIn(newFeatureFlags, _cfgUnqNames;",
                "patch_diff": "_cfgUnqNames =!Feature.QUOTE_FIELD_NAMES.enabledIn(newFeatureFlags, _cfgUnqNames;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "_cfgUnqNames = newFeatureFlags;",
                "patch_diff": "_cfgUnqNames = newFeatureFlags;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "_cfgUnqNames =!Feature.QUOTE_FIELD_NAMES.enabledIn(newFeatureFlags, _cfgUnqNames);",
                "patch_diff": "_cfgUnqNames =!Feature.QUOTE_FIELD_NAMES.enabledIn(newFeatureFlags, _cfgUnqNames);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (oldFeature.QUOTE_FIELD_NAMES.enabledIn(newFeatureFlags, changedFeatures);",
                "patch_diff": "if (oldFeature.QUOTE_FIELD_NAMES.enabledIn(newFeatureFlags, changedFeatures);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "_cfgUnqNames =!Feature.QUOTE_FIELD_NAMES.enabledIn(newFeatureFlags,",
                "patch_diff": "_cfgUnqNames =!Feature.QUOTE_FIELD_NAMES.enabledIn(newFeatureFlags,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "_cfgUnqNames = newFeatureFlags, changedFeatures;",
                "patch_diff": "_cfgUnqNames = newFeatureFlags, changedFeatures;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "_cfgUnqNames =!Feature.QUOTE_FIELD_NAMES.enabledIn(newFeatureFlags, changedFeatures);",
                "patch_diff": "_cfgUnqNames =!Feature.QUOTE_FIELD_NAMES.enabledIn(newFeatureFlags, changedFeatures);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "@Override public JsonGenerator disable(Feature f) { super.disable(f); if (f == Feature.QUOTE_FIELD_NAMES) { _cfgUnqNames = true; } return this; }"
    },
    "Math-101": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (source.substring(startIndex, endIndex) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-101/src/java/org/apache/commons/math/complex/ComplexFormat.java\t2022-07-19 16:20:37.371858120 +0200\n+++ /tmp/tmppd8gz309.java\t2022-07-19 16:20:37.395857985 +0200\n@@ -372,11 +372,11 @@\n \n         // parse imaginary character\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+if (source.substring(startIndex, endIndex) {\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n             // character examined.\n             pos.setIndex(initialIndex);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (endIndex.substring(startIndex) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-101/src/java/org/apache/commons/math/complex/ComplexFormat.java\t2022-07-19 16:20:40.499840986 +0200\n+++ /tmp/tmp8cdgou48.java\t2022-07-19 16:20:40.503840963 +0200\n@@ -372,11 +372,11 @@\n \n         // parse imaginary character\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+if (endIndex.substring(startIndex) {\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n             // character examined.\n             pos.setIndex(initialIndex);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (startIndex.substring(startIndex) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-101/src/java/org/apache/commons/math/complex/ComplexFormat.java\t2022-07-19 16:20:43.539824319 +0200\n+++ /tmp/tmp_xm9rfct.java\t2022-07-19 16:20:43.539824319 +0200\n@@ -372,11 +372,11 @@\n \n         // parse imaginary character\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+if (startIndex.substring(startIndex) {\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n             // character examined.\n             pos.setIndex(initialIndex);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (source.substring(startIndexIndex) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-101/src/java/org/apache/commons/math/complex/ComplexFormat.java\t2022-07-19 16:20:46.575807656 +0200\n+++ /tmp/tmp_x_5mjmm.java\t2022-07-19 16:20:46.575807656 +0200\n@@ -372,11 +372,11 @@\n \n         // parse imaginary character\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+if (source.substring(startIndexIndex) {\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n             // character examined.\n             pos.setIndex(initialIndex);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (endIndex.substring(startIndexIndex) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-101/src/java/org/apache/commons/math/complex/ComplexFormat.java\t2022-07-19 16:20:49.611790975 +0200\n+++ /tmp/tmp96pr_3wl.java\t2022-07-19 16:20:49.611790975 +0200\n@@ -372,11 +372,11 @@\n \n         // parse imaginary character\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+if (endIndex.substring(startIndexIndex) {\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n             // character examined.\n             pos.setIndex(initialIndex);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (source.substring(startIndex);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-101/src/java/org/apache/commons/math/complex/ComplexFormat.java\t2022-07-19 16:20:52.643774300 +0200\n+++ /tmp/tmpyopz8vvb.java\t2022-07-19 16:20:52.647774280 +0200\n@@ -372,11 +372,11 @@\n \n         // parse imaginary character\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+if (source.substring(startIndex);\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n             // character examined.\n             pos.setIndex(initialIndex);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (startIndex.length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-101/src/java/org/apache/commons/math/complex/ComplexFormat.java\t2022-07-19 16:20:55.727757322 +0200\n+++ /tmp/tmpoiytprpi.java\t2022-07-19 16:20:55.727757322 +0200\n@@ -372,11 +372,11 @@\n \n         // parse imaginary character\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+if (startIndex.length) {\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n             // character examined.\n             pos.setIndex(initialIndex);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (source.substring(startIndex) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-101/src/java/org/apache/commons/math/complex/ComplexFormat.java\t2022-07-19 16:20:58.771740549 +0200\n+++ /tmp/tmpb2mvuc5a.java\t2022-07-19 16:20:58.771740549 +0200\n@@ -372,11 +372,11 @@\n \n         // parse imaginary character\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+if (source.substring(startIndex) {\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n             // character examined.\n             pos.setIndex(initialIndex);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (endIndex.substring(startIndex, endIndex) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-101/src/java/org/apache/commons/math/complex/ComplexFormat.java\t2022-07-19 16:21:01.839723626 +0200\n+++ /tmp/tmpapz6cles.java\t2022-07-19 16:21:01.839723626 +0200\n@@ -372,11 +372,11 @@\n \n         // parse imaginary character\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+if (endIndex.substring(startIndex, endIndex) {\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n             // character examined.\n             pos.setIndex(initialIndex);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (startIndex.substring(startIndexIndex) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-101/src/java/org/apache/commons/math/complex/ComplexFormat.java\t2022-07-19 16:21:05.007706133 +0200\n+++ /tmp/tmp07yp5qkr.java\t2022-07-19 16:21:05.007706133 +0200\n@@ -372,11 +372,11 @@\n \n         // parse imaginary character\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+if (startIndex.substring(startIndexIndex) {\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n             // character examined.\n             pos.setIndex(initialIndex);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (",
        "fixed_line": "if ((startIndex >= source.length()) || (endIndex > source.length()) ||"
    },
    "JacksonXml-4": {
        "fixes": [
            {
                "k": 1,
                "patch": "_initWithRootName((jgen, rootName, ROOT_FOR_NULL);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonXml-4/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 16:21:08.283688027 +0200\n+++ /tmp/tmppcub6iug.java\t2022-07-19 16:21:08.331687761 +0200\n@@ -200,11 +200,11 @@\n     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n         //    configured root name...\n         if (jgen instanceof ToXmlGenerator) {\n-            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n+_initWithRootName((jgen, rootName, ROOT_FOR_NULL);\n         }\n         super.serializeValue(jgen, null);\n     }\n     \n     protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "_initWithRootName((jgen, ROOT_FOR_NULL);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonXml-4/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 16:21:10.119677869 +0200\n+++ /tmp/tmpyuuv_vxx.java\t2022-07-19 16:21:10.119677869 +0200\n@@ -200,11 +200,11 @@\n     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n         //    configured root name...\n         if (jgen instanceof ToXmlGenerator) {\n-            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n+_initWithRootName((jgen, ROOT_FOR_NULL);\n         }\n         super.serializeValue(jgen, null);\n     }\n     \n     protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "_initWithRootName((jgen, rootName) jgen, ROOT_FOR_NULL);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonXml-4/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 16:21:11.635669478 +0200\n+++ /tmp/tmpj_2obv1k.java\t2022-07-19 16:21:11.635669478 +0200\n@@ -200,11 +200,11 @@\n     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n         //    configured root name...\n         if (jgen instanceof ToXmlGenerator) {\n-            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n+_initWithRootName((jgen, rootName) jgen, ROOT_FOR_NULL);\n         }\n         super.serializeValue(jgen, null);\n     }\n     \n     protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "_initWithRootName((ToXmlGenerator) jgen, ROOT_FOR_NULL);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonXml-4/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 16:21:13.147661107 +0200\n+++ /tmp/tmpvhcingi1.java\t2022-07-19 16:21:13.151661083 +0200\n@@ -200,11 +200,11 @@\n     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n         //    configured root name...\n         if (jgen instanceof ToXmlGenerator) {\n-            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n+_initWithRootName((ToXmlGenerator) jgen, ROOT_FOR_NULL);\n         }\n         super.serializeValue(jgen, null);\n     }\n     \n     protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "_initWithRootName((jgen, rootName, ROOT_NAME_FOR_NULL);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonXml-4/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 16:21:14.803651930 +0200\n+++ /tmp/tmp5jvur_3m.java\t2022-07-19 16:21:14.803651930 +0200\n@@ -200,11 +200,11 @@\n     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n         //    configured root name...\n         if (jgen instanceof ToXmlGenerator) {\n-            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n+_initWithRootName((jgen, rootName, ROOT_NAME_FOR_NULL);\n         }\n         super.serializeValue(jgen, null);\n     }\n     \n     protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "_initWithRootName((jgen, rootName) jgen, ROOT_NAME_FOR_NULL);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonXml-4/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 16:21:16.299643639 +0200\n+++ /tmp/tmp7wvj5koy.java\t2022-07-19 16:21:16.299643639 +0200\n@@ -200,11 +200,11 @@\n     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n         //    configured root name...\n         if (jgen instanceof ToXmlGenerator) {\n-            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n+_initWithRootName((jgen, rootName) jgen, ROOT_NAME_FOR_NULL);\n         }\n         super.serializeValue(jgen, null);\n     }\n     \n     protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonXml-4/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 16:21:17.875634898 +0200\n+++ /tmp/tmpto_cibw2.java\t2022-07-19 16:21:17.875634898 +0200\n@@ -200,11 +200,11 @@\n     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n         //    configured root name...\n         if (jgen instanceof ToXmlGenerator) {\n-            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n+_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n         }\n         super.serializeValue(jgen, null);\n     }\n     \n     protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "_initWithRootName((jgen) jgen, ROOT_FOR_NULL);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonXml-4/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 16:21:26.535586795 +0200\n+++ /tmp/tmpaxqylqmc.java\t2022-07-19 16:21:26.535586795 +0200\n@@ -200,11 +200,11 @@\n     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n         //    configured root name...\n         if (jgen instanceof ToXmlGenerator) {\n-            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n+_initWithRootName((jgen) jgen, ROOT_FOR_NULL);\n         }\n         super.serializeValue(jgen, null);\n     }\n     \n     protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "_initWithRootName((jgen, ROOT_NAME_FOR_NULL);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonXml-4/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 16:21:28.179577648 +0200\n+++ /tmp/tmplvwwy2xs.java\t2022-07-19 16:21:28.179577648 +0200\n@@ -200,11 +200,11 @@\n     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n         //    configured root name...\n         if (jgen instanceof ToXmlGenerator) {\n-            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n+_initWithRootName((jgen, ROOT_NAME_FOR_NULL);\n         }\n         super.serializeValue(jgen, null);\n     }\n     \n     protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "_initWithRootName((jgen) jgen, ROOT_NAME_FOR_NULL);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonXml-4/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 16:21:29.735568990 +0200\n+++ /tmp/tmp6qo_uncw.java\t2022-07-19 16:21:29.735568990 +0200\n@@ -200,11 +200,11 @@\n     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n         //    configured root name...\n         if (jgen instanceof ToXmlGenerator) {\n-            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n+_initWithRootName((jgen) jgen, ROOT_NAME_FOR_NULL);\n         }\n         super.serializeValue(jgen, null);\n     }\n     \n     protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);",
        "fixed_line": "QName rootName = _rootNameFromConfig(); if (rootName == null) { rootName = ROOT_NAME_FOR_NULL; } if (jgen instanceof ToXmlGenerator) { _initWithRootName((ToXmlGenerator) jgen, rootName);"
    },
    "Math-19": {
        "fixes": [
            {
                "k": 1,
                "patch": "// definitions[0] = lB; boundaries[1] = uB;",
                "patch_diff": "// definitions[0] = lB; boundaries[1] = uB;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// } else if (lB; boundaries[1] = uB;",
                "patch_diff": "// } else if (lB; boundaries[1] = uB;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// definitions[0] = uB; boundaries[1] = uB;",
                "patch_diff": "// definitions[0] = uB; boundaries[1] = uB;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// definitions[0] = lB; boundaries[1] = lB;",
                "patch_diff": "// definitions[0] = lB; boundaries[1] = lB;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// definitions[0] = lB; boundaries[0] = uB;",
                "patch_diff": "// definitions[0] = lB; boundaries[0] = uB;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// definitions[0] = lB; boundaries[1] = uB; }",
                "patch_diff": "// definitions[0] = lB; boundaries[1] = uB; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// definitions[0] = uB; boundaries[1] = lB;",
                "patch_diff": "// definitions[0] = uB; boundaries[1] = lB;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// } else if (lB; boundaries[1] = lB;",
                "patch_diff": "// } else if (lB; boundaries[1] = lB;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// } else if (lB == null) {",
                "patch_diff": "// } else if (lB == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// } else if (lB > 32) {",
                "patch_diff": "// } else if (lB > 32) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "for (int i = 0; i < lB.length; i++) { if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) { final double max = Double.MAX_VALUE + boundaries[0][i]; final NumberIsTooLargeException e = new NumberIsTooLargeException(boundaries[1][i], max, true); e.getContext().addMessage(LocalizedFormats.OVERFLOW); e.getContext().addMessage(LocalizedFormats.INDEX, i); throw e; } }"
    },
    "Cli-15": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (valueList == null || valueList = defaultValues; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-15/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\t2022-07-19 16:21:33.247549427 +0200\n+++ /tmp/tmpnyjwirdy.java\t2022-07-19 16:21:33.331548958 +0200\n@@ -112,18 +112,11 @@\n                           List defaultValues) {\n         // initialize the return list\n         List valueList = (List) values.get(option);\n \n         // grab the correct default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = defaultValues;\n-        }\n-\n-        // augment the list with the default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = (List) this.defaultValues.get(option);\n-        }\n+if (valueList == null || valueList = defaultValues; }\n                 // if there are more default values as specified, add them to\n                 // the list.\n                     // copy the list first\n         \n         return valueList == null ? Collections.EMPTY_LIST : valueList;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (valueList == null) || valueList = defaultValues; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-15/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\t2022-07-19 16:21:35.107539057 +0200\n+++ /tmp/tmph9qbh_t8.java\t2022-07-19 16:21:35.107539057 +0200\n@@ -112,18 +112,11 @@\n                           List defaultValues) {\n         // initialize the return list\n         List valueList = (List) values.get(option);\n \n         // grab the correct default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = defaultValues;\n-        }\n-\n-        // augment the list with the default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = (List) this.defaultValues.get(option);\n-        }\n+if (valueList == null) || valueList = defaultValues; }\n                 // if there are more default values as specified, add them to\n                 // the list.\n                     // copy the list first\n         \n         return valueList == null ? Collections.EMPTY_LIST : valueList;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (valueList!= null && valueList = valueList; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-15/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\t2022-07-19 16:21:36.671530333 +0200\n+++ /tmp/tmpyhxj_9_c.java\t2022-07-19 16:21:36.671530333 +0200\n@@ -112,18 +112,11 @@\n                           List defaultValues) {\n         // initialize the return list\n         List valueList = (List) values.get(option);\n \n         // grab the correct default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = defaultValues;\n-        }\n-\n-        // augment the list with the default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = (List) this.defaultValues.get(option);\n-        }\n+if (valueList!= null && valueList = valueList; }\n                 // if there are more default values as specified, add them to\n                 // the list.\n                     // copy the list first\n         \n         return valueList == null ? Collections.EMPTY_LIST : valueList;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (valueList!= null && valueList = defaultValues; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-15/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\t2022-07-19 16:21:38.167521986 +0200\n+++ /tmp/tmpy9_c2rv5.java\t2022-07-19 16:21:38.167521986 +0200\n@@ -112,18 +112,11 @@\n                           List defaultValues) {\n         // initialize the return list\n         List valueList = (List) values.get(option);\n \n         // grab the correct default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = defaultValues;\n-        }\n-\n-        // augment the list with the default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = (List) this.defaultValues.get(option);\n-        }\n+if (valueList!= null && valueList = defaultValues; }\n                 // if there are more default values as specified, add them to\n                 // the list.\n                     // copy the list first\n         \n         return valueList == null ? Collections.EMPTY_LIST : valueList;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (valueList == null || valueList = valueList; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-15/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\t2022-07-19 16:21:39.671513589 +0200\n+++ /tmp/tmpg92m8ayb.java\t2022-07-19 16:21:39.671513589 +0200\n@@ -112,18 +112,11 @@\n                           List defaultValues) {\n         // initialize the return list\n         List valueList = (List) values.get(option);\n \n         // grab the correct default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = defaultValues;\n-        }\n-\n-        // augment the list with the default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = (List) this.defaultValues.get(option);\n-        }\n+if (valueList == null || valueList = valueList; }\n                 // if there are more default values as specified, add them to\n                 // the list.\n                     // copy the list first\n         \n         return valueList == null ? Collections.EMPTY_LIST : valueList;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (valueList!= null) || valueList = valueList; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-15/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\t2022-07-19 16:21:41.227504897 +0200\n+++ /tmp/tmpb9o8d6e3.java\t2022-07-19 16:21:41.227504897 +0200\n@@ -112,18 +112,11 @@\n                           List defaultValues) {\n         // initialize the return list\n         List valueList = (List) values.get(option);\n \n         // grab the correct default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = defaultValues;\n-        }\n-\n-        // augment the list with the default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = (List) this.defaultValues.get(option);\n-        }\n+if (valueList!= null) || valueList = valueList; }\n                 // if there are more default values as specified, add them to\n                 // the list.\n                     // copy the list first\n         \n         return valueList == null ? Collections.EMPTY_LIST : valueList;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (valueList!= null) || valueList = defaultValues; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-15/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\t2022-07-19 16:21:42.763496313 +0200\n+++ /tmp/tmpam_zo6ul.java\t2022-07-19 16:21:42.763496313 +0200\n@@ -112,18 +112,11 @@\n                           List defaultValues) {\n         // initialize the return list\n         List valueList = (List) values.get(option);\n \n         // grab the correct default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = defaultValues;\n-        }\n-\n-        // augment the list with the default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = (List) this.defaultValues.get(option);\n-        }\n+if (valueList!= null) || valueList = defaultValues; }\n                 // if there are more default values as specified, add them to\n                 // the list.\n                     // copy the list first\n         \n         return valueList == null ? Collections.EMPTY_LIST : valueList;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (valueList == null) || valueList = valueList; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-15/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\t2022-07-19 16:21:44.259487950 +0200\n+++ /tmp/tmps0gj91xq.java\t2022-07-19 16:21:44.259487950 +0200\n@@ -112,18 +112,11 @@\n                           List defaultValues) {\n         // initialize the return list\n         List valueList = (List) values.get(option);\n \n         // grab the correct default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = defaultValues;\n-        }\n-\n-        // augment the list with the default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = (List) this.defaultValues.get(option);\n-        }\n+if (valueList == null) || valueList = valueList; }\n                 // if there are more default values as specified, add them to\n                 // the list.\n                     // copy the list first\n         \n         return valueList == null ? Collections.EMPTY_LIST : valueList;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (valueList == null || valueList = defaultValues;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-15/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\t2022-07-19 16:21:45.807479293 +0200\n+++ /tmp/tmp658sj01n.java\t2022-07-19 16:21:45.807479293 +0200\n@@ -112,18 +112,11 @@\n                           List defaultValues) {\n         // initialize the return list\n         List valueList = (List) values.get(option);\n \n         // grab the correct default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = defaultValues;\n-        }\n-\n-        // augment the list with the default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = (List) this.defaultValues.get(option);\n-        }\n+if (valueList == null || valueList = defaultValues;\n                 // if there are more default values as specified, add them to\n                 // the list.\n                     // copy the list first\n         \n         return valueList == null ? Collections.EMPTY_LIST : valueList;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (valueList == null) || valueList = defaultValues;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-15/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\t2022-07-19 16:21:47.331470766 +0200\n+++ /tmp/tmpgmhs6f8n.java\t2022-07-19 16:21:47.331470766 +0200\n@@ -112,18 +112,11 @@\n                           List defaultValues) {\n         // initialize the return list\n         List valueList = (List) values.get(option);\n \n         // grab the correct default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = defaultValues;\n-        }\n-\n-        // augment the list with the default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = (List) this.defaultValues.get(option);\n-        }\n+if (valueList == null) || valueList = defaultValues;\n                 // if there are more default values as specified, add them to\n                 // the list.\n                     // copy the list first\n         \n         return valueList == null ? Collections.EMPTY_LIST : valueList;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if ((valueList == null) || valueList.isEmpty()) { valueList = defaultValues; } // augment the list with the default values if ((valueList == null) || valueList.isEmpty()) { valueList = (List) this.defaultValues.get(option); }",
        "fixed_line": "if (defaultValues == null || defaultValues.isEmpty()) { defaultValues = (List) this.defaultValues.get(option); } // augment the list with the default values if (defaultValues != null && !defaultValues.isEmpty()) { if (valueList == null || valueList.isEmpty()) { valueList = defaultValues; } else { // if there are more default values as specified, add them to // the list. if (defaultValues.size() > valueList.size()) { // copy the list first valueList = new ArrayList(valueList); for (int i=valueList.size(); i<defaultValues.size(); i++) { valueList.add(defaultValues.get(i)); } } } }"
    },
    "Closure-161": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if (left.getType() == Token.STRING) { Node left = left.getString(); if (right.getType() == Token.NUMBER) { return; } } else if (left.getType() == Token.NUMBER) { return; } }",
                "patch_diff": "// if (left.getType() == Token.STRING) { Node left = left.getString(); if (right.getType() == Token.NUMBER) { return; } } else if (left.getType() == Token.NUMBER) { return; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// if (left.getType() == Token.NAME) { Node left = left.getString(); if (right.getType() == Token.NUMBER) { return; } } else if (left.getType() == Token.NUMBER) { return; } }",
                "patch_diff": "// if (left.getType() == Token.NAME) { Node left = left.getString(); if (right.getType() == Token.NUMBER) { return; } } else if (left.getType() == Token.NUMBER) { return; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if (left.getType() == Token.STRING) { Node left = left.getString(); if (right.getType() == Token.NUMBER) { return; } } else if (left.getType() == Token.NUMBER) { return; } } else if (left.getType() == Token.NUMBER) { return; } }",
                "patch_diff": "// if (left.getType() == Token.STRING) { Node left = left.getString(); if (right.getType() == Token.NUMBER) { return; } } else if (left.getType() == Token.NUMBER) { return; } } else if (left.getType() == Token.NUMBER) { return; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// if (left.getType() == Token.STRING) { Node left = left.getString(); if (right.getType() == Token.NUMBER) { return; } } else if (left.getType() == Token.NUMBER) { return; } } else if (left.getType() == Token.NUMBER) {",
                "patch_diff": "// if (left.getType() == Token.STRING) { Node left = left.getString(); if (right.getType() == Token.NUMBER) { return; } } else if (left.getType() == Token.NUMBER) { return; } } else if (left.getType() == Token.NUMBER) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// if (left.getType() == Token.STRING) { Node left = left.getString(); if (right.getType() == Token.NUMBER) { return; } } else if (left.getType() == Token.NUMBER) { return; } } else if (left.getType() == Token.NUMBER) { return; }",
                "patch_diff": "// if (left.getType() == Token.STRING) { Node left = left.getString(); if (right.getType() == Token.NUMBER) { return; } } else if (left.getType() == Token.NUMBER) { return; } } else if (left.getType() == Token.NUMBER) { return; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if (left.getType() == Token.STRING) { Node left = left.getString(); if (right.getType() == Token.NUMBER) { return; } } else if (left.getType() == Token.NUMBER) { Node left = left.getParent(); if (right.getType()!= Token.NUMBER) { return; } } }",
                "patch_diff": "// if (left.getType() == Token.STRING) { Node left = left.getString(); if (right.getType() == Token.NUMBER) { return; } } else if (left.getType() == Token.NUMBER) { Node left = left.getParent(); if (right.getType()!= Token.NUMBER) { return; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// if (left.getType() == Token.STRING) { Node left = left.getString(); if (right.getType() == Token.NUMBER) { return; } } else if (left.getType() == Token.NUMBER) { Node left = left.getParent(); if (right.getType() == Token.NUMBER) { return; } } }",
                "patch_diff": "// if (left.getType() == Token.STRING) { Node left = left.getString(); if (right.getType() == Token.NUMBER) { return; } } else if (left.getType() == Token.NUMBER) { Node left = left.getParent(); if (right.getType() == Token.NUMBER) { return; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// if (left.getType() == Token.NAME) { Node left = left.getString(); if (right.getType() == Token.NUMBER) { return; } } else if (left.getType() == Token.NUMBER) { Node left = left.getParent(); if (right.getType()!= Token.NUMBER) { return; } } }",
                "patch_diff": "// if (left.getType() == Token.NAME) { Node left = left.getString(); if (right.getType() == Token.NUMBER) { return; } } else if (left.getType() == Token.NUMBER) { Node left = left.getParent(); if (right.getType()!= Token.NUMBER) { return; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// if (left.getType() == Token.STRING) { Node left = left.getString(); if (right.getType() == Token.NUMBER) { return; } } else if (left.getType() == Token.NUMBER) { Node left = left.getParent(); if (right.getType() == Token.NUMBER) { return; } }",
                "patch_diff": "// if (left.getType() == Token.STRING) { Node left = left.getString(); if (right.getType() == Token.NUMBER) { return; } } else if (left.getType() == Token.NUMBER) { Node left = left.getParent(); if (right.getType() == Token.NUMBER) { return; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if (left.getType() == Token.NAME) { Node left = left.getString(); if (right.getType() == Token.NUMBER) { return; } } else if (left.getType() == Token.NUMBER) { Node left = left.getParent(); if (right.getType() == Token.NUMBER) { return; } } }",
                "patch_diff": "// if (left.getType() == Token.NAME) { Node left = left.getString(); if (right.getType() == Token.NUMBER) { return; } } else if (left.getType() == Token.NUMBER) { Node left = left.getParent(); if (right.getType() == Token.NUMBER) { return; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (isAssignmentTarget(n)) { return n; }"
    },
    "JacksonDatabind-83": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (cause, ctxt)!= null) { return _deserialize(text, ctxt; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-83/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\t2022-07-19 16:21:51.175449241 +0200\n+++ /tmp/tmp4y3seocc.java\t2022-07-19 16:21:51.215449014 +0200\n@@ -114,13 +114,11 @@\n             Exception cause = null;\n             try {\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n+if (cause, ctxt)!= null) { return _deserialize(text, ctxt; }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n                 cause = me;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (cause, ctxt)!= null) { return _deserialize(text, ctxt); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-83/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\t2022-07-19 16:21:53.491436257 +0200\n+++ /tmp/tmpoy61vjk6.java\t2022-07-19 16:21:53.491436257 +0200\n@@ -114,13 +114,11 @@\n             Exception cause = null;\n             try {\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n+if (cause, ctxt)!= null) { return _deserialize(text, ctxt); }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n                 cause = me;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (_deserialize(jp, ctxt)!= null) { return _deserialize(text, ctxt; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-83/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\t2022-07-19 16:21:55.047427534 +0200\n+++ /tmp/tmpnpmv29xk.java\t2022-07-19 16:21:55.047427534 +0200\n@@ -114,13 +114,11 @@\n             Exception cause = null;\n             try {\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n+if (_deserialize(jp, ctxt)!= null) { return _deserialize(text, ctxt; }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n                 cause = me;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (jp, ctxt)!= null) { return _deserialize(text, ctxt; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-83/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\t2022-07-19 16:21:56.667418444 +0200\n+++ /tmp/tmp_4t84cf1.java\t2022-07-19 16:21:56.671418421 +0200\n@@ -114,13 +114,11 @@\n             Exception cause = null;\n             try {\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n+if (jp, ctxt)!= null) { return _deserialize(text, ctxt; }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n                 cause = me;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (_deserialize(jp, ctxt)!= null) { return _deserialize(text, ctxt); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-83/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\t2022-07-19 16:21:58.259409508 +0200\n+++ /tmp/tmptba5svsu.java\t2022-07-19 16:21:58.259409508 +0200\n@@ -114,13 +114,11 @@\n             Exception cause = null;\n             try {\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n+if (_deserialize(jp, ctxt)!= null) { return _deserialize(text, ctxt); }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n                 cause = me;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (options, ctxt)!= null) { return _deserialize(text, ctxt; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-83/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\t2022-07-19 16:22:00.155398861 +0200\n+++ /tmp/tmphkmfg_1l.java\t2022-07-19 16:22:00.155398861 +0200\n@@ -114,13 +114,11 @@\n             Exception cause = null;\n             try {\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n+if (options, ctxt)!= null) { return _deserialize(text, ctxt; }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n                 cause = me;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (module!= null) { return _deserialize(jp, ctxt, cause); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-83/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\t2022-07-19 16:22:01.771389780 +0200\n+++ /tmp/tmpruox7mwz.java\t2022-07-19 16:22:01.771389780 +0200\n@@ -114,13 +114,11 @@\n             Exception cause = null;\n             try {\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n+if (module!= null) { return _deserialize(jp, ctxt, cause); }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n                 cause = me;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (_deserialize(jp, ctxt)!= null) { return _deserialize(jp, ctxt; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-83/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\t2022-07-19 16:22:03.483380154 +0200\n+++ /tmp/tmp3wboxrw_.java\t2022-07-19 16:22:03.483380154 +0200\n@@ -114,13 +114,11 @@\n             Exception cause = null;\n             try {\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n+if (_deserialize(jp, ctxt)!= null) { return _deserialize(jp, ctxt; }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n                 cause = me;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (options, ctxt)!= null) { return _deserialize(text, ctxt); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-83/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\t2022-07-19 16:22:05.095371091 +0200\n+++ /tmp/tmpn3jjqwna.java\t2022-07-19 16:22:05.095371091 +0200\n@@ -114,13 +114,11 @@\n             Exception cause = null;\n             try {\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n+if (options, ctxt)!= null) { return _deserialize(text, ctxt); }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n                 cause = me;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (jp, ctxt)!= null) { return _deserialize(text, ctxt); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-83/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\t2022-07-19 16:22:06.831361323 +0200\n+++ /tmp/tmpm4jgy2dm.java\t2022-07-19 16:22:06.831361323 +0200\n@@ -114,13 +114,11 @@\n             Exception cause = null;\n             try {\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n+if (jp, ctxt)!= null) { return _deserialize(text, ctxt); }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n                 cause = me;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (_deserialize(text, ctxt) != null) { return _deserialize(text, ctxt); }",
        "fixed_line": ""
    },
    "Closure-38": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (x < 0 && val == '-') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-38/src/com/google/javascript/jscomp/CodeConsumer.java\t2022-07-19 16:22:08.535351729 +0200\n+++ /tmp/tmpiblngy9u.java\t2022-07-19 16:22:08.559351593 +0200\n@@ -240,11 +240,11 @@\n   void addNumber(double x) {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+if (x < 0 && val == '-') {\n       add(\" \");\n     }\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (x >= 0 && prev == '-') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-38/src/com/google/javascript/jscomp/CodeConsumer.java\t2022-07-19 16:22:13.079326129 +0200\n+++ /tmp/tmpk80d4cw3.java\t2022-07-19 16:22:13.079326129 +0200\n@@ -240,11 +240,11 @@\n   void addNumber(double x) {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+if (x >= 0 && prev == '-') {\n       add(\" \");\n     }\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (x < 0 || val == '-') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-38/src/com/google/javascript/jscomp/CodeConsumer.java\t2022-07-19 16:22:53.415097489 +0200\n+++ /tmp/tmplz302zj2.java\t2022-07-19 16:22:53.415097489 +0200\n@@ -240,11 +240,11 @@\n   void addNumber(double x) {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+if (x < 0 || val == '-') {\n       add(\" \");\n     }\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (x < 0 || prev == '-') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-38/src/com/google/javascript/jscomp/CodeConsumer.java\t2022-07-19 16:22:56.891077674 +0200\n+++ /tmp/tmpnf8cpzo8.java\t2022-07-19 16:22:56.895077651 +0200\n@@ -240,11 +240,11 @@\n   void addNumber(double x) {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+if (x < 0 || prev == '-') {\n       add(\" \");\n     }\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (x < 0 || child == '-') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-38/src/com/google/javascript/jscomp/CodeConsumer.java\t2022-07-19 16:23:35.094858774 +0200\n+++ /tmp/tmpx4f6q1ue.java\t2022-07-19 16:23:35.098858751 +0200\n@@ -240,11 +240,11 @@\n   void addNumber(double x) {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+if (x < 0 || child == '-') {\n       add(\" \");\n     }\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (x < 0 || current == '-') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-38/src/com/google/javascript/jscomp/CodeConsumer.java\t2022-07-19 16:23:38.474839312 +0200\n+++ /tmp/tmpup0l6z7h.java\t2022-07-19 16:23:38.474839312 +0200\n@@ -240,11 +240,11 @@\n   void addNumber(double x) {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+if (x < 0 || current == '-') {\n       add(\" \");\n     }\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (x < 0 || x == '-') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-38/src/com/google/javascript/jscomp/CodeConsumer.java\t2022-07-19 16:23:42.166818036 +0200\n+++ /tmp/tmp8hxxg0hp.java\t2022-07-19 16:23:42.170818013 +0200\n@@ -240,11 +240,11 @@\n   void addNumber(double x) {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+if (x < 0 || x == '-') {\n       add(\" \");\n     }\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (x < 0 && val > '-') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-38/src/com/google/javascript/jscomp/CodeConsumer.java\t2022-07-19 16:24:20.666595140 +0200\n+++ /tmp/tmp4exw02hg.java\t2022-07-19 16:24:20.666595140 +0200\n@@ -240,11 +240,11 @@\n   void addNumber(double x) {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+if (x < 0 && val > '-') {\n       add(\" \");\n     }\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (x < 0 && prev == '-') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-38/src/com/google/javascript/jscomp/CodeConsumer.java\t2022-07-19 16:24:24.230574412 +0200\n+++ /tmp/tmpxavqcloi.java\t2022-07-19 16:24:24.230574412 +0200\n@@ -240,11 +240,11 @@\n   void addNumber(double x) {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+if (x < 0 && prev == '-') {\n       add(\" \");\n     }\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (x < 0 || value == '-') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-38/src/com/google/javascript/jscomp/CodeConsumer.java\t2022-07-19 16:25:02.138353028 +0200\n+++ /tmp/tmpyjaoayw8.java\t2022-07-19 16:25:02.138353028 +0200\n@@ -240,11 +240,11 @@\n   void addNumber(double x) {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+if (x < 0 || value == '-') {\n       add(\" \");\n     }\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (x < 0 && prev == '-') {",
        "fixed_line": "if ((x < 0 || negativeZero) && prev == '-') {"
    },
    "Closure-128": {
        "fixes": [
            {
                "k": 1,
                "patch": "return index >= 0 && s.charAt(0)!= '0';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-128/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 16:25:05.738331920 +0200\n+++ /tmp/tmp6v_henwl.java\t2022-07-19 16:25:05.762331779 +0200\n@@ -786,11 +786,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+return index >= 0 && s.charAt(0)!= '0';\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return index >= 0 && s.charAt(0) == '0';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-128/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 16:25:10.826302063 +0200\n+++ /tmp/tmp6gyl0eot.java\t2022-07-19 16:25:10.826302063 +0200\n@@ -786,11 +786,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+return index >= 0 && s.charAt(0) == '0';\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return index > 0 && s.charAt(0)!= '0';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-128/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 16:25:14.474280633 +0200\n+++ /tmp/tmprlgl9tg7.java\t2022-07-19 16:25:14.474280633 +0200\n@@ -786,11 +786,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+return index > 0 && s.charAt(0)!= '0';\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return < 0 || s.charAt(0) == '0';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-128/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 16:25:18.122259196 +0200\n+++ /tmp/tmpbtcq200k.java\t2022-07-19 16:25:18.126259169 +0200\n@@ -786,11 +786,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+return < 0 || s.charAt(0) == '0';\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return index > 0 && s.charAt(0) == '0';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-128/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 16:25:21.538239104 +0200\n+++ /tmp/tmpg6segxve.java\t2022-07-19 16:25:21.538239104 +0200\n@@ -786,11 +786,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+return index > 0 && s.charAt(0) == '0';\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return s > 0 && s.charAt(0) == '0';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-128/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 16:25:25.226217399 +0200\n+++ /tmp/tmpi51ayjii.java\t2022-07-19 16:25:25.230217378 +0200\n@@ -786,11 +786,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+return s > 0 && s.charAt(0) == '0';\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return s >= 0 && s.charAt(0) == '0';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-128/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 16:25:28.842196107 +0200\n+++ /tmp/tmpshawyhuf.java\t2022-07-19 16:25:28.842196107 +0200\n@@ -786,11 +786,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+return s >= 0 && s.charAt(0) == '0';\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return index < 0 && s.charAt(0) == '0';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-128/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 16:25:32.530174375 +0200\n+++ /tmp/tmplby43vx1.java\t2022-07-19 16:25:32.534174349 +0200\n@@ -786,11 +786,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+return index < 0 && s.charAt(0) == '0';\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return index!= 0 && s.charAt(0) == '0';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-128/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 16:25:36.026153761 +0200\n+++ /tmp/tmp5ovnjuxf.java\t2022-07-19 16:25:36.026153761 +0200\n@@ -786,11 +786,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+return index!= 0 && s.charAt(0) == '0';\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return s!= 0 && s.charAt(0) == '0';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-128/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 16:25:39.462133485 +0200\n+++ /tmp/tmphd9ahj1z.java\t2022-07-19 16:25:39.466133464 +0200\n@@ -786,11 +786,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+return s!= 0 && s.charAt(0) == '0';\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return len > 0 && s.charAt(0) != '0';",
        "fixed_line": "if (len == 0) { return false; } for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c < '0' || c > '9') { return false; } } return len == 1 || s.charAt(0) != '0';"
    },
    "Codec-2": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (lineSeparator.length > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-2/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 16:25:43.126111853 +0200\n+++ /tmp/tmpwoxujcpv.java\t2022-07-19 16:25:43.154111688 +0200\n@@ -441,11 +441,11 @@\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buf[pos++] = PAD;\n                     }\n                     break;\n             }\n-            if (lineLength > 0) {\n+if (lineSeparator.length > 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (lineSeparator.length!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-2/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 16:25:46.414092432 +0200\n+++ /tmp/tmpmmx403ok.java\t2022-07-19 16:25:46.414092432 +0200\n@@ -441,11 +441,11 @@\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buf[pos++] = PAD;\n                     }\n                     break;\n             }\n-            if (lineLength > 0) {\n+if (lineSeparator.length!= 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (lineSeparator.length == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-2/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 16:25:48.950077443 +0200\n+++ /tmp/tmpj6lwoqiq.java\t2022-07-19 16:25:48.954077417 +0200\n@@ -441,11 +441,11 @@\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buf[pos++] = PAD;\n                     }\n                     break;\n             }\n-            if (lineLength > 0) {\n+if (lineSeparator.length == 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (lineSeparator.length >= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-2/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 16:25:51.422062826 +0200\n+++ /tmp/tmpxabd7h44.java\t2022-07-19 16:25:51.422062826 +0200\n@@ -441,11 +441,11 @@\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buf[pos++] = PAD;\n                     }\n                     break;\n             }\n-            if (lineLength > 0) {\n+if (lineSeparator.length >= 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (lineSeparator.length < 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-2/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 16:25:53.978047703 +0200\n+++ /tmp/tmpktdlgwlg.java\t2022-07-19 16:25:53.978047703 +0200\n@@ -441,11 +441,11 @@\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buf[pos++] = PAD;\n                     }\n                     break;\n             }\n-            if (lineLength > 0) {\n+if (lineSeparator.length < 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (lineSeparator.length <= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-2/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 16:25:56.514032697 +0200\n+++ /tmp/tmpkihfqsb9.java\t2022-07-19 16:25:56.514032697 +0200\n@@ -441,11 +441,11 @@\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buf[pos++] = PAD;\n                     }\n                     break;\n             }\n-            if (lineLength > 0) {\n+if (lineSeparator.length <= 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (lineSeparator!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-2/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 16:25:59.038017754 +0200\n+++ /tmp/tmpbmjxb7za.java\t2022-07-19 16:25:59.038017754 +0200\n@@ -441,11 +441,11 @@\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buf[pos++] = PAD;\n                     }\n                     break;\n             }\n-            if (lineLength > 0) {\n+if (lineSeparator!= 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (lineSeparator > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-2/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 16:26:00.730007730 +0200\n+++ /tmp/tmpz44i__ai.java\t2022-07-19 16:26:00.730007730 +0200\n@@ -441,11 +441,11 @@\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buf[pos++] = PAD;\n                     }\n                     break;\n             }\n-            if (lineLength > 0) {\n+if (lineSeparator > 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (lineSeparator == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-2/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 16:26:02.409997776 +0200\n+++ /tmp/tmpjach48c5.java\t2022-07-19 16:26:02.409997776 +0200\n@@ -441,11 +441,11 @@\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buf[pos++] = PAD;\n                     }\n                     break;\n             }\n-            if (lineLength > 0) {\n+if (lineSeparator == 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (pos > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-2/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 16:26:04.125987607 +0200\n+++ /tmp/tmp9ex065mr.java\t2022-07-19 16:26:04.125987607 +0200\n@@ -441,11 +441,11 @@\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buf[pos++] = PAD;\n                     }\n                     break;\n             }\n-            if (lineLength > 0) {\n+if (pos > 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (lineLength > 0) {",
        "fixed_line": "if (lineLength > 0 && pos > 0) {"
    },
    "JacksonDatabind-37": {
        "fixes": [
            {
                "k": 1,
                "patch": "return new SimpleType(_class, _superClass, _superClass, _bindings, _typeHandler, _asStatic);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-37/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\t2022-07-19 16:26:06.965970774 +0200\n+++ /tmp/tmpvwe8ctws.java\t2022-07-19 16:26:07.001970561 +0200\n@@ -130,11 +130,11 @@\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n         }\n         */\n         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n-        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n+return new SimpleType(_class, _superClass, _superClass, _bindings, _typeHandler, _asStatic);\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public JavaType withContentType(JavaType contentType) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return new SimpleType(_class, _superClass, _superClass, _valueHandler, _typeHandler, _asStatic);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-37/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\t2022-07-19 16:26:08.873959455 +0200\n+++ /tmp/tmp4k4f1n43.java\t2022-07-19 16:26:08.877959432 +0200\n@@ -130,11 +130,11 @@\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n         }\n         */\n         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n-        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n+return new SimpleType(_class, _superClass, _superClass, _valueHandler, _typeHandler, _asStatic);\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public JavaType withContentType(JavaType contentType) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return new SimpleType(_class, _superClass, _superClass, _bindings, _superClass, _valueHandler, _typeHandler, _asStatic);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-37/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\t2022-07-19 16:26:10.485949892 +0200\n+++ /tmp/tmpss512s04.java\t2022-07-19 16:26:10.485949892 +0200\n@@ -130,11 +130,11 @@\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n         }\n         */\n         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n-        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n+return new SimpleType(_class, _superClass, _superClass, _bindings, _superClass, _valueHandler, _typeHandler, _asStatic);\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public JavaType withContentType(JavaType contentType) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return new SimpleType(subclass, _superClass, _superClass, _bindings, _typeHandler, _asStatic);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-37/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\t2022-07-19 16:26:12.073940469 +0200\n+++ /tmp/tmp8gcc4wgb.java\t2022-07-19 16:26:12.077940444 +0200\n@@ -130,11 +130,11 @@\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n         }\n         */\n         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n-        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n+return new SimpleType(subclass, _superClass, _superClass, _bindings, _typeHandler, _asStatic);\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public JavaType withContentType(JavaType contentType) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return new SimpleType(subclass, _superClass, _superClass, _valueHandler, _typeHandler, _asStatic);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-37/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\t2022-07-19 16:26:13.653931091 +0200\n+++ /tmp/tmpk4nrby3o.java\t2022-07-19 16:26:13.653931091 +0200\n@@ -130,11 +130,11 @@\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n         }\n         */\n         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n-        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n+return new SimpleType(subclass, _superClass, _superClass, _valueHandler, _typeHandler, _asStatic);\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public JavaType withContentType(JavaType contentType) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return new SimpleType(_class, _superClass, _superClass, _valueHandler, _typeHandler,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-37/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\t2022-07-19 16:26:15.253921590 +0200\n+++ /tmp/tmp_j0p1s5k.java\t2022-07-19 16:26:15.257921567 +0200\n@@ -130,11 +130,11 @@\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n         }\n         */\n         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n-        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n+return new SimpleType(_class, _superClass, _superClass, _valueHandler, _typeHandler,\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public JavaType withContentType(JavaType contentType) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return new SimpleType(subclass, _superClass, _superClass, _valueHandler, _typeHandler,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-37/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\t2022-07-19 16:26:17.021911092 +0200\n+++ /tmp/tmp1fgi79cr.java\t2022-07-19 16:26:17.025911067 +0200\n@@ -130,11 +130,11 @@\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n         }\n         */\n         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n-        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n+return new SimpleType(subclass, _superClass, _superClass, _valueHandler, _typeHandler,\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public JavaType withContentType(JavaType contentType) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return new SimpleType(_class, _superClass, _superClass, _typeHandler, _asStatic);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-37/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\t2022-07-19 16:26:18.801900517 +0200\n+++ /tmp/tmpfk6wjxpe.java\t2022-07-19 16:26:18.801900517 +0200\n@@ -130,11 +130,11 @@\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n         }\n         */\n         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n-        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n+return new SimpleType(_class, _superClass, _superClass, _typeHandler, _asStatic);\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public JavaType withContentType(JavaType contentType) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return new SimpleType(_class, _superClass, _superClass, _valueHandler,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-37/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\t2022-07-19 16:26:20.449890725 +0200\n+++ /tmp/tmpal4ihvqr.java\t2022-07-19 16:26:20.449890725 +0200\n@@ -130,11 +130,11 @@\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n         }\n         */\n         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n-        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n+return new SimpleType(_class, _superClass, _superClass, _valueHandler,\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public JavaType withContentType(JavaType contentType) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return new SimpleType(_class, _superClass, _superClass, _bindings, _superClass, _bindings, _typeHandler, _asStatic);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-37/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\t2022-07-19 16:26:22.157880572 +0200\n+++ /tmp/tmppxd0_9wo.java\t2022-07-19 16:26:22.157880572 +0200\n@@ -130,11 +130,11 @@\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n         }\n         */\n         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n-        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n+return new SimpleType(_class, _superClass, _superClass, _bindings, _superClass, _bindings, _typeHandler, _asStatic);\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public JavaType withContentType(JavaType contentType) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,",
        "fixed_line": "return new SimpleType(subclass, _bindings, this, _superInterfaces,"
    },
    "Collections-27": {
        "fixes": [
            {
                "k": 1,
                "patch": "throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); }",
                "patch_diff": "throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} catch (final Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } }",
                "patch_diff": "} catch (final Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} catch (final Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); }",
                "patch_diff": "} catch (final Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} catch (final Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } }",
                "patch_diff": "} catch (final Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } }",
                "patch_diff": "} catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} catch (final Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (final Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } }",
                "patch_diff": "} catch (final Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (final Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } }",
                "patch_diff": "// } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} catch (final Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); }",
                "patch_diff": "} catch (final Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); }",
                "patch_diff": "// } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} catch (final Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception e) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } }",
                "patch_diff": "} catch (final Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception e) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "private void readObject(ObjectInputStream is) throws IOException, ClassNotFoundException { is.defaultReadObject(); // ensure that the de-serialized class is a Collection, COLLECTIONS-580 if (clazz != null && !Collection.class.isAssignableFrom(clazz)) { throw new UnsupportedOperationException(); } }"
    },
    "Mockito-24": {
        "fixes": [
            {
                "k": 1,
                "patch": "return JsonToken.VALUE_NUMBER_INT; // let's do implicit re-closed",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-24/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\t2022-07-19 16:26:25.829858740 +0200\n+++ /tmp/tmptk4x6jea.java\t2022-07-19 16:26:25.873858477 +0200\n@@ -71,11 +71,11 @@\n             }\n         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+return JsonToken.VALUE_NUMBER_INT; // let's do implicit re-closed\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n         return returnValueFor(returnType);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return JsonToken.VALUE_NUMBER_INT; // let's do implicit re-literals",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-24/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\t2022-07-19 16:26:32.461819272 +0200\n+++ /tmp/tmpg1pii2qz.java\t2022-07-19 16:26:32.461819272 +0200\n@@ -71,11 +71,11 @@\n             }\n         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+return JsonToken.VALUE_NUMBER_INT; // let's do implicit re-literals\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n         return returnValueFor(returnType);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return 0; // let's do implicit re-initialized or EMPTY",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-24/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\t2022-07-19 16:26:35.221802834 +0200\n+++ /tmp/tmp9duju_03.java\t2022-07-19 16:26:35.221802834 +0200\n@@ -71,11 +71,11 @@\n             }\n         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+return 0; // let's do implicit re-initialized or EMPTY\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n         return returnValueFor(returnType);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return JsonToken.VALUE_NUMBER_INT;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-24/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\t2022-07-19 16:27:12.397580752 +0200\n+++ /tmp/tmp02fhgvbt.java\t2022-07-19 16:27:12.397580752 +0200\n@@ -71,11 +71,11 @@\n             }\n         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+return JsonToken.VALUE_NUMBER_INT;\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n         return returnValueFor(returnType);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return 0; // let's do implicit re-closed",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-24/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\t2022-07-19 16:27:15.009565102 +0200\n+++ /tmp/tmpsvs3_jvv.java\t2022-07-19 16:27:15.009565102 +0200\n@@ -71,11 +71,11 @@\n             }\n         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+return 0; // let's do implicit re-closed\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n         return returnValueFor(returnType);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return 0; // let's do implicit re-returnType",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-24/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\t2022-07-19 16:27:49.249359423 +0200\n+++ /tmp/tmp4t9kkv9y.java\t2022-07-19 16:27:49.249359423 +0200\n@@ -71,11 +71,11 @@\n             }\n         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+return 0; // let's do implicit re-returnType\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n         return returnValueFor(returnType);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return 0; // let's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-24/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\t2022-07-19 16:28:23.669151709 +0200\n+++ /tmp/tmp_z8kp9nk.java\t2022-07-19 16:28:23.669151709 +0200\n@@ -71,11 +71,11 @@\n             }\n         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+return 0; // let's do implicit re-parse\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n         return returnValueFor(returnType);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return JsonToken.VALUE_NUMBER_INT; // let's do implicit re-initialized or EMPTY",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-24/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\t2022-07-19 16:28:57.980943759 +0200\n+++ /tmp/tmphnhxxwx9.java\t2022-07-19 16:28:57.980943759 +0200\n@@ -71,11 +71,11 @@\n             }\n         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+return JsonToken.VALUE_NUMBER_INT; // let's do implicit re-initialized or EMPTY\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n         return returnValueFor(returnType);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return JsonToken.VALUE_NUMBER_INT; // let's do implicit re-returnType",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-24/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\t2022-07-19 16:29:00.652927529 +0200\n+++ /tmp/tmprazicbws.java\t2022-07-19 16:29:00.652927529 +0200\n@@ -71,11 +71,11 @@\n             }\n         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+return JsonToken.VALUE_NUMBER_INT; // let's do implicit re-returnType\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n         return returnValueFor(returnType);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return 0; // let's do implicit rereturnType",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-24/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\t2022-07-19 16:29:03.308911393 +0200\n+++ /tmp/tmp7ku2awns.java\t2022-07-19 16:29:03.312911368 +0200\n@@ -71,11 +71,11 @@\n             }\n         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+return 0; // let's do implicit rereturnType\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n         return returnValueFor(returnType);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return 1;",
        "fixed_line": "return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;"
    },
    "Math-59": {
        "fixes": [
            {
                "k": 1,
                "patch": "return (a < b)? a : (Float.isNaN(b + b)? Float.NaN : b;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-59/src/main/java/org/apache/commons/math/util/FastMath.java\t2022-07-19 16:29:38.152699241 +0200\n+++ /tmp/tmpcfz4kzz3.java\t2022-07-19 16:29:38.180699070 +0200\n@@ -3477,11 +3477,11 @@\n      * @param a first value\n      * @param b second value\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+return (a < b)? a : (Float.isNaN(b + b)? Float.NaN : b;\n     }\n \n     /** Compute the maximum of two values\n      * @param a first value\n      * @param b second value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return (a < b)? b : (Float.isNaN(b + b)? Float.NaN : b;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-59/src/main/java/org/apache/commons/math/util/FastMath.java\t2022-07-19 16:29:40.568684501 +0200\n+++ /tmp/tmpzq0fjeyk.java\t2022-07-19 16:29:40.572684477 +0200\n@@ -3477,11 +3477,11 @@\n      * @param a first value\n      * @param b second value\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+return (a < b)? b : (Float.isNaN(b + b)? Float.NaN : b;\n     }\n \n     /** Compute the maximum of two values\n      * @param a first value\n      * @param b second value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return (a < b)? a : (Float.isNaN(b + a)? Float.NaN : b;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-59/src/main/java/org/apache/commons/math/util/FastMath.java\t2022-07-19 16:29:42.712671418 +0200\n+++ /tmp/tmp3r6figfo.java\t2022-07-19 16:29:42.716671393 +0200\n@@ -3477,11 +3477,11 @@\n      * @param a first value\n      * @param b second value\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+return (a < b)? a : (Float.isNaN(b + a)? Float.NaN : b;\n     }\n \n     /** Compute the maximum of two values\n      * @param a first value\n      * @param b second value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return (a == b)? a : (Float.isNaN(b + b)? Float.NaN : b;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-59/src/main/java/org/apache/commons/math/util/FastMath.java\t2022-07-19 16:29:44.728659112 +0200\n+++ /tmp/tmpfnmdjrk2.java\t2022-07-19 16:29:44.732659087 +0200\n@@ -3477,11 +3477,11 @@\n      * @param a first value\n      * @param b second value\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+return (a == b)? a : (Float.isNaN(b + b)? Float.NaN : b;\n     }\n \n     /** Compute the maximum of two values\n      * @param a first value\n      * @param b second value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return (a < b)? b : (Float.isNaN(b + a)? Float.NaN : b;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-59/src/main/java/org/apache/commons/math/util/FastMath.java\t2022-07-19 16:29:46.764646683 +0200\n+++ /tmp/tmpayho8gd9.java\t2022-07-19 16:29:46.764646683 +0200\n@@ -3477,11 +3477,11 @@\n      * @param a first value\n      * @param b second value\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+return (a < b)? b : (Float.isNaN(b + a)? Float.NaN : b;\n     }\n \n     /** Compute the maximum of two values\n      * @param a first value\n      * @param b second value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return (a == b)? a : (Float.isNaN(b + a)? Float.NaN : b;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-59/src/main/java/org/apache/commons/math/util/FastMath.java\t2022-07-19 16:29:48.860633884 +0200\n+++ /tmp/tmpzo89zmjy.java\t2022-07-19 16:29:48.860633884 +0200\n@@ -3477,11 +3477,11 @@\n      * @param a first value\n      * @param b second value\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+return (a == b)? a : (Float.isNaN(b + a)? Float.NaN : b;\n     }\n \n     /** Compute the maximum of two values\n      * @param a first value\n      * @param b second value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return (a == b)? b : (Float.isNaN(b + b)? Float.NaN : b;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-59/src/main/java/org/apache/commons/math/util/FastMath.java\t2022-07-19 16:29:50.828621864 +0200\n+++ /tmp/tmpb3i3wdk7.java\t2022-07-19 16:29:50.828621864 +0200\n@@ -3477,11 +3477,11 @@\n      * @param a first value\n      * @param b second value\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+return (a == b)? b : (Float.isNaN(b + b)? Float.NaN : b;\n     }\n \n     /** Compute the maximum of two values\n      * @param a first value\n      * @param b second value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return (a == b)? b : (Float.isNaN(b + a)? Float.NaN : b;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-59/src/main/java/org/apache/commons/math/util/FastMath.java\t2022-07-19 16:29:52.872609376 +0200\n+++ /tmp/tmpf0_xdmhp.java\t2022-07-19 16:29:52.876609352 +0200\n@@ -3477,11 +3477,11 @@\n      * @param a first value\n      * @param b second value\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+return (a == b)? b : (Float.isNaN(b + a)? Float.NaN : b;\n     }\n \n     /** Compute the maximum of two values\n      * @param a first value\n      * @param b second value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return (a == b)? a : (Float.isNaN(a + b)? Float.NaN : b;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-59/src/main/java/org/apache/commons/math/util/FastMath.java\t2022-07-19 16:29:54.872597157 +0200\n+++ /tmp/tmpsymmpgpf.java\t2022-07-19 16:29:54.876597132 +0200\n@@ -3477,11 +3477,11 @@\n      * @param a first value\n      * @param b second value\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+return (a == b)? a : (Float.isNaN(a + b)? Float.NaN : b;\n     }\n \n     /** Compute the maximum of two values\n      * @param a first value\n      * @param b second value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return (a == b)? b : (Float.isNaN(a + b)? Float.NaN : b;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-59/src/main/java/org/apache/commons/math/util/FastMath.java\t2022-07-19 16:29:56.924584615 +0200\n+++ /tmp/tmp1y_cuq6q.java\t2022-07-19 16:29:56.928584589 +0200\n@@ -3477,11 +3477,11 @@\n      * @param a first value\n      * @param b second value\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+return (a == b)? b : (Float.isNaN(a + b)? Float.NaN : b;\n     }\n \n     /** Compute the maximum of two values\n      * @param a first value\n      * @param b second value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);",
        "fixed_line": "return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);"
    },
    "Cli-29": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (str.startsWith(\"\\\"\\\" str = str.substring(1, length = str.length - 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-29/src/java/org/apache/commons/cli/Util.java\t2022-07-19 16:29:59.152570993 +0200\n+++ /tmp/tmpmg1q8mnw.java\t2022-07-19 16:29:59.232570506 +0200\n@@ -60,18 +60,11 @@\n      *\n      * @return The string without the leading and trailing quotes.\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n-        if (str.startsWith(\"\\\"\"))\n-        {\n-            str = str.substring(1, str.length());\n-        }\n-        int length = str.length();\n-        if (str.endsWith(\"\\\"\"))\n-        {\n-            str = str.substring(0, length - 1);\n+if (str.startsWith(\"\\\"\\\" str = str.substring(1, length = str.length - 1);\n         }\n         \n         return str;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (str.startsWith(\"\\\"\", str = str.length()); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-29/src/java/org/apache/commons/cli/Util.java\t2022-07-19 16:30:00.980559817 +0200\n+++ /tmp/tmpasa1twda.java\t2022-07-19 16:30:00.980559817 +0200\n@@ -60,18 +60,11 @@\n      *\n      * @return The string without the leading and trailing quotes.\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n-        if (str.startsWith(\"\\\"\"))\n-        {\n-            str = str.substring(1, str.length());\n-        }\n-        int length = str.length();\n-        if (str.endsWith(\"\\\"\"))\n-        {\n-            str = str.substring(0, length - 1);\n+if (str.startsWith(\"\\\"\", str = str.length()); }\n         }\n         \n         return str;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (str.startsWith(\"\\\"\\\" str = str; } else if (length > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-29/src/java/org/apache/commons/cli/Util.java\t2022-07-19 16:30:02.456550792 +0200\n+++ /tmp/tmp4z1f612u.java\t2022-07-19 16:30:02.456550792 +0200\n@@ -60,18 +60,11 @@\n      *\n      * @return The string without the leading and trailing quotes.\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n-        if (str.startsWith(\"\\\"\"))\n-        {\n-            str = str.substring(1, str.length());\n-        }\n-        int length = str.length();\n-        if (str.endsWith(\"\\\"\"))\n-        {\n-            str = str.substring(0, length - 1);\n+if (str.startsWith(\"\\\"\\\" str = str; } else if (length > 0) {\n         }\n         \n         return str;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (str.startsWith(\"\\\"\", str = str; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-29/src/java/org/apache/commons/cli/Util.java\t2022-07-19 16:30:03.924541814 +0200\n+++ /tmp/tmpq366t8_y.java\t2022-07-19 16:30:03.924541814 +0200\n@@ -60,18 +60,11 @@\n      *\n      * @return The string without the leading and trailing quotes.\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n-        if (str.startsWith(\"\\\"\"))\n-        {\n-            str = str.substring(1, str.length());\n-        }\n-        int length = str.length();\n-        if (str.endsWith(\"\\\"\"))\n-        {\n-            str = str.substring(0, length - 1);\n+if (str.startsWith(\"\\\"\", str = str; }\n         }\n         \n         return str;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (str.startsWith(\"\\\"\")) { str = str.substring(1, length = str.length - 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-29/src/java/org/apache/commons/cli/Util.java\t2022-07-19 16:30:05.348533104 +0200\n+++ /tmp/tmp3qertfv6.java\t2022-07-19 16:30:05.348533104 +0200\n@@ -60,18 +60,11 @@\n      *\n      * @return The string without the leading and trailing quotes.\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n-        if (str.startsWith(\"\\\"\"))\n-        {\n-            str = str.substring(1, str.length());\n-        }\n-        int length = str.length();\n-        if (str.endsWith(\"\\\"\"))\n-        {\n-            str = str.substring(0, length - 1);\n+if (str.startsWith(\"\\\"\")) { str = str.substring(1, length = str.length - 1);\n         }\n         \n         return str;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (str.startsWith(\"\\\"\\\" str = str; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-29/src/java/org/apache/commons/cli/Util.java\t2022-07-19 16:30:06.936523389 +0200\n+++ /tmp/tmpa3nelct7.java\t2022-07-19 16:30:06.936523389 +0200\n@@ -60,18 +60,11 @@\n      *\n      * @return The string without the leading and trailing quotes.\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n-        if (str.startsWith(\"\\\"\"))\n-        {\n-            str = str.substring(1, str.length());\n-        }\n-        int length = str.length();\n-        if (str.endsWith(\"\\\"\"))\n-        {\n-            str = str.substring(0, length - 1);\n+if (str.startsWith(\"\\\"\\\" str = str; }\n         }\n         \n         return str;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (str.startsWith(\"\\\"\")) { str = str; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-29/src/java/org/apache/commons/cli/Util.java\t2022-07-19 16:30:08.360514675 +0200\n+++ /tmp/tmpq2yry2i1.java\t2022-07-19 16:30:08.360514675 +0200\n@@ -60,18 +60,11 @@\n      *\n      * @return The string without the leading and trailing quotes.\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n-        if (str.startsWith(\"\\\"\"))\n-        {\n-            str = str.substring(1, str.length());\n-        }\n-        int length = str.length();\n-        if (str.endsWith(\"\\\"\"))\n-        {\n-            str = str.substring(0, length - 1);\n+if (str.startsWith(\"\\\"\")) { str = str; }\n         }\n         \n         return str;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (str.startsWith(\"\\\"\")) { str = str.length()); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-29/src/java/org/apache/commons/cli/Util.java\t2022-07-19 16:30:09.816505764 +0200\n+++ /tmp/tmpfc24abn6.java\t2022-07-19 16:30:09.816505764 +0200\n@@ -60,18 +60,11 @@\n      *\n      * @return The string without the leading and trailing quotes.\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n-        if (str.startsWith(\"\\\"\"))\n-        {\n-            str = str.substring(1, str.length());\n-        }\n-        int length = str.length();\n-        if (str.endsWith(\"\\\"\"))\n-        {\n-            str = str.substring(0, length - 1);\n+if (str.startsWith(\"\\\"\")) { str = str.length()); }\n         }\n         \n         return str;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (str.startsWith(\"\\\"\\\" str = str.substring(1, length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-29/src/java/org/apache/commons/cli/Util.java\t2022-07-19 16:30:11.292496729 +0200\n+++ /tmp/tmpcdg_7orv.java\t2022-07-19 16:30:11.292496729 +0200\n@@ -60,18 +60,11 @@\n      *\n      * @return The string without the leading and trailing quotes.\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n-        if (str.startsWith(\"\\\"\"))\n-        {\n-            str = str.substring(1, str.length());\n-        }\n-        int length = str.length();\n-        if (str.endsWith(\"\\\"\"))\n-        {\n-            str = str.substring(0, length - 1);\n+if (str.startsWith(\"\\\"\\\" str = str.substring(1, length) {\n         }\n         \n         return str;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (str.startsWith(\"\\\"\\\"\", str = str.length()); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-29/src/java/org/apache/commons/cli/Util.java\t2022-07-19 16:30:12.808487450 +0200\n+++ /tmp/tmpwjn6j6ti.java\t2022-07-19 16:30:12.808487450 +0200\n@@ -60,18 +60,11 @@\n      *\n      * @return The string without the leading and trailing quotes.\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n-        if (str.startsWith(\"\\\"\"))\n-        {\n-            str = str.substring(1, str.length());\n-        }\n-        int length = str.length();\n-        if (str.endsWith(\"\\\"\"))\n-        {\n-            str = str.substring(0, length - 1);\n+if (str.startsWith(\"\\\"\\\"\", str = str.length()); }\n         }\n         \n         return str;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (str.startsWith(\"\\\"\")) { str = str.substring(1, str.length()); } int length = str.length(); if (str.endsWith(\"\\\"\")) { str = str.substring(0, length - 1);",
        "fixed_line": "if (length > 1 && str.startsWith(\"\\\"\") && str.endsWith(\"\\\"\") && str.substring(1, length - 1).indexOf('\"') == -1) { str = str.substring(1, length - 1);"
    },
    "JxPath-6": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (l instanceof InitialContext || l instanceof SelfContext || l).getSingleNodePointer) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-6/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\t2022-07-19 16:30:14.584476577 +0200\n+++ /tmp/tmplx95p994.java\t2022-07-19 16:30:14.628476311 +0200\n@@ -52,15 +52,11 @@\n \n //        System.err.println(\"COMPARING: \" +\n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext || l instanceof SelfContext) {\n-            l = ((EvalContext) l).getSingleNodePointer();\n-        }\n-\n-        if (r instanceof InitialContext || r instanceof SelfContext) {\n+if (l instanceof InitialContext || l instanceof SelfContext || l).getSingleNodePointer) {\n             r = ((EvalContext) r).getSingleNodePointer();\n         }\n \n         if (l instanceof Collection) {\n             l = ((Collection) l).iterator();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (l instanceof InitialContext || l instanceof SelfContext? l : r instanceof SelfContext? l = ((EvalContext) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-6/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\t2022-07-19 16:30:16.800463006 +0200\n+++ /tmp/tmpo_uk7xcw.java\t2022-07-19 16:30:16.800463006 +0200\n@@ -52,15 +52,11 @@\n \n //        System.err.println(\"COMPARING: \" +\n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext || l instanceof SelfContext) {\n-            l = ((EvalContext) l).getSingleNodePointer();\n-        }\n-\n-        if (r instanceof InitialContext || r instanceof SelfContext) {\n+if (l instanceof InitialContext || l instanceof SelfContext? l : r instanceof SelfContext? l = ((EvalContext) {\n             r = ((EvalContext) r).getSingleNodePointer();\n         }\n \n         if (l instanceof Collection) {\n             l = ((Collection) l).iterator();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (l instanceof InitialContext || l instanceof SelfContext? l : r instanceof SelfContext) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-6/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\t2022-07-19 16:30:18.264454040 +0200\n+++ /tmp/tmps3s9kj51.java\t2022-07-19 16:30:18.300453818 +0200\n@@ -52,15 +52,11 @@\n \n //        System.err.println(\"COMPARING: \" +\n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext || l instanceof SelfContext) {\n-            l = ((EvalContext) l).getSingleNodePointer();\n-        }\n-\n-        if (r instanceof InitialContext || r instanceof SelfContext) {\n+if (l instanceof InitialContext || l instanceof SelfContext? l : r instanceof SelfContext) {\n             r = ((EvalContext) r).getSingleNodePointer();\n         }\n \n         if (l instanceof Collection) {\n             l = ((Collection) l).iterator();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (l instanceof InitialContext || l instanceof SelfContext || l instanceof SelfContext? l = ((EvalContext) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-6/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\t2022-07-19 16:30:20.164442400 +0200\n+++ /tmp/tmpmyvjug_u.java\t2022-07-19 16:30:20.164442400 +0200\n@@ -52,15 +52,11 @@\n \n //        System.err.println(\"COMPARING: \" +\n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext || l instanceof SelfContext) {\n-            l = ((EvalContext) l).getSingleNodePointer();\n-        }\n-\n-        if (r instanceof InitialContext || r instanceof SelfContext) {\n+if (l instanceof InitialContext || l instanceof SelfContext || l instanceof SelfContext? l = ((EvalContext) {\n             r = ((EvalContext) r).getSingleNodePointer();\n         }\n \n         if (l instanceof Collection) {\n             l = ((Collection) l).iterator();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (l instanceof InitialContext || r instanceof SelfContext? l = ((EvalContext) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-6/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\t2022-07-19 16:30:21.712432916 +0200\n+++ /tmp/tmpgovtt9k7.java\t2022-07-19 16:30:21.716432891 +0200\n@@ -52,15 +52,11 @@\n \n //        System.err.println(\"COMPARING: \" +\n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext || l instanceof SelfContext) {\n-            l = ((EvalContext) l).getSingleNodePointer();\n-        }\n-\n-        if (r instanceof InitialContext || r instanceof SelfContext) {\n+if (l instanceof InitialContext || r instanceof SelfContext? l = ((EvalContext) {\n             r = ((EvalContext) r).getSingleNodePointer();\n         }\n \n         if (l instanceof Collection) {\n             l = ((Collection) l).iterator();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (l instanceof InitialContext || l instanceof SelfContext? l : r.getSingleNodePointer;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-6/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\t2022-07-19 16:30:23.204423774 +0200\n+++ /tmp/tmp5877l_o8.java\t2022-07-19 16:30:23.208423749 +0200\n@@ -52,15 +52,11 @@\n \n //        System.err.println(\"COMPARING: \" +\n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext || l instanceof SelfContext) {\n-            l = ((EvalContext) l).getSingleNodePointer();\n-        }\n-\n-        if (r instanceof InitialContext || r instanceof SelfContext) {\n+if (l instanceof InitialContext || l instanceof SelfContext? l : r.getSingleNodePointer;\n             r = ((EvalContext) r).getSingleNodePointer();\n         }\n \n         if (l instanceof Collection) {\n             l = ((Collection) l).iterator();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (l instanceof InitialContext || l instanceof SelfContext || l instanceof SelfContext? l : r instanceof SelfContext) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-6/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\t2022-07-19 16:30:24.760414237 +0200\n+++ /tmp/tmpdg2byuhp.java\t2022-07-19 16:30:24.760414237 +0200\n@@ -52,15 +52,11 @@\n \n //        System.err.println(\"COMPARING: \" +\n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext || l instanceof SelfContext) {\n-            l = ((EvalContext) l).getSingleNodePointer();\n-        }\n-\n-        if (r instanceof InitialContext || r instanceof SelfContext) {\n+if (l instanceof InitialContext || l instanceof SelfContext || l instanceof SelfContext? l : r instanceof SelfContext) {\n             r = ((EvalContext) r).getSingleNodePointer();\n         }\n \n         if (l instanceof Collection) {\n             l = ((Collection) l).iterator();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (l instanceof InitialContext || l instanceof SelfContext? l = ((EvalContext) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-6/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\t2022-07-19 16:30:26.416404086 +0200\n+++ /tmp/tmpno41seuk.java\t2022-07-19 16:30:26.436403964 +0200\n@@ -52,15 +52,11 @@\n \n //        System.err.println(\"COMPARING: \" +\n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext || l instanceof SelfContext) {\n-            l = ((EvalContext) l).getSingleNodePointer();\n-        }\n-\n-        if (r instanceof InitialContext || r instanceof SelfContext) {\n+if (l instanceof InitialContext || l instanceof SelfContext? l = ((EvalContext) {\n             r = ((EvalContext) r).getSingleNodePointer();\n         }\n \n         if (l instanceof Collection) {\n             l = ((Collection) l).iterator();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (l instanceof InitialContext || l instanceof SelfContext || l instanceof SelfContext? l : r instanceof SelfContext? l = ((EvalContext) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-6/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\t2022-07-19 16:30:28.032394178 +0200\n+++ /tmp/tmp290ordey.java\t2022-07-19 16:30:28.036394154 +0200\n@@ -52,15 +52,11 @@\n \n //        System.err.println(\"COMPARING: \" +\n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext || l instanceof SelfContext) {\n-            l = ((EvalContext) l).getSingleNodePointer();\n-        }\n-\n-        if (r instanceof InitialContext || r instanceof SelfContext) {\n+if (l instanceof InitialContext || l instanceof SelfContext || l instanceof SelfContext? l : r instanceof SelfContext? l = ((EvalContext) {\n             r = ((EvalContext) r).getSingleNodePointer();\n         }\n \n         if (l instanceof Collection) {\n             l = ((Collection) l).iterator();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (l instanceof InitialContext || l instanceof SelfContext || l instanceof SelfContext) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-6/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\t2022-07-19 16:30:29.660384197 +0200\n+++ /tmp/tmp7teul0vd.java\t2022-07-19 16:30:29.660384197 +0200\n@@ -52,15 +52,11 @@\n \n //        System.err.println(\"COMPARING: \" +\n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext || l instanceof SelfContext) {\n-            l = ((EvalContext) l).getSingleNodePointer();\n-        }\n-\n-        if (r instanceof InitialContext || r instanceof SelfContext) {\n+if (l instanceof InitialContext || l instanceof SelfContext || l instanceof SelfContext) {\n             r = ((EvalContext) r).getSingleNodePointer();\n         }\n \n         if (l instanceof Collection) {\n             l = ((Collection) l).iterator();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (l instanceof InitialContext || l instanceof SelfContext) { l = ((EvalContext) l).getSingleNodePointer(); } if (r instanceof InitialContext || r instanceof SelfContext) {",
        "fixed_line": "if (l instanceof InitialContext) { ((EvalContext) l).reset(); } if (l instanceof SelfContext) { l = ((EvalContext) l).getSingleNodePointer(); } if (r instanceof InitialContext) { ((EvalContext) r).reset(); } if (r instanceof SelfContext) {"
    },
    "Closure-24": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (gramps.isVar && n.hasChildren) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-24/src/com/google/javascript/jscomp/ScopedAliases.java\t2022-07-19 16:30:34.748352989 +0200\n+++ /tmp/tmpayx1kuqa.java\t2022-07-19 16:30:34.816352571 +0200\n@@ -273,28 +273,11 @@\n       Scope scope = t.getScope();\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-        }\n-        }\n+if (gramps.isVar && n.hasChildren) {\n       }\n     }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (var.isVar && n.hasChildren) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-24/src/com/google/javascript/jscomp/ScopedAliases.java\t2022-07-19 16:30:39.632323018 +0200\n+++ /tmp/tmph0weq9z9.java\t2022-07-19 16:30:39.636322993 +0200\n@@ -273,28 +273,11 @@\n       Scope scope = t.getScope();\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-        }\n-        }\n+if (var.isVar && n.hasChildren) {\n       }\n     }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (var.isVar; n.hasChildren) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-24/src/com/google/javascript/jscomp/ScopedAliases.java\t2022-07-19 16:30:43.184301212 +0200\n+++ /tmp/tmp82z1uu7w.java\t2022-07-19 16:30:43.184301212 +0200\n@@ -273,28 +273,11 @@\n       Scope scope = t.getScope();\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-        }\n-        }\n+if (var.isVar; n.hasChildren) {\n       }\n     }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (parent.isVar && n.hasChildren) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-24/src/com/google/javascript/jscomp/ScopedAliases.java\t2022-07-19 16:30:46.512280774 +0200\n+++ /tmp/tmppixhpay3.java\t2022-07-19 16:30:46.512280774 +0200\n@@ -273,28 +273,11 @@\n       Scope scope = t.getScope();\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-        }\n-        }\n+if (parent.isVar && n.hasChildren) {\n       }\n     }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (nots.isVar && n.hasChildren) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-24/src/com/google/javascript/jscomp/ScopedAliases.java\t2022-07-19 16:30:50.024259202 +0200\n+++ /tmp/tmpsb6j_2by.java\t2022-07-19 16:30:50.024259202 +0200\n@@ -273,28 +273,11 @@\n       Scope scope = t.getScope();\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-        }\n-        }\n+if (nots.isVar && n.hasChildren) {\n       }\n     }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (parent.isVar; n.hasChildren) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-24/src/com/google/javascript/jscomp/ScopedAliases.java\t2022-07-19 16:30:53.448238161 +0200\n+++ /tmp/tmpkz71rvet.java\t2022-07-19 16:30:53.448238161 +0200\n@@ -273,28 +273,11 @@\n       Scope scope = t.getScope();\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-        }\n-        }\n+if (parent.isVar; n.hasChildren) {\n       }\n     }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (var.isVar()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-24/src/com/google/javascript/jscomp/ScopedAliases.java\t2022-07-19 16:30:57.300214483 +0200\n+++ /tmp/tmpvr4yasx5.java\t2022-07-19 16:30:57.300214483 +0200\n@@ -273,28 +273,11 @@\n       Scope scope = t.getScope();\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-        }\n-        }\n+if (var.isVar()) {\n       }\n     }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (scope.isVar && n.hasChildren) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-24/src/com/google/javascript/jscomp/ScopedAliases.java\t2022-07-19 16:31:02.032185385 +0200\n+++ /tmp/tmp4pj13hf0.java\t2022-07-19 16:31:02.040185336 +0200\n@@ -273,28 +273,11 @@\n       Scope scope = t.getScope();\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-        }\n-        }\n+if (scope.isVar && n.hasChildren) {\n       }\n     }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (gramps.isVar;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-24/src/com/google/javascript/jscomp/ScopedAliases.java\t2022-07-19 16:31:07.700150513 +0200\n+++ /tmp/tmpd_7ir5_s.java\t2022-07-19 16:31:07.804149875 +0200\n@@ -273,28 +273,11 @@\n       Scope scope = t.getScope();\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-        }\n-        }\n+if (gramps.isVar;\n       }\n     }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (parent.isVar()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-24/src/com/google/javascript/jscomp/ScopedAliases.java\t2022-07-19 16:31:13.160116907 +0200\n+++ /tmp/tmpkz5r4ir5.java\t2022-07-19 16:31:13.252116342 +0200\n@@ -273,28 +273,11 @@\n       Scope scope = t.getScope();\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-        }\n-        }\n+if (parent.isVar()) {\n       }\n     }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (parent.isVar()) { if (n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = scope.getVar(name); aliases.put(name, aliasVar); String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); // Bleeding functions already get a BAD_PARAMETERS error, so just // do nothing. // Parameters of the scope function also get a BAD_PARAMETERS // error. } else { // TODO(robbyw): Support using locals for private variables. report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } }",
        "fixed_line": "if (parent.isVar() && n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = scope.getVar(name); aliases.put(name, aliasVar); String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); } else if (v.isBleedingFunction()) { // Bleeding functions already get a BAD_PARAMETERS error, so just // do nothing. } else if (parent.getType() == Token.LP) {"
    },
    "Lang-18": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (tokenLen == 2) { rule = selectNumberRule.YEAR, tokenLen = TwoDigitYearField.INSTANCE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-18/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 16:31:19.200079716 +0200\n+++ /tmp/tmpnpuugkgq.java\t2022-07-19 16:31:20.044074513 +0200\n@@ -490,14 +490,11 @@\n             switch (c) {\n             case 'G': // era designator (text)\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n+if (tokenLen == 2) { rule = selectNumberRule.YEAR, tokenLen = TwoDigitYearField.INSTANCE;\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 if (tokenLen >= 4) {\n                     rule = new TextField(Calendar.MONTH, months);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (tokenLen == 2) { rule = selectNumberRule.YEAR, tokenLen =tokenLen; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-18/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 16:31:22.900056916 +0200\n+++ /tmp/tmpd0e36fi7.java\t2022-07-19 16:31:22.960056545 +0200\n@@ -490,14 +490,11 @@\n             switch (c) {\n             case 'G': // era designator (text)\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n+if (tokenLen == 2) { rule = selectNumberRule.YEAR, tokenLen =tokenLen; }\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 if (tokenLen >= 4) {\n                     rule = new TextField(Calendar.MONTH, months);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (tokenLen >= 4) { rule = selectNumberRule.YEAR, tokenLen = TwoDigitYearField.INSTANCE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-18/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 16:31:25.808038996 +0200\n+++ /tmp/tmp3jaox6kt.java\t2022-07-19 16:31:25.808038996 +0200\n@@ -490,14 +490,11 @@\n             switch (c) {\n             case 'G': // era designator (text)\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n+if (tokenLen >= 4) { rule = selectNumberRule.YEAR, tokenLen = TwoDigitYearField.INSTANCE;\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 if (tokenLen >= 4) {\n                     rule = new TextField(Calendar.MONTH, months);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (tokenLen >= 4) { rule = selectNumberRule.YEAR, tokenLen =tokenLen; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-18/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 16:31:28.472022579 +0200\n+++ /tmp/tmprorumxiw.java\t2022-07-19 16:31:28.508022357 +0200\n@@ -490,14 +490,11 @@\n             switch (c) {\n             case 'G': // era designator (text)\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n+if (tokenLen >= 4) { rule = selectNumberRule.YEAR, tokenLen =tokenLen; }\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 if (tokenLen >= 4) {\n                     rule = new TextField(Calendar.MONTH, months);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (tokenLen == 2) { rule = selectNumberRule(Calendar.YEAR, tokenLen = TwoDigitYearField.INSTANCE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-18/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 16:31:30.628009288 +0200\n+++ /tmp/tmp73ad9_ca.java\t2022-07-19 16:31:30.628009288 +0200\n@@ -490,14 +490,11 @@\n             switch (c) {\n             case 'G': // era designator (text)\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n+if (tokenLen == 2) { rule = selectNumberRule(Calendar.YEAR, tokenLen = TwoDigitYearField.INSTANCE;\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 if (tokenLen >= 4) {\n                     rule = new TextField(Calendar.MONTH, months);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (tokenLen == 2) { rule = selectNumberRule(Calendar.YEAR, tokenLen =tokenLen; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-18/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 16:31:34.071988053 +0200\n+++ /tmp/tmpb0dmov86.java\t2022-07-19 16:31:34.095987905 +0200\n@@ -490,14 +490,11 @@\n             switch (c) {\n             case 'G': // era designator (text)\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n+if (tokenLen == 2) { rule = selectNumberRule(Calendar.YEAR, tokenLen =tokenLen; }\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 if (tokenLen >= 4) {\n                     rule = new TextField(Calendar.MONTH, months);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen = TwoDigitYearField.INSTANCE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-18/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 16:31:36.679971956 +0200\n+++ /tmp/tmprpmhz9um.java\t2022-07-19 16:31:36.679971956 +0200\n@@ -490,14 +490,11 @@\n             switch (c) {\n             case 'G': // era designator (text)\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n+if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen = TwoDigitYearField.INSTANCE;\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 if (tokenLen >= 4) {\n                     rule = new TextField(Calendar.MONTH, months);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen =tokenLen; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-18/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 16:31:39.207956365 +0200\n+++ /tmp/tmpbs182vda.java\t2022-07-19 16:31:39.287955871 +0200\n@@ -490,14 +490,11 @@\n             switch (c) {\n             case 'G': // era designator (text)\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n+if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen =tokenLen; }\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 if (tokenLen >= 4) {\n                     rule = new TextField(Calendar.MONTH, months);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (tokenLen == 2) { rule = selectNumberRule(Calendar.YEAR, tokenLen =tokenLen;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-18/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 16:31:41.187944144 +0200\n+++ /tmp/tmpitc3yiu0.java\t2022-07-19 16:31:41.187944144 +0200\n@@ -490,14 +490,11 @@\n             switch (c) {\n             case 'G': // era designator (text)\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n+if (tokenLen == 2) { rule = selectNumberRule(Calendar.YEAR, tokenLen =tokenLen;\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 if (tokenLen >= 4) {\n                     rule = new TextField(Calendar.MONTH, months);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen =tokenLen;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-18/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 16:31:43.527929694 +0200\n+++ /tmp/tmpjqg19_rx.java\t2022-07-19 16:31:43.527929694 +0200\n@@ -490,14 +490,11 @@\n             switch (c) {\n             case 'G': // era designator (text)\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n+if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen =tokenLen;\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 if (tokenLen >= 4) {\n                     rule = new TextField(Calendar.MONTH, months);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen); } else { rule = TwoDigitYearField.INSTANCE;",
        "fixed_line": "if (tokenLen == 2) { rule = TwoDigitYearField.INSTANCE; } else { rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);"
    },
    "Jsoup-17": {
        "fixes": [
            {
                "k": 1,
                "patch": "private static String typeString = String.valueOf(0x00000000000;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-17/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 16:31:46.515911248 +0200\n+++ /tmp/tmphwzb_c8b.java\t2022-07-19 16:31:46.799909492 +0200\n@@ -1446,11 +1446,11 @@\n             return true;\n             // todo: implement. Also; how do we get here?\n         }\n     };\n \n-    private static String nullString = String.valueOf(0x0000);\n+private static String typeString = String.valueOf(0x00000000000;\n \n     abstract boolean process(Token t, TreeBuilder tb);\n \n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "private static String nullString = String.valueOf(0x00000000000;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-17/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 16:31:50.483886737 +0200\n+++ /tmp/tmpx0kc1985.java\t2022-07-19 16:31:50.483886737 +0200\n@@ -1446,11 +1446,11 @@\n             return true;\n             // todo: implement. Also; how do we get here?\n         }\n     };\n \n-    private static String nullString = String.valueOf(0x0000);\n+private static String nullString = String.valueOf(0x00000000000;\n \n     abstract boolean process(Token t, TreeBuilder tb);\n \n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "private static String String nullString = String.valueOf(0x00000000000;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-17/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 16:31:53.551867792 +0200\n+++ /tmp/tmp0yoqjsp9.java\t2022-07-19 16:31:53.551867792 +0200\n@@ -1446,11 +1446,11 @@\n             return true;\n             // todo: implement. Also; how do we get here?\n         }\n     };\n \n-    private static String nullString = String.valueOf(0x0000);\n+private static String String nullString = String.valueOf(0x00000000000;\n \n     abstract boolean process(Token t, TreeBuilder tb);\n \n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "private static String[]String = String.valueOf(0x0000);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-17/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 16:31:55.523855610 +0200\n+++ /tmp/tmpa9vh_h35.java\t2022-07-19 16:31:55.523855610 +0200\n@@ -1446,11 +1446,11 @@\n             return true;\n             // todo: implement. Also; how do we get here?\n         }\n     };\n \n-    private static String nullString = String.valueOf(0x0000);\n+private static String[]String = String.valueOf(0x0000);\n \n     abstract boolean process(Token t, TreeBuilder tb);\n \n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private static String typeString = String.valueOf(0x0000);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-17/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 16:31:58.703835953 +0200\n+++ /tmp/tmp97zpsjif.java\t2022-07-19 16:31:58.703835953 +0200\n@@ -1446,11 +1446,11 @@\n             return true;\n             // todo: implement. Also; how do we get here?\n         }\n     };\n \n-    private static String nullString = String.valueOf(0x0000);\n+private static String typeString = String.valueOf(0x0000);\n \n     abstract boolean process(Token t, TreeBuilder tb);\n \n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "private static String String nullString = String.valueOf(0x0000);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-17/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 16:32:01.459818924 +0200\n+++ /tmp/tmpa24s0s8h.java\t2022-07-19 16:32:01.507818628 +0200\n@@ -1446,11 +1446,11 @@\n             return true;\n             // todo: implement. Also; how do we get here?\n         }\n     };\n \n-    private static String nullString = String.valueOf(0x0000);\n+private static String String nullString = String.valueOf(0x0000);\n \n     abstract boolean process(Token t, TreeBuilder tb);\n \n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private static String nullString = String.valueOf(0x0000);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-17/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 16:32:04.439800501 +0200\n+++ /tmp/tmptmuxq2l6.java\t2022-07-19 16:32:04.439800501 +0200\n@@ -1446,11 +1446,11 @@\n             return true;\n             // todo: implement. Also; how do we get here?\n         }\n     };\n \n-    private static String nullString = String.valueOf(0x0000);\n+private static String nullString = String.valueOf(0x0000);\n \n     abstract boolean process(Token t, TreeBuilder tb);\n \n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "private static String[]String = String.valueOf(0x0000,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-17/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 16:32:12.367751466 +0200\n+++ /tmp/tmpdhgkd74n.java\t2022-07-19 16:32:12.367751466 +0200\n@@ -1446,11 +1446,11 @@\n             return true;\n             // todo: implement. Also; how do we get here?\n         }\n     };\n \n-    private static String nullString = String.valueOf(0x0000);\n+private static String[]String = String.valueOf(0x0000,\n \n     abstract boolean process(Token t, TreeBuilder tb);\n \n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private static String[]String = String.valueOf(0x00000000000;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-17/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 16:32:15.091734613 +0200\n+++ /tmp/tmp7llsmexg.java\t2022-07-19 16:32:15.231733742 +0200\n@@ -1446,11 +1446,11 @@\n             return true;\n             // todo: implement. Also; how do we get here?\n         }\n     };\n \n-    private static String nullString = String.valueOf(0x0000);\n+private static String[]String = String.valueOf(0x00000000000;\n \n     abstract boolean process(Token t, TreeBuilder tb);\n \n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "private static String typeString = String.valueOf(0x0000,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-17/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 16:32:18.047716318 +0200\n+++ /tmp/tmpc653q9q2.java\t2022-07-19 16:32:18.051716294 +0200\n@@ -1446,11 +1446,11 @@\n             return true;\n             // todo: implement. Also; how do we get here?\n         }\n     };\n \n-    private static String nullString = String.valueOf(0x0000);\n+private static String typeString = String.valueOf(0x0000,\n \n     abstract boolean process(Token t, TreeBuilder tb);\n \n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "private static String nullString = String.valueOf(0x0000);",
        "fixed_line": "private static String nullString = String.valueOf('\\u0000');"
    },
    "JacksonDatabind-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "return _unknownType; /* declared if it's || context.findType) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-11/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 16:32:21.275696334 +0200\n+++ /tmp/tmpqn9o7bip.java\t2022-07-19 16:32:21.543694675 +0200\n@@ -890,18 +890,11 @@\n     {\n         final String name = type.getName();\n         // 19-Mar-2015: Without context, all we can check are bounds.\n         if (context == null) {\n             // And to prevent infinite loops, now need this:\n-            return _unknownType();\n-        } else {\n-            // Ok: here's where context might come in handy!\n-            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n-             *   unresolved type variables to handle some cases where bounds\n-             *   are enough. Let's hope it does not hide real fail cases.\n-             */\n-            JavaType actualType = context.findType(name);\n+return _unknownType; /* declared if it's || context.findType) {\n             if (actualType != null) {\n                 return actualType;\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return _unknownType; /* declared if necessary, actualType = context.findType(actualType, _unknownClass;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-11/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 16:32:25.467670376 +0200\n+++ /tmp/tmpptlbmth5.java\t2022-07-19 16:32:25.571669730 +0200\n@@ -890,18 +890,11 @@\n     {\n         final String name = type.getName();\n         // 19-Mar-2015: Without context, all we can check are bounds.\n         if (context == null) {\n             // And to prevent infinite loops, now need this:\n-            return _unknownType();\n-        } else {\n-            // Ok: here's where context might come in handy!\n-            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n-             *   unresolved type variables to handle some cases where bounds\n-             *   are enough. Let's hope it does not hide real fail cases.\n-             */\n-            JavaType actualType = context.findType(name);\n+return _unknownType; /* declared if necessary, actualType = context.findType(actualType, _unknownClass;\n             if (actualType != null) {\n                 return actualType;\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return _unknownType; no collision listType = context.findType(actualType, _unknownClass, _unknownClass;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-11/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 16:32:28.095654099 +0200\n+++ /tmp/tmpyw_72i8m.java\t2022-07-19 16:32:28.095654099 +0200\n@@ -890,18 +890,11 @@\n     {\n         final String name = type.getName();\n         // 19-Mar-2015: Without context, all we can check are bounds.\n         if (context == null) {\n             // And to prevent infinite loops, now need this:\n-            return _unknownType();\n-        } else {\n-            // Ok: here's where context might come in handy!\n-            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n-             *   unresolved type variables to handle some cases where bounds\n-             *   are enough. Let's hope it does not hide real fail cases.\n-             */\n-            JavaType actualType = context.findType(name);\n+return _unknownType; no collision listType = context.findType(actualType, _unknownClass, _unknownClass;\n             if (actualType != null) {\n                 return actualType;\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return _unknownType; /* declared if necessary, actualType = context.findType(value)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-11/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 16:32:30.575638735 +0200\n+++ /tmp/tmpbg0lwfs5.java\t2022-07-19 16:32:30.607638539 +0200\n@@ -890,18 +890,11 @@\n     {\n         final String name = type.getName();\n         // 19-Mar-2015: Without context, all we can check are bounds.\n         if (context == null) {\n             // And to prevent infinite loops, now need this:\n-            return _unknownType();\n-        } else {\n-            // Ok: here's where context might come in handy!\n-            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n-             *   unresolved type variables to handle some cases where bounds\n-             *   are enough. Let's hope it does not hide real fail cases.\n-             */\n-            JavaType actualType = context.findType(name);\n+return _unknownType; /* declared if necessary, actualType = context.findType(value)\n             if (actualType != null) {\n                 return actualType;\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return _unknownType; no collision listType = context.findType(actualType, _unknownClass;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-11/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 16:32:33.435621014 +0200\n+++ /tmp/tmpcruf0pqj.java\t2022-07-19 16:32:33.523620462 +0200\n@@ -890,18 +890,11 @@\n     {\n         final String name = type.getName();\n         // 19-Mar-2015: Without context, all we can check are bounds.\n         if (context == null) {\n             // And to prevent infinite loops, now need this:\n-            return _unknownType();\n-        } else {\n-            // Ok: here's where context might come in handy!\n-            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n-             *   unresolved type variables to handle some cases where bounds\n-             *   are enough. Let's hope it does not hide real fail cases.\n-             */\n-            JavaType actualType = context.findType(name);\n+return _unknownType; no collision listType = context.findType(actualType, _unknownClass;\n             if (actualType != null) {\n                 return actualType;\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return _unknownType; /* declared if necessary, actualType = context.findType(actualType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-11/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 16:32:36.151604181 +0200\n+++ /tmp/tmpetluchri.java\t2022-07-19 16:32:36.151604181 +0200\n@@ -890,18 +890,11 @@\n     {\n         final String name = type.getName();\n         // 19-Mar-2015: Without context, all we can check are bounds.\n         if (context == null) {\n             // And to prevent infinite loops, now need this:\n-            return _unknownType();\n-        } else {\n-            // Ok: here's where context might come in handy!\n-            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n-             *   unresolved type variables to handle some cases where bounds\n-             *   are enough. Let's hope it does not hide real fail cases.\n-             */\n-            JavaType actualType = context.findType(name);\n+return _unknownType; /* declared if necessary, actualType = context.findType(actualType);\n             if (actualType != null) {\n                 return actualType;\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return _unknownType; /* declared if necessary, actualType = context.findType(actualType, _unknownClass, _unknownClass;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-11/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 16:32:37.811593894 +0200\n+++ /tmp/tmpo0zuy4ru.java\t2022-07-19 16:32:37.811593894 +0200\n@@ -890,18 +890,11 @@\n     {\n         final String name = type.getName();\n         // 19-Mar-2015: Without context, all we can check are bounds.\n         if (context == null) {\n             // And to prevent infinite loops, now need this:\n-            return _unknownType();\n-        } else {\n-            // Ok: here's where context might come in handy!\n-            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n-             *   unresolved type variables to handle some cases where bounds\n-             *   are enough. Let's hope it does not hide real fail cases.\n-             */\n-            JavaType actualType = context.findType(name);\n+return _unknownType; /* declared if necessary, actualType = context.findType(actualType, _unknownClass, _unknownClass;\n             if (actualType != null) {\n                 return actualType;\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return _unknownType; no collision listType = context.findType(value)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-11/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 16:32:39.367584247 +0200\n+++ /tmp/tmpbthg__0r.java\t2022-07-19 16:32:39.367584247 +0200\n@@ -890,18 +890,11 @@\n     {\n         final String name = type.getName();\n         // 19-Mar-2015: Without context, all we can check are bounds.\n         if (context == null) {\n             // And to prevent infinite loops, now need this:\n-            return _unknownType();\n-        } else {\n-            // Ok: here's where context might come in handy!\n-            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n-             *   unresolved type variables to handle some cases where bounds\n-             *   are enough. Let's hope it does not hide real fail cases.\n-             */\n-            JavaType actualType = context.findType(name);\n+return _unknownType; no collision listType = context.findType(value)\n             if (actualType != null) {\n                 return actualType;\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return _unknownType; /* declared if necessary, actualType = context.findType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-11/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 16:32:40.847575072 +0200\n+++ /tmp/tmprtwcjg_2.java\t2022-07-19 16:32:40.847575072 +0200\n@@ -890,18 +890,11 @@\n     {\n         final String name = type.getName();\n         // 19-Mar-2015: Without context, all we can check are bounds.\n         if (context == null) {\n             // And to prevent infinite loops, now need this:\n-            return _unknownType();\n-        } else {\n-            // Ok: here's where context might come in handy!\n-            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n-             *   unresolved type variables to handle some cases where bounds\n-             *   are enough. Let's hope it does not hide real fail cases.\n-             */\n-            JavaType actualType = context.findType(name);\n+return _unknownType; /* declared if necessary, actualType = context.findType;\n             if (actualType != null) {\n                 return actualType;\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return _unknownType; /* declared iffracts || context.findType) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-11/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 16:32:42.423565297 +0200\n+++ /tmp/tmpyinghvar.java\t2022-07-19 16:32:42.423565297 +0200\n@@ -890,18 +890,11 @@\n     {\n         final String name = type.getName();\n         // 19-Mar-2015: Without context, all we can check are bounds.\n         if (context == null) {\n             // And to prevent infinite loops, now need this:\n-            return _unknownType();\n-        } else {\n-            // Ok: here's where context might come in handy!\n-            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n-             *   unresolved type variables to handle some cases where bounds\n-             *   are enough. Let's hope it does not hide real fail cases.\n-             */\n-            JavaType actualType = context.findType(name);\n+return _unknownType; /* declared iffracts || context.findType) {\n             if (actualType != null) {\n                 return actualType;\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return _unknownType(); } else { // Ok: here's where context might come in handy! /* 19-Mar-2015, tatu: As per [databind#609], may need to allow * unresolved type variables to handle some cases where bounds * are enough. Let's hope it does not hide real fail cases. */ JavaType actualType = context.findType(name);",
        "fixed_line": "context = new TypeBindings(this, (Class<?>) null); } else { // Ok: here's where context might come in handy! /* 19-Mar-2015, tatu: As per [databind#609], may need to allow * unresolved type variables to handle some cases where bounds * are enough. Let's hope it does not hide real fail cases. */ JavaType actualType = context.findType(name, false);"
    },
    "Lang-53": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (field.get(Calendar.SECOND) && (!round || minutes < 30 || seconds > 30 * 1000L; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java\t2022-07-19 16:32:44.167554482 +0200\n+++ /tmp/tmpwgff6sv1.java\t2022-07-19 16:32:44.195554309 +0200\n@@ -640,20 +640,11 @@\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         if (field == Calendar.SECOND) {\n             done = true;\n-            }\n-        }\n-\n-        // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-        if (field == Calendar.MINUTE) {\n-            done = true;\n-            }\n+} else if (field.get(Calendar.SECOND) && (!round || minutes < 30 || seconds > 30 * 1000L; }\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (field == val.get(Calendar.SECOND) && (!round || minutes < 30 || seconds > 30 * 1000L; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java\t2022-07-19 16:32:45.939543492 +0200\n+++ /tmp/tmp4p52ssz0.java\t2022-07-19 16:32:45.939543492 +0200\n@@ -640,20 +640,11 @@\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         if (field == Calendar.SECOND) {\n             done = true;\n-            }\n-        }\n-\n-        // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-        if (field == Calendar.MINUTE) {\n-            done = true;\n-            }\n+} else if (field == val.get(Calendar.SECOND) && (!round || minutes < 30 || seconds > 30 * 1000L; }\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (field == val.SECOND && (!round || minutes < 30 || seconds > 30 * 1000L; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java\t2022-07-19 16:32:47.531533619 +0200\n+++ /tmp/tmphoqgplzh.java\t2022-07-19 16:32:47.531533619 +0200\n@@ -640,20 +640,11 @@\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         if (field == Calendar.SECOND) {\n             done = true;\n-            }\n-        }\n-\n-        // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-        if (field == Calendar.MINUTE) {\n-            done = true;\n-            }\n+} else if (field == val.SECOND && (!round || minutes < 30 || seconds > 30 * 1000L; }\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (field.get(Calendar.SECOND) && (!round || minutes < 30 || seconds > 59) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java\t2022-07-19 16:32:49.023524361 +0200\n+++ /tmp/tmp0ssyzjto.java\t2022-07-19 16:32:49.023524361 +0200\n@@ -640,20 +640,11 @@\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         if (field == Calendar.SECOND) {\n             done = true;\n-            }\n-        }\n-\n-        // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-        if (field == Calendar.MINUTE) {\n-            done = true;\n-            }\n+} else if (field.get(Calendar.SECOND) && (!round || minutes < 30 || seconds > 59) {\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (seconds = val.get(Calendar.SECOND - 1) * DateTimeConstants.MILLIS_PER_MINUTE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java\t2022-07-19 16:32:50.511515129 +0200\n+++ /tmp/tmp45f_fatg.java\t2022-07-19 16:32:50.511515129 +0200\n@@ -640,20 +640,11 @@\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         if (field == Calendar.SECOND) {\n             done = true;\n-            }\n-        }\n-\n-        // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-        if (field == Calendar.MINUTE) {\n-            done = true;\n-            }\n+} else if (seconds = val.get(Calendar.SECOND - 1) * DateTimeConstants.MILLIS_PER_MINUTE;\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (field == val.get(Calendar.SECOND) && (!round || seconds < 30 || seconds > 30 * 1000L; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java\t2022-07-19 16:32:52.071505450 +0200\n+++ /tmp/tmptl2jr6e1.java\t2022-07-19 16:32:52.071505450 +0200\n@@ -640,20 +640,11 @@\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         if (field == Calendar.SECOND) {\n             done = true;\n-            }\n-        }\n-\n-        // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-        if (field == Calendar.MINUTE) {\n-            done = true;\n-            }\n+} else if (field == val.get(Calendar.SECOND) && (!round || seconds < 30 || seconds > 30 * 1000L; }\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (seconds = val.get(Calendar.SECOND - 1) * DateTimeConstants.MINUTE || minutes == Calendar.MINUTE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java\t2022-07-19 16:32:53.623495817 +0200\n+++ /tmp/tmpkfb0nlud.java\t2022-07-19 16:32:53.623495817 +0200\n@@ -640,20 +640,11 @@\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         if (field == Calendar.SECOND) {\n             done = true;\n-            }\n-        }\n-\n-        // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-        if (field == Calendar.MINUTE) {\n-            done = true;\n-            }\n+} else if (seconds = val.get(Calendar.SECOND - 1) * DateTimeConstants.MINUTE || minutes == Calendar.MINUTE;\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (field == val.get(Calendar.SECOND) && (!round || minutes < 30 || seconds > 59) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java\t2022-07-19 16:32:55.131486458 +0200\n+++ /tmp/tmpyb136qly.java\t2022-07-19 16:32:55.135486434 +0200\n@@ -640,20 +640,11 @@\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         if (field == Calendar.SECOND) {\n             done = true;\n-            }\n-        }\n-\n-        // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-        if (field == Calendar.MINUTE) {\n-            done = true;\n-            }\n+} else if (field == val.get(Calendar.SECOND) && (!round || minutes < 30 || seconds > 59) {\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (field.get(Calendar.SECOND) && (!round || seconds < 30 || seconds > 30 * 1000L; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java\t2022-07-19 16:32:56.607477297 +0200\n+++ /tmp/tmpwvcpregl.java\t2022-07-19 16:32:56.607477297 +0200\n@@ -640,20 +640,11 @@\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         if (field == Calendar.SECOND) {\n             done = true;\n-            }\n-        }\n-\n-        // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-        if (field == Calendar.MINUTE) {\n-            done = true;\n-            }\n+} else if (field.get(Calendar.SECOND) && (!round || seconds < 30 || seconds > 30 * 1000L; }\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (field.get(Calendar.SECOND) && (!round || minutes < 30) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java\t2022-07-19 16:32:58.047468358 +0200\n+++ /tmp/tmpj5u38xsj.java\t2022-07-19 16:32:58.047468358 +0200\n@@ -640,20 +640,11 @@\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         if (field == Calendar.SECOND) {\n             done = true;\n-            }\n-        }\n-\n-        // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-        if (field == Calendar.MINUTE) {\n-            done = true;\n-            }\n+} else if (field.get(Calendar.SECOND) && (!round || minutes < 30) {\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "} } // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done && (!round || seconds < 30)) { time = time - (seconds * 1000L); if (field == Calendar.MINUTE) { done = true; }",
        "fixed_line": "} if (field == Calendar.SECOND) { done = true; } // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done && (!round || seconds < 30)) { time = time - (seconds * 1000L); }"
    },
    "Closure-71": {
        "fixes": [
            {
                "k": 1,
                "patch": "boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-71/src/com/google/javascript/jscomp/CheckAccessControls.java\t2022-07-19 16:33:00.351454054 +0200\n+++ /tmp/tmpssrzf_os.java\t2022-07-19 16:33:00.395453781 +0200\n@@ -411,11 +411,11 @@\n     String propertyName = getprop.getLastChild().getString();\n \n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n       // Find the lowest property defined on a class with visibility\n       // information.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-71/src/com/google/javascript/jscomp/CheckAccessControls.java\t2022-07-19 16:33:35.631234732 +0200\n+++ /tmp/tmpc8a0g0x9.java\t2022-07-19 16:33:35.631234732 +0200\n@@ -411,11 +411,11 @@\n     String propertyName = getprop.getLastChild().getString();\n \n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n       // Find the lowest property defined on a class with visibility\n       // information.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-71/src/com/google/javascript/jscomp/CheckAccessControls.java\t2022-07-19 16:34:07.883033786 +0200\n+++ /tmp/tmpjxcy5j_t.java\t2022-07-19 16:34:07.883033786 +0200\n@@ -411,11 +411,11 @@\n     String propertyName = getprop.getLastChild().getString();\n \n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n       // Find the lowest property defined on a class with visibility\n       // information.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-71/src/com/google/javascript/jscomp/CheckAccessControls.java\t2022-07-19 16:34:40.474830317 +0200\n+++ /tmp/tmpe360ohgk.java\t2022-07-19 16:34:40.474830317 +0200\n@@ -411,11 +411,11 @@\n     String propertyName = getprop.getLastChild().getString();\n \n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n       // Find the lowest property defined on a class with visibility\n       // information.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-71/src/com/google/javascript/jscomp/CheckAccessControls.java\t2022-07-19 16:35:13.094626288 +0200\n+++ /tmp/tmpixfrvuai.java\t2022-07-19 16:35:13.094626288 +0200\n@@ -411,11 +411,11 @@\n     String propertyName = getprop.getLastChild().getString();\n \n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n       // Find the lowest property defined on a class with visibility\n       // information.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property-inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-71/src/com/google/javascript/jscomp/CheckAccessControls.java\t2022-07-19 16:35:45.922420596 +0200\n+++ /tmp/tmpsp0t9cbf.java\t2022-07-19 16:35:45.922420596 +0200\n@@ -411,11 +411,11 @@\n     String propertyName = getprop.getLastChild().getString();\n \n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property-inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n       // Find the lowest property defined on a class with visibility\n       // information.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property-inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-71/src/com/google/javascript/jscomp/CheckAccessControls.java\t2022-07-19 16:36:18.246217726 +0200\n+++ /tmp/tmpdbhiep5y.java\t2022-07-19 16:36:18.246217726 +0200\n@@ -411,11 +411,11 @@\n     String propertyName = getprop.getLastChild().getString();\n \n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property-inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n       // Find the lowest property defined on a class with visibility\n       // information.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property-inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-71/src/com/google/javascript/jscomp/CheckAccessControls.java\t2022-07-19 16:36:50.958012103 +0200\n+++ /tmp/tmp4j4w6egg.java\t2022-07-19 16:36:50.958012103 +0200\n@@ -411,11 +411,11 @@\n     String propertyName = getprop.getLastChild().getString();\n \n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property-inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n       // Find the lowest property defined on a class with visibility\n       // information.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to check whether a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-71/src/com/google/javascript/jscomp/CheckAccessControls.java\t2022-07-19 16:37:23.477807392 +0200\n+++ /tmp/tmp302dof11.java\t2022-07-19 16:37:23.477807392 +0200\n@@ -411,11 +411,11 @@\n     String propertyName = getprop.getLastChild().getString();\n \n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to check whether a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n       // Find the lowest property defined on a class with visibility\n       // information.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to check // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-71/src/com/google/javascript/jscomp/CheckAccessControls.java\t2022-07-19 16:37:55.789603715 +0200\n+++ /tmp/tmpvpx_tszb.java\t2022-07-19 16:37:55.793603688 +0200\n@@ -411,11 +411,11 @@\n     String propertyName = getprop.getLastChild().getString();\n \n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to check // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n       // Find the lowest property defined on a class with visibility\n       // information.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "boolean isOverride = t.inGlobalScope() &&",
        "fixed_line": "boolean isOverride = parent.getJSDocInfo() != null &&"
    },
    "Csv-14": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (first && (c < '0' || c > '9' && c < 'A' || c > 'Z' || c < 'a' || c > 'z')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-14/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 16:38:28.537397025 +0200\n+++ /tmp/tmpch1yz642.java\t2022-07-19 16:38:28.569396825 +0200\n@@ -1034,11 +1034,11 @@\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+if (first && (c < '0' || c > '9' && c < 'A' || c > 'Z' || c < 'a' || c > 'z')) {\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (first && (c < '0' || c > '9' || c < 'A' || c > 'Z' || c < 'a' || c > 'z')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-14/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 16:38:30.505384597 +0200\n+++ /tmp/tmpxowa4l4w.java\t2022-07-19 16:38:30.509384573 +0200\n@@ -1034,11 +1034,11 @@\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+if (first && (c < '0' || c > '9' || c < 'A' || c > 'Z' || c < 'a' || c > 'z')) {\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (first && (c < '0' || c > '9' && c < 'A' || c > 'Z' || c < 'a' && c > 'z')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-14/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 16:38:32.177374038 +0200\n+++ /tmp/tmp6gimk_1h.java\t2022-07-19 16:38:32.177374038 +0200\n@@ -1034,11 +1034,11 @@\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+if (first && (c < '0' || c > '9' && c < 'A' || c > 'Z' || c < 'a' && c > 'z')) {\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (first && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a'",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-14/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 16:38:33.925362996 +0200\n+++ /tmp/tmpkg1xlya6.java\t2022-07-19 16:38:33.925362996 +0200\n@@ -1034,11 +1034,11 @@\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+if (first && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a'\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (first && (c < '0' || c > '9' || c < 'A' || c > 'Z' || c < 'a' && c > 'z')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-14/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 16:38:35.501353040 +0200\n+++ /tmp/tmpp5y00ert.java\t2022-07-19 16:38:35.501353040 +0200\n@@ -1034,11 +1034,11 @@\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+if (first && (c < '0' || c > '9' || c < 'A' || c > 'Z' || c < 'a' && c > 'z')) {\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (first && (c < '0' || c > '9' && c < 'A' || c > 'Z' || c < 'a'",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-14/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 16:38:37.221342175 +0200\n+++ /tmp/tmpf52q5q_m.java\t2022-07-19 16:38:37.225342151 +0200\n@@ -1034,11 +1034,11 @@\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+if (first && (c < '0' || c > '9' && c < 'A' || c > 'Z' || c < 'a'\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (first && (c < '0' || c > '9' || c < 'A' || c > 'Z' && c < 'a'",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-14/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 16:38:38.713332749 +0200\n+++ /tmp/tmpgerym2fj.java\t2022-07-19 16:38:38.717332725 +0200\n@@ -1034,11 +1034,11 @@\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+if (first && (c < '0' || c > '9' || c < 'A' || c > 'Z' && c < 'a'\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (first && (c < '0' || c > '9' || c < 'A' || c > 'Z' || c < 'a'",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-14/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 16:38:40.305322690 +0200\n+++ /tmp/tmpmp1px883.java\t2022-07-19 16:38:40.305322690 +0200\n@@ -1034,11 +1034,11 @@\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+if (first && (c < '0' || c > '9' || c < 'A' || c > 'Z' || c < 'a'\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (c < '0' || (c > '9' && c < 'A' || c > 'Z' || c < 'a' && c > 'z')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-14/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 16:38:41.813313164 +0200\n+++ /tmp/tmpq3ht7faj.java\t2022-07-19 16:38:41.813313164 +0200\n@@ -1034,11 +1034,11 @@\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+if (c < '0' || (c > '9' && c < 'A' || c > 'Z' || c < 'a' && c > 'z')) {\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (c < '0' || (c > '9' && c < 'A' || c > 'Z' && c < 'a'",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-14/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 16:38:46.309284754 +0200\n+++ /tmp/tmpu30setn6.java\t2022-07-19 16:38:46.313284729 +0200\n@@ -1034,11 +1034,11 @@\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+if (c < '0' || (c > '9' && c < 'A' || c > 'Z' && c < 'a'\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {",
        "fixed_line": "if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {"
    },
    "Chart-23": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int i = 0; i < this.shape; i++) { if (this.shape == null) { this.shape = shape; this.shape = shape; this.shape = shape; this.legendLine = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape;",
                "patch_diff": "for (int i = 0; i < this.shape; i++) { if (this.shape == null) { this.shape = shape; this.shape = shape; this.shape = shape; this.legendLine = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = 0; i < this.shape; i++) { if (this.shape == null) { this.shape = shape; this.shape = shape; this.legendLine = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape;",
                "patch_diff": "for (int i = 0; i < this.shape; i++) { if (this.shape == null) { this.shape = shape; this.shape = shape; this.legendLine = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0; i < this.shape; i++) { if (this.shape == null) { this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.legendLine = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape;",
                "patch_diff": "for (int i = 0; i < this.shape; i++) { if (this.shape == null) { this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.legendLine = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = 0; i < this.shape; i++) { if (this.shape == null) { this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this",
                "patch_diff": "for (int i = 0; i < this.shape; i++) { if (this.shape == null) { this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = 0; i < this.shape; i++) { if (this.shape == null) { this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; }",
                "patch_diff": "for (int i = 0; i < this.shape; i++) { if (this.shape == null) { this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = this.seriesCount; i < this.seriesCount; i++) { if (this.shape == 0.0) { this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.",
                "patch_diff": "for (int i = this.seriesCount; i < this.seriesCount; i++) { if (this.shape == 0.0) { this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = 0; i < this.seriesCount; i++) { if (this.shape == 0.0) { this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.legendLine = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape",
                "patch_diff": "for (int i = 0; i < this.seriesCount; i++) { if (this.shape == 0.0) { this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.legendLine = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = 0; i < this.shape; i++) { if (this.shape == null) { this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; notify",
                "patch_diff": "for (int i = 0; i < this.shape; i++) { if (this.shape == null) { this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; notify",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int i = this.seriesCount; i < this.seriesCount; i++) { if (this.shape == 0.0) { this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; } }",
                "patch_diff": "for (int i = this.seriesCount; i < this.seriesCount; i++) { if (this.shape == 0.0) { this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = 0; i < this.shape; i++) { if (this.shape == null) { this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; if",
                "patch_diff": "for (int i = 0; i < this.shape; i++) { if (this.shape == null) { this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; this.shape = shape; if",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "public boolean equals(Object obj) { if (obj == this) { return true; } if (!(obj instanceof MinMaxCategoryRenderer)) { return false; } MinMaxCategoryRenderer that = (MinMaxCategoryRenderer) obj; if (this.plotLines != that.plotLines) { return false; } if (!PaintUtilities.equal(this.groupPaint, that.groupPaint)) { return false; } if (!this.groupStroke.equals(that.groupStroke)) { return false; } return super.equals(obj); }"
    },
    "JacksonDatabind-98": {
        "fixes": [
            {
                "k": 1,
                "patch": "buffer.assignParameter(typeIdReader, typeId);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-98/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\t2022-07-19 16:38:50.333259320 +0200\n+++ /tmp/tmpddieigs7.java\t2022-07-19 16:38:50.377259045 +0200\n@@ -293,11 +293,11 @@\n                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n                 // for now, should only be needed for creator properties, too\n                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                     //    apply deserializer... fun fun.\n-                    buffer.assignParameter(typeProp, typeId);\n+buffer.assignParameter(typeIdReader, typeId);\n                 }\n             }\n         }\n         Object bean = creator.build(ctxt, buffer);\n         // third: assign non-creator properties\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "buffer.assignParameter(typeProp, beanClass);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-98/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\t2022-07-19 16:38:53.029242284 +0200\n+++ /tmp/tmp8k43em5m.java\t2022-07-19 16:38:53.029242284 +0200\n@@ -293,11 +293,11 @@\n                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n                 // for now, should only be needed for creator properties, too\n                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                     //    apply deserializer... fun fun.\n-                    buffer.assignParameter(typeProp, typeId);\n+buffer.assignParameter(typeProp, beanClass);\n                 }\n             }\n         }\n         Object bean = creator.build(ctxt, buffer);\n         // third: assign non-creator properties\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "buffer.assignParameter(typeProp, typeId);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-98/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\t2022-07-19 16:38:54.693231764 +0200\n+++ /tmp/tmpifuc54h7.java\t2022-07-19 16:38:54.693231764 +0200\n@@ -293,11 +293,11 @@\n                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n                 // for now, should only be needed for creator properties, too\n                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                     //    apply deserializer... fun fun.\n-                    buffer.assignParameter(typeProp, typeId);\n+buffer.assignParameter(typeProp, typeId);\n                 }\n             }\n         }\n         Object bean = creator.build(ctxt, buffer);\n         // third: assign non-creator properties\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "buffer.assignParameter(typeProp, typeId;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-98/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\t2022-07-19 16:39:55.096849551 +0200\n+++ /tmp/tmp7cuzn5ku.java\t2022-07-19 16:39:55.096849551 +0200\n@@ -293,11 +293,11 @@\n                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n                 // for now, should only be needed for creator properties, too\n                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                     //    apply deserializer... fun fun.\n-                    buffer.assignParameter(typeProp, typeId);\n+buffer.assignParameter(typeProp, typeId;\n                 }\n             }\n         }\n         Object bean = creator.build(ctxt, buffer);\n         // third: assign non-creator properties\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "buffer.assignParameter(typeProp, bean;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-98/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\t2022-07-19 16:39:56.672839570 +0200\n+++ /tmp/tmppd65v99u.java\t2022-07-19 16:39:56.676839543 +0200\n@@ -293,11 +293,11 @@\n                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n                 // for now, should only be needed for creator properties, too\n                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                     //    apply deserializer... fun fun.\n-                    buffer.assignParameter(typeProp, typeId);\n+buffer.assignParameter(typeProp, bean;\n                 }\n             }\n         }\n         Object bean = creator.build(ctxt, buffer);\n         // third: assign non-creator properties\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "buffer.assignParameter(typeProp, beanProp);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-98/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\t2022-07-19 16:39:58.180830017 +0200\n+++ /tmp/tmplotpml_c.java\t2022-07-19 16:39:58.180830017 +0200\n@@ -293,11 +293,11 @@\n                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n                 // for now, should only be needed for creator properties, too\n                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                     //    apply deserializer... fun fun.\n-                    buffer.assignParameter(typeProp, typeId);\n+buffer.assignParameter(typeProp, beanProp);\n                 }\n             }\n         }\n         Object bean = creator.build(ctxt, buffer);\n         // third: assign non-creator properties\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "buffer.assignParameter(typeProp, bean);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-98/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\t2022-07-19 16:39:59.936818895 +0200\n+++ /tmp/tmpj03hnbil.java\t2022-07-19 16:39:59.936818895 +0200\n@@ -293,11 +293,11 @@\n                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n                 // for now, should only be needed for creator properties, too\n                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                     //    apply deserializer... fun fun.\n-                    buffer.assignParameter(typeProp, typeId);\n+buffer.assignParameter(typeProp, bean);\n                 }\n             }\n         }\n         Object bean = creator.build(ctxt, buffer);\n         // third: assign non-creator properties\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "buffer.assignParameter(typeId, typeId);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-98/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\t2022-07-19 16:40:01.672807896 +0200\n+++ /tmp/tmps1oq7kgz.java\t2022-07-19 16:40:01.672807896 +0200\n@@ -293,11 +293,11 @@\n                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n                 // for now, should only be needed for creator properties, too\n                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                     //    apply deserializer... fun fun.\n-                    buffer.assignParameter(typeProp, typeId);\n+buffer.assignParameter(typeId, typeId);\n                 }\n             }\n         }\n         Object bean = creator.build(ctxt, buffer);\n         // third: assign non-creator properties\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "buffer.assignParameter(typeProp, beanProp;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-98/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\t2022-07-19 16:40:03.392796999 +0200\n+++ /tmp/tmp70642psh.java\t2022-07-19 16:40:03.392796999 +0200\n@@ -293,11 +293,11 @@\n                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n                 // for now, should only be needed for creator properties, too\n                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                     //    apply deserializer... fun fun.\n-                    buffer.assignParameter(typeProp, typeId);\n+buffer.assignParameter(typeProp, beanProp;\n                 }\n             }\n         }\n         Object bean = creator.build(ctxt, buffer);\n         // third: assign non-creator properties\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "buffer.assignParameter(typeId, id);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-98/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\t2022-07-19 16:40:04.932787243 +0200\n+++ /tmp/tmphwdrg0c1.java\t2022-07-19 16:40:04.932787243 +0200\n@@ -293,11 +293,11 @@\n                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n                 // for now, should only be needed for creator properties, too\n                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                     //    apply deserializer... fun fun.\n-                    buffer.assignParameter(typeProp, typeId);\n+buffer.assignParameter(typeId, id);\n                 }\n             }\n         }\n         Object bean = creator.build(ctxt, buffer);\n         // third: assign non-creator properties\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "buffer.assignParameter(typeProp, typeId);",
        "fixed_line": "final Object v; if (typeProp.getType().hasRawClass(String.class)) { v = typeId; } else { TokenBuffer tb = new TokenBuffer(p, ctxt); tb.writeString(typeId); v = typeProp.getValueDeserializer().deserialize(tb.asParserOnFirstToken(), ctxt); tb.close(); } buffer.assignParameter(typeProp, v);"
    },
    "Lang-33": {
        "fixes": [
            {
                "k": 1,
                "patch": "classes[i] = array[i].getClass - 1].getClassLink;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-33/src/main/java/org/apache/commons/lang3/ClassUtils.java\t2022-07-19 16:40:06.816775305 +0200\n+++ /tmp/tmpdbol1a3e.java\t2022-07-19 16:40:06.844775130 +0200\n@@ -905,11 +905,11 @@\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+classes[i] = array[i].getClass - 1].getClassLink;\n         }\n         return classes;\n     }\n \n     // Short canonical name\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "classes[i] = array[i].getClass - 1].getClass(array[i]);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-33/src/main/java/org/apache/commons/lang3/ClassUtils.java\t2022-07-19 16:40:08.504764612 +0200\n+++ /tmp/tmp4bl7u8p_.java\t2022-07-19 16:40:08.504764612 +0200\n@@ -905,11 +905,11 @@\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+classes[i] = array[i].getClass - 1].getClass(array[i]);\n         }\n         return classes;\n     }\n \n     // Short canonical name\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "classes[i] = array[i].getClass - 1].getClassVal;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-33/src/main/java/org/apache/commons/lang3/ClassUtils.java\t2022-07-19 16:40:09.992755182 +0200\n+++ /tmp/tmprb5pz09w.java\t2022-07-19 16:40:09.992755182 +0200\n@@ -905,11 +905,11 @@\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+classes[i] = array[i].getClass - 1].getClassVal;\n         }\n         return classes;\n     }\n \n     // Short canonical name\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "classes[i] = array[i].getClass - 1].getClass;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-33/src/main/java/org/apache/commons/lang3/ClassUtils.java\t2022-07-19 16:40:11.536745398 +0200\n+++ /tmp/tmpwwpdh7or.java\t2022-07-19 16:40:11.536745398 +0200\n@@ -905,11 +905,11 @@\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+classes[i] = array[i].getClass - 1].getClass;\n         }\n         return classes;\n     }\n \n     // Short canonical name\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "classes[i] = array[i].getClass - 1].getClass - 1].getClassVal;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-33/src/main/java/org/apache/commons/lang3/ClassUtils.java\t2022-07-19 16:40:13.108735436 +0200\n+++ /tmp/tmp4xktczhp.java\t2022-07-19 16:40:13.108735436 +0200\n@@ -905,11 +905,11 @@\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+classes[i] = array[i].getClass - 1].getClass - 1].getClassVal;\n         }\n         return classes;\n     }\n \n     // Short canonical name\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "classes[i] = array[i].getClass - 1].getClass();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-33/src/main/java/org/apache/commons/lang3/ClassUtils.java\t2022-07-19 16:40:14.696725374 +0200\n+++ /tmp/tmpznaw9xn3.java\t2022-07-19 16:40:14.696725374 +0200\n@@ -905,11 +905,11 @@\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+classes[i] = array[i].getClass - 1].getClass();\n         }\n         return classes;\n     }\n \n     // Short canonical name\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "classes[i] = array[i].getClass;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-33/src/main/java/org/apache/commons/lang3/ClassUtils.java\t2022-07-19 16:40:16.268715410 +0200\n+++ /tmp/tmpfrpccfp6.java\t2022-07-19 16:40:16.268715410 +0200\n@@ -905,11 +905,11 @@\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+classes[i] = array[i].getClass;\n         }\n         return classes;\n     }\n \n     // Short canonical name\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "classes[i] = array[i].getClassLink;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-33/src/main/java/org/apache/commons/lang3/ClassUtils.java\t2022-07-19 16:40:18.012704356 +0200\n+++ /tmp/tmpvvyynwny.java\t2022-07-19 16:40:18.012704356 +0200\n@@ -905,11 +905,11 @@\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+classes[i] = array[i].getClassLink;\n         }\n         return classes;\n     }\n \n     // Short canonical name\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "classes[i] = array[i].getClass();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-33/src/main/java/org/apache/commons/lang3/ClassUtils.java\t2022-07-19 16:40:19.700693657 +0200\n+++ /tmp/tmpao2f61wy.java\t2022-07-19 16:40:19.700693657 +0200\n@@ -905,11 +905,11 @@\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+classes[i] = array[i].getClass();\n         }\n         return classes;\n     }\n \n     // Short canonical name\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "classes[i] = array[i].getClassVal;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-33/src/main/java/org/apache/commons/lang3/ClassUtils.java\t2022-07-19 16:40:29.356632446 +0200\n+++ /tmp/tmpdktr9afh.java\t2022-07-19 16:40:29.356632446 +0200\n@@ -905,11 +905,11 @@\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+classes[i] = array[i].getClassVal;\n         }\n         return classes;\n     }\n \n     // Short canonical name\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "classes[i] = array[i].getClass();",
        "fixed_line": "classes[i] = array[i] == null ? null : array[i].getClass();"
    },
    "Closure-160": {
        "fixes": [
            {
                "k": 1,
                "patch": "(warningsGuard!= null &&!warningsGuard.disables.CHECK_VARIABLES) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-160/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 16:40:31.308620070 +0200\n+++ /tmp/tmpkvfs9rxj.java\t2022-07-19 16:40:31.328619944 +0200\n@@ -270,17 +270,11 @@\n     // variables later so that the compiler doesn't crash. It also\n     // checks the externs file for validity. If you don't want to warn\n     // about missing variable declarations, we shut that specific\n     // error off.\n     if (!options.checkSymbols &&\n-        (warningsGuard == null || !warningsGuard.disables(\n-            DiagnosticGroups.CHECK_VARIABLES))) {\n-      guards.add(new DiagnosticGroupWarningsGuard(\n-          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n-    }\n-\n-    this.warningsGuard = new ComposeWarningsGuard(guards);\n+(warningsGuard!= null &&!warningsGuard.disables.CHECK_VARIABLES) {\n   }\n \n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLESUSPENDED_VARIABLES) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-160/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 16:40:34.420600336 +0200\n+++ /tmp/tmpzjrq9xcn.java\t2022-07-19 16:40:34.420600336 +0200\n@@ -270,17 +270,11 @@\n     // variables later so that the compiler doesn't crash. It also\n     // checks the externs file for validity. If you don't want to warn\n     // about missing variable declarations, we shut that specific\n     // error off.\n     if (!options.checkSymbols &&\n-        (warningsGuard == null || !warningsGuard.disables(\n-            DiagnosticGroups.CHECK_VARIABLES))) {\n-      guards.add(new DiagnosticGroupWarningsGuard(\n-          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n-    }\n-\n-    this.warningsGuard = new ComposeWarningsGuard(guards);\n+(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLESUSPENDED_VARIABLES) {\n   }\n \n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLES) { state.CHECK_VARIABLE, CheckLevel.OFF; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-160/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 16:40:37.020583850 +0200\n+++ /tmp/tmpz2qgq61q.java\t2022-07-19 16:40:37.024583823 +0200\n@@ -270,17 +270,11 @@\n     // variables later so that the compiler doesn't crash. It also\n     // checks the externs file for validity. If you don't want to warn\n     // about missing variable declarations, we shut that specific\n     // error off.\n     if (!options.checkSymbols &&\n-        (warningsGuard == null || !warningsGuard.disables(\n-            DiagnosticGroups.CHECK_VARIABLES))) {\n-      guards.add(new DiagnosticGroupWarningsGuard(\n-          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n-    }\n-\n-    this.warningsGuard = new ComposeWarningsGuard(guards);\n+(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLES) { state.CHECK_VARIABLE, CheckLevel.OFF; }\n   }\n \n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLESUSPENDED_VARIABLESUSPENDED_VARIABLES;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-160/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 16:40:39.520567994 +0200\n+++ /tmp/tmp2tb6rbby.java\t2022-07-19 16:40:39.520567994 +0200\n@@ -270,17 +270,11 @@\n     // variables later so that the compiler doesn't crash. It also\n     // checks the externs file for validity. If you don't want to warn\n     // about missing variable declarations, we shut that specific\n     // error off.\n     if (!options.checkSymbols &&\n-        (warningsGuard == null || !warningsGuard.disables(\n-            DiagnosticGroups.CHECK_VARIABLES))) {\n-      guards.add(new DiagnosticGroupWarningsGuard(\n-          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n-    }\n-\n-    this.warningsGuard = new ComposeWarningsGuard(guards);\n+(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLESUSPENDED_VARIABLESUSPENDED_VARIABLES;\n   }\n \n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLESUSPENDED;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-160/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 16:40:42.048551960 +0200\n+++ /tmp/tmporyxhkpd.java\t2022-07-19 16:40:42.048551960 +0200\n@@ -270,17 +270,11 @@\n     // variables later so that the compiler doesn't crash. It also\n     // checks the externs file for validity. If you don't want to warn\n     // about missing variable declarations, we shut that specific\n     // error off.\n     if (!options.checkSymbols &&\n-        (warningsGuard == null || !warningsGuard.disables(\n-            DiagnosticGroups.CHECK_VARIABLES))) {\n-      guards.add(new DiagnosticGroupWarningsGuard(\n-          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n-    }\n-\n-    this.warningsGuard = new ComposeWarningsGuard(guards);\n+(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLESUSPENDED;\n   }\n \n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLES) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-160/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 16:40:44.620535649 +0200\n+++ /tmp/tmpn62k__yc.java\t2022-07-19 16:40:44.620535649 +0200\n@@ -270,17 +270,11 @@\n     // variables later so that the compiler doesn't crash. It also\n     // checks the externs file for validity. If you don't want to warn\n     // about missing variable declarations, we shut that specific\n     // error off.\n     if (!options.checkSymbols &&\n-        (warningsGuard == null || !warningsGuard.disables(\n-            DiagnosticGroups.CHECK_VARIABLES))) {\n-      guards.add(new DiagnosticGroupWarningsGuard(\n-          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n-    }\n-\n-    this.warningsGuard = new ComposeWarningsGuard(guards);\n+(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLES) {\n   }\n \n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLESUSPENDED) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-160/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 16:40:47.112519842 +0200\n+++ /tmp/tmp3cf9347f.java\t2022-07-19 16:40:47.116519815 +0200\n@@ -270,17 +270,11 @@\n     // variables later so that the compiler doesn't crash. It also\n     // checks the externs file for validity. If you don't want to warn\n     // about missing variable declarations, we shut that specific\n     // error off.\n     if (!options.checkSymbols &&\n-        (warningsGuard == null || !warningsGuard.disables(\n-            DiagnosticGroups.CHECK_VARIABLES))) {\n-      guards.add(new DiagnosticGroupWarningsGuard(\n-          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n-    }\n-\n-    this.warningsGuard = new ComposeWarningsGuard(guards);\n+(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLESUSPENDED) {\n   }\n \n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLESUSPENDED_VARIABLESUSPENDED_VARIABLES) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-160/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 16:40:49.676503577 +0200\n+++ /tmp/tmp5nx9nw5u.java\t2022-07-19 16:40:49.676503577 +0200\n@@ -270,17 +270,11 @@\n     // variables later so that the compiler doesn't crash. It also\n     // checks the externs file for validity. If you don't want to warn\n     // about missing variable declarations, we shut that specific\n     // error off.\n     if (!options.checkSymbols &&\n-        (warningsGuard == null || !warningsGuard.disables(\n-            DiagnosticGroups.CHECK_VARIABLES))) {\n-      guards.add(new DiagnosticGroupWarningsGuard(\n-          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n-    }\n-\n-    this.warningsGuard = new ComposeWarningsGuard(guards);\n+(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLESUSPENDED_VARIABLESUSPENDED_VARIABLES) {\n   }\n \n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLESUSPENDED_VARIABLES;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-160/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 16:40:52.192487615 +0200\n+++ /tmp/tmpa4tqda8b.java\t2022-07-19 16:40:52.192487615 +0200\n@@ -270,17 +270,11 @@\n     // variables later so that the compiler doesn't crash. It also\n     // checks the externs file for validity. If you don't want to warn\n     // about missing variable declarations, we shut that specific\n     // error off.\n     if (!options.checkSymbols &&\n-        (warningsGuard == null || !warningsGuard.disables(\n-            DiagnosticGroups.CHECK_VARIABLES))) {\n-      guards.add(new DiagnosticGroupWarningsGuard(\n-          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n-    }\n-\n-    this.warningsGuard = new ComposeWarningsGuard(guards);\n+(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLESUSPENDED_VARIABLES;\n   }\n \n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLESUSPENDEDDEDWarningsGuard) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-160/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 16:40:54.708471651 +0200\n+++ /tmp/tmp65luj_dy.java\t2022-07-19 16:40:54.712471627 +0200\n@@ -270,17 +270,11 @@\n     // variables later so that the compiler doesn't crash. It also\n     // checks the externs file for validity. If you don't want to warn\n     // about missing variable declarations, we shut that specific\n     // error off.\n     if (!options.checkSymbols &&\n-        (warningsGuard == null || !warningsGuard.disables(\n-            DiagnosticGroups.CHECK_VARIABLES))) {\n-      guards.add(new DiagnosticGroupWarningsGuard(\n-          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n-    }\n-\n-    this.warningsGuard = new ComposeWarningsGuard(guards);\n+(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLESUSPENDEDDEDWarningsGuard) {\n   }\n \n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "(warningsGuard == null || !warningsGuard.disables( DiagnosticGroups.CHECK_VARIABLES))) { guards.add(new DiagnosticGroupWarningsGuard( DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF)); } this.warningsGuard = new ComposeWarningsGuard(guards);",
        "fixed_line": "ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards); // All passes must run the variable check. This synthesizes // variables later so that the compiler doesn't crash. It also // checks the externs file for validity. If you don't want to warn // about missing variable declarations, we shut that specific // error off. if (!options.checkSymbols && !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) { composedGuards.addGuard(new DiagnosticGroupWarningsGuard( DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF)); } this.warningsGuard = composedGuards;"
    },
    "Math-50": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x0 = x1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2022-07-19 16:40:57.552453605 +0200\n+++ /tmp/tmpzcfiwf1o.java\t2022-07-19 16:40:57.600453303 +0200\n@@ -182,14 +182,11 @@\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x0 = x1);\n                     break;\n                 default:\n                     // Should never happen.\n                     throw new MathInternalError();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x0 = x0); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2022-07-19 16:41:00.056437716 +0200\n+++ /tmp/tmpps7affps.java\t2022-07-19 16:41:00.056437716 +0200\n@@ -182,14 +182,11 @@\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x0 = x0); }\n                     break;\n                 default:\n                     // Should never happen.\n                     throw new MathInternalError();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x1 = x0);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2022-07-19 16:41:02.040425127 +0200\n+++ /tmp/tmpab8x0iib.java\t2022-07-19 16:41:02.040425127 +0200\n@@ -182,14 +182,11 @@\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x1 = x0);\n                     break;\n                 default:\n                     // Should never happen.\n                     throw new MathInternalError();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x0 = x0); if (x0 = x0); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2022-07-19 16:41:04.088412131 +0200\n+++ /tmp/tmp5g0vqlf1.java\t2022-07-19 16:41:04.088412131 +0200\n@@ -182,14 +182,11 @@\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x0 = x0); if (x0 = x0); }\n                     break;\n                 default:\n                     // Should never happen.\n                     throw new MathInternalError();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x0 = x0); double x0 = x0);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2022-07-19 16:41:06.076399512 +0200\n+++ /tmp/tmpc2k6wvgg.java\t2022-07-19 16:41:06.076399512 +0200\n@@ -182,14 +182,11 @@\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x0 = x0); double x0 = x0);\n                     break;\n                 default:\n                     // Should never happen.\n                     throw new MathInternalError();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x0 = x0); } else if (x0 = x0); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2022-07-19 16:41:08.076386819 +0200\n+++ /tmp/tmp91uwq_8d.java\t2022-07-19 16:41:08.076386819 +0200\n@@ -182,14 +182,11 @@\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x0 = x0); } else if (x0 = x0); }\n                     break;\n                 default:\n                     // Should never happen.\n                     throw new MathInternalError();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x1 = x0); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2022-07-19 16:41:10.092374023 +0200\n+++ /tmp/tmpfssch2l7.java\t2022-07-19 16:41:10.092374023 +0200\n@@ -182,14 +182,11 @@\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x1 = x0); }\n                     break;\n                 default:\n                     // Should never happen.\n                     throw new MathInternalError();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (x0 = 0.5 * (x0 + x1 - x0) * (x1 = x0 - f1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2022-07-19 16:41:12.004361888 +0200\n+++ /tmp/tmpscfwupqj.java\t2022-07-19 16:41:12.004361888 +0200\n@@ -182,14 +182,11 @@\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+if (x0 = 0.5 * (x0 + x1 - x0) * (x1 = x0 - f1;\n                     break;\n                 default:\n                     // Should never happen.\n                     throw new MathInternalError();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x0 = x0);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2022-07-19 16:41:14.016349115 +0200\n+++ /tmp/tmp85lgb_5l.java\t2022-07-19 16:41:14.016349115 +0200\n@@ -182,14 +182,11 @@\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x0 = x0);\n                     break;\n                 default:\n                     // Should never happen.\n                     throw new MathInternalError();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (x0 = 0.5 * (x0 + x1) / (x0 = x1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2022-07-19 16:41:16.016336418 +0200\n+++ /tmp/tmp_etk9t3p.java\t2022-07-19 16:41:16.016336418 +0200\n@@ -182,14 +182,11 @@\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+if (x0 = 0.5 * (x0 + x1) / (x0 = x1);\n                     break;\n                 default:\n                     // Should never happen.\n                     throw new MathInternalError();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); }",
        "fixed_line": ""
    },
    "Cli-26": {
        "fixes": [
            {
                "k": 1,
                "patch": "Option option = new Option(opt, description);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-26/src/java/org/apache/commons/cli/OptionBuilder.java\t2022-07-19 16:41:18.264322149 +0200\n+++ /tmp/tmpzk4o3rtk.java\t2022-07-19 16:41:18.344321638 +0200\n@@ -344,11 +344,11 @@\n      * a valid character.  See Option.\n      */\n     public static Option create(String opt) throws IllegalArgumentException\n     {\n             // create the option\n-        Option option = new Option(opt, description);\n+Option option = new Option(opt, description);\n \n             // set the option properties\n             option.setLongOpt(longopt);\n             option.setRequired(required);\n             option.setOptionalArg(optionalArg);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "Option option = new Option(opt, description;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-26/src/java/org/apache/commons/cli/OptionBuilder.java\t2022-07-19 16:41:20.944305131 +0200\n+++ /tmp/tmpba8leees.java\t2022-07-19 16:41:20.944305131 +0200\n@@ -344,11 +344,11 @@\n      * a valid character.  See Option.\n      */\n     public static Option create(String opt) throws IllegalArgumentException\n     {\n             // create the option\n-        Option option = new Option(opt, description);\n+Option option = new Option(opt, description;\n \n             // set the option properties\n             option.setLongOpt(longopt);\n             option.setRequired(required);\n             option.setOptionalArg(optionalArg);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "Option option = new Option(opt, option;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-26/src/java/org/apache/commons/cli/OptionBuilder.java\t2022-07-19 16:41:22.476295407 +0200\n+++ /tmp/tmpcq62tt6z.java\t2022-07-19 16:41:22.476295407 +0200\n@@ -344,11 +344,11 @@\n      * a valid character.  See Option.\n      */\n     public static Option create(String opt) throws IllegalArgumentException\n     {\n             // create the option\n-        Option option = new Option(opt, description);\n+Option option = new Option(opt, option;\n \n             // set the option properties\n             option.setLongOpt(longopt);\n             option.setRequired(required);\n             option.setOptionalArg(optionalArg);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "Option option = new Option(opt, option);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-26/src/java/org/apache/commons/cli/OptionBuilder.java\t2022-07-19 16:41:23.992285779 +0200\n+++ /tmp/tmpty4z_hz7.java\t2022-07-19 16:41:23.992285779 +0200\n@@ -344,11 +344,11 @@\n      * a valid character.  See Option.\n      */\n     public static Option create(String opt) throws IllegalArgumentException\n     {\n             // create the option\n-        Option option = new Option(opt, description);\n+Option option = new Option(opt, option);\n \n             // set the option properties\n             option.setLongOpt(longopt);\n             option.setRequired(required);\n             option.setOptionalArg(optionalArg);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "Option option = new Option(opt, option.length;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-26/src/java/org/apache/commons/cli/OptionBuilder.java\t2022-07-19 16:41:25.592275619 +0200\n+++ /tmp/tmpl3_kqikh.java\t2022-07-19 16:41:25.592275619 +0200\n@@ -344,11 +344,11 @@\n      * a valid character.  See Option.\n      */\n     public static Option create(String opt) throws IllegalArgumentException\n     {\n             // create the option\n-        Option option = new Option(opt, description);\n+Option option = new Option(opt, option.length;\n \n             // set the option properties\n             option.setLongOpt(longopt);\n             option.setRequired(required);\n             option.setOptionalArg(optionalArg);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "Option option = new Option(opt, description,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-26/src/java/org/apache/commons/cli/OptionBuilder.java\t2022-07-19 16:41:27.036266449 +0200\n+++ /tmp/tmpdaom8k7s.java\t2022-07-19 16:41:27.036266449 +0200\n@@ -344,11 +344,11 @@\n      * a valid character.  See Option.\n      */\n     public static Option create(String opt) throws IllegalArgumentException\n     {\n             // create the option\n-        Option option = new Option(opt, description);\n+Option option = new Option(opt, description,\n \n             // set the option properties\n             option.setLongOpt(longopt);\n             option.setRequired(required);\n             option.setOptionalArg(optionalArg);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "Option option = new Option;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-26/src/java/org/apache/commons/cli/OptionBuilder.java\t2022-07-19 16:41:28.568256723 +0200\n+++ /tmp/tmp91iqfz48.java\t2022-07-19 16:41:28.568256723 +0200\n@@ -344,11 +344,11 @@\n      * a valid character.  See Option.\n      */\n     public static Option create(String opt) throws IllegalArgumentException\n     {\n             // create the option\n-        Option option = new Option(opt, description);\n+Option option = new Option;\n \n             // set the option properties\n             option.setLongOpt(longopt);\n             option.setRequired(required);\n             option.setOptionalArg(optionalArg);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "Option option = new Option(opt, option.length);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-26/src/java/org/apache/commons/cli/OptionBuilder.java\t2022-07-19 16:41:30.084247094 +0200\n+++ /tmp/tmpf1sjssu9.java\t2022-07-19 16:41:30.084247094 +0200\n@@ -344,11 +344,11 @@\n      * a valid character.  See Option.\n      */\n     public static Option create(String opt) throws IllegalArgumentException\n     {\n             // create the option\n-        Option option = new Option(opt, description);\n+Option option = new Option(opt, option.length);\n \n             // set the option properties\n             option.setLongOpt(longopt);\n             option.setRequired(required);\n             option.setOptionalArg(optionalArg);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "Option option = new Option(opt,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-26/src/java/org/apache/commons/cli/OptionBuilder.java\t2022-07-19 16:41:31.736236602 +0200\n+++ /tmp/tmprqukd_4e.java\t2022-07-19 16:41:31.736236602 +0200\n@@ -344,11 +344,11 @@\n      * a valid character.  See Option.\n      */\n     public static Option create(String opt) throws IllegalArgumentException\n     {\n             // create the option\n-        Option option = new Option(opt, description);\n+Option option = new Option(opt,\n \n             // set the option properties\n             option.setLongOpt(longopt);\n             option.setRequired(required);\n             option.setOptionalArg(optionalArg);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "Option option = new Option(opt, option.value);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-26/src/java/org/apache/commons/cli/OptionBuilder.java\t2022-07-19 16:41:33.296226696 +0200\n+++ /tmp/tmpu8dwrhcn.java\t2022-07-19 16:41:33.296226696 +0200\n@@ -344,11 +344,11 @@\n      * a valid character.  See Option.\n      */\n     public static Option create(String opt) throws IllegalArgumentException\n     {\n             // create the option\n-        Option option = new Option(opt, description);\n+Option option = new Option(opt, option.value);\n \n             // set the option properties\n             option.setLongOpt(longopt);\n             option.setRequired(required);\n             option.setOptionalArg(optionalArg);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "Option option = new Option(opt, description);",
        "fixed_line": "Option option = null; try { // create the option option = new Option(opt, description); // set the option properties option.setLongOpt(longopt); option.setRequired(required); option.setOptionalArg(optionalArg); option.setArgs(numberOfArgs); option.setType(type); option.setValueSeparator(valuesep); option.setArgName(argName); } finally { // reset the OptionBuilder properties OptionBuilder.reset(); }"
    },
    "Math-53": {
        "fixes": [
            {
                "k": 1,
                "patch": "return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }",
                "patch_diff": "return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return createComplex(rhs + rhs.getReal(), imaginary + rhs.getImaginary()); }",
                "patch_diff": "return createComplex(rhs + rhs.getReal(), imaginary + rhs.getImaginary()); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0; i < lhs.getReal(), imaginary + rhs.getImaginary()); }",
                "patch_diff": "for (int i = 0; i < lhs.getReal(), imaginary + rhs.getImaginary()); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new NullArgumentException(\"Objects of type \" + rhs.getReal(), imaginary + rhs.getImaginary()); }",
                "patch_diff": "throw new NullArgumentException(\"Objects of type \" + rhs.getReal(), imaginary + rhs.getImaginary()); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "throw new NullArgumentException(rhs.checkNotNull(rhs.getReal(), imaginary + rhs.getImaginary()); }",
                "patch_diff": "throw new NullArgumentException(rhs.checkNotNull(rhs.getReal(), imaginary + rhs.getImaginary()); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "throw new NullArgumentException(rhs.checkNotNull(real + rhs.getReal(), imaginary + rhs.getImaginary()); }",
                "patch_diff": "throw new NullArgumentException(rhs.checkNotNull(real + rhs.getReal(), imaginary + rhs.getImaginary()); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} NullArgumentException(rhs.checkNotNull(real + rhs.getReal(), imaginary + rhs.getImaginary()); }",
                "patch_diff": "} NullArgumentException(rhs.checkNotNull(real + rhs.getReal(), imaginary + rhs.getImaginary()); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} NullArgumentException(rhs.checkNotNull(real + rhs.getReal(), imaginary + rhs.getImaginary());",
                "patch_diff": "} NullArgumentException(rhs.checkNotNull(real + rhs.getReal(), imaginary + rhs.getImaginary());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "throw new NullArgumentException(rhs.getReal(), imaginary + rhs.getImaginary()); }",
                "patch_diff": "throw new NullArgumentException(rhs.getReal(), imaginary + rhs.getImaginary()); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());",
                "patch_diff": "return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (isNaN || rhs.isNaN) { return NaN; }"
    },
    "Time-4": {
        "fixes": [
            {
                "k": 1,
                "patch": "Partial newPartial = new Partial(0, newTypes, newValues);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-4/src/main/java/org/joda/time/Partial.java\t2022-07-19 16:41:36.748204769 +0200\n+++ /tmp/tmpi532w5t9.java\t2022-07-19 16:41:36.800204439 +0200\n@@ -459,11 +459,11 @@\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+Partial newPartial = new Partial(0, newTypes, newValues);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n         if (value == getValue(index)) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "Partial newPartial = new Partial; iChronology, newTypes, newValues);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-4/src/main/java/org/joda/time/Partial.java\t2022-07-19 16:41:38.836191508 +0200\n+++ /tmp/tmpo8eclnbr.java\t2022-07-19 16:41:38.836191508 +0200\n@@ -459,11 +459,11 @@\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+Partial newPartial = new Partial; iChronology, newTypes, newValues);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n         if (value == getValue(index)) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "Partial newPartial = new Partial(iChronology, newTypes, newValues);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-4/src/main/java/org/joda/time/Partial.java\t2022-07-19 16:41:40.332182004 +0200\n+++ /tmp/tmp4elcl06b.java\t2022-07-19 16:41:40.332182004 +0200\n@@ -459,11 +459,11 @@\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+Partial newPartial = new Partial(iChronology, newTypes, newValues);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n         if (value == getValue(index)) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "Partial newPartial = newPartial(minChronology, newTypes, newValues);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-4/src/main/java/org/joda/time/Partial.java\t2022-07-19 16:41:54.952089116 +0200\n+++ /tmp/tmpc64gflbj.java\t2022-07-19 16:41:54.952089116 +0200\n@@ -459,11 +459,11 @@\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+Partial newPartial = newPartial(minChronology, newTypes, newValues);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n         if (value == getValue(index)) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "Partial newPartial = new Partial(iChronology, newTypes, newValues;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-4/src/main/java/org/joda/time/Partial.java\t2022-07-19 16:41:57.696071679 +0200\n+++ /tmp/tmptlf15m6x.java\t2022-07-19 16:41:57.696071679 +0200\n@@ -459,11 +459,11 @@\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+Partial newPartial = new Partial(iChronology, newTypes, newValues;\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n         if (value == getValue(index)) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "Partial newPartial = newPartial(iChronology, newTypes, newValues);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-4/src/main/java/org/joda/time/Partial.java\t2022-07-19 16:41:59.308061435 +0200\n+++ /tmp/tmpu3wwtk4l.java\t2022-07-19 16:41:59.308061435 +0200\n@@ -459,11 +459,11 @@\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+Partial newPartial = newPartial(iChronology, newTypes, newValues);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n         if (value == getValue(index)) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "Partial newPartial = new PartialContext, newTypes, newValues);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-4/src/main/java/org/joda/time/Partial.java\t2022-07-19 16:42:01.032050479 +0200\n+++ /tmp/tmp0svc9hc4.java\t2022-07-19 16:42:01.032050479 +0200\n@@ -459,11 +459,11 @@\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+Partial newPartial = new PartialContext, newTypes, newValues);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n         if (value == getValue(index)) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "Partial newPartial = new Partial[iChronology, newTypes, newValues);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-4/src/main/java/org/joda/time/Partial.java\t2022-07-19 16:42:02.532040946 +0200\n+++ /tmp/tmpc40jijiw.java\t2022-07-19 16:42:02.536040918 +0200\n@@ -459,11 +459,11 @@\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+Partial newPartial = new Partial[iChronology, newTypes, newValues);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n         if (value == getValue(index)) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "Partial newPartial = newPartial(minChronology, newTypes, newValues;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-4/src/main/java/org/joda/time/Partial.java\t2022-07-19 16:42:04.084031080 +0200\n+++ /tmp/tmp87bxx0ui.java\t2022-07-19 16:42:04.084031080 +0200\n@@ -459,11 +459,11 @@\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+Partial newPartial = newPartial(minChronology, newTypes, newValues;\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n         if (value == getValue(index)) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "Partial newPartial = new Partial[iChronology, newTypes, newValues;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-4/src/main/java/org/joda/time/Partial.java\t2022-07-19 16:42:05.628021266 +0200\n+++ /tmp/tmpfmuogucv.java\t2022-07-19 16:42:05.628021266 +0200\n@@ -459,11 +459,11 @@\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+Partial newPartial = new Partial[iChronology, newTypes, newValues;\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n         if (value == getValue(index)) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "Partial newPartial = new Partial(iChronology, newTypes, newValues);",
        "fixed_line": "Partial newPartial = new Partial(newTypes, newValues, iChronology);"
    },
    "Mockito-7": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (type instanceof Class<?>) {",
                "patch_diff": "} else if (type instanceof Class<?>) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} registerTypeVariablesOn(type);",
                "patch_diff": "} registerTypeVariablesOn(type);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (TypeVariables : type.getBounds()) { registerType = type.getActualType(); } registerType = type.getActualType(); }",
                "patch_diff": "for (TypeVariables : type.getBounds()) { registerType = type.getActualType(); } registerType = type.getActualType(); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (TypeVariables : type.getBounds()) { registerTypeVariablesOn(type); } registerType = type.getActualType(); }",
                "patch_diff": "for (TypeVariables : type.getBounds()) { registerTypeVariablesOn(type); } registerType = type.getActualType(); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (type instanceof Type) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type); }",
                "patch_diff": "} else if (type instanceof Type) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (TypeVariables : type.getBounds()) { registerTypeVariablesOn(type); } registerType(type); }",
                "patch_diff": "for (TypeVariables : type.getBounds()) { registerTypeVariablesOn(type); } registerType(type); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (TypeVariables : type.getBounds()) { registerType = type; } registerType = type.getActualType(); }",
                "patch_diff": "for (TypeVariables : type.getBounds()) { registerType = type; } registerType = type.getActualType(); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} registerTypeVariablesOn(type,",
                "patch_diff": "} registerTypeVariablesOn(type,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (TypeVariables : type.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type); }",
                "patch_diff": "for (TypeVariables : type.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (TypeVariables : type.getBounds()) {",
                "patch_diff": "for (TypeVariables : type.getBounds()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "registerTypeParametersOn(new TypeVariable[] { typeVariable });"
    },
    "Closure-120": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (block.isFunction) {",
                "patch_diff": "} else if (block.isFunction) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (block.isFunction) {",
                "patch_diff": "if (block.isFunction) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "block = block.getParent()) {",
                "patch_diff": "block = block.getParent()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "block = fn.isFunction;",
                "patch_diff": "block = fn.isFunction;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "block = block.isFunction;",
                "patch_diff": "block = block.isFunction;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (block == null) {",
                "patch_diff": "if (block == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "block = fnType.isFunction;",
                "patch_diff": "block = fnType.isFunction;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// block == null; block = block.",
                "patch_diff": "// block == null; block = block.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// block only override if more specific",
                "patch_diff": "// block only override if more specific",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// block == null; block = ref.block;",
                "patch_diff": "// block == null; block = ref.block;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (ref.getSymbol().getScope() != ref.scope) { return false; }"
    },
    "Closure-7": {
        "fixes": [
            {
                "k": 1,
                "patch": "return ctorType && ctorType.isSubtype(typetype)? ctorType : null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2022-07-19 16:42:10.915987652 +0200\n+++ /tmp/tmpsrin5q8n.java\t2022-07-19 16:42:10.967987324 +0200\n@@ -608,11 +608,11 @@\n \n     @Override\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+return ctorType && ctorType.isSubtype(typetype)? ctorType : null;\n           // Objects are restricted to \"Function\", subtypes are left\n           // Only filter out subtypes of \"function\"\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return resultEqualsValue && ctorType.isSubtype(typetype)? ctorType : null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2022-07-19 16:42:15.871956146 +0200\n+++ /tmp/tmp8ysp2cph.java\t2022-07-19 16:42:15.871956146 +0200\n@@ -608,11 +608,11 @@\n \n     @Override\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+return resultEqualsValue && ctorType.isSubtype(typetype)? ctorType : null;\n           // Objects are restricted to \"Function\", subtypes are left\n           // Only filter out subtypes of \"function\"\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return resultEqualsValue && ctorType.isSubtype(type, ctorType? ctorType : null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2022-07-19 16:42:19.351934019 +0200\n+++ /tmp/tmph5yyar16.java\t2022-07-19 16:42:19.351934019 +0200\n@@ -608,11 +608,11 @@\n \n     @Override\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+return resultEqualsValue && ctorType.isSubtype(type, ctorType? ctorType : null;\n           // Objects are restricted to \"Function\", subtypes are left\n           // Only filter out subtypes of \"function\"\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return resultEqualsValue && ctorType.isSubtype(type == null? ctorType : null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2022-07-19 16:42:22.699912733 +0200\n+++ /tmp/tmpb2w01tkr.java\t2022-07-19 16:42:22.699912733 +0200\n@@ -608,11 +608,11 @@\n \n     @Override\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+return resultEqualsValue && ctorType.isSubtype(type == null? ctorType : null;\n           // Objects are restricted to \"Function\", subtypes are left\n           // Only filter out subtypes of \"function\"\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return resultEqualsValue && ctorType.isSubtype(typeOfType? ctorType : null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2022-07-19 16:42:25.943892103 +0200\n+++ /tmp/tmpcnf7ea6h.java\t2022-07-19 16:42:25.943892103 +0200\n@@ -608,11 +608,11 @@\n \n     @Override\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+return resultEqualsValue && ctorType.isSubtype(typeOfType? ctorType : null;\n           // Objects are restricted to \"Function\", subtypes are left\n           // Only filter out subtypes of \"function\"\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return resultEqualsValue && ctorType.isSubtype(type? ctorType : null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2022-07-19 16:42:29.187871474 +0200\n+++ /tmp/tmphfly37ya.java\t2022-07-19 16:42:29.187871474 +0200\n@@ -608,11 +608,11 @@\n \n     @Override\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+return resultEqualsValue && ctorType.isSubtype(type? ctorType : null;\n           // Objects are restricted to \"Function\", subtypes are left\n           // Only filter out subtypes of \"function\"\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return resultEqualsValue && ctorType.isSubtype(type)? ctorType : null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2022-07-19 16:42:32.415850944 +0200\n+++ /tmp/tmp55z1rhol.java\t2022-07-19 16:42:32.415850944 +0200\n@@ -608,11 +608,11 @@\n \n     @Override\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+return resultEqualsValue && ctorType.isSubtype(type)? ctorType : null;\n           // Objects are restricted to \"Function\", subtypes are left\n           // Only filter out subtypes of \"function\"\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return resultEqualsValue && ctorType.isSubtype(type))? ctorType : null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2022-07-19 16:43:21.291539920 +0200\n+++ /tmp/tmpqtx56mab.java\t2022-07-19 16:43:21.291539920 +0200\n@@ -608,11 +608,11 @@\n \n     @Override\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+return resultEqualsValue && ctorType.isSubtype(type))? ctorType : null;\n           // Objects are restricted to \"Function\", subtypes are left\n           // Only filter out subtypes of \"function\"\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return ctorType && ctorType.isSubtype(type)? ctorType : null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2022-07-19 16:43:24.547519187 +0200\n+++ /tmp/tmpl2ogqg1f.java\t2022-07-19 16:43:24.551519163 +0200\n@@ -608,11 +608,11 @@\n \n     @Override\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+return ctorType && ctorType.isSubtype(type)? ctorType : null;\n           // Objects are restricted to \"Function\", subtypes are left\n           // Only filter out subtypes of \"function\"\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return resultEqualsValue && ctorType.isSubtype(type : null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2022-07-19 16:43:28.063496800 +0200\n+++ /tmp/tmp54ji73sa.java\t2022-07-19 16:43:28.063496800 +0200\n@@ -608,11 +608,11 @@\n \n     @Override\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+return resultEqualsValue && ctorType.isSubtype(type : null;\n           // Objects are restricted to \"Function\", subtypes are left\n           // Only filter out subtypes of \"function\"\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;",
        "fixed_line": "if (resultEqualsValue) { // Objects are restricted to \"Function\", subtypes are left return ctorType.getGreatestSubtype(type); } else { // Only filter out subtypes of \"function\" return type.isSubtype(ctorType) ? null : type; }"
    },
    "JacksonDatabind-45": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (format.getShapeClass == JsonFormat.Shape.STRING) { // could still be null",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-45/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 16:43:31.787473083 +0200\n+++ /tmp/tmpxo6bsh6s.java\t2022-07-19 16:43:31.819472880 +0200\n@@ -58,11 +58,11 @@\n                 JsonFormat.Shape shape = format.getShape();\n                 if (shape.isNumeric()) {\n                     return withFormat(Boolean.TRUE, null);\n                 }\n \n-                if (format.getShape() == JsonFormat.Shape.STRING) {\n+if (format.getShapeClass == JsonFormat.Shape.STRING) { // could still be null\n                     TimeZone tz = format.getTimeZone();\n                     final String pattern = format.hasPattern()\n                                     ? format.getPattern()\n                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                     final Locale loc = format.hasLocale()\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (format.getShapeClass == JsonFormat.Shape.STRING) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-45/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 16:43:34.099458360 +0200\n+++ /tmp/tmp7_yxx9mj.java\t2022-07-19 16:43:34.099458360 +0200\n@@ -58,11 +58,11 @@\n                 JsonFormat.Shape shape = format.getShape();\n                 if (shape.isNumeric()) {\n                     return withFormat(Boolean.TRUE, null);\n                 }\n \n-                if (format.getShape() == JsonFormat.Shape.STRING) {\n+if (format.getShapeClass == JsonFormat.Shape.STRING) {\n                     TimeZone tz = format.getTimeZone();\n                     final String pattern = format.hasPattern()\n                                     ? format.getPattern()\n                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                     final Locale loc = format.hasLocale()\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (format.getShape() == JsonFormat.Shape.STRING) { // could still be null",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-45/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 16:43:35.839447279 +0200\n+++ /tmp/tmpgrl94gxp.java\t2022-07-19 16:43:35.839447279 +0200\n@@ -58,11 +58,11 @@\n                 JsonFormat.Shape shape = format.getShape();\n                 if (shape.isNumeric()) {\n                     return withFormat(Boolean.TRUE, null);\n                 }\n \n-                if (format.getShape() == JsonFormat.Shape.STRING) {\n+if (format.getShape() == JsonFormat.Shape.STRING) { // could still be null\n                     TimeZone tz = format.getTimeZone();\n                     final String pattern = format.hasPattern()\n                                     ? format.getPattern()\n                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                     final Locale loc = format.hasLocale()\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (format.getShapeCount == JsonFormat.Shape.STRING) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-45/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 16:44:14.635200108 +0200\n+++ /tmp/tmpab_7v2j4.java\t2022-07-19 16:44:14.635200108 +0200\n@@ -58,11 +58,11 @@\n                 JsonFormat.Shape shape = format.getShape();\n                 if (shape.isNumeric()) {\n                     return withFormat(Boolean.TRUE, null);\n                 }\n \n-                if (format.getShape() == JsonFormat.Shape.STRING) {\n+if (format.getShapeCount == JsonFormat.Shape.STRING) {\n                     TimeZone tz = format.getTimeZone();\n                     final String pattern = format.hasPattern()\n                                     ? format.getPattern()\n                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                     final Locale loc = format.hasLocale()\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (format.getShapeOffset == JsonFormat.Shape.STRING) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-45/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 16:44:16.435188633 +0200\n+++ /tmp/tmp7v35pxia.java\t2022-07-19 16:44:16.435188633 +0200\n@@ -58,11 +58,11 @@\n                 JsonFormat.Shape shape = format.getShape();\n                 if (shape.isNumeric()) {\n                     return withFormat(Boolean.TRUE, null);\n                 }\n \n-                if (format.getShape() == JsonFormat.Shape.STRING) {\n+if (format.getShapeOffset == JsonFormat.Shape.STRING) {\n                     TimeZone tz = format.getTimeZone();\n                     final String pattern = format.hasPattern()\n                                     ? format.getPattern()\n                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                     final Locale loc = format.hasLocale()\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (format.getShapeType == JsonFormat.Shape.STRING) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-45/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 16:44:18.091178078 +0200\n+++ /tmp/tmper1jj2pg.java\t2022-07-19 16:44:18.091178078 +0200\n@@ -58,11 +58,11 @@\n                 JsonFormat.Shape shape = format.getShape();\n                 if (shape.isNumeric()) {\n                     return withFormat(Boolean.TRUE, null);\n                 }\n \n-                if (format.getShape() == JsonFormat.Shape.STRING) {\n+if (format.getShapeType == JsonFormat.Shape.STRING) {\n                     TimeZone tz = format.getTimeZone();\n                     final String pattern = format.hasPattern()\n                                     ? format.getPattern()\n                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                     final Locale loc = format.hasLocale()\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (format.getShapeCount == JsonFormat.Shape.STRING) { // could still be null",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-45/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 16:44:19.831166989 +0200\n+++ /tmp/tmpe08zv3en.java\t2022-07-19 16:44:19.831166989 +0200\n@@ -58,11 +58,11 @@\n                 JsonFormat.Shape shape = format.getShape();\n                 if (shape.isNumeric()) {\n                     return withFormat(Boolean.TRUE, null);\n                 }\n \n-                if (format.getShape() == JsonFormat.Shape.STRING) {\n+if (format.getShapeCount == JsonFormat.Shape.STRING) { // could still be null\n                     TimeZone tz = format.getTimeZone();\n                     final String pattern = format.hasPattern()\n                                     ? format.getPattern()\n                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                     final Locale loc = format.hasLocale()\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (format.getShape()!= JsonFormat.Shape.STRING) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-45/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 16:44:21.651155387 +0200\n+++ /tmp/tmpy3zpucv2.java\t2022-07-19 16:44:21.651155387 +0200\n@@ -58,11 +58,11 @@\n                 JsonFormat.Shape shape = format.getShape();\n                 if (shape.isNumeric()) {\n                     return withFormat(Boolean.TRUE, null);\n                 }\n \n-                if (format.getShape() == JsonFormat.Shape.STRING) {\n+if (format.getShape()!= JsonFormat.Shape.STRING) {\n                     TimeZone tz = format.getTimeZone();\n                     final String pattern = format.hasPattern()\n                                     ? format.getPattern()\n                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                     final Locale loc = format.hasLocale()\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (format.getShapeType == JsonFormat.Shape.STRING) { // could still be null",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-45/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 16:44:58.167014669 +0200\n+++ /tmp/tmpunfgto0s.java\t2022-07-19 16:44:58.167014669 +0200\n@@ -58,11 +58,11 @@\n                 JsonFormat.Shape shape = format.getShape();\n                 if (shape.isNumeric()) {\n                     return withFormat(Boolean.TRUE, null);\n                 }\n \n-                if (format.getShape() == JsonFormat.Shape.STRING) {\n+if (format.getShapeType == JsonFormat.Shape.STRING) { // could still be null\n                     TimeZone tz = format.getTimeZone();\n                     final String pattern = format.hasPattern()\n                                     ? format.getPattern()\n                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                     final Locale loc = format.hasLocale()\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (format.getShape == JsonFormat.Shape.STRING) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-45/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 16:44:59.843014728 +0200\n+++ /tmp/tmp944ekvc2.java\t2022-07-19 16:44:59.843014728 +0200\n@@ -58,11 +58,11 @@\n                 JsonFormat.Shape shape = format.getShape();\n                 if (shape.isNumeric()) {\n                     return withFormat(Boolean.TRUE, null);\n                 }\n \n-                if (format.getShape() == JsonFormat.Shape.STRING) {\n+if (format.getShape == JsonFormat.Shape.STRING) {\n                     TimeZone tz = format.getTimeZone();\n                     final String pattern = format.hasPattern()\n                                     ? format.getPattern()\n                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                     final Locale loc = format.hasLocale()\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (format.getShape() == JsonFormat.Shape.STRING) {",
        "fixed_line": "if ((shape == JsonFormat.Shape.STRING) || format.hasPattern() || format.hasLocale() || format.hasTimeZone()) {"
    },
    "JacksonDatabind-82": {
        "fixes": [
            {
                "k": 1,
                "patch": "ignored = ignoreAny.getIgnored;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-82/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\t2022-07-19 16:45:01.691014756 +0200\n+++ /tmp/tmp7382mjbd.java\t2022-07-19 16:45:01.743014756 +0200\n@@ -490,11 +490,11 @@\n \n         if (ignorals != null) {\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.getIgnored();\n+ignored = ignoreAny.getIgnored;\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n         } else {\n             ignored = Collections.emptySet();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "ignored = ignoreAnyals.getIgnored;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-82/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\t2022-07-19 16:45:04.059014736 +0200\n+++ /tmp/tmpes4umdd9.java\t2022-07-19 16:45:04.063014736 +0200\n@@ -490,11 +490,11 @@\n \n         if (ignorals != null) {\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.getIgnored();\n+ignored = ignoreAnyals.getIgnored;\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n         } else {\n             ignored = Collections.emptySet();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "ignored = ignoreAny.getIgnored();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-82/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\t2022-07-19 16:45:05.875014678 +0200\n+++ /tmp/tmpj6bxjmg5.java\t2022-07-19 16:45:05.875014678 +0200\n@@ -490,11 +490,11 @@\n \n         if (ignorals != null) {\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.getIgnored();\n+ignored = ignoreAny.getIgnored();\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n         } else {\n             ignored = Collections.emptySet();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "ignored = ignoreAnyals.getIgnored();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-82/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\t2022-07-19 16:45:07.643014586 +0200\n+++ /tmp/tmpiqk38qxo.java\t2022-07-19 16:45:07.647014586 +0200\n@@ -490,11 +490,11 @@\n \n         if (ignorals != null) {\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.getIgnored();\n+ignored = ignoreAnyals.getIgnored();\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n         } else {\n             ignored = Collections.emptySet();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "ignored = ignoredBuilderals.getIgnored;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-82/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\t2022-07-19 16:45:09.451014457 +0200\n+++ /tmp/tmpduwvzo1k.java\t2022-07-19 16:45:09.455014457 +0200\n@@ -490,11 +490,11 @@\n \n         if (ignorals != null) {\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.getIgnored();\n+ignored = ignoredBuilderals.getIgnored;\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n         } else {\n             ignored = Collections.emptySet();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "ignored = ignoredObjectals.getIgnored();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-82/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\t2022-07-19 16:45:11.227014297 +0200\n+++ /tmp/tmppuov8m8b.java\t2022-07-19 16:45:11.227014297 +0200\n@@ -490,11 +490,11 @@\n \n         if (ignorals != null) {\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.getIgnored();\n+ignored = ignoredObjectals.getIgnored();\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n         } else {\n             ignored = Collections.emptySet();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "ignored = ignorals.getIgnored();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-82/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\t2022-07-19 16:45:13.003014103 +0200\n+++ /tmp/tmp9pp45rvm.java\t2022-07-19 16:45:13.007014103 +0200\n@@ -490,11 +490,11 @@\n \n         if (ignorals != null) {\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.getIgnored();\n+ignored = ignorals.getIgnored();\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n         } else {\n             ignored = Collections.emptySet();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "ignored = ignoredBuilderals.getIgnored();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-82/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\t2022-07-19 16:45:56.838998668 +0200\n+++ /tmp/tmp6iip1ym2.java\t2022-07-19 16:45:56.842998666 +0200\n@@ -490,11 +490,11 @@\n \n         if (ignorals != null) {\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.getIgnored();\n+ignored = ignoredBuilderals.getIgnored();\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n         } else {\n             ignored = Collections.emptySet();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "ignored = ignoredBuilder.getIgnored();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-82/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\t2022-07-19 16:45:58.550997664 +0200\n+++ /tmp/tmpuiu92xxr.java\t2022-07-19 16:45:58.550997664 +0200\n@@ -490,11 +490,11 @@\n \n         if (ignorals != null) {\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.getIgnored();\n+ignored = ignoredBuilder.getIgnored();\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n         } else {\n             ignored = Collections.emptySet();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "ignored = ignored.getIgnored();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-82/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\t2022-07-19 16:46:00.342996582 +0200\n+++ /tmp/tmppv3n9br6.java\t2022-07-19 16:46:00.342996582 +0200\n@@ -490,11 +490,11 @@\n \n         if (ignorals != null) {\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.getIgnored();\n+ignored = ignored.getIgnored();\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n         } else {\n             ignored = Collections.emptySet();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "ignored = ignorals.getIgnored();",
        "fixed_line": "ignored = ignorals.findIgnoredForDeserialization();"
    },
    "JacksonDatabind-47": {
        "fixes": [
            {
                "k": 1,
                "patch": "// } catch (Exception e) { throw new JsonMappingException(\"Failed to widen type \"+type.getName(), e); }",
                "patch_diff": "// } catch (Exception e) { throw new JsonMappingException(\"Failed to widen type \"+type.getName(), e); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// } catch (IllegalArgumentException iae) { throw new JsonMappingException(\"Failed to widen type \"+type.getName(), e); }",
                "patch_diff": "// } catch (IllegalArgumentException iae) { throw new JsonMappingException(\"Failed to widen type \"+type.getName(), e); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// } catch (Exception e) { throw new JsonMappingException(e); }",
                "patch_diff": "// } catch (Exception e) { throw new JsonMappingException(e); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// } catch (Exception e) { throw new JsonMappingException(\"Failed to widen type \"+type); }",
                "patch_diff": "// } catch (Exception e) { throw new JsonMappingException(\"Failed to widen type \"+type); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// } catch (IllegalArgumentException iae) { throw new JsonMappingException(\"Failed to widen type \"+type+\" with content-type annotation (\"+t.getName(), e); }",
                "patch_diff": "// } catch (IllegalArgumentException iae) { throw new JsonMappingException(\"Failed to widen type \"+type+\" with content-type annotation (\"+t.getName(), e); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// } catch (IllegalArgumentException iae) { throw new JsonMappingException(\"Failed to widen type \"+type); }",
                "patch_diff": "// } catch (IllegalArgumentException iae) { throw new JsonMappingException(\"Failed to widen type \"+type); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// } catch (IllegalArgumentException iae) { throw new JsonMappingException(\"Failed to widen type \"+type+\" with content-type annotation (\"+keyClass.getName(), e); }",
                "patch_diff": "// } catch (IllegalArgumentException iae) { throw new JsonMappingException(\"Failed to widen type \"+type+\" with content-type annotation (\"+keyClass.getName(), e); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// } catch (Exception e) { throw new JsonMappingException(\"Failed to widen type \"+type+\" with content-type annotation (\"+t.getName(), e); }",
                "patch_diff": "// } catch (Exception e) { throw new JsonMappingException(\"Failed to widen type \"+type+\" with content-type annotation (\"+t.getName(), e); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// } catch (IllegalArgumentException iae) { throw new JsonMappingException(\"Failed to widen type \"+type+\" with key-type annotation (\"+keyClass.getName(), e); }",
                "patch_diff": "// } catch (IllegalArgumentException iae) { throw new JsonMappingException(\"Failed to widen type \"+type+\" with key-type annotation (\"+keyClass.getName(), e); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// }",
                "patch_diff": "// }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "Class<?> currRaw = type.getRawClass(); try { // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`, // may be needed here too in future? if (serClass.isAssignableFrom(currRaw)) { // common case type = tf.constructGeneralizedType(type, serClass); } else if (currRaw.isAssignableFrom(serClass)) { // specialization, ok as well type = tf.constructSpecializedType(type, serClass); } else { throw new JsonMappingException(null, String.format(\"Can not refine serialization type %s into %s; types not related\", type, serClass.getName())); }"
    },
    "Closure-119": {
        "fixes": [
            {
                "k": 1,
                "patch": "type = Name.Type.FUNCTION; break;",
                "patch_diff": "type = Name.Type.FUNCTION; break;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "switch (type) { case Token.FUNCTION: case Token.FUNCTION: case Token.INC: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.INC: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token",
                "patch_diff": "switch (type) { case Token.FUNCTION: case Token.FUNCTION: case Token.INC: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.INC: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "switch (type) { case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.INC: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.INC: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token",
                "patch_diff": "switch (type) { case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.INC: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.INC: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "switch (type) { case Token.FUNCTION: case Token.FUNCTION: case Token.INC: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.INC: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token",
                "patch_diff": "switch (type) { case Token.FUNCTION: case Token.FUNCTION: case Token.INC: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.INC: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "switch (type) { case Token.FUNCTION: case Token.FUNCTION: case Token.INC: case Token.FUNCTION: case Token.FUNCTION: case Token.INC: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token",
                "patch_diff": "switch (type) { case Token.FUNCTION: case Token.FUNCTION: case Token.INC: case Token.FUNCTION: case Token.FUNCTION: case Token.INC: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "switch (type) { case Token.FUNCTION: case Token.FUNCTION: case Token.INC: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.INC: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.INC: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token",
                "patch_diff": "switch (type) { case Token.FUNCTION: case Token.FUNCTION: case Token.INC: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.INC: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.INC: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "switch (type) { case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.INC: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token",
                "patch_diff": "switch (type) { case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.INC: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "switch (type) { case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.INC: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token",
                "patch_diff": "switch (type) { case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.INC: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "switch (type) { case Token.FUNCTION: case Token.FUNCTION: case Token.INC: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token",
                "patch_diff": "switch (type) { case Token.FUNCTION: case Token.FUNCTION: case Token.INC: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "switch (type) { case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.INC: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token",
                "patch_diff": "switch (type) { case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.INC: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token.FUNCTION: case Token",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "case Token.CATCH:"
    },
    "Math-39": {
        "fixes": [
            {
                "k": 1,
                "patch": "// next stages for (int k = 0; k < yDotK.length; ++k) {",
                "patch_diff": "// next stages for (int k = 0; k < yDotK.length; ++k) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// next stages for (int k = 0; k < x.length; ++k) {",
                "patch_diff": "// next stages for (int k = 0; k < x.length; ++k) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// next stages for (int k = 0; k < yDotK; ++k) {",
                "patch_diff": "// next stages for (int k = 0; k < yDotK; ++k) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int k = 0; k < x.length; ++k) {",
                "patch_diff": "for (int k = 0; k < x.length; ++k) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int k = 0; k < yDotK.length; ++k) {",
                "patch_diff": "for (int k = 0; k < yDotK.length; ++k) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int k = 0; k < x.length; ++j) {",
                "patch_diff": "for (int k = 0; k < x.length; ++j) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// next stages for (int k = 0; k < x.length; ++j) {",
                "patch_diff": "// next stages for (int k = 0; k < x.length; ++j) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int k = 0; k < yDotK; ++k) {",
                "patch_diff": "for (int k = 0; k < yDotK; ++k) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int k = 1; k < x.length; ++k) {",
                "patch_diff": "for (int k = 1; k < x.length; ++k) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// next stages for (int k = 0; k < yDotK; ++j) {",
                "patch_diff": "// next stages for (int k = 0; k < yDotK; ++j) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (forward) { if (stepStart + stepSize >= t) { stepSize = t - stepStart; } } else { if (stepStart + stepSize <= t) { stepSize = t - stepStart; } }"
    },
    "Time-20": {
        "fixes": [
            {
                "k": 1,
                "patch": "bucket.setZone(id = position + 1, text.length();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-20/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\t2022-07-19 16:46:08.154991495 +0200\n+++ /tmp/tmpgpbn3sa5.java\t2022-07-19 16:46:08.186991475 +0200\n@@ -2539,12 +2539,11 @@\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n+bucket.setZone(id = position + 1, text.length();\n                 }\n             }\n             return ~position;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "bucket.setZone(id = text.length - position + 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-20/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\t2022-07-19 16:46:09.982990218 +0200\n+++ /tmp/tmpp8u45nhz.java\t2022-07-19 16:46:09.982990218 +0200\n@@ -2539,12 +2539,11 @@\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n+bucket.setZone(id = text.length - position + 1;\n                 }\n             }\n             return ~position;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "bucket.setZone(DateTimeZone.forID(id + 1, text.length - position;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-20/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\t2022-07-19 16:46:11.586989071 +0200\n+++ /tmp/tmp3kz7i8yx.java\t2022-07-19 16:46:11.586989071 +0200\n@@ -2539,12 +2539,11 @@\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n+bucket.setZone(DateTimeZone.forID(id + 1, text.length - position;\n                 }\n             }\n             return ~position;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "bucket.setZone(DateTimeZone.forID(id + 1, text.length() - position;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-20/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\t2022-07-19 16:46:13.234987866 +0200\n+++ /tmp/tmpxd8o315z.java\t2022-07-19 16:46:13.238987861 +0200\n@@ -2539,12 +2539,11 @@\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n+bucket.setZone(DateTimeZone.forID(id + 1, text.length() - position;\n                 }\n             }\n             return ~position;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "bucket.setZone(id = position + 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-20/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\t2022-07-19 16:46:14.822986680 +0200\n+++ /tmp/tmpvs2kdtox.java\t2022-07-19 16:46:14.822986680 +0200\n@@ -2539,12 +2539,11 @@\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n+bucket.setZone(id = position + 1;\n                 }\n             }\n             return ~position;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "bucket.setZone(DateTimeZone.forID(id + 1, text.length();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-20/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\t2022-07-19 16:46:16.398985478 +0200\n+++ /tmp/tmpejxj8ru_.java\t2022-07-19 16:46:16.402985473 +0200\n@@ -2539,12 +2539,11 @@\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n+bucket.setZone(DateTimeZone.forID(id + 1, text.length();\n                 }\n             }\n             return ~position;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "bucket.setZone(id = str + id;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-20/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\t2022-07-19 16:46:17.966984261 +0200\n+++ /tmp/tmpyr5o1sfi.java\t2022-07-19 16:46:17.970984257 +0200\n@@ -2539,12 +2539,11 @@\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n+bucket.setZone(id = str + id;\n                 }\n             }\n             return ~position;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "bucket.setZone(idid = position + 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-20/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\t2022-07-19 16:46:19.550983003 +0200\n+++ /tmp/tmpy_mgijvy.java\t2022-07-19 16:46:19.554982998 +0200\n@@ -2539,12 +2539,11 @@\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n+bucket.setZone(idid = position + 1;\n                 }\n             }\n             return ~position;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "bucket.setZone(id = position + 1, text.length - position;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-20/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\t2022-07-19 16:46:21.046981797 +0200\n+++ /tmp/tmpre6wkfjz.java\t2022-07-19 16:46:21.050981794 +0200\n@@ -2539,12 +2539,11 @@\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n+bucket.setZone(id = position + 1, text.length - position;\n                 }\n             }\n             return ~position;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "bucket.setZone(id = position + id;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-20/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\t2022-07-19 16:46:22.542980566 +0200\n+++ /tmp/tmpliq2r4k4.java\t2022-07-19 16:46:22.542980566 +0200\n@@ -2539,12 +2539,11 @@\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n+bucket.setZone(id = position + id;\n                 }\n             }\n             return ~position;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "bucket.setZone(DateTimeZone.forID(id)); return position + id.length();",
        "fixed_line": "String best = null; for (String id : ALL_IDS) { if (str.startsWith(id)) { if (best == null || id.length() > best.length()) { best = id; } } } if (best != null) { bucket.setZone(DateTimeZone.forID(best)); return position + best.length(); }"
    },
    "Math-69": {
        "fixes": [
            {
                "k": 1,
                "patch": "out[i][j] = 2 * r; - tDistribution.cumulativeProbability) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-69/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\t2022-07-19 16:46:24.246979141 +0200\n+++ /tmp/tmp6p71qg7c.java\t2022-07-19 16:46:24.274979118 +0200\n@@ -166,11 +166,11 @@\n                 if (i == j) {\n                     out[i][j] = 0d;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+out[i][j] = 2 * r; - tDistribution.cumulativeProbability) {\n                 }\n             }\n         }\n         return new BlockRealMatrix(out);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "out[i][j] = 2 * r; tDistribution.cumulativeProbability) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-69/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\t2022-07-19 16:46:26.470977239 +0200\n+++ /tmp/tmps57_40a9.java\t2022-07-19 16:46:26.470977239 +0200\n@@ -166,11 +166,11 @@\n                 if (i == j) {\n                     out[i][j] = 0d;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+out[i][j] = 2 * r; tDistribution.cumulativeProbability) {\n                 }\n             }\n         }\n         return new BlockRealMatrix(out);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "out[i][j] = 2 * r; tDistribution.cumulativeProbability(t));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-69/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\t2022-07-19 16:46:28.414975538 +0200\n+++ /tmp/tmpt25l2bjk.java\t2022-07-19 16:46:28.414975538 +0200\n@@ -166,11 +166,11 @@\n                 if (i == j) {\n                     out[i][j] = 0d;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+out[i][j] = 2 * r; tDistribution.cumulativeProbability(t));\n                 }\n             }\n         }\n         return new BlockRealMatrix(out);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "out[i][j] = 2 * r; - tDistribution.cumulativeProbability(t));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-69/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\t2022-07-19 16:46:30.346973810 +0200\n+++ /tmp/tmp0ty3zj0u.java\t2022-07-19 16:46:30.346973810 +0200\n@@ -166,11 +166,11 @@\n                 if (i == j) {\n                     out[i][j] = 0d;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+out[i][j] = 2 * r; - tDistribution.cumulativeProbability(t));\n                 }\n             }\n         }\n         return new BlockRealMatrix(out);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "out[i][j] = 2 * r; tDistribution.cumulativeProbability(t;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-69/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\t2022-07-19 16:46:32.286972042 +0200\n+++ /tmp/tmpru21_9cl.java\t2022-07-19 16:46:32.286972042 +0200\n@@ -166,11 +166,11 @@\n                 if (i == j) {\n                     out[i][j] = 0d;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+out[i][j] = 2 * r; tDistribution.cumulativeProbability(t;\n                 }\n             }\n         }\n         return new BlockRealMatrix(out);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "out[i][j] = 2 * r; - tDistribution.cumulativeProbability;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-69/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\t2022-07-19 16:46:34.182970279 +0200\n+++ /tmp/tmp96839e58.java\t2022-07-19 16:46:34.182970279 +0200\n@@ -166,11 +166,11 @@\n                 if (i == j) {\n                     out[i][j] = 0d;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+out[i][j] = 2 * r; - tDistribution.cumulativeProbability;\n                 }\n             }\n         }\n         return new BlockRealMatrix(out);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "out[i][j] = 2 * r; - tDistribution.cumulativeProbability(t;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-69/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\t2022-07-19 16:46:36.170968396 +0200\n+++ /tmp/tmpm7i4l6v6.java\t2022-07-19 16:46:36.170968396 +0200\n@@ -166,11 +166,11 @@\n                 if (i == j) {\n                     out[i][j] = 0d;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+out[i][j] = 2 * r; - tDistribution.cumulativeProbability(t;\n                 }\n             }\n         }\n         return new BlockRealMatrix(out);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "out[i][j] = 2 * r; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-69/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\t2022-07-19 16:46:38.154966480 +0200\n+++ /tmp/tmplxqkcfdi.java\t2022-07-19 16:46:38.158966476 +0200\n@@ -166,11 +166,11 @@\n                 if (i == j) {\n                     out[i][j] = 0d;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+out[i][j] = 2 * r; }\n                 }\n             }\n         }\n         return new BlockRealMatrix(out);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "out[i][j] = 2 * r.cumulativeProbability(t;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-69/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\t2022-07-19 16:46:40.122964544 +0200\n+++ /tmp/tmpi5jezczz.java\t2022-07-19 16:46:40.122964544 +0200\n@@ -166,11 +166,11 @@\n                 if (i == j) {\n                     out[i][j] = 0d;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+out[i][j] = 2 * r.cumulativeProbability(t;\n                 }\n             }\n         }\n         return new BlockRealMatrix(out);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "out[i][j] = 2 * r;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-69/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\t2022-07-19 16:46:42.034962628 +0200\n+++ /tmp/tmpkwp9w65f.java\t2022-07-19 16:46:42.034962628 +0200\n@@ -166,11 +166,11 @@\n                 if (i == j) {\n                     out[i][j] = 0d;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+out[i][j] = 2 * r;\n                 }\n             }\n         }\n         return new BlockRealMatrix(out);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));",
        "fixed_line": "out[i][j] = 2 * tDistribution.cumulativeProbability(-t);"
    },
    "JacksonCore-3": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if (start == end) { _inputPtr = end; _inputEnd = end; _inputEnd = end; _inputEnd = end; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = 0; } // If we have offset, need to omit that from byte offset, so: _bufferRecyc",
                "patch_diff": "// if (start == end) { _inputPtr = end; _inputEnd = end; _inputEnd = end; _inputEnd = end; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = 0; } // If we have offset, need to omit that from byte offset, so: _bufferRecyc",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// if (start == end) { _inputPtr = end; _inputEnd = end; _inputEnd = end; _inputEnd = end; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = 0; } // If we have offset, need to omit that from byte",
                "patch_diff": "// if (start == end) { _inputPtr = end; _inputEnd = end; _inputEnd = end; _inputEnd = end; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = 0; } // If we have offset, need to omit that from byte",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if (start == end) { _inputPtr = end; _inputEnd = end; _inputEnd = end; _inputEnd = end; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRec",
                "patch_diff": "// if (start == end) { _inputPtr = end; _inputEnd = end; _inputEnd = end; _inputEnd = end; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRec",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// if (start == end) { _inputPtr = end; _inputEnd = end; _inputEnd = end; _inputEnd = end; _inputEnd = end; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = 0; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = offset, so: _bufferRecyclable",
                "patch_diff": "// if (start == end) { _inputPtr = end; _inputEnd = end; _inputEnd = end; _inputEnd = end; _inputEnd = end; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = 0; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = offset, so: _bufferRecyclable",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// if (start == end) { _inputPtr = end; _inputEnd = end; _inputEnd = end; _inputEnd = end; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; _bufferRecyclable = true; _bufferRecyc",
                "patch_diff": "// if (start == end) { _inputPtr = end; _inputEnd = end; _inputEnd = end; _inputEnd = end; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; _bufferRecyclable = true; _bufferRecyc",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if (start == end) { _inputPtr = end; _inputEnd = end; _inputEnd = end; _inputEnd = end; _inputEnd = end; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = 0; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = 0; } // If we have offset, need",
                "patch_diff": "// if (start == end) { _inputPtr = end; _inputEnd = end; _inputEnd = end; _inputEnd = end; _inputEnd = end; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = 0; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = 0; } // If we have offset, need",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// if (start == end) { _inputPtr = end; _inputEnd = end; _inputEnd = end; _inputEnd = end; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = offset, so: _bufferRecyclable; _bufferRecyc",
                "patch_diff": "// if (start == end) { _inputPtr = end; _inputEnd = end; _inputEnd = end; _inputEnd = end; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = offset, so: _bufferRecyclable; _bufferRecyc",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// if (start == end) { _inputPtr = end; _inputEnd = end; _inputEnd = end; _inputEnd = end; _inputEnd = end; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = 0; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; _bufferRecyclable = true",
                "patch_diff": "// if (start == end) { _inputPtr = end; _inputEnd = end; _inputEnd = end; _inputEnd = end; _inputEnd = end; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = 0; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; _bufferRecyclable = true",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// if (start == end) { _inputPtr = end; _inputEnd = end; _inputEnd = end; _inputEnd = end; _inputEnd = end; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = 0; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; _bufferRecyclable = end",
                "patch_diff": "// if (start == end) { _inputPtr = end; _inputEnd = end; _inputEnd = end; _inputEnd = end; _inputEnd = end; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = 0; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; _bufferRecyclable = end",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if (start == end) { _inputPtr = end; _inputEnd = end; _inputEnd = end; _inputEnd = end; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = offset, so: _bufferRecyclable = 0; } // If",
                "patch_diff": "// if (start == end) { _inputPtr = end; _inputEnd = end; _inputEnd = end; _inputEnd = end; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = true; _bufferRecyclable = true; } // If we have offset, need to omit that from byte offset, so: _bufferRecyclable = offset, so: _bufferRecyclable = 0; } // If",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "_currInputRowStart = start; // If we have offset, need to omit that from byte offset, so: _currInputProcessed = -start;"
    },
    "Cli-9": {
        "fixes": [
            {
                "k": 1,
                "patch": "throw new MissingOptionException(buff.millisecondPart.millisecondPart.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-9/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 16:46:52.146951941 +0200\n+++ /tmp/tmp76c5olut.java\t2022-07-19 16:46:52.222951857 +0200\n@@ -317,11 +317,11 @@\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n             }\n \n-            throw new MissingOptionException(buff.toString());\n+throw new MissingOptionException(buff.millisecondPart.millisecondPart.toString());\n         }\n     }\n \n     /**\n      * <p>Process the argument values for the specified Option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "throw new MissingOptionException(buff.millisecondPart.millisecond);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-9/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 16:46:54.266949585 +0200\n+++ /tmp/tmpv1fqubv6.java\t2022-07-19 16:46:54.266949585 +0200\n@@ -317,11 +317,11 @@\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n             }\n \n-            throw new MissingOptionException(buff.toString());\n+throw new MissingOptionException(buff.millisecondPart.millisecond);\n         }\n     }\n \n     /**\n      * <p>Process the argument values for the specified Option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "throw new MissingOptionException(buff.MINUTE_VALUE_VALUE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-9/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 16:46:55.802947852 +0200\n+++ /tmp/tmp03mpdrso.java\t2022-07-19 16:46:55.802947852 +0200\n@@ -317,11 +317,11 @@\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n             }\n \n-            throw new MissingOptionException(buff.toString());\n+throw new MissingOptionException(buff.MINUTE_VALUE_VALUE;\n         }\n     }\n \n     /**\n      * <p>Process the argument values for the specified Option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new MissingOptionException(buff.MINUTE_VALUE)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-9/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 16:46:57.306946136 +0200\n+++ /tmp/tmpy31ct0dn.java\t2022-07-19 16:46:57.306946136 +0200\n@@ -317,11 +317,11 @@\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n             }\n \n-            throw new MissingOptionException(buff.toString());\n+throw new MissingOptionException(buff.MINUTE_VALUE)\n         }\n     }\n \n     /**\n      * <p>Process the argument values for the specified Option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "throw new MissingOptionException(buff.millisecondPart.millisecondPart.millisecondPart.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-9/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 16:46:58.814944393 +0200\n+++ /tmp/tmpfcu6px5a.java\t2022-07-19 16:46:58.814944393 +0200\n@@ -317,11 +317,11 @@\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n             }\n \n-            throw new MissingOptionException(buff.toString());\n+throw new MissingOptionException(buff.millisecondPart.millisecondPart.millisecondPart.toString());\n         }\n     }\n \n     /**\n      * <p>Process the argument values for the specified Option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "throw new MissingOptionException(buff.millisecondPart.millisecondPart.millisecond);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-9/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 16:47:00.430942505 +0200\n+++ /tmp/tmp28ogrty9.java\t2022-07-19 16:47:00.430942505 +0200\n@@ -317,11 +317,11 @@\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n             }\n \n-            throw new MissingOptionException(buff.toString());\n+throw new MissingOptionException(buff.millisecondPart.millisecondPart.millisecond);\n         }\n     }\n \n     /**\n      * <p>Process the argument values for the specified Option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "throw new MissingOptionException(buff.MINUTE_VALUE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-9/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 16:47:02.066940568 +0200\n+++ /tmp/tmpw99ryvz7.java\t2022-07-19 16:47:02.066940568 +0200\n@@ -317,11 +317,11 @@\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n             }\n \n-            throw new MissingOptionException(buff.toString());\n+throw new MissingOptionException(buff.MINUTE_VALUE;\n         }\n     }\n \n     /**\n      * <p>Process the argument values for the specified Option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "throw new MissingOptionException(buff.MIN_VALUE_VALUE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-9/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 16:47:03.458938903 +0200\n+++ /tmp/tmpvc15nlse.java\t2022-07-19 16:47:03.458938903 +0200\n@@ -317,11 +317,11 @@\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n             }\n \n-            throw new MissingOptionException(buff.toString());\n+throw new MissingOptionException(buff.MIN_VALUE_VALUE;\n         }\n     }\n \n     /**\n      * <p>Process the argument values for the specified Option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "throw new MissingOptionException(buff.MIN_VALUE)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-9/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 16:47:04.938937114 +0200\n+++ /tmp/tmpktk03kd9.java\t2022-07-19 16:47:04.938937114 +0200\n@@ -317,11 +317,11 @@\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n             }\n \n-            throw new MissingOptionException(buff.toString());\n+throw new MissingOptionException(buff.MIN_VALUE)\n         }\n     }\n \n     /**\n      * <p>Process the argument values for the specified Option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "throw new MissingOptionException(buff.millisecondPart.millisecondPart.millisecondPart.millisecond);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-9/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 16:47:06.458935255 +0200\n+++ /tmp/tmp9okic0_b.java\t2022-07-19 16:47:06.458935255 +0200\n@@ -317,11 +317,11 @@\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n             }\n \n-            throw new MissingOptionException(buff.toString());\n+throw new MissingOptionException(buff.millisecondPart.millisecondPart.millisecondPart.millisecond);\n         }\n     }\n \n     /**\n      * <p>Process the argument values for the specified Option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "throw new MissingOptionException(buff.toString());",
        "fixed_line": "buff.append(\", \"); } throw new MissingOptionException(buff.substring(0, buff.length() - 2));"
    },
    "Math-78": {
        "fixes": [
            {
                "k": 1,
                "patch": "// for (int i = 0; i < f.length; i++) { if (isJSIdentifier(f)) { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction",
                "patch_diff": "// for (int i = 0; i < f.length; i++) { if (isJSIdentifier(f)) { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// }",
                "patch_diff": "// }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// for (int i = 0; i < f.length; i++) { if (isJSIdentifier(f)) { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateReal(",
                "patch_diff": "// for (int i = 0; i < f.length; i++) { if (isJSIdentifier(f)) { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateReal(",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// for (int i = 0; i < f; i++) { if (f == null) { f = new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction(); } }",
                "patch_diff": "// for (int i = 0; i < f; i++) { if (f == null) { f = new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction(); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// for (int i = 0; i < f; i++) { if (f == null) { f = new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { //",
                "patch_diff": "// for (int i = 0; i < f; i++) { if (f == null) { f = new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { //",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// for (int i = 0; i < f; i++) { if (f == null) { f = new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw",
                "patch_diff": "// for (int i = 0; i < f; i++) { if (f == null) { f = new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// for (int i = 0; i < f; i++) { if (f == null) { f = new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { }",
                "patch_diff": "// for (int i = 0; i < f; i++) { if (f == null) { f = new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// for (int i = 0; i < f; i++) { if (f == null) { f = new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction; } }",
                "patch_diff": "// for (int i = 0; i < f; i++) { if (f == null) { f = new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// for (int i = 0; i < f.length; i++) { if (isJSIdentifier(f)) { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction(); } } }",
                "patch_diff": "// for (int i = 0; i < f.length; i++) { if (isJSIdentifier(f)) { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction(); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// for (int i = 0; i < f.length; i++) { if (isJSIdentifier(f)) { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { } } }",
                "patch_diff": "// for (int i = 0; i < f.length; i++) { if (isJSIdentifier(f)) { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { throw new UnivariateRealFunction() { } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (ga * gb > 0) { // this is a corner case: // - there was an event near ta, // - there is another event between ta and tb // - when ta was computed, convergence was reached on the \"wrong side\" of the interval // this implies that the real sign of ga is the same as gb, so we need to slightly // shift ta to make sure ga and gb get opposite signs and the solver won't complain // about bracketing final double epsilon = (forward ? 0.25 : -0.25) * convergence; for (int k = 0; (k < 4) && (ga * gb > 0); ++k) { ta += epsilon; interpolator.setInterpolatedTime(ta); ga = handler.g(ta, interpolator.getInterpolatedState()); } if (ga * gb > 0) { // this should never happen throw MathRuntimeException.createInternalError(null); } }"
    },
    "Time-22": {
        "fixes": [
            {
                "k": 1,
                "patch": "this(duration, null, nullText, null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-22/src/main/java/org/joda/time/base/BasePeriod.java\t2022-07-19 16:47:10.570930126 +0200\n+++ /tmp/tmpea34wwn9.java\t2022-07-19 16:47:10.590930101 +0200\n@@ -217,11 +217,11 @@\n      * The calculation uses the hour, minute, second and millisecond fields.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        this(duration, null, null);\n+this(duration, null, nullText, null);\n         // bug [3264409]\n     }\n \n     /**\n      * Creates a period from the given millisecond duration, which is only really\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "this(0, duration, null, null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-22/src/main/java/org/joda/time/base/BasePeriod.java\t2022-07-19 16:47:12.638927492 +0200\n+++ /tmp/tmpebsi0snj.java\t2022-07-19 16:47:12.638927492 +0200\n@@ -217,11 +217,11 @@\n      * The calculation uses the hour, minute, second and millisecond fields.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        this(duration, null, null);\n+this(0, duration, null, null);\n         // bug [3264409]\n     }\n \n     /**\n      * Creates a period from the given millisecond duration, which is only really\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "this(duration, null, null, nullText);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-22/src/main/java/org/joda/time/base/BasePeriod.java\t2022-07-19 16:47:27.498907484 +0200\n+++ /tmp/tmpz0p3a3xp.java\t2022-07-19 16:47:27.498907484 +0200\n@@ -217,11 +217,11 @@\n      * The calculation uses the hour, minute, second and millisecond fields.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        this(duration, null, null);\n+this(duration, null, null, nullText);\n         // bug [3264409]\n     }\n \n     /**\n      * Creates a period from the given millisecond duration, which is only really\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "this(duration, null, null, nullText, null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-22/src/main/java/org/joda/time/base/BasePeriod.java\t2022-07-19 16:47:29.750904292 +0200\n+++ /tmp/tmp3y8p73cz.java\t2022-07-19 16:47:29.750904292 +0200\n@@ -217,11 +217,11 @@\n      * The calculation uses the hour, minute, second and millisecond fields.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        this(duration, null, null);\n+this(duration, null, null, nullText, null);\n         // bug [3264409]\n     }\n \n     /**\n      * Creates a period from the given millisecond duration, which is only really\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "this(duration, null, nullText);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-22/src/main/java/org/joda/time/base/BasePeriod.java\t2022-07-19 16:47:31.994901065 +0200\n+++ /tmp/tmpti2h3tla.java\t2022-07-19 16:47:31.994901065 +0200\n@@ -217,11 +217,11 @@\n      * The calculation uses the hour, minute, second and millisecond fields.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        this(duration, null, null);\n+this(duration, null, nullText);\n         // bug [3264409]\n     }\n \n     /**\n      * Creates a period from the given millisecond duration, which is only really\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "this(duration, null, null });",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-22/src/main/java/org/joda/time/base/BasePeriod.java\t2022-07-19 16:47:34.694897130 +0200\n+++ /tmp/tmp6ossx5mt.java\t2022-07-19 16:47:34.722897086 +0200\n@@ -217,11 +217,11 @@\n      * The calculation uses the hour, minute, second and millisecond fields.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        this(duration, null, null);\n+this(duration, null, null });\n         // bug [3264409]\n     }\n \n     /**\n      * Creates a period from the given millisecond duration, which is only really\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "this(duration, null, null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-22/src/main/java/org/joda/time/base/BasePeriod.java\t2022-07-19 16:47:37.398893127 +0200\n+++ /tmp/tmplcdjfbmc.java\t2022-07-19 16:47:37.398893127 +0200\n@@ -217,11 +217,11 @@\n      * The calculation uses the hour, minute, second and millisecond fields.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        this(duration, null, null);\n+this(duration, null, null;\n         // bug [3264409]\n     }\n \n     /**\n      * Creates a period from the given millisecond duration, which is only really\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "this(duration, null, millis);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-22/src/main/java/org/joda/time/base/BasePeriod.java\t2022-07-19 16:47:39.906889362 +0200\n+++ /tmp/tmp41464ys8.java\t2022-07-19 16:47:40.018889190 +0200\n@@ -217,11 +217,11 @@\n      * The calculation uses the hour, minute, second and millisecond fields.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        this(duration, null, null);\n+this(duration, null, millis);\n         // bug [3264409]\n     }\n \n     /**\n      * Creates a period from the given millisecond duration, which is only really\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "this(duration, null, null, null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-22/src/main/java/org/joda/time/base/BasePeriod.java\t2022-07-19 16:47:42.866884849 +0200\n+++ /tmp/tmpizn3lo6_.java\t2022-07-19 16:47:42.866884849 +0200\n@@ -217,11 +217,11 @@\n      * The calculation uses the hour, minute, second and millisecond fields.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        this(duration, null, null);\n+this(duration, null, null, null);\n         // bug [3264409]\n     }\n \n     /**\n      * Creates a period from the given millisecond duration, which is only really\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "this(duration, null, nullText, nullText);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-22/src/main/java/org/joda/time/base/BasePeriod.java\t2022-07-19 16:47:45.282881114 +0200\n+++ /tmp/tmpq6cqsgi2.java\t2022-07-19 16:47:45.282881114 +0200\n@@ -217,11 +217,11 @@\n      * The calculation uses the hour, minute, second and millisecond fields.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        this(duration, null, null);\n+this(duration, null, nullText, nullText);\n         // bug [3264409]\n     }\n \n     /**\n      * Creates a period from the given millisecond duration, which is only really\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "this(duration, null, null);",
        "fixed_line": "super(); // bug [3264409] iType = PeriodType.time(); int[] values = ISOChronology.getInstanceUTC().get(this, duration); iType = PeriodType.standard(); iValues = new int[8]; System.arraycopy(values, 0, iValues, 4, 4);"
    },
    "Closure-97": {
        "fixes": [
            {
                "k": 1,
                "patch": "result = lvalInt >>>MediancestorBlock.tokenToName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-97/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 16:47:48.406876218 +0200\n+++ /tmp/tmpdtzr67k_.java\t2022-07-19 16:47:48.934875382 +0200\n@@ -693,11 +693,11 @@\n           break;\n         case Token.URSH:\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+result = lvalInt >>>MediancestorBlock.tokenToName;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "result = lvalInt >>>MediancestorInt;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-97/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 16:47:53.618867868 +0200\n+++ /tmp/tmpxn8m71wo.java\t2022-07-19 16:47:53.618867868 +0200\n@@ -693,11 +693,11 @@\n           break;\n         case Token.URSH:\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+result = lvalInt >>>MediancestorInt;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "result = lvalInt >>>Mediancestor;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-97/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 16:47:56.470863208 +0200\n+++ /tmp/tmpz2a44gl5.java\t2022-07-19 16:47:56.474863201 +0200\n@@ -693,11 +693,11 @@\n           break;\n         case Token.URSH:\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+result = lvalInt >>>Mediancestor;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "result = lvalInt >>>MediancestorBlock;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-97/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 16:47:59.022858983 +0200\n+++ /tmp/tmpwokesy32.java\t2022-07-19 16:47:59.022858983 +0200\n@@ -693,11 +693,11 @@\n           break;\n         case Token.URSH:\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+result = lvalInt >>>MediancestorBlock;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "result = lvalInt >>> 12;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-97/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 16:48:01.574854707 +0200\n+++ /tmp/tmpu3p8bwnx.java\t2022-07-19 16:48:01.574854707 +0200\n@@ -693,11 +693,11 @@\n           break;\n         case Token.URSH:\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+result = lvalInt >>> 12;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "result = valInt >>> rvalInt;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-97/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 16:48:35.562792989 +0200\n+++ /tmp/tmpg6algx0w.java\t2022-07-19 16:48:35.562792989 +0200\n@@ -693,11 +693,11 @@\n           break;\n         case Token.URSH:\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+result = valInt >>> rvalInt;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "result = lvalInt >>> 15;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-97/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 16:48:38.714786828 +0200\n+++ /tmp/tmpiyl783r2.java\t2022-07-19 16:48:38.714786828 +0200\n@@ -693,11 +693,11 @@\n           break;\n         case Token.URSH:\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+result = lvalInt >>> 15;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "result = lvalInt >>> 16;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-97/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 16:49:04.054734706 +0200\n+++ /tmp/tmp93mfyh_8.java\t2022-07-19 16:49:04.054734706 +0200\n@@ -693,11 +693,11 @@\n           break;\n         case Token.URSH:\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+result = lvalInt >>> 16;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "result = lvalInt >>> rvalInt;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-97/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 16:49:30.310675977 +0200\n+++ /tmp/tmpdvttlb0b.java\t2022-07-19 16:49:30.314675968 +0200\n@@ -693,11 +693,11 @@\n           break;\n         case Token.URSH:\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+result = lvalInt >>> rvalInt;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "result = this.tokenToName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-97/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 16:49:53.810619562 +0200\n+++ /tmp/tmpsq2xv82a.java\t2022-07-19 16:49:53.810619562 +0200\n@@ -693,11 +693,11 @@\n           break;\n         case Token.URSH:\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+result = this.tokenToName;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "result = lvalInt >>> rvalInt;",
        "fixed_line": "long lvalLong = lvalInt & 0xffffffffL; result = lvalLong >>> rvalInt;"
    },
    "Math-34": {
        "fixes": [
            {
                "k": 1,
                "patch": "return200osomesosomes.iterator();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-34/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\t2022-07-19 16:49:55.686614909 +0200\n+++ /tmp/tmpejsjy0k7.java\t2022-07-19 16:49:55.726614807 +0200\n@@ -204,8 +204,8 @@\n      * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+return200osomesosomes.iterator();\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return serosomesosomes.iterator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-34/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\t2022-07-19 16:49:58.122608831 +0200\n+++ /tmp/tmpprn2vlfn.java\t2022-07-19 16:49:58.122608831 +0200\n@@ -204,8 +204,8 @@\n      * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+return serosomesosomes.iterator;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return chromosomes_DECL.iterator();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-34/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\t2022-07-19 16:50:00.190603642 +0200\n+++ /tmp/tmp4mc24ypa.java\t2022-07-19 16:50:00.194603630 +0200\n@@ -204,8 +204,8 @@\n      * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+return chromosomes_DECL.iterator();\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return lastComparisonosomesosomes.iterator();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-34/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\t2022-07-19 16:50:02.318598274 +0200\n+++ /tmp/tmpxd51x7oq.java\t2022-07-19 16:50:02.318598274 +0200\n@@ -204,8 +204,8 @@\n      * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+return lastComparisonosomesosomes.iterator();\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return serosomesosomes.iterator();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-34/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\t2022-07-19 16:50:04.506592726 +0200\n+++ /tmp/tmpjsebsj82.java\t2022-07-19 16:50:04.506592726 +0200\n@@ -204,8 +204,8 @@\n      * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+return serosomesosomes.iterator();\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return chromosomes.iterator();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-34/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\t2022-07-19 16:50:06.550587514 +0200\n+++ /tmp/tmp6admodia.java\t2022-07-19 16:50:06.550587514 +0200\n@@ -204,8 +204,8 @@\n      * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+return chromosomes.iterator();\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return chromosomesosomes.iterator();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-34/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\t2022-07-19 16:50:34.146514710 +0200\n+++ /tmp/tmpqqs1apk_.java\t2022-07-19 16:50:34.158514680 +0200\n@@ -204,8 +204,8 @@\n      * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+return chromosomesosomes.iterator();\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return200osomes.iterator();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-34/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\t2022-07-19 16:50:36.262508944 +0200\n+++ /tmp/tmppjp7d4yq.java\t2022-07-19 16:50:36.262508944 +0200\n@@ -204,8 +204,8 @@\n      * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+return200osomes.iterator();\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return lastComparisonosomes.iterator();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-34/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\t2022-07-19 16:50:38.318503312 +0200\n+++ /tmp/tmpys8f9qjy.java\t2022-07-19 16:50:38.318503312 +0200\n@@ -204,8 +204,8 @@\n      * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+return lastComparisonosomes.iterator();\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return serosomes.iterator();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-34/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\t2022-07-19 16:50:40.370497668 +0200\n+++ /tmp/tmp4juz_dn9.java\t2022-07-19 16:50:40.374497657 +0200\n@@ -204,8 +204,8 @@\n      * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+return serosomes.iterator();\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return chromosomes.iterator();",
        "fixed_line": "return getChromosomes().iterator();"
    },
    "Closure-23": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int i = 0; n!= null && i < intIndex; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-23/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 16:50:42.698491239 +0200\n+++ /tmp/tmprvrks9a5.java\t2022-07-19 16:50:42.718491182 +0200\n@@ -1446,11 +1446,11 @@\n       return n;\n     }\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null && i < intIndex; i++) {\n+for (int i = 0; n!= null && i < intIndex; i++) {\n         elem = current;\n \n       current = current.getNext();\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = 0; elem!= null && i < intIndex; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-23/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 16:51:26.330365112 +0200\n+++ /tmp/tmpk5on_gjx.java\t2022-07-19 16:51:26.330365112 +0200\n@@ -1446,11 +1446,11 @@\n       return n;\n     }\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null && i < intIndex; i++) {\n+for (int i = 0; elem!= null && i < intIndex; i++) {\n         elem = current;\n \n       current = current.getNext();\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0, null && currentIndex < intIndex; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-23/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 16:52:05.370243746 +0200\n+++ /tmp/tmpm_pmwyfi.java\t2022-07-19 16:52:05.370243746 +0200\n@@ -1446,11 +1446,11 @@\n       return n;\n     }\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null && i < intIndex; i++) {\n+for (int i = 0, null && currentIndex < intIndex; i++) {\n         elem = current;\n \n       current = current.getNext();\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = 0; it!= null && i < intIndex; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-23/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 16:52:08.834232614 +0200\n+++ /tmp/tmp7r7qpzsj.java\t2022-07-19 16:52:08.834232614 +0200\n@@ -1446,11 +1446,11 @@\n       return n;\n     }\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null && i < intIndex; i++) {\n+for (int i = 0; it!= null && i < intIndex; i++) {\n         elem = current;\n \n       current = current.getNext();\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = 0; elem!= null && currentIndex < intIndex; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-23/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 16:52:12.322221340 +0200\n+++ /tmp/tmp4xgkc6hz.java\t2022-07-19 16:52:12.322221340 +0200\n@@ -1446,11 +1446,11 @@\n       return n;\n     }\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null && i < intIndex; i++) {\n+for (int i = 0; elem!= null && currentIndex < intIndex; i++) {\n         elem = current;\n \n       current = current.getNext();\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = first; current!= null && i < intIndex; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-23/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 16:52:15.822209972 +0200\n+++ /tmp/tmpra6yqxcg.java\t2022-07-19 16:52:15.826209961 +0200\n@@ -1446,11 +1446,11 @@\n       return n;\n     }\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null && i < intIndex; i++) {\n+for (int i = first; current!= null && i < intIndex; i++) {\n         elem = current;\n \n       current = current.getNext();\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = elem!= null && i < intIndex; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-23/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 16:52:19.398198295 +0200\n+++ /tmp/tmpyz48suy7.java\t2022-07-19 16:52:19.402198284 +0200\n@@ -1446,11 +1446,11 @@\n       return n;\n     }\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null && i < intIndex; i++) {\n+for (int i = elem!= null && i < intIndex; i++) {\n         elem = current;\n \n       current = current.getNext();\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = 0, null && current!= intIndex; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-23/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 16:52:22.770187230 +0200\n+++ /tmp/tmpkk4kakpg.java\t2022-07-19 16:52:22.770187230 +0200\n@@ -1446,11 +1446,11 @@\n       return n;\n     }\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null && i < intIndex; i++) {\n+for (int i = 0, null && current!= intIndex; i++) {\n         elem = current;\n \n       current = current.getNext();\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int i = 0; current!= null && i < intIndex; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-23/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 16:52:26.042176442 +0200\n+++ /tmp/tmpzmolmcex.java\t2022-07-19 16:52:26.042176442 +0200\n@@ -1446,11 +1446,11 @@\n       return n;\n     }\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null && i < intIndex; i++) {\n+for (int i = 0; current!= null && i < intIndex; i++) {\n         elem = current;\n \n       current = current.getNext();\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = 0, null && i < intIndex; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-23/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 16:53:04.886044631 +0200\n+++ /tmp/tmpobes_afi.java\t2022-07-19 16:53:04.886044631 +0200\n@@ -1446,11 +1446,11 @@\n       return n;\n     }\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null && i < intIndex; i++) {\n+for (int i = 0, null && i < intIndex; i++) {\n         elem = current;\n \n       current = current.getNext();\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "for (int i = 0; current != null && i < intIndex; i++) {",
        "fixed_line": "for (int i = 0; current != null; i++) { if (i != intIndex) { if (mayHaveSideEffects(current)) { return n; } } else { elem = current; }"
    },
    "Jsoup-40": {
        "fixes": [
            {
                "k": 1,
                "patch": "Validate.notEmpty(nameTest;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-40/src/main/java/org/jsoup/nodes/DocumentType.java\t2022-07-19 16:53:08.394032398 +0200\n+++ /tmp/tmp8q61nwcg.java\t2022-07-19 16:53:08.426032285 +0200\n@@ -17,11 +17,11 @@\n      * @param baseUri the doctype's base URI\n      */\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+Validate.notEmpty(nameTest;\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "Validate.notEmpty(baseUri);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-40/src/main/java/org/jsoup/nodes/DocumentType.java\t2022-07-19 16:53:10.098026436 +0200\n+++ /tmp/tmp81blngjv.java\t2022-07-19 16:53:10.098026436 +0200\n@@ -17,11 +17,11 @@\n      * @param baseUri the doctype's base URI\n      */\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+Validate.notEmpty(baseUri);\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "Validate.notEmpty(yUri);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-40/src/main/java/org/jsoup/nodes/DocumentType.java\t2022-07-19 16:53:13.722013716 +0200\n+++ /tmp/tmp7v0th94x.java\t2022-07-19 16:53:13.726013701 +0200\n@@ -17,11 +17,11 @@\n      * @param baseUri the doctype's base URI\n      */\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+Validate.notEmpty(yUri);\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "Validate.notEmpty(baseUri;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-40/src/main/java/org/jsoup/nodes/DocumentType.java\t2022-07-19 16:53:15.270008266 +0200\n+++ /tmp/tmp8_dv2eki.java\t2022-07-19 16:53:15.270008266 +0200\n@@ -17,11 +17,11 @@\n      * @param baseUri the doctype's base URI\n      */\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+Validate.notEmpty(baseUri;\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "Validate.notEmpty(closed;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-40/src/main/java/org/jsoup/nodes/DocumentType.java\t2022-07-19 16:53:16.774002958 +0200\n+++ /tmp/tmp4etrvu24.java\t2022-07-19 16:53:16.774002958 +0200\n@@ -17,11 +17,11 @@\n      * @param baseUri the doctype's base URI\n      */\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+Validate.notEmpty(closed;\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "Validate.notEmpty(yUri;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-40/src/main/java/org/jsoup/nodes/DocumentType.java\t2022-07-19 16:53:18.321997481 +0200\n+++ /tmp/tmp8q0kiiyo.java\t2022-07-19 16:53:18.321997481 +0200\n@@ -17,11 +17,11 @@\n      * @param baseUri the doctype's base URI\n      */\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+Validate.notEmpty(yUri;\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "Validate.notEmpty(closed);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-40/src/main/java/org/jsoup/nodes/DocumentType.java\t2022-07-19 16:53:19.741992461 +0200\n+++ /tmp/tmprlbgyyu2.java\t2022-07-19 16:53:19.745992447 +0200\n@@ -17,11 +17,11 @@\n      * @param baseUri the doctype's base URI\n      */\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+Validate.notEmpty(closed);\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "Validate.notEmpty(name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-40/src/main/java/org/jsoup/nodes/DocumentType.java\t2022-07-19 16:53:21.285986985 +0200\n+++ /tmp/tmp10fs0rj5.java\t2022-07-19 16:53:21.285986985 +0200\n@@ -17,11 +17,11 @@\n      * @param baseUri the doctype's base URI\n      */\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+Validate.notEmpty(name;\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "Validate.notEmpty(SESSION;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-40/src/main/java/org/jsoup/nodes/DocumentType.java\t2022-07-19 16:53:22.729981854 +0200\n+++ /tmp/tmps1ooson1.java\t2022-07-19 16:53:22.729981854 +0200\n@@ -17,11 +17,11 @@\n      * @param baseUri the doctype's base URI\n      */\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+Validate.notEmpty(SESSION;\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "Validate.notEmpty(name);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-40/src/main/java/org/jsoup/nodes/DocumentType.java\t2022-07-19 16:53:24.249976445 +0200\n+++ /tmp/tmpllcpare9.java\t2022-07-19 16:53:24.249976445 +0200\n@@ -17,11 +17,11 @@\n      * @param baseUri the doctype's base URI\n      */\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+Validate.notEmpty(name);\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "Validate.notEmpty(name);",
        "fixed_line": ""
    },
    "Math-42": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (basicRows.contains(o) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-42/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 16:53:27.349965382 +0200\n+++ /tmp/tmpjix94wgt.java\t2022-07-19 16:53:27.369965312 +0200\n@@ -408,11 +408,11 @@\n           }\n           Integer basicRow = getBasicRow(colIndex);\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n+if (basicRows.contains(o) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (basic.contains(o) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-42/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 16:53:29.765956734 +0200\n+++ /tmp/tmp6dt735np.java\t2022-07-19 16:53:29.765956734 +0200\n@@ -408,11 +408,11 @@\n           }\n           Integer basicRow = getBasicRow(colIndex);\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n+if (basic.contains(o) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (basicRows.contains(numNegative) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-42/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 16:53:31.829949326 +0200\n+++ /tmp/tmpn4ilj6sp.java\t2022-07-19 16:53:31.829949326 +0200\n@@ -408,11 +408,11 @@\n           }\n           Integer basicRow = getBasicRow(colIndex);\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n+if (basicRows.contains(numNegative) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (basicRows.contains(cDefault) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-42/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 16:53:33.813942187 +0200\n+++ /tmp/tmpf9d13f5t.java\t2022-07-19 16:53:33.813942187 +0200\n@@ -408,11 +408,11 @@\n           }\n           Integer basicRow = getBasicRow(colIndex);\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n+if (basicRows.contains(cDefault) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (basic.contains(numNegative) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-42/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 16:53:35.845934862 +0200\n+++ /tmp/tmphd5l0k11.java\t2022-07-19 16:53:35.845934862 +0200\n@@ -408,11 +408,11 @@\n           }\n           Integer basicRow = getBasicRow(colIndex);\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n+if (basic.contains(numNegative) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (basicRows.contains(value) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-42/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 16:53:37.917927372 +0200\n+++ /tmp/tmpze4addl9.java\t2022-07-19 16:53:37.917927372 +0200\n@@ -408,11 +408,11 @@\n           }\n           Integer basicRow = getBasicRow(colIndex);\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n+if (basicRows.contains(value) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (basicRows.contains(unmodifiableNegative) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-42/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 16:53:39.989919867 +0200\n+++ /tmp/tmpn0q12nsy.java\t2022-07-19 16:53:39.989919867 +0200\n@@ -408,11 +408,11 @@\n           }\n           Integer basicRow = getBasicRow(colIndex);\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n+if (basicRows.contains(unmodifiableNegative) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (basic.contains(value) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-42/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 16:53:42.013912519 +0200\n+++ /tmp/tmp6uuv71ss.java\t2022-07-19 16:53:42.013912519 +0200\n@@ -408,11 +408,11 @@\n           }\n           Integer basicRow = getBasicRow(colIndex);\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n+if (basic.contains(value) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (basic.contains(cDefault) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-42/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 16:53:44.061905066 +0200\n+++ /tmp/tmpofavitve.java\t2022-07-19 16:53:44.061905066 +0200\n@@ -408,11 +408,11 @@\n           }\n           Integer basicRow = getBasicRow(colIndex);\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n+if (basic.contains(cDefault) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (basic.contains(unmodifiableNegative) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-42/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 16:53:46.109897596 +0200\n+++ /tmp/tmp42mi2_yn.java\t2022-07-19 16:53:46.109897596 +0200\n@@ -408,11 +408,11 @@\n           }\n           Integer basicRow = getBasicRow(colIndex);\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n+if (basic.contains(unmodifiableNegative) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (basicRows.contains(basicRow)) {",
        "fixed_line": "if (basicRow != null && basicRow == 0) { // if the basic row is found to be the objective function row // set the coefficient to 0 -> this case handles unconstrained // variables that are still part of the objective function coefficients[i] = 0; } else if (basicRows.contains(basicRow)) {"
    },
    "Lang-9": {
        "fixes": [
            {
                "k": 1,
                "patch": "doStrategy= collector.add(currentStrategy; currentStrategy= collector.toArray(new Strategy[collector.size()]); }",
                "patch_diff": "doStrategy= collector.add(currentStrategy; currentStrategy= collector.toArray(new Strategy[collector.size()]); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "doStrategy= collector.add(currentStrategy; currentStrategy= collector.toArray(new Strategy[collector.size()]);",
                "patch_diff": "doStrategy= collector.add(currentStrategy; currentStrategy= collector.toArray(new Strategy[collector.size()]);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "doStrategy= collector.add(currentStrategy; currentStrategy= collector.toArray(new Stroke= collector.size()]); }",
                "patch_diff": "doStrategy= collector.add(currentStrategy; currentStrategy= collector.toArray(new Stroke= collector.size()]); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "doStrategy= collector.add(currentStrategy; currentStrategy= collector.toArray(new Stroke= collector.size()]);",
                "patch_diff": "doStrategy= collector.add(currentStrategy; currentStrategy= collector.toArray(new Stroke= collector.size()]);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "doStrategy= collector.add(currentStrategy; currentStrategy= collector.toArray(new Stroke= collector.size() {",
                "patch_diff": "doStrategy= collector.add(currentStrategy; currentStrategy= collector.toArray(new Stroke= collector.size() {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "doStrategy= collector.add(currentStrategy; currentStrategy= collector.toArray(newgetX[collector.size()]); }",
                "patch_diff": "doStrategy= collector.add(currentStrategy; currentStrategy= collector.toArray(newgetX[collector.size()]); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "doStrategy= collector.add(currentStrategy; currentStrategy= collector.toArray(new Strategy[collector.size()]));",
                "patch_diff": "doStrategy= collector.add(currentStrategy; currentStrategy= collector.toArray(new Strategy[collector.size()]));",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "doStrategy= collector.add(currentStrategy; currentStrategy= collector.toArray(new Strategy[collector.size()])); }",
                "patch_diff": "doStrategy= collector.add(currentStrategy; currentStrategy= collector.toArray(new Strategy[collector.size()])); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "doStrategy= collector.add(currentStrategy; currentStrategy= collector.toArray(newInit;",
                "patch_diff": "doStrategy= collector.add(currentStrategy; currentStrategy= collector.toArray(newInit;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "doStrategy= collector.add(currentStrategy; currentStrategy= collector.toArray(new Check= collector.size() {",
                "patch_diff": "doStrategy= collector.add(currentStrategy; currentStrategy= collector.toArray(new Check= collector.size() {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (patternMatcher.regionStart() != patternMatcher.regionEnd()) { throw new IllegalArgumentException(\"Failed to parse \\\"\"+pattern+\"\\\" ; gave up at index \"+patternMatcher.regionStart()); }"
    },
    "Closure-28": {
        "fixes": [
            {
                "k": 1,
                "patch": "we're done. */; /* declared if it's likely that they will get folded when we're done. */ } }",
                "patch_diff": "we're done. */; /* declared if it's likely that they will get folded when we're done. */ } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "we're done. */;",
                "patch_diff": "we're done. */;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "we're done. */; /* declared if it's likely that they will get folded when we're done. */ }",
                "patch_diff": "we're done. */; /* declared if it's likely that they will get folded when we're done. */ }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "we're done. */; /* declared if it's likely that they will get folded when we're done when we're done. */ } }",
                "patch_diff": "we're done. */; /* declared if it's likely that they will get folded when we're done when we're done. */ } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "we're done. */; /* declared if it's likely that they will get folded when we're done will get folded when we're done. */ } }",
                "patch_diff": "we're done. */; /* declared if it's likely that they will get folded when we're done will get folded when we're done. */ } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "we're done. */; /* declared if it's likely that they will get folded when we're done when we're done. */ }",
                "patch_diff": "we're done. */; /* declared if it's likely that they will get folded when we're done when we're done. */ }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "we're done. */; /* declared if it's likely that they will get folded when we're done will get folded when we're done. */ }",
                "patch_diff": "we're done. */; /* declared if it's likely that they will get folded when we're done will get folded when we're done. */ }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "we're done. */; /* declared if it's likely that they will get folded when we're done, we're done. */ } }",
                "patch_diff": "we're done. */; /* declared if it's likely that they will get folded when we're done, we're done. */ } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "we're done. */; /* declared if it's likely that they will get folded when we're done. */)",
                "patch_diff": "we're done. */; /* declared if it's likely that they will get folded when we're done. */)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "we're done. */; /* declared if it's likely that they will get folded when we're done, we're done. */ }",
                "patch_diff": "we're done. */; /* declared if it's likely that they will get folded when we're done, we're done. */ }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "@Override void addConstant(String newcode) { add(\"0\"); }"
    },
    "Closure-13": {
        "fixes": [
            {
                "k": 1,
                "patch": "Node next = c.getNext; // c = c.next, may be removed",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-13/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\t2022-07-19 16:53:51.641877335 +0200\n+++ /tmp/tmpx6xahu7t.java\t2022-07-19 16:53:51.677877203 +0200\n@@ -122,11 +122,11 @@\n     int visits = 0;\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         traverse(c);\n-        Node next = c.getNext();\n+Node next = c.getNext; // c = c.next, may be removed\n         c = next;\n       }\n \n       visit(node);\n       visits++;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "Node next = c.getNext(); // c = c.next, may be removed",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-13/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\t2022-07-19 16:53:56.673858800 +0200\n+++ /tmp/tmps5ezl0xa.java\t2022-07-19 16:53:56.705858682 +0200\n@@ -122,11 +122,11 @@\n     int visits = 0;\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         traverse(c);\n-        Node next = c.getNext();\n+Node next = c.getNext(); // c = c.next, may be removed\n         c = next;\n       }\n \n       visit(node);\n       visits++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "Node next = c.getNext(); // c may be null or empty",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-13/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\t2022-07-19 16:54:40.117694762 +0200\n+++ /tmp/tmp091x6agu.java\t2022-07-19 16:54:40.117694762 +0200\n@@ -122,11 +122,11 @@\n     int visits = 0;\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         traverse(c);\n-        Node next = c.getNext();\n+Node next = c.getNext(); // c may be null or empty\n         c = next;\n       }\n \n       visit(node);\n       visits++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "Node next = c.getNext(); // c may be removed.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-13/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\t2022-07-19 16:55:21.469532300 +0200\n+++ /tmp/tmpvcoct43e.java\t2022-07-19 16:55:21.469532300 +0200\n@@ -122,11 +122,11 @@\n     int visits = 0;\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         traverse(c);\n-        Node next = c.getNext();\n+Node next = c.getNext(); // c may be removed.\n         c = next;\n       }\n \n       visit(node);\n       visits++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "Node next = c.getNext(); // c.next, may be removed",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-13/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\t2022-07-19 16:56:02.809364211 +0200\n+++ /tmp/tmptqnu1q83.java\t2022-07-19 16:56:02.809364211 +0200\n@@ -122,11 +122,11 @@\n     int visits = 0;\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         traverse(c);\n-        Node next = c.getNext();\n+Node next = c.getNext(); // c.next, may be removed\n         c = next;\n       }\n \n       visit(node);\n       visits++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "Node next = c.getNext(); // c may be removed (c)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-13/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\t2022-07-19 16:56:43.969191657 +0200\n+++ /tmp/tmpto55hceu.java\t2022-07-19 16:56:43.973191639 +0200\n@@ -122,11 +122,11 @@\n     int visits = 0;\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         traverse(c);\n-        Node next = c.getNext();\n+Node next = c.getNext(); // c may be removed (c)\n         c = next;\n       }\n \n       visit(node);\n       visits++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "Node next = c.getNext(); // c may be removed",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-13/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\t2022-07-19 16:57:24.997014889 +0200\n+++ /tmp/tmpiki7b14z.java\t2022-07-19 16:57:24.997014889 +0200\n@@ -122,11 +122,11 @@\n     int visits = 0;\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         traverse(c);\n-        Node next = c.getNext();\n+Node next = c.getNext(); // c may be removed\n         c = next;\n       }\n \n       visit(node);\n       visits++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "Node next = c.getNext(); // c = c.next, block;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-13/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\t2022-07-19 16:58:06.248832730 +0200\n+++ /tmp/tmp4fvs5wxc.java\t2022-07-19 16:58:06.248832730 +0200\n@@ -122,11 +122,11 @@\n     int visits = 0;\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         traverse(c);\n-        Node next = c.getNext();\n+Node next = c.getNext(); // c = c.next, block;\n         c = next;\n       }\n \n       visit(node);\n       visits++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "Node next = c.getNext(); // c = c.next;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-13/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\t2022-07-19 16:58:47.428646809 +0200\n+++ /tmp/tmp8rw_wyc5.java\t2022-07-19 16:58:47.428646809 +0200\n@@ -122,11 +122,11 @@\n     int visits = 0;\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         traverse(c);\n-        Node next = c.getNext();\n+Node next = c.getNext(); // c = c.next;\n         c = next;\n       }\n \n       visit(node);\n       visits++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "Node next = c.getNext; // c = c.next, may be null or empty",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-13/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\t2022-07-19 16:59:28.376458202 +0200\n+++ /tmp/tmp782_2i2o.java\t2022-07-19 16:59:28.376458202 +0200\n@@ -122,11 +122,11 @@\n     int visits = 0;\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         traverse(c);\n-        Node next = c.getNext();\n+Node next = c.getNext; // c = c.next, may be null or empty\n         c = next;\n       }\n \n       visit(node);\n       visits++;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "Node next = c.getNext();",
        "fixed_line": "Node next = c.getNext();"
    },
    "JacksonDatabind-35": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (typeId!= JsonToken.START_OBJECT) { throw ctxt: \"need JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-35/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\t2022-07-19 16:59:32.160440595 +0200\n+++ /tmp/tmp64ukya_v.java\t2022-07-19 16:59:32.276440059 +0200\n@@ -84,14 +84,11 @@\n             if (typeId != null) {\n                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n             }\n         }\n         // first, sanity checks\n-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n-        }\n+if (typeId!= JsonToken.START_OBJECT) { throw ctxt: \"need JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }\n             // should always get field name, but just in case...\n             if (p.nextToken() != JsonToken.FIELD_NAME) {\n                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (typeId!= JsonToken.START_OBJECT) { throw ctxt; add JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-35/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\t2022-07-19 16:59:34.212431033 +0200\n+++ /tmp/tmp1iojt923.java\t2022-07-19 16:59:34.212431033 +0200\n@@ -84,14 +84,11 @@\n             if (typeId != null) {\n                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n             }\n         }\n         // first, sanity checks\n-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n-        }\n+if (typeId!= JsonToken.START_OBJECT) { throw ctxt; add JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }\n             // should always get field name, but just in case...\n             if (p.nextToken() != JsonToken.FIELD_NAME) {\n                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (type == JsonToken.START_OBJECT) { throw ctxt: \"need JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-35/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\t2022-07-19 16:59:35.784423704 +0200\n+++ /tmp/tmp82xwmg3e.java\t2022-07-19 16:59:35.784423704 +0200\n@@ -84,14 +84,11 @@\n             if (typeId != null) {\n                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n             }\n         }\n         // first, sanity checks\n-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n-        }\n+if (type == JsonToken.START_OBJECT) { throw ctxt: \"need JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }\n             // should always get field name, but just in case...\n             if (p.nextToken() != JsonToken.FIELD_NAME) {\n                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (typeId == JsonToken.START_OBJECT) { throw ctxt: \"need JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-35/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\t2022-07-19 16:59:37.392416203 +0200\n+++ /tmp/tmpy2omvbzs.java\t2022-07-19 16:59:37.392416203 +0200\n@@ -84,14 +84,11 @@\n             if (typeId != null) {\n                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n             }\n         }\n         // first, sanity checks\n-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n-        }\n+if (typeId == JsonToken.START_OBJECT) { throw ctxt: \"need JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }\n             // should always get field name, but just in case...\n             if (p.nextToken() != JsonToken.FIELD_NAME) {\n                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (_typeId!= JsonToken.START_OBJECT) { throw ctxt: \"need JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-35/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\t2022-07-19 16:59:39.024408583 +0200\n+++ /tmp/tmpkfmcjvly.java\t2022-07-19 16:59:39.024408583 +0200\n@@ -84,14 +84,11 @@\n             if (typeId != null) {\n                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n             }\n         }\n         // first, sanity checks\n-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n-        }\n+if (_typeId!= JsonToken.START_OBJECT) { throw ctxt: \"need JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }\n             // should always get field name, but just in case...\n             if (p.nextToken() != JsonToken.FIELD_NAME) {\n                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (_typeId == JsonToken.START_OBJECT) { throw ctxt: \"need JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-35/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\t2022-07-19 16:59:40.616401145 +0200\n+++ /tmp/tmpxvvdf2mf.java\t2022-07-19 16:59:40.616401145 +0200\n@@ -84,14 +84,11 @@\n             if (typeId != null) {\n                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n             }\n         }\n         // first, sanity checks\n-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n-        }\n+if (_typeId == JsonToken.START_OBJECT) { throw ctxt: \"need JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }\n             // should always get field name, but just in case...\n             if (p.nextToken() != JsonToken.FIELD_NAME) {\n                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (type == JsonToken.START_OBJECT) { throw ctxt; add JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-35/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\t2022-07-19 16:59:42.116394132 +0200\n+++ /tmp/tmpan2q4c64.java\t2022-07-19 16:59:42.116394132 +0200\n@@ -84,14 +84,11 @@\n             if (typeId != null) {\n                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n             }\n         }\n         // first, sanity checks\n-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n-        }\n+if (type == JsonToken.START_OBJECT) { throw ctxt; add JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }\n             // should always get field name, but just in case...\n             if (p.nextToken() != JsonToken.FIELD_NAME) {\n                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (typeId!= JsonToken.START_OBJECT) { throw ctxt.wrong JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-35/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\t2022-07-19 16:59:43.720386626 +0200\n+++ /tmp/tmp_m44d958.java\t2022-07-19 16:59:43.720386626 +0200\n@@ -84,14 +84,11 @@\n             if (typeId != null) {\n                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n             }\n         }\n         // first, sanity checks\n-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n-        }\n+if (typeId!= JsonToken.START_OBJECT) { throw ctxt.wrong JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }\n             // should always get field name, but just in case...\n             if (p.nextToken() != JsonToken.FIELD_NAME) {\n                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (typeId == JsonToken.START_OBJECT) { throw ctxt; add JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-35/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\t2022-07-19 16:59:45.348379004 +0200\n+++ /tmp/tmpkyjd_k5d.java\t2022-07-19 16:59:45.352378987 +0200\n@@ -84,14 +84,11 @@\n             if (typeId != null) {\n                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n             }\n         }\n         // first, sanity checks\n-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n-        }\n+if (typeId == JsonToken.START_OBJECT) { throw ctxt; add JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }\n             // should always get field name, but just in case...\n             if (p.nextToken() != JsonToken.FIELD_NAME) {\n                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (type == JsonToken.START_OBJECT) { throw ctxt.wrong JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-35/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\t2022-07-19 16:59:46.932371584 +0200\n+++ /tmp/tmp4xvj9nun.java\t2022-07-19 16:59:46.932371584 +0200\n@@ -84,14 +84,11 @@\n             if (typeId != null) {\n                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n             }\n         }\n         // first, sanity checks\n-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n-        }\n+if (type == JsonToken.START_OBJECT) { throw ctxt.wrong JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }\n             // should always get field name, but just in case...\n             if (p.nextToken() != JsonToken.FIELD_NAME) {\n                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (p.getCurrentToken() != JsonToken.START_OBJECT) { throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT, \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName()); }",
        "fixed_line": "JsonToken t = p.getCurrentToken(); if (t == JsonToken.START_OBJECT) { // should always get field name, but just in case... if (p.nextToken() != JsonToken.FIELD_NAME) { throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME, \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\"); } } else if (t != JsonToken.FIELD_NAME) { throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT, \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName()); }"
    },
    "Gson-17": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (in.peek!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\t2022-07-19 16:59:48.752363052 +0200\n+++ /tmp/tmpxn8m1h_r.java\t2022-07-19 16:59:48.784362903 +0200\n@@ -94,12 +94,11 @@\n     }\n   }\n \n   @Override\n   public Date read(JsonReader in) throws IOException {\n-    if (in.peek() != JsonToken.STRING) {\n-      throw new JsonParseException(\"The date should be a string value\");\n+if (in.peek!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\");\n     }\n     Date date = deserializeToDate(in.nextString());\n     if (dateType == Date.class) {\n       return date;\n     } else if (dateType == Timestamp.class) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (in.peek!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string 0,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\t2022-07-19 16:59:50.732353763 +0200\n+++ /tmp/tmpgujx7to0.java\t2022-07-19 16:59:50.732353763 +0200\n@@ -94,12 +94,11 @@\n     }\n   }\n \n   @Override\n   public Date read(JsonReader in) throws IOException {\n-    if (in.peek() != JsonToken.STRING) {\n-      throw new JsonParseException(\"The date should be a string value\");\n+if (in.peek!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string 0,\n     }\n     Date date = deserializeToDate(in.nextString());\n     if (dateType == Date.class) {\n       return date;\n     } else if (dateType == Timestamp.class) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (in.peek!= JsonToken.STRING) { throw new JsonParseExceptionParseException(\"The date should be a string value\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\t2022-07-19 16:59:52.284346475 +0200\n+++ /tmp/tmpadq9e5kc.java\t2022-07-19 16:59:52.284346475 +0200\n@@ -94,12 +94,11 @@\n     }\n   }\n \n   @Override\n   public Date read(JsonReader in) throws IOException {\n-    if (in.peek() != JsonToken.STRING) {\n-      throw new JsonParseException(\"The date should be a string value\");\n+if (in.peek!= JsonToken.STRING) { throw new JsonParseExceptionParseException(\"The date should be a string value\");\n     }\n     Date date = deserializeToDate(in.nextString());\n     if (dateType == Date.class) {\n       return date;\n     } else if (dateType == Timestamp.class) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (in.peek!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string string value\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\t2022-07-19 16:59:53.872339014 +0200\n+++ /tmp/tmpea6szvhn.java\t2022-07-19 16:59:53.872339014 +0200\n@@ -94,12 +94,11 @@\n     }\n   }\n \n   @Override\n   public Date read(JsonReader in) throws IOException {\n-    if (in.peek() != JsonToken.STRING) {\n-      throw new JsonParseException(\"The date should be a string value\");\n+if (in.peek!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string string value\");\n     }\n     Date date = deserializeToDate(in.nextString());\n     if (dateType == Date.class) {\n       return date;\n     } else if (dateType == Timestamp.class) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (in.peek!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\t2022-07-19 16:59:55.548331134 +0200\n+++ /tmp/tmpao2jv6pk.java\t2022-07-19 16:59:55.552331115 +0200\n@@ -94,12 +94,11 @@\n     }\n   }\n \n   @Override\n   public Date read(JsonReader in) throws IOException {\n-    if (in.peek() != JsonToken.STRING) {\n-      throw new JsonParseException(\"The date should be a string value\");\n+if (in.peek!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string\");\n     }\n     Date date = deserializeToDate(in.nextString());\n     if (dateType == Date.class) {\n       return date;\n     } else if (dateType == Timestamp.class) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (in.peek!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string parent\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\t2022-07-19 16:59:57.228323228 +0200\n+++ /tmp/tmppzsw_cfe.java\t2022-07-19 16:59:57.232323211 +0200\n@@ -94,12 +94,11 @@\n     }\n   }\n \n   @Override\n   public Date read(JsonReader in) throws IOException {\n-    if (in.peek() != JsonToken.STRING) {\n-      throw new JsonParseException(\"The date should be a string value\");\n+if (in.peek!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string parent\");\n     }\n     Date date = deserializeToDate(in.nextString());\n     if (dateType == Date.class) {\n       return date;\n     } else if (dateType == Timestamp.class) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (in.peek!= JsonToken.STRING) { throw new JsonParseExceptionParseException(\"The date should be a string 0,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\t2022-07-19 16:59:58.904315339 +0200\n+++ /tmp/tmpzgtxh078.java\t2022-07-19 16:59:58.904315339 +0200\n@@ -94,12 +94,11 @@\n     }\n   }\n \n   @Override\n   public Date read(JsonReader in) throws IOException {\n-    if (in.peek() != JsonToken.STRING) {\n-      throw new JsonParseException(\"The date should be a string value\");\n+if (in.peek!= JsonToken.STRING) { throw new JsonParseExceptionParseException(\"The date should be a string 0,\n     }\n     Date date = deserializeToDate(in.nextString());\n     if (dateType == Date.class) {\n       return date;\n     } else if (dateType == Timestamp.class) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (in.peek!= JsonToken.STRING) { throw new JsonParseException(\"The date (of type\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\t2022-07-19 17:00:00.476307933 +0200\n+++ /tmp/tmp70opu6ue.java\t2022-07-19 17:00:00.476307933 +0200\n@@ -94,12 +94,11 @@\n     }\n   }\n \n   @Override\n   public Date read(JsonReader in) throws IOException {\n-    if (in.peek() != JsonToken.STRING) {\n-      throw new JsonParseException(\"The date should be a string value\");\n+if (in.peek!= JsonToken.STRING) { throw new JsonParseException(\"The date (of type\");\n     }\n     Date date = deserializeToDate(in.nextString());\n     if (dateType == Date.class) {\n       return date;\n     } else if (dateType == Timestamp.class) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (in.peek!= JsonToken.STRING) { throw new JsonParseExceptionParseException(\"The date should be a string string value\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\t2022-07-19 17:00:02.144300069 +0200\n+++ /tmp/tmpotz2bm1y.java\t2022-07-19 17:00:02.144300069 +0200\n@@ -94,12 +94,11 @@\n     }\n   }\n \n   @Override\n   public Date read(JsonReader in) throws IOException {\n-    if (in.peek() != JsonToken.STRING) {\n-      throw new JsonParseException(\"The date should be a string value\");\n+if (in.peek!= JsonToken.STRING) { throw new JsonParseExceptionParseException(\"The date should be a string string value\");\n     }\n     Date date = deserializeToDate(in.nextString());\n     if (dateType == Date.class) {\n       return date;\n     } else if (dateType == Timestamp.class) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (in.peek!= JsonToken.STRING) { throw new JsonParseExceptionParseException(\"The date should be a string parent\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\t2022-07-19 17:00:03.816292181 +0200\n+++ /tmp/tmpaxyvrtcu.java\t2022-07-19 17:00:03.816292181 +0200\n@@ -94,12 +94,11 @@\n     }\n   }\n \n   @Override\n   public Date read(JsonReader in) throws IOException {\n-    if (in.peek() != JsonToken.STRING) {\n-      throw new JsonParseException(\"The date should be a string value\");\n+if (in.peek!= JsonToken.STRING) { throw new JsonParseExceptionParseException(\"The date should be a string parent\");\n     }\n     Date date = deserializeToDate(in.nextString());\n     if (dateType == Date.class) {\n       return date;\n     } else if (dateType == Timestamp.class) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (in.peek() != JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\");",
        "fixed_line": "if (in.peek() == JsonToken.NULL) { in.nextNull(); return null;"
    },
    "Csv-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "{ final String recordSeparator = format.getRecordSeparator(); newRecord = true; }",
                "patch_diff": "{ final String recordSeparator = format.getRecordSeparator(); newRecord = true; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "{ final String recordSeparator = format.getRecordSeparator(); newRecord = false; }",
                "patch_diff": "{ final String recordSeparator = format.getRecordSeparator(); newRecord = false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "{ final String recordSeparator = format.getRecordSeparator(); if (recordSeparator!= null) { out.append(recordSeparator); } } }",
                "patch_diff": "{ final String recordSeparator = format.getRecordSeparator(); if (recordSeparator!= null) { out.append(recordSeparator); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "{ final String recordSeparator = format.getRecordSeparator(); if (recordSeparator!= null) { out.append(recordSeparator); } }",
                "patch_diff": "{ final String recordSeparator = format.getRecordSeparator(); if (recordSeparator!= null) { out.append(recordSeparator); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = 0; i < recordSeparator; i++) {",
                "patch_diff": "for (int i = 0; i < recordSeparator; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "{ final String recordSeparator = format.getRecordSeparator(); if (recordSeparator) { out.append(recordSeparator); } } }",
                "patch_diff": "{ final String recordSeparator = format.getRecordSeparator(); if (recordSeparator) { out.append(recordSeparator); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "{ final String recordSeparator = format.getRecordSeparator(); out.append(recordSeparator); newRecord = true; }",
                "patch_diff": "{ final String recordSeparator = format.getRecordSeparator(); out.append(recordSeparator); newRecord = true; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "{ final String recordSeparator = format.getRecordSeparator(); if (recordSeparator!= null) { out.append(path.getRecordSeparator()); } } }",
                "patch_diff": "{ final String recordSeparator = format.getRecordSeparator(); if (recordSeparator!= null) { out.append(path.getRecordSeparator()); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "{ final String recordSeparator = format.getRecordSeparator(); if (recordSeparator!= null) { out.append(path.getRecordSeparator()); } }",
                "patch_diff": "{ final String recordSeparator = format.getRecordSeparator(); if (recordSeparator!= null) { out.append(path.getRecordSeparator()); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "{ final String recordSeparator = format.getRecordSeparator(); if (recordSeparator!= null) { break; } } }",
                "patch_diff": "{ final String recordSeparator = format.getRecordSeparator(); if (recordSeparator!= null) { break; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (recordSeparator != null) { out.append(recordSeparator); }"
    },
    "Closure-36": {
        "fixes": [
            {
                "k": 1,
                "patch": "// issue 668: Don't inline",
                "patch_diff": "// issue 668: Don't inline",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// issue 668: Don't inline it }",
                "patch_diff": "// issue 668: Don't inline it }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// issue 668: Don't inline it was non-literal characters that might be valid (empty be",
                "patch_diff": "// issue 668: Don't inline it was non-literal characters that might be valid (empty be",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// issue 668: Don't inline throw new IllegalArgumentException(\"Invalid 668: Don't inline \" + reference); }",
                "patch_diff": "// issue 668: Don't inline throw new IllegalArgumentException(\"Invalid 668: Don't inline \" + reference); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// issue 668: Don't inline it was non-literal characters that might be valid (empty be valid)",
                "patch_diff": "// issue 668: Don't inline it was non-literal characters that might be valid (empty be valid)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// issue 668: Don't inline it's non-literal characters that might be valid (empty be",
                "patch_diff": "// issue 668: Don't inline it's non-literal characters that might be valid (empty be",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// issue 668: Don't inline it = canMoveModerately(initialization, reference);",
                "patch_diff": "// issue 668: Don't inline it = canMoveModerately(initialization, reference);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// issue 668: Don't inline it = canMoveModerately(initialization, reference); }",
                "patch_diff": "// issue 668: Don't inline it = canMoveModerately(initialization, reference); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// issue 668: Don't inline it was non-literal characters that might be valid (empty be // need to check",
                "patch_diff": "// issue 668: Don't inline it was non-literal characters that might be valid (empty be // need to check",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// issue 668: Don't inline throw new IllegalArgumentException(value) isMoveModerately(initialization, reference);",
                "patch_diff": "// issue 668: Don't inline throw new IllegalArgumentException(value) isMoveModerately(initialization, reference);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (convention.getSingletonGetterClassName(callNode) != null) { return false; }"
    },
    "Closure-65": {
        "fixes": [
            {
                "k": 1,
                "patch": "case '\\0': sb.append(\"\\\\0ListList; break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-65/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 17:00:09.004267671 +0200\n+++ /tmp/tmp8t67n87y.java\t2022-07-19 17:00:09.048267463 +0200\n@@ -1010,11 +1010,11 @@\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+case '\\0': sb.append(\"\\\\0ListList; break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n         case '\\\\': sb.append(backslashEscape); break;\n         case '\\\"': sb.append(doublequoteEscape); break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "case '\\0': sb = s.append(\"\\\\0token; break, i.ch) break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-65/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 17:00:11.976253610 +0200\n+++ /tmp/tmp48j95vpo.java\t2022-07-19 17:00:11.976253610 +0200\n@@ -1010,11 +1010,11 @@\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+case '\\0': sb = s.append(\"\\\\0token; break, i.ch) break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n         case '\\\\': sb.append(backslashEscape); break;\n         case '\\\"': sb.append(doublequoteEscape); break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "case '\\0': sb = s.append(\"\\\\0token; break = i.next) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-65/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 17:00:14.484241728 +0200\n+++ /tmp/tmp14lw95zm.java\t2022-07-19 17:00:14.484241728 +0200\n@@ -1010,11 +1010,11 @@\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+case '\\0': sb = s.append(\"\\\\0token; break = i.next) {\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n         case '\\\\': sb.append(backslashEscape); break;\n         case '\\\"': sb.append(doublequoteEscape); break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "case '\\0': sb.append(\"\\\\0token; break, i.ch) break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-65/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 17:00:16.956230006 +0200\n+++ /tmp/tmp5cf1i1_d.java\t2022-07-19 17:00:16.956230006 +0200\n@@ -1010,11 +1010,11 @@\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+case '\\0': sb.append(\"\\\\0token; break, i.ch) break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n         case '\\\\': sb.append(backslashEscape); break;\n         case '\\\"': sb.append(doublequoteEscape); break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "case '\\0': sb = s.append(\"\\\\0token; break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-65/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 17:00:19.576217570 +0200\n+++ /tmp/tmpt13lmjf_.java\t2022-07-19 17:00:19.576217570 +0200\n@@ -1010,11 +1010,11 @@\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+case '\\0': sb = s.append(\"\\\\0token; break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n         case '\\\\': sb.append(backslashEscape); break;\n         case '\\\"': sb.append(doublequoteEscape); break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "case '\\0': sb.append(\"\\\\0List; break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-65/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 17:00:22.064205749 +0200\n+++ /tmp/tmpfnda6n2_.java\t2022-07-19 17:00:22.064205749 +0200\n@@ -1010,11 +1010,11 @@\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+case '\\0': sb.append(\"\\\\0List; break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n         case '\\\\': sb.append(backslashEscape); break;\n         case '\\\"': sb.append(doublequoteEscape); break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "case '\\0': sb = s.append(\"\\\\0token; break, i.ch) break, i.ch) break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-65/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 17:00:24.688193270 +0200\n+++ /tmp/tmp61kmtfsz.java\t2022-07-19 17:00:24.688193270 +0200\n@@ -1010,11 +1010,11 @@\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+case '\\0': sb = s.append(\"\\\\0token; break, i.ch) break, i.ch) break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n         case '\\\\': sb.append(backslashEscape); break;\n         case '\\\"': sb.append(doublequoteEscape); break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "case '\\0': sb.append(\"\\\\0token; break = i.next) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-65/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 17:00:27.192181350 +0200\n+++ /tmp/tmp44gn4epn.java\t2022-07-19 17:00:27.196181331 +0200\n@@ -1010,11 +1010,11 @@\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+case '\\0': sb.append(\"\\\\0token; break = i.next) {\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n         case '\\\\': sb.append(backslashEscape); break;\n         case '\\\"': sb.append(doublequoteEscape); break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "case '\\0': sb.append(\"\\\\0ListListList; break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-65/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 17:00:29.648169647 +0200\n+++ /tmp/tmpds_6vt67.java\t2022-07-19 17:00:29.648169647 +0200\n@@ -1010,11 +1010,11 @@\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+case '\\0': sb.append(\"\\\\0ListListList; break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n         case '\\\\': sb.append(backslashEscape); break;\n         case '\\\"': sb.append(doublequoteEscape); break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "case '\\0': sb = s.append(\"\\\\0\"); break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-65/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 17:00:32.148157724 +0200\n+++ /tmp/tmp44ws291h.java\t2022-07-19 17:00:32.148157724 +0200\n@@ -1010,11 +1010,11 @@\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+case '\\0': sb = s.append(\"\\\\0\"); break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n         case '\\\\': sb.append(backslashEscape); break;\n         case '\\\"': sb.append(doublequoteEscape); break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "case '\\0': sb.append(\"\\\\0\"); break;",
        "fixed_line": "case '\\0': sb.append(\"\\\\000\"); break;"
    },
    "JxPath-8": {
        "fixes": [
            {
                "k": 1,
                "patch": "return left instanceof IteratorSetUtil.doubleValue(right, left);",
                "patch_diff": "return left instanceof IteratorSetUtil.doubleValue(right, left);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return left instanceof IteratorSetUtil.doubleValue(left, rd = InfoSetUtil.doubleValue(right, left);",
                "patch_diff": "return left instanceof IteratorSetUtil.doubleValue(left, rd = InfoSetUtil.doubleValue(right, left);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} double ld = InfoSetUtil.doubleValue(right, left);",
                "patch_diff": "} double ld = InfoSetUtil.doubleValue(right, left);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return left instanceof IteratorSetUtil.doubleValue(left, rd = InfoSetUtil.doubleValue(right, left); }",
                "patch_diff": "return left instanceof IteratorSetUtil.doubleValue(left, rd = InfoSetUtil.doubleValue(right, left); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return left instanceof IteratorSetUtil.doubleValue(right, left); }",
                "patch_diff": "return left instanceof IteratorSetUtil.doubleValue(right, left); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return left instanceof SelfContext) {",
                "patch_diff": "return left instanceof SelfContext) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return left instanceof IteratorSetUtil.doubleValue(left, rd = InfoSetUtil.doubleValue(right);",
                "patch_diff": "return left instanceof IteratorSetUtil.doubleValue(left, rd = InfoSetUtil.doubleValue(right);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return left instanceof IteratorSetUtil.doubleValue(left, rd = InfoSetUtil.doubleValue(left, left);",
                "patch_diff": "return left instanceof IteratorSetUtil.doubleValue(left, rd = InfoSetUtil.doubleValue(left, left);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return left instanceof IteratorSetUtil.doubleValue(left, rd = InfoSetUtil.doubleValue(left);",
                "patch_diff": "return left instanceof IteratorSetUtil.doubleValue(left, rd = InfoSetUtil.doubleValue(left);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return left instanceof IteratorSetUtil.doubleValue(left, rd = InfoSetUtil.doubleValue(right;",
                "patch_diff": "return left instanceof IteratorSetUtil.doubleValue(left, rd = InfoSetUtil.doubleValue(right;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (Double.isNaN(ld)) { return false; } double rd = InfoSetUtil.doubleValue(right); if (Double.isNaN(rd)) { return false; }"
    },
    "Time-17": {
        "fixes": [
            {
                "k": 1,
                "patch": "long instantBefore = convertUTC > 3 * DateTimeConstants.MILLIS_PER_HOUR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-17/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 17:00:37.072134205 +0200\n+++ /tmp/tmp7sqpc9va.java\t2022-07-19 17:00:37.096134091 +0200\n@@ -1162,19 +1162,11 @@\n      */\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n-        }\n-        \n-        // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+long instantBefore = convertUTC > 3 * DateTimeConstants.MILLIS_PER_HOUR;\n         \n         // calculate result\n           // currently in later offset\n           // currently in earlier offset\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "long instantBefore = convertUTC(instant - offset) * DateTimeConstants.MILLIS_PER_HOUR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-17/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 17:00:39.160124218 +0200\n+++ /tmp/tmppkavf33m.java\t2022-07-19 17:00:39.160124218 +0200\n@@ -1162,19 +1162,11 @@\n      */\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n-        }\n-        \n-        // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+long instantBefore = convertUTC(instant - offset) * DateTimeConstants.MILLIS_PER_HOUR;\n         \n         // calculate result\n           // currently in later offset\n           // currently in earlier offset\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "long instantBefore = convertUTC * DateTimeConstants.MILLIS_PER_HOUR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-17/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 17:00:40.868116045 +0200\n+++ /tmp/tmp4i1mem1d.java\t2022-07-19 17:00:40.868116045 +0200\n@@ -1162,19 +1162,11 @@\n      */\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n-        }\n-        \n-        // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+long instantBefore = convertUTC * DateTimeConstants.MILLIS_PER_HOUR;\n         \n         // calculate result\n           // currently in later offset\n           // currently in earlier offset\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "long instantBefore = convertUTC - offset) * DateTimeConstants.MILLIS_PER_HOUR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-17/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 17:00:42.544108018 +0200\n+++ /tmp/tmpimp3j3dh.java\t2022-07-19 17:00:42.544108018 +0200\n@@ -1162,19 +1162,11 @@\n      */\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n-        }\n-        \n-        // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+long instantBefore = convertUTC - offset) * DateTimeConstants.MILLIS_PER_HOUR;\n         \n         // calculate result\n           // currently in later offset\n           // currently in earlier offset\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "long instantBefore = convertUTCToLocal - 3 * DateTimeConstants.MILLIS_PER_HOUR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-17/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 17:00:44.048100811 +0200\n+++ /tmp/tmpb96qcxil.java\t2022-07-19 17:00:44.048100811 +0200\n@@ -1162,19 +1162,11 @@\n      */\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n-        }\n-        \n-        // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+long instantBefore = convertUTCToLocal - 3 * DateTimeConstants.MILLIS_PER_HOUR;\n         \n         // calculate result\n           // currently in later offset\n           // currently in earlier offset\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "long instantBefore = new DateTimeConstants.MILLIS_PER_HOUR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-17/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 17:00:45.756092620 +0200\n+++ /tmp/tmprfnirj49.java\t2022-07-19 17:00:45.760092604 +0200\n@@ -1162,19 +1162,11 @@\n      */\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n-        }\n-        \n-        // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+long instantBefore = new DateTimeConstants.MILLIS_PER_HOUR;\n         \n         // calculate result\n           // currently in later offset\n           // currently in earlier offset\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "long instantBefore = convertUTCCount * DateTimeConstants.MILLIS_PER_HOUR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-17/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 17:00:47.380084830 +0200\n+++ /tmp/tmpjdcm72mf.java\t2022-07-19 17:00:47.380084830 +0200\n@@ -1162,19 +1162,11 @@\n      */\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n-        }\n-        \n-        // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+long instantBefore = convertUTCCount * DateTimeConstants.MILLIS_PER_HOUR;\n         \n         // calculate result\n           // currently in later offset\n           // currently in earlier offset\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "long instantBefore = convertUTCs * DateTimeConstants.MILLIS_PER_HOUR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-17/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 17:00:49.040076860 +0200\n+++ /tmp/tmpeuyc_xek.java\t2022-07-19 17:00:49.040076860 +0200\n@@ -1162,19 +1162,11 @@\n      */\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n-        }\n-        \n-        // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+long instantBefore = convertUTCs * DateTimeConstants.MILLIS_PER_HOUR;\n         \n         // calculate result\n           // currently in later offset\n           // currently in earlier offset\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "long instantBefore = instant / DateTimeConstants.MILLIS_PER_HOUR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-17/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 17:00:50.700068889 +0200\n+++ /tmp/tmpd2x1_p0l.java\t2022-07-19 17:00:50.704068869 +0200\n@@ -1162,19 +1162,11 @@\n      */\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n-        }\n-        \n-        // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+long instantBefore = instant / DateTimeConstants.MILLIS_PER_HOUR;\n         \n         // calculate result\n           // currently in later offset\n           // currently in earlier offset\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "long instantBefore = convertUTC - offset;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-17/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 17:00:52.436060544 +0200\n+++ /tmp/tmpjqomkjn0.java\t2022-07-19 17:00:52.440060524 +0200\n@@ -1162,19 +1162,11 @@\n      */\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n-        }\n-        \n-        // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+long instantBefore = convertUTC - offset;\n         \n         // calculate result\n           // currently in later offset\n           // currently in earlier offset\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR); long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR); if (instantBefore == instantAfter) { return instant; // not an overlap (less than is a gap, equal is normal case) } // work out range of instants that have duplicate local times long local = convertUTCToLocal(instant); return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);",
        "fixed_line": "long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR; long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR; long offsetBefore = getOffset(instantBefore); long offsetAfter = getOffset(instantAfter); if (offsetBefore <= offsetAfter) { return instant; // not an overlap (less than is a gap, equal is normal case) } // work out range of instants that have duplicate local times long diff = offsetBefore - offsetAfter; long transition = nextTransition(instantBefore); long overlapStart = transition - diff; long overlapEnd = transition + diff; if (instant < overlapStart || instant >= overlapEnd) { return instant; // not an overlap } // calculate result long afterStart = instant - overlapStart; if (afterStart >= diff) { // currently in later offset return earlierOrLater ? instant : instant - diff; } else { // currently in earlier offset return earlierOrLater ? instant + diff : instant; }"
    },
    "Math-58": {
        "fixes": [
            {
                "k": 1,
                "patch": "return guess.Parametric point (0 + guess;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2022-07-19 17:00:54.264051753 +0200\n+++ /tmp/tmpxysbqto5.java\t2022-07-19 17:00:54.284051655 +0200\n@@ -116,11 +116,11 @@\n      * @return the parameters of the Gaussian function that best fits the\n      * observed points (in the same order as above).\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+return guess.Parametric point (0 + guess;\n     }\n \n     /**\n      * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n      * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return guess.Parametric % guess;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2022-07-19 17:00:56.708039990 +0200\n+++ /tmp/tmpbd5f8ryb.java\t2022-07-19 17:00:56.708039990 +0200\n@@ -116,11 +116,11 @@\n      * @return the parameters of the Gaussian function that best fits the\n      * observed points (in the same order as above).\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+return guess.Parametric % guess;\n     }\n \n     /**\n      * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n      * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return guess.Parametric!= guess;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2022-07-19 17:00:58.904029412 +0200\n+++ /tmp/tmp1_7we3rv.java\t2022-07-19 17:00:58.904029412 +0200\n@@ -116,11 +116,11 @@\n      * @return the parameters of the Gaussian function that best fits the\n      * observed points (in the same order as above).\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+return guess.Parametric!= guess;\n     }\n \n     /**\n      * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n      * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return guess.Parametric(), guess;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2022-07-19 17:01:01.004019288 +0200\n+++ /tmp/tmpgukga5yx.java\t2022-07-19 17:01:01.008019268 +0200\n@@ -116,11 +116,11 @@\n      * @return the parameters of the Gaussian function that best fits the\n      * observed points (in the same order as above).\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+return guess.Parametric(), guess;\n     }\n \n     /**\n      * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n      * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return guess.Parametric += guess;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2022-07-19 17:01:02.940009948 +0200\n+++ /tmp/tmpvrcdowud.java\t2022-07-19 17:01:02.940009948 +0200\n@@ -116,11 +116,11 @@\n      * @return the parameters of the Gaussian function that best fits the\n      * observed points (in the same order as above).\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+return guess.Parametric += guess;\n     }\n \n     /**\n      * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n      * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return guess.Parametric(), guess);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2022-07-19 17:01:05.039999810 +0200\n+++ /tmp/tmpzso3yaog.java\t2022-07-19 17:01:05.039999810 +0200\n@@ -116,11 +116,11 @@\n      * @return the parameters of the Gaussian function that best fits the\n      * observed points (in the same order as above).\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+return guess.Parametric(), guess);\n     }\n \n     /**\n      * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n      * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return guess.Parametric - guess;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2022-07-19 17:01:07.055990070 +0200\n+++ /tmp/tmpf373k05h.java\t2022-07-19 17:01:07.055990070 +0200\n@@ -116,11 +116,11 @@\n      * @return the parameters of the Gaussian function that best fits the\n      * observed points (in the same order as above).\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+return guess.Parametric - guess;\n     }\n \n     /**\n      * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n      * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return fit.Parametric(), guess;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2022-07-19 17:01:09.207979665 +0200\n+++ /tmp/tmpwf09ru7j.java\t2022-07-19 17:01:09.211979646 +0200\n@@ -116,11 +116,11 @@\n      * @return the parameters of the Gaussian function that best fits the\n      * observed points (in the same order as above).\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+return fit.Parametric(), guess;\n     }\n \n     /**\n      * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n      * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return fit.Parametric(), guess);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2022-07-19 17:01:11.287969603 +0200\n+++ /tmp/tmpdahbki7x.java\t2022-07-19 17:01:11.287969603 +0200\n@@ -116,11 +116,11 @@\n      * @return the parameters of the Gaussian function that best fits the\n      * observed points (in the same order as above).\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+return fit.Parametric(), guess);\n     }\n \n     /**\n      * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n      * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return guess;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2022-07-19 17:01:13.231960191 +0200\n+++ /tmp/tmpy6fyl1d5.java\t2022-07-19 17:01:13.231960191 +0200\n@@ -116,11 +116,11 @@\n      * @return the parameters of the Gaussian function that best fits the\n      * observed points (in the same order as above).\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+return guess;\n     }\n \n     /**\n      * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n      * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return fit(new Gaussian.Parametric(), guess);",
        "fixed_line": "return fit(guess);"
    },
    "Gson-16": {
        "fixes": [
            {
                "k": 1,
                "patch": "// this implementation? TypeVariable<?> typeVariable = (TypeVariable<?>) toType;",
                "patch_diff": "// this implementation? TypeVariable<?> typeVariable = (TypeVariable<?>) toType;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// this implementation? TypeVariable<?> typeVariable = (TypeVariable<?>) typeVariable;",
                "patch_diff": "// this implementation? TypeVariable<?> typeVariable = (TypeVariable<?>) typeVariable;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// this implementation? TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;",
                "patch_diff": "// this implementation? TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// this implementation? TypeVariable<?> typeVariable = (TypeVariable<?>) typeVariable; // cannot reduce due to infinite recursion to infinite recursion to infinite recursion to infinite recursion",
                "patch_diff": "// this implementation? TypeVariable<?> typeVariable = (TypeVariable<?>) typeVariable; // cannot reduce due to infinite recursion to infinite recursion to infinite recursion to infinite recursion",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// this implementation? TypeVariable<?> typeVariable = (TypeVariable<?>) typeVariable; // cannot reduce due to infinite recursion to infinite recursion to infinite recursion",
                "patch_diff": "// this implementation? TypeVariable<?> typeVariable = (TypeVariable<?>) typeVariable; // cannot reduce due to infinite recursion to infinite recursion to infinite recursion",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// this implementation? TypeVariable<?> typeVariable<?> = (TypeVariable<?>) toType;",
                "patch_diff": "// this implementation? TypeVariable<?> typeVariable<?> = (TypeVariable<?>) toType;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// this implementation? TypeVariable<?> typeVariable = (TypeVariable<?>) toType; // cannot reduce due to infinite recursion to infinite recursion to infinite recursion",
                "patch_diff": "// this implementation? TypeVariable<?> typeVariable = (TypeVariable<?>) toType; // cannot reduce due to infinite recursion to infinite recursion to infinite recursion",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// this implementation? TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve; // cannot reduce due to infinite recursion to infinite recursion to infinite recursion",
                "patch_diff": "// this implementation? TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve; // cannot reduce due to infinite recursion to infinite recursion to infinite recursion",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// this implementation? TypeVariable<?> typeVariable<?> = (TypeVariable<?>) toResolve; // cannot reduce due to infinite recursion to infinite recursion to infinite recursion to //",
                "patch_diff": "// this implementation? TypeVariable<?> typeVariable<?> = (TypeVariable<?>) toResolve; // cannot reduce due to infinite recursion to infinite recursion to infinite recursion to //",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// this implementation? TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve; // cannot reduce due to infinite recursion to infinite recursion",
                "patch_diff": "// this implementation? TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve; // cannot reduce due to infinite recursion to infinite recursion",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (visitedTypeVariables.contains(typeVariable)) { // cannot reduce due to infinite recursion return toResolve; } else { visitedTypeVariables.add(typeVariable); }"
    },
    "JacksonDatabind-99": {
        "fixes": [
            {
                "k": 1,
                "patch": "sb.append(_referencedType.getName());",
                "patch_diff": "sb.append(_referencedType.getName());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "sb = new StringBuilder(referencedType.getName()); sb.append(_referencedType.toCanonical());",
                "patch_diff": "sb = new StringBuilder(referencedType.getName()); sb.append(_referencedType.toCanonical());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "sb.append(_referencedType.getName()); sb.append(_referencedType.toCanonical());",
                "patch_diff": "sb.append(_referencedType.getName()); sb.append(_referencedType.toCanonical());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "StringBuilder sb = new StringBuilder(referencedType.getName()); sb.append(_referencedType.toCanonical());",
                "patch_diff": "StringBuilder sb = new StringBuilder(referencedType.getName()); sb.append(_referencedType.toCanonical());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "sb = new StringBuilder(referencedType.getName()); sb.append(_referencedType.toString());",
                "patch_diff": "sb = new StringBuilder(referencedType.getName()); sb.append(_referencedType.toString());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "sb = new StringBuilder(referencedType.getName());",
                "patch_diff": "sb = new StringBuilder(referencedType.getName());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "sb.append(_referencedType.getName()); sb.append(_referencedType.toString());",
                "patch_diff": "sb.append(_referencedType.getName()); sb.append(_referencedType.toString());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "sb = new StringBuilder(referencedType.getName()); sb.append(_nsencedType.toCanonical());",
                "patch_diff": "sb = new StringBuilder(referencedType.getName()); sb.append(_nsencedType.toCanonical());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "sb = sb.append(_referencedType.getName()); sb.append(_referencedType.toCanonical());",
                "patch_diff": "sb = sb.append(_referencedType.getName()); sb.append(_referencedType.toCanonical());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "sb = new StringBuilder(referencedType.getName()); sb.append(_referencedType.getName());",
                "patch_diff": "sb = new StringBuilder(referencedType.getName()); sb.append(_referencedType.getName());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "sb.append('>');"
    },
    "JacksonDatabind-19": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if no typeParams = findTypeParameters(rawClass, MapType, _unknownClass, _unknownClass;",
                "patch_diff": "// if no typeParams = findTypeParameters(rawClass, MapType, _unknownClass, _unknownClass;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// if no typeParams = findTypeParameters(rawClass, MapType, _unknownClass, _unknownClass, _unknownClass;",
                "patch_diff": "// if no typeParams = findTypeParameters(rawClass, MapType, _unknownClass, _unknownClass, _unknownClass;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if no typeParams = findTypeParameters(rawClass, MapType, _unknownClass, _unknownClass, _unknownClass, _unknownClass;",
                "patch_diff": "// if no typeParams = findTypeParameters(rawClass, MapType, _unknownClass, _unknownClass, _unknownClass, _unknownClass;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// if no typeParams = findTypeParameters(rawClass, MapType, _unknownClass;",
                "patch_diff": "// if no typeParams = findTypeParameters(rawClass, MapType, _unknownClass;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// if no typeParams = findTypeParameters(rawClass, MapType, _unknownClass, _unknownClass, _unknownClass, _unknownClass, _unknownClass;",
                "patch_diff": "// if no typeParams = findTypeParameters(rawClass, MapType, _unknownClass, _unknownClass, _unknownClass, _unknownClass, _unknownClass;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if no typeParams = findTypeParameters(rawClass, MapType, _unknownClass, _unknownClass, _typeParams, _asStatic);",
                "patch_diff": "// if no typeParams = findTypeParameters(rawClass, MapType, _unknownClass, _unknownClass, _typeParams, _asStatic);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// if no typeParams = findTypeParameters(rawClass, MapType, _unknownClass, _unknownClass);",
                "patch_diff": "// if no typeParams = findTypeParameters(rawClass, MapType, _unknownClass, _unknownClass);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// if no typeParams = findTypeParameters(rawClass, MapType, _unknownClass);",
                "patch_diff": "// if no typeParams = findTypeParameters(rawClass, MapType, _unknownClass);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// if no typeParams = findTypeParameters(rawClass, MapType, _unknownClass, _unknownClass, _unknownClass, _typeParams, _asStatic);",
                "patch_diff": "// if no typeParams = findTypeParameters(rawClass, MapType, _unknownClass, _unknownClass, _unknownClass, _typeParams, _asStatic);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if no typeParams = findTypeParameters(rawClass, MapType, _unknownClass, _unknownClass, _unknownClass);",
                "patch_diff": "// if no typeParams = findTypeParameters(rawClass, MapType, _unknownClass, _unknownClass, _unknownClass);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (rawClass == Properties.class) { return MapType.construct(rawClass, CORE_TYPE_STRING, CORE_TYPE_STRING); }"
    },
    "Csv-1": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (current == '\\n') { // firstChar; need to do lineCounter",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\t2022-07-19 17:02:01.655723764 +0200\n+++ /tmp/tmpyj54n2ry.java\t2022-07-19 17:02:01.683723627 +0200\n@@ -53,11 +53,11 @@\n     }\n \n     @Override\n     public int read() throws IOException {\n         int current = super.read();\n-        if (current == '\\n') {\n+if (current == '\\n') { // firstChar; need to do lineCounter\n             lineCounter++;\n         }\n         lastChar = current;\n         return lastChar;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (current == == '\\n') { // firstChar; need to do lineCounter",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\t2022-07-19 17:02:04.603709252 +0200\n+++ /tmp/tmpbegkhrsw.java\t2022-07-19 17:02:04.603709252 +0200\n@@ -53,11 +53,11 @@\n     }\n \n     @Override\n     public int read() throws IOException {\n         int current = super.read();\n-        if (current == '\\n') {\n+if (current == == '\\n') { // firstChar; need to do lineCounter\n             lineCounter++;\n         }\n         lastChar = current;\n         return lastChar;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (current!= '\\n') { // firstChar; need to do lineCounter",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\t2022-07-19 17:02:06.027702241 +0200\n+++ /tmp/tmpn__o75fr.java\t2022-07-19 17:02:06.027702241 +0200\n@@ -53,11 +53,11 @@\n     }\n \n     @Override\n     public int read() throws IOException {\n         int current = super.read();\n-        if (current == '\\n') {\n+if (current!= '\\n') { // firstChar; need to do lineCounter\n             lineCounter++;\n         }\n         lastChar = current;\n         return lastChar;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (current ==('\\n') { // firstChar; need to check",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\t2022-07-19 17:02:08.371690685 +0200\n+++ /tmp/tmp09kvc725.java\t2022-07-19 17:02:08.371690685 +0200\n@@ -53,11 +53,11 @@\n     }\n \n     @Override\n     public int read() throws IOException {\n         int current = super.read();\n-        if (current == '\\n') {\n+if (current ==('\\n') { // firstChar; need to check\n             lineCounter++;\n         }\n         lastChar = current;\n         return lastChar;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (current == == '\\n') { // firstChar; need to check",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\t2022-07-19 17:02:09.791683683 +0200\n+++ /tmp/tmpvtmmy6be.java\t2022-07-19 17:02:09.795683663 +0200\n@@ -53,11 +53,11 @@\n     }\n \n     @Override\n     public int read() throws IOException {\n         int current = super.read();\n-        if (current == '\\n') {\n+if (current == == '\\n') { // firstChar; need to check\n             lineCounter++;\n         }\n         lastChar = current;\n         return lastChar;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (current == '\\n') { // firstChar; need to check",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\t2022-07-19 17:02:11.255676460 +0200\n+++ /tmp/tmpomm4nboa.java\t2022-07-19 17:02:11.259676441 +0200\n@@ -53,11 +53,11 @@\n     }\n \n     @Override\n     public int read() throws IOException {\n         int current = super.read();\n-        if (current == '\\n') {\n+if (current == '\\n') { // firstChar; need to check\n             lineCounter++;\n         }\n         lastChar = current;\n         return lastChar;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (current == '\\n') { // firstChar == lastChar; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\t2022-07-19 17:02:13.667664555 +0200\n+++ /tmp/tmp9w9f97lp.java\t2022-07-19 17:02:13.667664555 +0200\n@@ -53,11 +53,11 @@\n     }\n \n     @Override\n     public int read() throws IOException {\n         int current = super.read();\n-        if (current == '\\n') {\n+if (current == '\\n') { // firstChar == lastChar; }\n             lineCounter++;\n         }\n         lastChar = current;\n         return lastChar;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (current ==('\\n') { // firstChar; need to do lineCounter",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\t2022-07-19 17:02:16.039652835 +0200\n+++ /tmp/tmpogbz0avn.java\t2022-07-19 17:02:16.039652835 +0200\n@@ -53,11 +53,11 @@\n     }\n \n     @Override\n     public int read() throws IOException {\n         int current = super.read();\n-        if (current == '\\n') {\n+if (current ==('\\n') { // firstChar; need to do lineCounter\n             lineCounter++;\n         }\n         lastChar = current;\n         return lastChar;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (current == '\\n') { // firstChar; need the lastChar",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\t2022-07-19 17:02:17.483645697 +0200\n+++ /tmp/tmp5imqi3a3.java\t2022-07-19 17:02:17.483645697 +0200\n@@ -53,11 +53,11 @@\n     }\n \n     @Override\n     public int read() throws IOException {\n         int current = super.read();\n-        if (current == '\\n') {\n+if (current == '\\n') { // firstChar; need the lastChar\n             lineCounter++;\n         }\n         lastChar = current;\n         return lastChar;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (current == == '\\n') { // firstChar == lastChar; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\t2022-07-19 17:02:20.015633175 +0200\n+++ /tmp/tmp1aasmh_m.java\t2022-07-19 17:02:20.015633175 +0200\n@@ -53,11 +53,11 @@\n     }\n \n     @Override\n     public int read() throws IOException {\n         int current = super.read();\n-        if (current == '\\n') {\n+if (current == == '\\n') { // firstChar == lastChar; }\n             lineCounter++;\n         }\n         lastChar = current;\n         return lastChar;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (current == '\\n') {",
        "fixed_line": "if (current == '\\r' || (current == '\\n' && lastChar != '\\r')) {"
    },
    "JacksonDatabind-64": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (tatu:: declaredType.isEnabled(Feature.CANONICALIZE_OVERRIDE, am, declaredType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-64/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\t2022-07-19 17:02:21.759624545 +0200\n+++ /tmp/tmpu7vcj2vz.java\t2022-07-19 17:02:21.795624365 +0200\n@@ -152,16 +152,11 @@\n \n             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n             //    revert logic to the case of general/per-property handling, so both\n             //    type-default AND null are to be excluded.\n             //    (as per [databind#1417]\n-            if (_useRealPropertyDefaults) {\n-                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n-                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n-                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-                }\n-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n+if (tatu:: declaredType.isEnabled(Feature.CANONICALIZE_OVERRIDE, am, declaredType);\n             } else {\n                 valueToSuppress = getDefaultValue(actualType);\n                 suppressNulls = true;\n             }\n             if (valueToSuppress == null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (tatu:: declaredType.isEnabled(MapperFeature.CANONICALIZE_OVERRIDE, am, declaredType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-64/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\t2022-07-19 17:02:24.007613414 +0200\n+++ /tmp/tmpa3zcevql.java\t2022-07-19 17:02:24.007613414 +0200\n@@ -152,16 +152,11 @@\n \n             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n             //    revert logic to the case of general/per-property handling, so both\n             //    type-default AND null are to be excluded.\n             //    (as per [databind#1417]\n-            if (_useRealPropertyDefaults) {\n-                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n-                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n-                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-                }\n-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n+if (tatu:: declaredType.isEnabled(MapperFeature.CANONICALIZE_OVERRIDE, am, declaredType);\n             } else {\n                 valueToSuppress = getDefaultValue(actualType);\n                 suppressNulls = true;\n             }\n             if (valueToSuppress == null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (tatu:: declaredType.isEnabled(Feature.CANONICALIZE_OVERRIDE, am) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-64/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\t2022-07-19 17:02:25.463606201 +0200\n+++ /tmp/tmp74xpu0_z.java\t2022-07-19 17:02:25.467606178 +0200\n@@ -152,16 +152,11 @@\n \n             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n             //    revert logic to the case of general/per-property handling, so both\n             //    type-default AND null are to be excluded.\n             //    (as per [databind#1417]\n-            if (_useRealPropertyDefaults) {\n-                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n-                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n-                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-                }\n-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n+if (tatu:: declaredType.isEnabled(Feature.CANONICALIZE_OVERRIDE, am) {\n             } else {\n                 valueToSuppress = getDefaultValue(actualType);\n                 suppressNulls = true;\n             }\n             if (valueToSuppress == null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (tatu:: declaredType.isEnabled(Feature.CANONICALIZE_OVERRIDE, am;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-64/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\t2022-07-19 17:02:27.015598506 +0200\n+++ /tmp/tmp0tk8zokh.java\t2022-07-19 17:02:27.015598506 +0200\n@@ -152,16 +152,11 @@\n \n             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n             //    revert logic to the case of general/per-property handling, so both\n             //    type-default AND null are to be excluded.\n             //    (as per [databind#1417]\n-            if (_useRealPropertyDefaults) {\n-                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n-                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n-                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-                }\n-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n+if (tatu:: declaredType.isEnabled(Feature.CANONICALIZE_OVERRIDE, am;\n             } else {\n                 valueToSuppress = getDefaultValue(actualType);\n                 suppressNulls = true;\n             }\n             if (valueToSuppress == null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (tatu:: declaredType.isEnabled(MapperFeature.CANONICALIZE_OVERRIDE, am) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-64/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\t2022-07-19 17:02:28.539590948 +0200\n+++ /tmp/tmpok8zui_d.java\t2022-07-19 17:02:28.539590948 +0200\n@@ -152,16 +152,11 @@\n \n             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n             //    revert logic to the case of general/per-property handling, so both\n             //    type-default AND null are to be excluded.\n             //    (as per [databind#1417]\n-            if (_useRealPropertyDefaults) {\n-                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n-                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n-                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-                }\n-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n+if (tatu:: declaredType.isEnabled(MapperFeature.CANONICALIZE_OVERRIDE, am) {\n             } else {\n                 valueToSuppress = getDefaultValue(actualType);\n                 suppressNulls = true;\n             }\n             if (valueToSuppress == null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (tatu:: declaredType.isEnabled(Feature.CANONICALIZE_OVERRIDE, declaredType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-64/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\t2022-07-19 17:02:30.083583288 +0200\n+++ /tmp/tmpd2gjpp51.java\t2022-07-19 17:02:30.087583268 +0200\n@@ -152,16 +152,11 @@\n \n             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n             //    revert logic to the case of general/per-property handling, so both\n             //    type-default AND null are to be excluded.\n             //    (as per [databind#1417]\n-            if (_useRealPropertyDefaults) {\n-                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n-                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n-                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-                }\n-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n+if (tatu:: declaredType.isEnabled(Feature.CANONICALIZE_OVERRIDE, declaredType);\n             } else {\n                 valueToSuppress = getDefaultValue(actualType);\n                 suppressNulls = true;\n             }\n             if (valueToSuppress == null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (tatu:: declaredType.isEnabled(MapperFeature.CANONICALIZE_OVERRIDE, am;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-64/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\t2022-07-19 17:02:31.687575329 +0200\n+++ /tmp/tmp75wsgmgv.java\t2022-07-19 17:02:31.687575329 +0200\n@@ -152,16 +152,11 @@\n \n             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n             //    revert logic to the case of general/per-property handling, so both\n             //    type-default AND null are to be excluded.\n             //    (as per [databind#1417]\n-            if (_useRealPropertyDefaults) {\n-                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n-                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n-                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-                }\n-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n+if (tatu:: declaredType.isEnabled(MapperFeature.CANONICALIZE_OVERRIDE, am;\n             } else {\n                 valueToSuppress = getDefaultValue(actualType);\n                 suppressNulls = true;\n             }\n             if (valueToSuppress == null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (tatu:: declaredType.isEnabled(Feature.CANONICALIZE_OVERRIDE, am);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-64/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\t2022-07-19 17:02:33.187567881 +0200\n+++ /tmp/tmpvoc5273h.java\t2022-07-19 17:02:33.187567881 +0200\n@@ -152,16 +152,11 @@\n \n             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n             //    revert logic to the case of general/per-property handling, so both\n             //    type-default AND null are to be excluded.\n             //    (as per [databind#1417]\n-            if (_useRealPropertyDefaults) {\n-                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n-                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n-                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-                }\n-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n+if (tatu:: declaredType.isEnabled(Feature.CANONICALIZE_OVERRIDE, am);\n             } else {\n                 valueToSuppress = getDefaultValue(actualType);\n                 suppressNulls = true;\n             }\n             if (valueToSuppress == null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (tatu:: declaredType.isEnabled(MapperFeature.CANONICALIZE_OVERRIDE, declaredType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-64/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\t2022-07-19 17:02:34.699560367 +0200\n+++ /tmp/tmptoro9ku8.java\t2022-07-19 17:02:34.699560367 +0200\n@@ -152,16 +152,11 @@\n \n             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n             //    revert logic to the case of general/per-property handling, so both\n             //    type-default AND null are to be excluded.\n             //    (as per [databind#1417]\n-            if (_useRealPropertyDefaults) {\n-                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n-                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n-                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-                }\n-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n+if (tatu:: declaredType.isEnabled(MapperFeature.CANONICALIZE_OVERRIDE, declaredType);\n             } else {\n                 valueToSuppress = getDefaultValue(actualType);\n                 suppressNulls = true;\n             }\n             if (valueToSuppress == null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (tatu:: declaredType.isEnabled(Feature.CANONICALIZE_OVERRIDE, am)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-64/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\t2022-07-19 17:02:36.223552795 +0200\n+++ /tmp/tmp_h3jajxs.java\t2022-07-19 17:02:36.223552795 +0200\n@@ -152,16 +152,11 @@\n \n             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n             //    revert logic to the case of general/per-property handling, so both\n             //    type-default AND null are to be excluded.\n             //    (as per [databind#1417]\n-            if (_useRealPropertyDefaults) {\n-                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n-                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n-                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-                }\n-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n+if (tatu:: declaredType.isEnabled(Feature.CANONICALIZE_OVERRIDE, am)) {\n             } else {\n                 valueToSuppress = getDefaultValue(actualType);\n                 suppressNulls = true;\n             }\n             if (valueToSuppress == null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (_useRealPropertyDefaults) { // 07-Sep-2016, tatu: may also need to front-load access forcing now if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) { am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS)); } valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);",
        "fixed_line": "Object defaultBean; // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\", // revert logic to the case of general/per-property handling, so both // type-default AND null are to be excluded. // (as per [databind#1417] if (_useRealPropertyDefaults && (defaultBean = getDefaultBean()) != null) { // 07-Sep-2016, tatu: may also need to front-load access forcing now if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) { am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS)); } try { valueToSuppress = am.getValue(defaultBean); } catch (Exception e) { _throwWrapped(e, propDef.getName(), defaultBean); }"
    },
    "JxPath-21": {
        "fixes": [
            {
                "k": 1,
                "patch": "return ValueUtils.getLength(lengthlengthBaseValue());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-21/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\t2022-07-19 17:02:37.987544020 +0200\n+++ /tmp/tmpzeycnnea.java\t2022-07-19 17:02:38.047543724 +0200\n@@ -147,11 +147,11 @@\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      * @return int length\n      */\n     public int getLength() {\n-        return ValueUtils.getLength(getBaseValue());\n+return ValueUtils.getLength(lengthlengthBaseValue());\n     }\n \n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return ValueUtils.getLength(collection) - 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-21/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\t2022-07-19 17:02:40.447531785 +0200\n+++ /tmp/tmpi5hrqjft.java\t2022-07-19 17:02:40.447531785 +0200\n@@ -147,11 +147,11 @@\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      * @return int length\n      */\n     public int getLength() {\n-        return ValueUtils.getLength(getBaseValue());\n+return ValueUtils.getLength(collection) - 1);\n     }\n \n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return ValueUtils.getLength(collection) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-21/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\t2022-07-19 17:02:42.107523521 +0200\n+++ /tmp/tmpocodlze3.java\t2022-07-19 17:02:42.107523521 +0200\n@@ -147,11 +147,11 @@\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      * @return int length\n      */\n     public int getLength() {\n-        return ValueUtils.getLength(getBaseValue());\n+return ValueUtils.getLength(collection) {\n     }\n \n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return ValueUtils.getLength(collection) - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-21/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\t2022-07-19 17:02:43.671515731 +0200\n+++ /tmp/tmphzn0pa38.java\t2022-07-19 17:02:43.671515731 +0200\n@@ -147,11 +147,11 @@\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      * @return int length\n      */\n     public int getLength() {\n-        return ValueUtils.getLength(getBaseValue());\n+return ValueUtils.getLength(collection) - 1;\n     }\n \n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return ValueUtils.getLength(lengthlength;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-21/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\t2022-07-19 17:02:45.347507379 +0200\n+++ /tmp/tmpfbxhy01b.java\t2022-07-19 17:02:45.347507379 +0200\n@@ -147,11 +147,11 @@\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      * @return int length\n      */\n     public int getLength() {\n-        return ValueUtils.getLength(getBaseValue());\n+return ValueUtils.getLength(lengthlength;\n     }\n \n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return ValueUtils.getLength(value);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-21/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\t2022-07-19 17:02:46.923499524 +0200\n+++ /tmp/tmpr3xnq7p1.java\t2022-07-19 17:02:46.923499524 +0200\n@@ -147,11 +147,11 @@\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      * @return int length\n      */\n     public int getLength() {\n-        return ValueUtils.getLength(getBaseValue());\n+return ValueUtils.getLength(value);\n     }\n \n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return ValueUtils.getLength(collection);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-21/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\t2022-07-19 17:02:52.703470680 +0200\n+++ /tmp/tmp6u8e7e8t.java\t2022-07-19 17:02:52.703470680 +0200\n@@ -147,11 +147,11 @@\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      * @return int length\n      */\n     public int getLength() {\n-        return ValueUtils.getLength(getBaseValue());\n+return ValueUtils.getLength(collection);\n     }\n \n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return ValueUtils.getLength(lengthlengthlength;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-21/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\t2022-07-19 17:02:54.291462749 +0200\n+++ /tmp/tmptfhrwry3.java\t2022-07-19 17:02:54.291462749 +0200\n@@ -147,11 +147,11 @@\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      * @return int length\n      */\n     public int getLength() {\n-        return ValueUtils.getLength(getBaseValue());\n+return ValueUtils.getLength(lengthlengthlength;\n     }\n \n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return ValueUtils.getLength(lengthlength - 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-21/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\t2022-07-19 17:02:55.927454572 +0200\n+++ /tmp/tmpa8hntyb9.java\t2022-07-19 17:02:55.931454552 +0200\n@@ -147,11 +147,11 @@\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      * @return int length\n      */\n     public int getLength() {\n-        return ValueUtils.getLength(getBaseValue());\n+return ValueUtils.getLength(lengthlength - 1);\n     }\n \n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return ValueUtils.getLength(collectioncollection);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-21/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\t2022-07-19 17:02:57.875444832 +0200\n+++ /tmp/tmp32dt270g.java\t2022-07-19 17:02:57.875444832 +0200\n@@ -147,11 +147,11 @@\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      * @return int length\n      */\n     public int getLength() {\n-        return ValueUtils.getLength(getBaseValue());\n+return ValueUtils.getLength(collectioncollection);\n     }\n \n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return ValueUtils.getLength(getBaseValue());",
        "fixed_line": "Object baseValue = getBaseValue(); return baseValue == null ? 1 : ValueUtils.getLength(baseValue);"
    },
    "Closure-62": {
        "fixes": [
            {
                "k": 1,
                "patch": "&& 0 <= charno && charno < charno && charno < sourceExcerpt.length()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-62/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\t2022-07-19 17:03:01.227428063 +0200\n+++ /tmp/tmptih47p0o.java\t2022-07-19 17:03:01.743425477 +0200\n@@ -93,11 +93,11 @@\n \n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+&& 0 <= charno && charno < charno && charno < sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n             b.append(c);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "&& 0 <= charno && charno < charno && charno < EOFcerpt.length()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-62/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\t2022-07-19 17:03:48.911187886 +0200\n+++ /tmp/tmptslbh24t.java\t2022-07-19 17:03:48.911187886 +0200\n@@ -93,11 +93,11 @@\n \n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+&& 0 <= charno && charno < charno && charno < EOFcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n             b.append(c);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "&& 0 <= charno && charno < charno && charno < lineno;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-62/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\t2022-07-19 17:03:54.127161439 +0200\n+++ /tmp/tmpw0266pum.java\t2022-07-19 17:03:54.127161439 +0200\n@@ -93,11 +93,11 @@\n \n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+&& 0 <= charno && charno < charno && charno < lineno;\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n             b.append(c);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "&& 0 <= charno && charno < EOFcerpt.length()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-62/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\t2022-07-19 17:03:58.979136806 +0200\n+++ /tmp/tmpj_szlrk0.java\t2022-07-19 17:03:58.983136788 +0200\n@@ -93,11 +93,11 @@\n \n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+&& 0 <= charno && charno < EOFcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n             b.append(c);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "&& 0 <= charno && charno < sourceExcerpt.length()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-62/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\t2022-07-19 17:04:04.591108284 +0200\n+++ /tmp/tmpji8pd20f.java\t2022-07-19 17:04:04.591108284 +0200\n@@ -93,11 +93,11 @@\n \n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+&& 0 <= charno && charno < sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n             b.append(c);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "&& 0 <= charno && charno < datacerpt.length()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-62/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\t2022-07-19 17:04:45.090901342 +0200\n+++ /tmp/tmpj1albwj9.java\t2022-07-19 17:04:45.090901342 +0200\n@@ -93,11 +93,11 @@\n \n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+&& 0 <= charno && charno < datacerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n             b.append(c);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "&& 0 <= charno && charno < linenocerpt.length()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-62/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\t2022-07-19 17:04:48.654883043 +0200\n+++ /tmp/tmprn0pb_pd.java\t2022-07-19 17:04:48.674882938 +0200\n@@ -93,11 +93,11 @@\n \n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+&& 0 <= charno && charno < linenocerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n             b.append(c);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "&& 0 <= charno && charno < 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-62/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\t2022-07-19 17:04:52.158865038 +0200\n+++ /tmp/tmpd7_0omqp.java\t2022-07-19 17:04:52.158865038 +0200\n@@ -93,11 +93,11 @@\n \n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+&& 0 <= charno && charno < 0) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n             b.append(c);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "&& 0 <= charno && charno < lineno;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-62/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\t2022-07-19 17:05:27.798681162 +0200\n+++ /tmp/tmpn9svx5oe.java\t2022-07-19 17:05:27.798681162 +0200\n@@ -93,11 +93,11 @@\n \n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+&& 0 <= charno && charno < lineno;\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n             b.append(c);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "&& 0 <= charno && charno < charno && charno < datacerpt.length()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-62/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\t2022-07-19 17:05:31.066664235 +0200\n+++ /tmp/tmp4btovfgs.java\t2022-07-19 17:05:31.066664235 +0200\n@@ -93,11 +93,11 @@\n \n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+&& 0 <= charno && charno < charno && charno < datacerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n             b.append(c);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "&& 0 <= charno && charno < sourceExcerpt.length()) {",
        "fixed_line": "&& 0 <= charno && charno <= sourceExcerpt.length()) {"
    },
    "Lang-6": {
        "fixes": [
            {
                "k": 1,
                "patch": "pos += Character.charCount(pt, pt + 1) : 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-6/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 17:05:34.670645556 +0200\n+++ /tmp/tmp7x9a18qx.java\t2022-07-19 17:05:34.722645286 +0200\n@@ -90,11 +90,11 @@\n                 continue;\n             }\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+pos += Character.charCount(pt, pt + 1) : 0;\n             }\n         }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "pos += Character.charCount(pt, ptIndex + 1) : 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-6/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 17:05:36.442636367 +0200\n+++ /tmp/tmpnjevgve3.java\t2022-07-19 17:05:36.446636344 +0200\n@@ -90,11 +90,11 @@\n                 continue;\n             }\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+pos += Character.charCount(pt, ptIndex + 1) : 0;\n             }\n         }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "pos += Character.charCount(pt, pos);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-6/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 17:05:38.030628130 +0200\n+++ /tmp/tmpoxgnwtk2.java\t2022-07-19 17:05:38.030628130 +0200\n@@ -90,11 +90,11 @@\n                 continue;\n             }\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+pos += Character.charCount(pt, pos);\n             }\n         }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "pos += Character.charCount(pt, pt));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-6/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 17:05:39.602619973 +0200\n+++ /tmp/tmpc1ygvzfi.java\t2022-07-19 17:05:39.602619973 +0200\n@@ -90,11 +90,11 @@\n                 continue;\n             }\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+pos += Character.charCount(pt, pt));\n             }\n         }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "pos += Character.charCount(pt, pt pt);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-6/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 17:05:41.086612271 +0200\n+++ /tmp/tmp8v2g32id.java\t2022-07-19 17:05:41.086612271 +0200\n@@ -90,11 +90,11 @@\n                 continue;\n             }\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+pos += Character.charCount(pt, pt pt);\n             }\n         }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "pos += Character.charCount(pt, ptName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-6/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 17:05:42.570604565 +0200\n+++ /tmp/tmp7bnszq_k.java\t2022-07-19 17:05:42.570604565 +0200\n@@ -90,11 +90,11 @@\n                 continue;\n             }\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+pos += Character.charCount(pt, ptName);\n             }\n         }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "pos += Character.charCount(pt, ptIndex);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-6/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 17:05:44.094596652 +0200\n+++ /tmp/tmpkv02noe1.java\t2022-07-19 17:05:44.094596652 +0200\n@@ -90,11 +90,11 @@\n                 continue;\n             }\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+pos += Character.charCount(pt, ptIndex);\n             }\n         }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "pos += Character.charCount(pt, pt;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-6/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 17:05:45.742588090 +0200\n+++ /tmp/tmpfgid1siz.java\t2022-07-19 17:05:45.742588090 +0200\n@@ -90,11 +90,11 @@\n                 continue;\n             }\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+pos += Character.charCount(pt, pt;\n             }\n         }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "pos += Character.charCount(pt, pt);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-6/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 17:05:47.242580293 +0200\n+++ /tmp/tmpbewn1amy.java\t2022-07-19 17:05:47.242580293 +0200\n@@ -90,11 +90,11 @@\n                 continue;\n             }\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+pos += Character.charCount(pt, pt);\n             }\n         }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "pos += Character.charCount(pt, pt + 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-6/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 17:05:48.846571958 +0200\n+++ /tmp/tmphgpcl9sw.java\t2022-07-19 17:05:48.846571958 +0200\n@@ -90,11 +90,11 @@\n                 continue;\n             }\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+pos += Character.charCount(pt, pt + 1));\n             }\n         }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "pos += Character.charCount(Character.codePointAt(input, pos));",
        "fixed_line": "pos += Character.charCount(Character.codePointAt(input, pt));"
    },
    "Csv-2": {
        "fixes": [
            {
                "k": 1,
                "patch": "return index!= null? values[index.intValue()] : null; }",
                "patch_diff": "return index!= null? values[index.intValue()] : null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return index!= null? values[index] : null; }",
                "patch_diff": "return index!= null? values[index] : null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return index!= null? values[index.intValue()] : null; }",
                "patch_diff": "return index!= null? values[index.intValue()] : null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (index == null? values[index] : null; }",
                "patch_diff": "if (index == null? values[index] : null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (index == null? values[index.intValue()] : null; }",
                "patch_diff": "if (index == null? values[index.intValue()] : null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return index!= null? values[index] : null; }",
                "patch_diff": "return index!= null? values[index] : null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (index!= null? values[index] : null; }",
                "patch_diff": "if (index!= null? values[index] : null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (index == null? values : null; }",
                "patch_diff": "if (index == null? values : null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return index!= null? values[index]; }",
                "patch_diff": "return index!= null? values[index]; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (index == null? values[index.intValue()] : null;",
                "patch_diff": "if (index == null? values[index.intValue()] : null;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "try { return index != null ? values[index.intValue()] : null; } catch (ArrayIndexOutOfBoundsException e) { throw new IllegalArgumentException( String.format( \"Index for header '%s' is %d but CSVRecord only has %d values!\", name, index.intValue(), values.length)); }"
    },
    "Math-17": {
        "fixes": [
            {
                "k": 1,
                "patch": "this(x;=x&lt this(x, y) {",
                "patch_diff": "this(x;=x&lt this(x, y) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "this(x);",
                "patch_diff": "this(x);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "this(x;=x&lt this.x&lt this(x, y) {",
                "patch_diff": "this(x;=x&lt this.x&lt this(x, y) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "this(x;=x&lt this.x&lt this(x, y);",
                "patch_diff": "this(x;=x&lt this.x&lt this(x, y);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "this(x;=x&lt this.x&lt this(x);",
                "patch_diff": "this(x;=x&lt this.x&lt this(x);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "this(x;=x&lt this.x&lt this();",
                "patch_diff": "this(x;=x&lt this.x&lt this();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "this(x;=x&lt this.x&lt this. * There are speed advantages in this",
                "patch_diff": "this(x;=x&lt this.x&lt this. * There are speed advantages in this",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "this(x;=x&lt this.x&lt this(x) {",
                "patch_diff": "this(x;=x&lt this.x&lt this(x) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "this(x;=x&lt this(x);",
                "patch_diff": "this(x;=x&lt this(x);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "this(x;=x&lt this.x&lt this",
                "patch_diff": "this(x;=x&lt this.x&lt this",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (x >= 0 && x < RADIX) { return multiplyFast(x); } else { return multiply(newInstance(x)); }"
    },
    "Closure-83": {
        "fixes": [
            {
                "k": 1,
                "patch": "String param = params.getParameterString;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-83/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 17:05:53.694546745 +0200\n+++ /tmp/tmp7iilp3e2.java\t2022-07-19 17:05:53.722546598 +0200\n@@ -329,11 +329,11 @@\n         super(parser, option, setter);\n       }\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = params.getParameter(0);\n+String param = params.getParameterString;\n \n         if (param == null) {\n           setter.addValue(true);\n           return 0;\n         } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "String param = params.getParameterTypes;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-83/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 17:05:57.262528172 +0200\n+++ /tmp/tmp26_npub_.java\t2022-07-19 17:05:57.262528172 +0200\n@@ -329,11 +329,11 @@\n         super(parser, option, setter);\n       }\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = params.getParameter(0);\n+String param = params.getParameterTypes;\n \n         if (param == null) {\n           setter.addValue(true);\n           return 0;\n         } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "String param = params.getParameter am;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-83/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 17:05:59.942514215 +0200\n+++ /tmp/tmp0x_z7fb4.java\t2022-07-19 17:05:59.942514215 +0200\n@@ -329,11 +329,11 @@\n         super(parser, option, setter);\n       }\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = params.getParameter(0);\n+String param = params.getParameter am;\n \n         if (param == null) {\n           setter.addValue(true);\n           return 0;\n         } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "String param = params.getParameterList;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-83/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 17:06:02.426501271 +0200\n+++ /tmp/tmp7z59f2qz.java\t2022-07-19 17:06:02.430501248 +0200\n@@ -329,11 +329,11 @@\n         super(parser, option, setter);\n       }\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = params.getParameter(0);\n+String param = params.getParameterList;\n \n         if (param == null) {\n           setter.addValue(true);\n           return 0;\n         } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "String param = params.getParameter;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-83/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 17:06:05.102487321 +0200\n+++ /tmp/tmph73waxuh.java\t2022-07-19 17:06:05.102487321 +0200\n@@ -329,11 +329,11 @@\n         super(parser, option, setter);\n       }\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = params.getParameter(0);\n+String param = params.getParameter;\n \n         if (param == null) {\n           setter.addValue(true);\n           return 0;\n         } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "String param = params.getParameterVal;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-83/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 17:06:07.850472988 +0200\n+++ /tmp/tmpuwzxzx7e.java\t2022-07-19 17:06:07.854472966 +0200\n@@ -329,11 +329,11 @@\n         super(parser, option, setter);\n       }\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = params.getParameter(0);\n+String param = params.getParameterVal;\n \n         if (param == null) {\n           setter.addValue(true);\n           return 0;\n         } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "String param = params.getParametering;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-83/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 17:06:10.618458545 +0200\n+++ /tmp/tmpa0gzcabl.java\t2022-07-19 17:06:10.618458545 +0200\n@@ -329,11 +329,11 @@\n         super(parser, option, setter);\n       }\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = params.getParameter(0);\n+String param = params.getParametering;\n \n         if (param == null) {\n           setter.addValue(true);\n           return 0;\n         } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "String param = params.getParameterWriter;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-83/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 17:06:13.306444512 +0200\n+++ /tmp/tmpv0yi0nj3.java\t2022-07-19 17:06:13.310444491 +0200\n@@ -329,11 +329,11 @@\n         super(parser, option, setter);\n       }\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = params.getParameter(0);\n+String param = params.getParameterWriter;\n \n         if (param == null) {\n           setter.addValue(true);\n           return 0;\n         } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "String param = params.getParameter(1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-83/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 17:06:16.126429780 +0200\n+++ /tmp/tmp3kxjxqku.java\t2022-07-19 17:06:16.126429780 +0200\n@@ -329,11 +329,11 @@\n         super(parser, option, setter);\n       }\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = params.getParameter(0);\n+String param = params.getParameter(1);\n \n         if (param == null) {\n           setter.addValue(true);\n           return 0;\n         } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "String param = params.getParameter(0);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-83/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 17:06:47.414265875 +0200\n+++ /tmp/tmp5no0lst2.java\t2022-07-19 17:06:47.414265875 +0200\n@@ -329,11 +329,11 @@\n         super(parser, option, setter);\n       }\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = params.getParameter(0);\n+String param = params.getParameter(0);\n \n         if (param == null) {\n           setter.addValue(true);\n           return 0;\n         } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "String param = params.getParameter(0);",
        "fixed_line": "String param = null; try { param = params.getParameter(0); } catch (CmdLineException e) {}"
    },
    "Time-25": {
        "fixes": [
            {
                "k": 1,
                "patch": "offsetAdjusted = nextAdjusted; }",
                "patch_diff": "offsetAdjusted = nextAdjusted; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "nextAdjusted = nextAdjusted; }",
                "patch_diff": "nextAdjusted = nextAdjusted; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "offsetAdjusted = nextLocal - offsetAdjusted; }",
                "patch_diff": "offsetAdjusted = nextLocal - offsetAdjusted; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "nextAdjusted = nextLocal - offsetAdjusted; }",
                "patch_diff": "nextAdjusted = nextLocal - offsetAdjusted; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "offsetAdjusted = nextAdjusted - offsetAdjusted; }",
                "patch_diff": "offsetAdjusted = nextAdjusted - offsetAdjusted; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "offsetLocaled = nextAdjusted; }",
                "patch_diff": "offsetLocaled = nextAdjusted; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "offsetAdjusted = nextTransition(instantLocal - offsetAdjusted; }",
                "patch_diff": "offsetAdjusted = nextTransition(instantLocal - offsetAdjusted; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "offsetAdjusted = nextLocal - offsetLocal; }",
                "patch_diff": "offsetAdjusted = nextLocal - offsetLocal; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "nextAdjusted = nextAdjusted - offsetAdjusted; }",
                "patch_diff": "nextAdjusted = nextAdjusted - offsetAdjusted; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "offsetAdjusted = nextLocal - offsetAdjusted;",
                "patch_diff": "offsetAdjusted = nextLocal - offsetAdjusted;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "} else if (offsetLocal > 0) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; } }"
    },
    "Closure-56": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if (js.indexOf('\\n', pos) == -1) {",
                "patch_diff": "// if (js.indexOf('\\n', pos) == -1) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) { return",
                "patch_diff": "// } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) { return",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); }",
                "patch_diff": "// } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); }",
                "patch_diff": "// } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) { return js.",
                "patch_diff": "// } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) { return js.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if (js.indexOf('\\n', pos) == -1) { return null; } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); } else",
                "patch_diff": "// if (js.indexOf('\\n', pos) == -1) { return null; } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); } else",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos)); }",
                "patch_diff": "// } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos)); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) { return null;",
                "patch_diff": "// } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) { return null;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, js.indexOf('\\n', pos)); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) { return js.",
                "patch_diff": "// } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, js.indexOf('\\n', pos)); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) { return js.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos)); }",
                "patch_diff": "// } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) == -1) { return js.substring(pos, pos, js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos) { return js.substring(pos, js.indexOf('\\n', pos)); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (pos >= js.length()) { return null; } else { return js.substring(pos, js.length()); }"
    },
    "Math-45": {
        "fixes": [
            {
                "k": 1,
                "patch": "this.columns = row; this.columns = new OpenIntToDoubleHashMap(0.0);",
                "patch_diff": "this.columns = row; this.columns = new OpenIntToDoubleHashMap(0.0);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "this.columns = row; this.rows = new OpenIntToDoubleHashMap(0.0);",
                "patch_diff": "this.columns = row; this.rows = new OpenIntToDoubleHashMap(0.0);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "this.columns = row; this.columns = new OpenIntToDoubleHashMap(0.0); }",
                "patch_diff": "this.columns = row; this.columns = new OpenIntToDoubleHashMap(0.0); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "this.columns = row; this.columns = new OpenIntToDoubleHashMap(0.0;",
                "patch_diff": "this.columns = row; this.columns = new OpenIntToDoubleHashMap(0.0;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "this.columns = row; this.columns = new OpenIntToDoubleHashMap(0.0); this.entries = new OpenIntToDoubleHashMap(0.0);",
                "patch_diff": "this.columns = row; this.columns = new OpenIntToDoubleHashMap(0.0); this.entries = new OpenIntToDoubleHashMap(0.0);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "this.columns = row; this.columns = new OpenIntToDoubleHashMap(0.0); this.entries = new OpenIntToDoubleHashMap(0.0); }",
                "patch_diff": "this.columns = row; this.columns = new OpenIntToDoubleHashMap(0.0); this.entries = new OpenIntToDoubleHashMap(0.0); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "this.columns = row; this.columns = new OpenIntToDoubleHashMap(0.0); this.entries = new OpenIntToDoubleHashMap(0.0;",
                "patch_diff": "this.columns = row; this.columns = new OpenIntToDoubleHashMap(0.0); this.entries = new OpenIntToDoubleHashMap(0.0;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "this.columns = row; this.rows = new OpenIntToDoubleHashMap(0.0); }",
                "patch_diff": "this.columns = row; this.rows = new OpenIntToDoubleHashMap(0.0); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "this.columns = row; this.rows = new OpenIntToDoubleHashMap(0.0;",
                "patch_diff": "this.columns = row; this.rows = new OpenIntToDoubleHashMap(0.0;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "this.columns = row; this.rows = new OpenIntToDoubleHashMap(0.0); this.entries = new OpenIntToDoubleHashMap(0.0);",
                "patch_diff": "this.columns = row; this.rows = new OpenIntToDoubleHashMap(0.0); this.entries = new OpenIntToDoubleHashMap(0.0);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "long lRow = (long) rowDimension; long lCol = (long) columnDimension; if (lRow * lCol >= (long) Integer.MAX_VALUE) { throw new NumberIsTooLargeException(lRow * lCol, Integer.MAX_VALUE, false); }"
    },
    "Lang-26": {
        "fixes": [
            {
                "k": 1,
                "patch": "Calendar c = new GregorianCalendar(200mTimeZone(mTimeZone);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-26/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 17:07:22.834079297 +0200\n+++ /tmp/tmp9jzuqq_v.java\t2022-07-19 17:07:22.858079170 +0200\n@@ -815,11 +815,11 @@\n      * \n      * @param date  the date to format\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+Calendar c = new GregorianCalendar(200mTimeZone(mTimeZone);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "Calendar c = new GregorianCalendar(mTimeZone.mTimeZone;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-26/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 17:07:24.722069324 +0200\n+++ /tmp/tmpjnyd1ob_.java\t2022-07-19 17:07:24.722069324 +0200\n@@ -815,11 +815,11 @@\n      * \n      * @param date  the date to format\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+Calendar c = new GregorianCalendar(mTimeZone.mTimeZone;\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "Calendar c = new GregorianCalendar(200mTimeZone;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-26/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 17:07:26.314060911 +0200\n+++ /tmp/tmpfjedno8a.java\t2022-07-19 17:07:26.318060890 +0200\n@@ -815,11 +815,11 @@\n      * \n      * @param date  the date to format\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+Calendar c = new GregorianCalendar(200mTimeZone;\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "Calendar c = new GregorianCalendar(mTimeZoneId);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-26/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 17:07:27.926052390 +0200\n+++ /tmp/tmpzv0dzp6f.java\t2022-07-19 17:07:27.926052390 +0200\n@@ -815,11 +815,11 @@\n      * \n      * @param date  the date to format\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+Calendar c = new GregorianCalendar(mTimeZoneId);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "Calendar c = new GregorianCalendar(mTimeZoneLengthEstimate);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-26/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 17:07:29.734042833 +0200\n+++ /tmp/tmpvjea0_x3.java\t2022-07-19 17:07:29.734042833 +0200\n@@ -815,11 +815,11 @@\n      * \n      * @param date  the date to format\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+Calendar c = new GregorianCalendar(mTimeZoneLengthEstimate);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "Calendar c = new GregorianCalendar(mTimeZone;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-26/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 17:07:31.478033609 +0200\n+++ /tmp/tmps2ovn01v.java\t2022-07-19 17:07:31.478033609 +0200\n@@ -815,11 +815,11 @@\n      * \n      * @param date  the date to format\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+Calendar c = new GregorianCalendar(mTimeZone;\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "Calendar c = new GregorianCalendar(mTimeZone.mTimeZoneCount);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-26/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 17:07:33.010025504 +0200\n+++ /tmp/tmp9tgreqca.java\t2022-07-19 17:07:33.010025504 +0200\n@@ -815,11 +815,11 @@\n      * \n      * @param date  the date to format\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+Calendar c = new GregorianCalendar(mTimeZone.mTimeZoneCount);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "Calendar c = new GregorianCalendar(2006, 10, 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-26/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 17:07:34.782016127 +0200\n+++ /tmp/tmpz9n0a189.java\t2022-07-19 17:07:34.782016127 +0200\n@@ -815,11 +815,11 @@\n      * \n      * @param date  the date to format\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+Calendar c = new GregorianCalendar(2006, 10, 1);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "Calendar c = new GregorianCalendar(mTimeZone);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-26/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 17:07:44.645963890 +0200\n+++ /tmp/tmp53un_324.java\t2022-07-19 17:07:44.645963890 +0200\n@@ -815,11 +815,11 @@\n      * \n      * @param date  the date to format\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+Calendar c = new GregorianCalendar(mTimeZone);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "Calendar c = new GregorianCalendar(mTimeZoneCount);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-26/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 17:07:53.957914507 +0200\n+++ /tmp/tmplykd2owi.java\t2022-07-19 17:07:53.957914507 +0200\n@@ -815,11 +815,11 @@\n      * \n      * @param date  the date to format\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+Calendar c = new GregorianCalendar(mTimeZoneCount);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "Calendar c = new GregorianCalendar(mTimeZone);",
        "fixed_line": "Calendar c = new GregorianCalendar(mTimeZone, mLocale);"
    },
    "Math-94": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (u * v == 0.0) { // gcd is even...",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-94/src/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 17:07:55.813904657 +0200\n+++ /tmp/tmpgul75w15.java\t2022-07-19 17:07:55.849904466 +0200\n@@ -407,11 +407,11 @@\n      * @param v a non-zero number\n      * @return the greatest common divisor, never zero\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+if (u * v == 0.0) { // gcd is even...\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (u * v == 0) { // not do zero",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-94/src/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 17:08:03.353864611 +0200\n+++ /tmp/tmpob6e9o3c.java\t2022-07-19 17:08:03.353864611 +0200\n@@ -407,11 +407,11 @@\n      * @param v a non-zero number\n      * @return the greatest common divisor, never zero\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+if (u * v == 0) { // not do zero\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (u * v == 0) { // even...",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-94/src/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 17:08:10.285827758 +0200\n+++ /tmp/tmpf2fso6tw.java\t2022-07-19 17:08:10.289827737 +0200\n@@ -407,11 +407,11 @@\n      * @param v a non-zero number\n      * @return the greatest common divisor, never zero\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+if (u * v == 0) { // even...\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (u * v == 0.0) { // if even...",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-94/src/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 17:08:17.241790744 +0200\n+++ /tmp/tmpz_xlww_8.java\t2022-07-19 17:08:17.245790721 +0200\n@@ -407,11 +407,11 @@\n      * @param v a non-zero number\n      * @return the greatest common divisor, never zero\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+if (u * v == 0.0) { // if even...\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (u / v == 0.0) { // gcd is even...",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-94/src/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 17:08:24.205753648 +0200\n+++ /tmp/tmps70rpv3k.java\t2022-07-19 17:08:24.205753648 +0200\n@@ -407,11 +407,11 @@\n      * @param v a non-zero number\n      * @return the greatest common divisor, never zero\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+if (u / v == 0.0) { // gcd is even...\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (u * v == 0) { // gcd is even...",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-94/src/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 17:08:31.121716776 +0200\n+++ /tmp/tmpo2f0i2ac.java\t2022-07-19 17:08:31.125716754 +0200\n@@ -407,11 +407,11 @@\n      * @param v a non-zero number\n      * @return the greatest common divisor, never zero\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+if (u * v == 0) { // gcd is even...\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (u * v == 0) { // if even...",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-94/src/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 17:08:37.981680169 +0200\n+++ /tmp/tmp0tcqo2u1.java\t2022-07-19 17:08:37.981680169 +0200\n@@ -407,11 +407,11 @@\n      * @param v a non-zero number\n      * @return the greatest common divisor, never zero\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+if (u * v == 0) { // if even...\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (u * v == 0.0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-94/src/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 17:08:44.929643057 +0200\n+++ /tmp/tmp9l211b3_.java\t2022-07-19 17:08:44.933643036 +0200\n@@ -407,11 +407,11 @@\n      * @param v a non-zero number\n      * @return the greatest common divisor, never zero\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+if (u * v == 0.0) {\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (u * v == 0.0) { // not do zero",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-94/src/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 17:08:51.913605719 +0200\n+++ /tmp/tmp1vtoe3rt.java\t2022-07-19 17:08:51.913605719 +0200\n@@ -407,11 +407,11 @@\n      * @param v a non-zero number\n      * @return the greatest common divisor, never zero\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+if (u * v == 0.0) { // not do zero\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (u * v == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-94/src/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 17:08:58.821568756 +0200\n+++ /tmp/tmps0x4_9nt.java\t2022-07-19 17:08:58.821568756 +0200\n@@ -407,11 +407,11 @@\n      * @param v a non-zero number\n      * @return the greatest common divisor, never zero\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+if (u * v == 0) {\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (u * v == 0) {",
        "fixed_line": "if ((u == 0) || (v == 0)) {"
    },
    "Lang-59": {
        "fixes": [
            {
                "k": 1,
                "patch": "str.getChars(0, strLen, buffer, size) + padLen;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 17:09:05.949530583 +0200\n+++ /tmp/tmpaymxc0lv.java\t2022-07-19 17:09:05.981530412 +0200\n@@ -879,11 +879,11 @@\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+str.getChars(0, strLen, buffer, size) + padLen;\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + strLen + i] = padChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "str.getChars(0, strLen, buffer, size - width;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 17:09:07.677521324 +0200\n+++ /tmp/tmp3q9rrr8o.java\t2022-07-19 17:09:07.681521303 +0200\n@@ -879,11 +879,11 @@\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+str.getChars(0, strLen, buffer, size - width;\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + strLen + i] = padChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "str.getChars(0, strLen, buffer, size);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 17:09:09.129513540 +0200\n+++ /tmp/tmpg35x23z6.java\t2022-07-19 17:09:09.129513540 +0200\n@@ -879,11 +879,11 @@\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+str.getChars(0, strLen, buffer, size);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + strLen + i] = padChar;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "str.getChars(0, strLen, buffer, size = padLen;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 17:09:18.757461905 +0200\n+++ /tmp/tmpylfwyywi.java\t2022-07-19 17:09:18.757461905 +0200\n@@ -879,11 +879,11 @@\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+str.getChars(0, strLen, buffer, size = padLen;\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + strLen + i] = padChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "str.getChars(0, strLen, buffer, size) - width;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 17:09:20.265453811 +0200\n+++ /tmp/tmp29q0v3pw.java\t2022-07-19 17:09:20.265453811 +0200\n@@ -879,11 +879,11 @@\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+str.getChars(0, strLen, buffer, size) - width;\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + strLen + i] = padChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "str.getChars(0, strLen, buffer, size + width);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 17:09:21.853445287 +0200\n+++ /tmp/tmpz5th07js.java\t2022-07-19 17:09:21.853445287 +0200\n@@ -879,11 +879,11 @@\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+str.getChars(0, strLen, buffer, size + width);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + strLen + i] = padChar;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "str.getChars(0, strLen, buffer, size;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 17:09:31.225394949 +0200\n+++ /tmp/tmpy8qvrrht.java\t2022-07-19 17:09:31.229394928 +0200\n@@ -879,11 +879,11 @@\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+str.getChars(0, strLen, buffer, size;\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + strLen + i] = padChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "str.getChars(0, strLen, buffer, size size);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 17:09:32.765386672 +0200\n+++ /tmp/tmp44j41d4w.java\t2022-07-19 17:09:32.765386672 +0200\n@@ -879,11 +879,11 @@\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+str.getChars(0, strLen, buffer, size size);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + strLen + i] = padChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "str.getChars(0, strLen, buffer, size + padLen;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 17:09:34.257378651 +0200\n+++ /tmp/tmppeivbg7e.java\t2022-07-19 17:09:34.261378630 +0200\n@@ -879,11 +879,11 @@\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+str.getChars(0, strLen, buffer, size + padLen;\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + strLen + i] = padChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "str.getChars(0, strLen, buffer, size size;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 17:09:35.825370221 +0200\n+++ /tmp/tmphmbpz169.java\t2022-07-19 17:09:35.829370200 +0200\n@@ -879,11 +879,11 @@\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+str.getChars(0, strLen, buffer, size size;\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + strLen + i] = padChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "str.getChars(0, strLen, buffer, size);",
        "fixed_line": "str.getChars(0, width, buffer, size);"
    },
    "JacksonDatabind-107": {
        "fixes": [
            {
                "k": 1,
                "patch": "return _defaultContextualValueDeserializationContextualValueSer;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-107/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\t2022-07-19 17:09:37.537361015 +0200\n+++ /tmp/tmpovebze0g.java\t2022-07-19 17:09:37.589360735 +0200\n@@ -160,11 +160,11 @@\n                 if (deser == null) {\n                     // 10-May-2016, tatu: We may get some help...\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                        return null;\n+return _defaultContextualValueDeserializationContextualValueSer;\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n             } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return _defaultValueSer;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-107/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\t2022-07-19 17:09:39.785348923 +0200\n+++ /tmp/tmp3rwj15ir.java\t2022-07-19 17:09:39.785348923 +0200\n@@ -160,11 +160,11 @@\n                 if (deser == null) {\n                     // 10-May-2016, tatu: We may get some help...\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                        return null;\n+return _defaultValueSer;\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n             } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return _defaultContextualValueSer;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-107/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\t2022-07-19 17:09:41.437340035 +0200\n+++ /tmp/tmpnkjkbtze.java\t2022-07-19 17:09:41.437340035 +0200\n@@ -160,11 +160,11 @@\n                 if (deser == null) {\n                     // 10-May-2016, tatu: We may get some help...\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                        return null;\n+return _defaultContextualValueSer;\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n             } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return _defaultDeserializer;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-107/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\t2022-07-19 17:09:43.097331102 +0200\n+++ /tmp/tmph8knvrof.java\t2022-07-19 17:09:43.097331102 +0200\n@@ -160,11 +160,11 @@\n                 if (deser == null) {\n                     // 10-May-2016, tatu: We may get some help...\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                        return null;\n+return _defaultDeserializer;\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n             } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return _defaultContextualValueDeserializer;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-107/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\t2022-07-19 17:09:44.773322083 +0200\n+++ /tmp/tmp7rwj9yn9.java\t2022-07-19 17:09:44.777322060 +0200\n@@ -160,11 +160,11 @@\n                 if (deser == null) {\n                     // 10-May-2016, tatu: We may get some help...\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                        return null;\n+return _defaultContextualValueDeserializer;\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n             } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return _objectIdReader;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-107/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\t2022-07-19 17:09:46.505312758 +0200\n+++ /tmp/tmpfr5vsh1i.java\t2022-07-19 17:09:46.505312758 +0200\n@@ -160,11 +160,11 @@\n                 if (deser == null) {\n                     // 10-May-2016, tatu: We may get some help...\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                        return null;\n+return _objectIdReader;\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n             } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return _defaultContextualValueDeserializationContextualValueDeserializationContextualValueSer;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-107/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\t2022-07-19 17:09:48.233303455 +0200\n+++ /tmp/tmpwfbjgxr8.java\t2022-07-19 17:09:48.237303434 +0200\n@@ -160,11 +160,11 @@\n                 if (deser == null) {\n                     // 10-May-2016, tatu: We may get some help...\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                        return null;\n+return _defaultContextualValueDeserializationContextualValueDeserializationContextualValueSer;\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n             } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return _defaultImpl;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-107/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\t2022-07-19 17:09:49.953294192 +0200\n+++ /tmp/tmpte7vyply.java\t2022-07-19 17:09:49.953294192 +0200\n@@ -160,11 +160,11 @@\n                 if (deser == null) {\n                     // 10-May-2016, tatu: We may get some help...\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                        return null;\n+return _defaultImpl;\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n             } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return _defaultValueDeserializationContextualValueSer;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-107/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\t2022-07-19 17:09:51.725284647 +0200\n+++ /tmp/tmpb6hm3och.java\t2022-07-19 17:09:51.729284626 +0200\n@@ -160,11 +160,11 @@\n                 if (deser == null) {\n                     // 10-May-2016, tatu: We may get some help...\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                        return null;\n+return _defaultValueDeserializationContextualValueSer;\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n             } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return _defaultContext;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-107/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\t2022-07-19 17:09:53.497275100 +0200\n+++ /tmp/tmprcu9py7_.java\t2022-07-19 17:09:53.497275100 +0200\n@@ -160,11 +160,11 @@\n                 if (deser == null) {\n                     // 10-May-2016, tatu: We may get some help...\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                        return null;\n+return _defaultContext;\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n             } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return null;",
        "fixed_line": "return NullifyingDeserializer.instance;"
    },
    "Closure-87": {
        "fixes": [
            {
                "k": 1,
                "patch": "return NodeUtil.isExpressionNode(n;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 17:09:55.429264689 +0200\n+++ /tmp/tmpu_okh0d0.java\t2022-07-19 17:09:55.457264536 +0200\n@@ -528,11 +528,11 @@\n           // into other expressions.\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n \n-          return NodeUtil.isExpressionNode(maybeExpr);\n+return NodeUtil.isExpressionNode(n;\n       }\n     }\n \n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return NodeUtil.isExpressionNode(parent, n.hasOneChild;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 17:09:58.793246558 +0200\n+++ /tmp/tmpatech3qh.java\t2022-07-19 17:09:58.797246537 +0200\n@@ -528,11 +528,11 @@\n           // into other expressions.\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n \n-          return NodeUtil.isExpressionNode(maybeExpr);\n+return NodeUtil.isExpressionNode(parent, n.hasOneChild;\n       }\n     }\n \n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return NodeUtil.isExpressionNode(parent) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 17:10:01.305233014 +0200\n+++ /tmp/tmpaj873muu.java\t2022-07-19 17:10:01.305233014 +0200\n@@ -528,11 +528,11 @@\n           // into other expressions.\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n \n-          return NodeUtil.isExpressionNode(maybeExpr);\n+return NodeUtil.isExpressionNode(parent) {\n       }\n     }\n \n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return NodeUtil.isExpressionNode(parent, n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 17:10:03.745219853 +0200\n+++ /tmp/tmp44pua4nn.java\t2022-07-19 17:10:03.749219832 +0200\n@@ -528,11 +528,11 @@\n           // into other expressions.\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n \n-          return NodeUtil.isExpressionNode(maybeExpr);\n+return NodeUtil.isExpressionNode(parent, n);\n       }\n     }\n \n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return NodeUtil.isExpressionNode( return NodeUtil.isExpressionNode(parent;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 17:10:06.577204575 +0200\n+++ /tmp/tmp7h2evnq3.java\t2022-07-19 17:10:06.577204575 +0200\n@@ -528,11 +528,11 @@\n           // into other expressions.\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n \n-          return NodeUtil.isExpressionNode(maybeExpr);\n+return NodeUtil.isExpressionNode( return NodeUtil.isExpressionNode(parent;\n       }\n     }\n \n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return NodeUtil.isExpressionNode(parent) && n.hasOneChild;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 17:10:09.081191063 +0200\n+++ /tmp/tmp_cai0o_u.java\t2022-07-19 17:10:09.081191063 +0200\n@@ -528,11 +528,11 @@\n           // into other expressions.\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n \n-          return NodeUtil.isExpressionNode(maybeExpr);\n+return NodeUtil.isExpressionNode(parent) && n.hasOneChild;\n       }\n     }\n \n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return NodeUtil.isExpressionNode(n.hasOneChild;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 17:10:11.853176099 +0200\n+++ /tmp/tmpkotwj898.java\t2022-07-19 17:10:11.853176099 +0200\n@@ -528,11 +528,11 @@\n           // into other expressions.\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n \n-          return NodeUtil.isExpressionNode(maybeExpr);\n+return NodeUtil.isExpressionNode(n.hasOneChild;\n       }\n     }\n \n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return NodeUtil.isExpressionNode( return NodeUtil.isExpressionNode;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 17:10:14.237163228 +0200\n+++ /tmp/tmpjwtq0j3s.java\t2022-07-19 17:10:14.237163228 +0200\n@@ -528,11 +528,11 @@\n           // into other expressions.\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n \n-          return NodeUtil.isExpressionNode(maybeExpr);\n+return NodeUtil.isExpressionNode( return NodeUtil.isExpressionNode;\n       }\n     }\n \n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return NodeUtil.isExpressionNode( n.hasOneChild;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 17:10:16.673150071 +0200\n+++ /tmp/tmpakpuc6gu.java\t2022-07-19 17:10:16.673150071 +0200\n@@ -528,11 +528,11 @@\n           // into other expressions.\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n \n-          return NodeUtil.isExpressionNode(maybeExpr);\n+return NodeUtil.isExpressionNode( n.hasOneChild;\n       }\n     }\n \n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return NodeUtil.isExpressionNode(parent;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 17:10:19.153136673 +0200\n+++ /tmp/tmpe9h7sqas.java\t2022-07-19 17:10:19.157136651 +0200\n@@ -528,11 +528,11 @@\n           // into other expressions.\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n \n-          return NodeUtil.isExpressionNode(maybeExpr);\n+return NodeUtil.isExpressionNode(parent;\n       }\n     }\n \n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return NodeUtil.isExpressionNode(maybeExpr);",
        "fixed_line": "if (maybeExpr.getType() == Token.EXPR_RESULT) { // IE has a bug where event handlers behave differently when // their return value is used vs. when their return value is in // an EXPR_RESULT. It's pretty freaking weird. See: // http://code.google.com/p/closure-compiler/issues/detail?id=291 // We try to detect this case, and not fold EXPR_RESULTs // into other expressions. if (maybeExpr.getFirstChild().getType() == Token.CALL) { Node calledFn = maybeExpr.getFirstChild().getFirstChild(); // We only have to worry about methods with an implicit 'this' // param, or this doesn't happen. if (calledFn.getType() == Token.GETELEM) { return false; } else if (calledFn.getType() == Token.GETPROP && calledFn.getLastChild().getString().startsWith(\"on\")) { return false; } } return true; } return false;"
    },
    "Math-7": {
        "fixes": [
            {
                "k": 1,
                "patch": "currentEvent.stepAcceptedAllUnknown, remainingStep = state.stopAtStartX;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-7/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\t2022-07-19 17:10:21.785122449 +0200\n+++ /tmp/tmpbdpy08or.java\t2022-07-19 17:10:21.829122211 +0200\n@@ -341,37 +341,11 @@\n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n-\n-                if (isLastStep) {\n-                    // the event asked to stop integration\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n-                    return eventT;\n-                }\n-\n-                boolean needReset = currentEvent.reset(eventT, eventY);\n-                if (needReset) {\n-                    // some event handler has triggered changes that\n-                    // invalidate the derivatives, we need to recompute them\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    computeDerivatives(eventT, y, yDot);\n-                    resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n+currentEvent.stepAcceptedAllUnknown, remainingStep = state.stopAtStartX;\n                     return eventT;\n                 }\n \n                 // prepare handling of the remaining part of the step\n                 previousT = eventT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "currentEvent.stepAcceptedClassName = remainingStep;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-7/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\t2022-07-19 17:10:24.309108807 +0200\n+++ /tmp/tmpc9lrnbay.java\t2022-07-19 17:10:24.309108807 +0200\n@@ -341,37 +341,11 @@\n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n-\n-                if (isLastStep) {\n-                    // the event asked to stop integration\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n-                    return eventT;\n-                }\n-\n-                boolean needReset = currentEvent.reset(eventT, eventY);\n-                if (needReset) {\n-                    // some event handler has triggered changes that\n-                    // invalidate the derivatives, we need to recompute them\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    computeDerivatives(eventT, y, yDot);\n-                    resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n+currentEvent.stepAcceptedClassName = remainingStep;\n                     return eventT;\n                 }\n \n                 // prepare handling of the remaining part of the step\n                 previousT = eventT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "currentEvent.stepAccepted vec = remainingStep;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-7/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\t2022-07-19 17:10:26.377097627 +0200\n+++ /tmp/tmp2cn8k5_k.java\t2022-07-19 17:10:26.377097627 +0200\n@@ -341,37 +341,11 @@\n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n-\n-                if (isLastStep) {\n-                    // the event asked to stop integration\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n-                    return eventT;\n-                }\n-\n-                boolean needReset = currentEvent.reset(eventT, eventY);\n-                if (needReset) {\n-                    // some event handler has triggered changes that\n-                    // invalidate the derivatives, we need to recompute them\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    computeDerivatives(eventT, y, yDot);\n-                    resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n+currentEvent.stepAccepted vec = remainingStep;\n                     return eventT;\n                 }\n \n                 // prepare handling of the remaining part of the step\n                 previousT = eventT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "currentEvent.stepAcceptedT(x, y) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-7/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\t2022-07-19 17:10:28.337087027 +0200\n+++ /tmp/tmpw_8xnzjt.java\t2022-07-19 17:10:28.341087007 +0200\n@@ -341,37 +341,11 @@\n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n-\n-                if (isLastStep) {\n-                    // the event asked to stop integration\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n-                    return eventT;\n-                }\n-\n-                boolean needReset = currentEvent.reset(eventT, eventY);\n-                if (needReset) {\n-                    // some event handler has triggered changes that\n-                    // invalidate the derivatives, we need to recompute them\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    computeDerivatives(eventT, y, yDot);\n-                    resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n+currentEvent.stepAcceptedT(x, y) {\n                     return eventT;\n                 }\n \n                 // prepare handling of the remaining part of the step\n                 previousT = eventT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "currentEvent.stepAcceptedComponent(x, y) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-7/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\t2022-07-19 17:10:30.345076167 +0200\n+++ /tmp/tmppwbaul88.java\t2022-07-19 17:10:30.345076167 +0200\n@@ -341,37 +341,11 @@\n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n-\n-                if (isLastStep) {\n-                    // the event asked to stop integration\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n-                    return eventT;\n-                }\n-\n-                boolean needReset = currentEvent.reset(eventT, eventY);\n-                if (needReset) {\n-                    // some event handler has triggered changes that\n-                    // invalidate the derivatives, we need to recompute them\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    computeDerivatives(eventT, y, yDot);\n-                    resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n+currentEvent.stepAcceptedComponent(x, y) {\n                     return eventT;\n                 }\n \n                 // prepare handling of the remaining part of the step\n                 previousT = eventT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "currentEvent.stepAcceptedAllUnknown, remainingStep = state.stopAtStartY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-7/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\t2022-07-19 17:10:32.373065195 +0200\n+++ /tmp/tmpi4u2l2d1.java\t2022-07-19 17:10:32.373065195 +0200\n@@ -341,37 +341,11 @@\n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n-\n-                if (isLastStep) {\n-                    // the event asked to stop integration\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n-                    return eventT;\n-                }\n-\n-                boolean needReset = currentEvent.reset(eventT, eventY);\n-                if (needReset) {\n-                    // some event handler has triggered changes that\n-                    // invalidate the derivatives, we need to recompute them\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    computeDerivatives(eventT, y, yDot);\n-                    resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n+currentEvent.stepAcceptedAllUnknown, remainingStep = state.stopAtStartY;\n                     return eventT;\n                 }\n \n                 // prepare handling of the remaining part of the step\n                 previousT = eventT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "currentEvent.stepAcceptedAllUnknown, remainingStep = state.stopAtPos;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-7/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\t2022-07-19 17:10:34.441054005 +0200\n+++ /tmp/tmph2h2vm8r.java\t2022-07-19 17:10:34.441054005 +0200\n@@ -341,37 +341,11 @@\n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n-\n-                if (isLastStep) {\n-                    // the event asked to stop integration\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n-                    return eventT;\n-                }\n-\n-                boolean needReset = currentEvent.reset(eventT, eventY);\n-                if (needReset) {\n-                    // some event handler has triggered changes that\n-                    // invalidate the derivatives, we need to recompute them\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    computeDerivatives(eventT, y, yDot);\n-                    resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n+currentEvent.stepAcceptedAllUnknown, remainingStep = state.stopAtPos;\n                     return eventT;\n                 }\n \n                 // prepare handling of the remaining part of the step\n                 previousT = eventT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "currentEvent.stepAcceptedAllUnknown, remainingStep = state.stopStep;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-7/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\t2022-07-19 17:10:36.593042359 +0200\n+++ /tmp/tmpxwo52gl0.java\t2022-07-19 17:10:36.593042359 +0200\n@@ -341,37 +341,11 @@\n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n-\n-                if (isLastStep) {\n-                    // the event asked to stop integration\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n-                    return eventT;\n-                }\n-\n-                boolean needReset = currentEvent.reset(eventT, eventY);\n-                if (needReset) {\n-                    // some event handler has triggered changes that\n-                    // invalidate the derivatives, we need to recompute them\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    computeDerivatives(eventT, y, yDot);\n-                    resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n+currentEvent.stepAcceptedAllUnknown, remainingStep = state.stopStep;\n                     return eventT;\n                 }\n \n                 // prepare handling of the remaining part of the step\n                 previousT = eventT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "currentEvent.stepAcceptedTag(x, y) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-7/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\t2022-07-19 17:10:38.577031618 +0200\n+++ /tmp/tmpy6khn4xl.java\t2022-07-19 17:10:38.581031597 +0200\n@@ -341,37 +341,11 @@\n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n-\n-                if (isLastStep) {\n-                    // the event asked to stop integration\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n-                    return eventT;\n-                }\n-\n-                boolean needReset = currentEvent.reset(eventT, eventY);\n-                if (needReset) {\n-                    // some event handler has triggered changes that\n-                    // invalidate the derivatives, we need to recompute them\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    computeDerivatives(eventT, y, yDot);\n-                    resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n+currentEvent.stepAcceptedTag(x, y) {\n                     return eventT;\n                 }\n \n                 // prepare handling of the remaining part of the step\n                 previousT = eventT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "currentEvent.stepAcceptedParser = remainingStep;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-7/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\t2022-07-19 17:10:40.601020658 +0200\n+++ /tmp/tmph2goy2tz.java\t2022-07-19 17:10:40.605020637 +0200\n@@ -341,37 +341,11 @@\n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n-\n-                if (isLastStep) {\n-                    // the event asked to stop integration\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n-                    return eventT;\n-                }\n-\n-                boolean needReset = currentEvent.reset(eventT, eventY);\n-                if (needReset) {\n-                    // some event handler has triggered changes that\n-                    // invalidate the derivatives, we need to recompute them\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    computeDerivatives(eventT, y, yDot);\n-                    resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n+currentEvent.stepAcceptedParser = remainingStep;\n                     return eventT;\n                 }\n \n                 // prepare handling of the remaining part of the step\n                 previousT = eventT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "currentEvent.stepAccepted(eventT, eventY); isLastStep = currentEvent.stop(); // handle the first part of the step, up to the event for (final StepHandler handler : stepHandlers) { handler.handleStep(interpolator, isLastStep); } if (isLastStep) { // the event asked to stop integration System.arraycopy(eventY, 0, y, 0, y.length); for (final EventState remaining : occuringEvents) { remaining.stepAccepted(eventT, eventY); } return eventT; } boolean needReset = currentEvent.reset(eventT, eventY); if (needReset) { // some event handler has triggered changes that // invalidate the derivatives, we need to recompute them System.arraycopy(eventY, 0, y, 0, y.length); computeDerivatives(eventT, y, yDot); resetOccurred = true; for (final EventState remaining : occuringEvents) { remaining.stepAccepted(eventT, eventY); }",
        "fixed_line": "for (final EventState state : eventsStates) { state.stepAccepted(eventT, eventY); isLastStep = isLastStep || state.stop(); } // handle the first part of the step, up to the event for (final StepHandler handler : stepHandlers) { handler.handleStep(interpolator, isLastStep); } if (isLastStep) { // the event asked to stop integration System.arraycopy(eventY, 0, y, 0, y.length); return eventT; } boolean needReset = false; for (final EventState state : eventsStates) { needReset = needReset || state.reset(eventT, eventY); }"
    },
    "Cli-20": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (token.indexOf('=')!= token.substring(0, token.length - 1) { tokens.indexOf('=') + 1, tokens.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-20/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 17:10:42.877008331 +0200\n+++ /tmp/tmpj7233ken.java\t2022-07-19 17:10:42.969007835 +0200\n@@ -109,18 +109,11 @@\n             String token = (String) iter.next();\n \n             // handle long option --foo or --foo=bar\n             if (token.startsWith(\"--\"))\n             {\n-                if (token.indexOf('=') != -1)\n-                {\n-                    tokens.add(token.substring(0, token.indexOf('=')));\n-                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n-                }\n-                else\n-                {\n-                    tokens.add(token);\n+if (token.indexOf('=')!= token.substring(0, token.length - 1) { tokens.indexOf('=') + 1, tokens.length()));\n                 }\n             }\n \n             // single hyphen\n             else if (\"-\".equals(token))\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (token.indexOf('=')!= -1) { token.indexOf('=') + 1, tokens.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-20/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 17:10:44.760998127 +0200\n+++ /tmp/tmpfo2vjx5w.java\t2022-07-19 17:10:44.760998127 +0200\n@@ -109,18 +109,11 @@\n             String token = (String) iter.next();\n \n             // handle long option --foo or --foo=bar\n             if (token.startsWith(\"--\"))\n             {\n-                if (token.indexOf('=') != -1)\n-                {\n-                    tokens.add(token.substring(0, token.indexOf('=')));\n-                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n-                }\n-                else\n-                {\n-                    tokens.add(token);\n+if (token.indexOf('=')!= -1) { token.indexOf('=') + 1, tokens.length()));\n                 }\n             }\n \n             // single hyphen\n             else if (\"-\".equals(token))\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (token.indexOf('=')!= token.STRING) token.indexOf('=') + 1, tokens.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-20/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 17:10:46.176990455 +0200\n+++ /tmp/tmptxlek8gu.java\t2022-07-19 17:10:46.176990455 +0200\n@@ -109,18 +109,11 @@\n             String token = (String) iter.next();\n \n             // handle long option --foo or --foo=bar\n             if (token.startsWith(\"--\"))\n             {\n-                if (token.indexOf('=') != -1)\n-                {\n-                    tokens.add(token.substring(0, token.indexOf('=')));\n-                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n-                }\n-                else\n-                {\n-                    tokens.add(token);\n+if (token.indexOf('=')!= token.STRING) token.indexOf('=') + 1, tokens.length()));\n                 }\n             }\n \n             // single hyphen\n             else if (\"-\".equals(token))\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (token.indexOf('=')!= token.substring(0, token.length - 1) { tokens.indexOf('=') + 1, token.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-20/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 17:10:47.648982479 +0200\n+++ /tmp/tmppq4zeej2.java\t2022-07-19 17:10:47.648982479 +0200\n@@ -109,18 +109,11 @@\n             String token = (String) iter.next();\n \n             // handle long option --foo or --foo=bar\n             if (token.startsWith(\"--\"))\n             {\n-                if (token.indexOf('=') != -1)\n-                {\n-                    tokens.add(token.substring(0, token.indexOf('=')));\n-                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n-                }\n-                else\n-                {\n-                    tokens.add(token);\n+if (token.indexOf('=')!= token.substring(0, token.length - 1) { tokens.indexOf('=') + 1, token.length()));\n                 }\n             }\n \n             // single hyphen\n             else if (\"-\".equals(token))\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (token.indexOf('=')!= -1) { tokens.indexOf('=') + 1, tokens.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-20/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 17:10:49.080974719 +0200\n+++ /tmp/tmpxgwiy837.java\t2022-07-19 17:10:49.080974719 +0200\n@@ -109,18 +109,11 @@\n             String token = (String) iter.next();\n \n             // handle long option --foo or --foo=bar\n             if (token.startsWith(\"--\"))\n             {\n-                if (token.indexOf('=') != -1)\n-                {\n-                    tokens.add(token.substring(0, token.indexOf('=')));\n-                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n-                }\n-                else\n-                {\n-                    tokens.add(token);\n+if (token.indexOf('=')!= -1) { tokens.indexOf('=') + 1, tokens.length()));\n                 }\n             }\n \n             // single hyphen\n             else if (\"-\".equals(token))\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (token.indexOf('=')!= token.STRING) token.indexOf('=') + 1, token.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-20/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 17:10:50.516966935 +0200\n+++ /tmp/tmp09ejzyf1.java\t2022-07-19 17:10:50.520966914 +0200\n@@ -109,18 +109,11 @@\n             String token = (String) iter.next();\n \n             // handle long option --foo or --foo=bar\n             if (token.startsWith(\"--\"))\n             {\n-                if (token.indexOf('=') != -1)\n-                {\n-                    tokens.add(token.substring(0, token.indexOf('=')));\n-                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n-                }\n-                else\n-                {\n-                    tokens.add(token);\n+if (token.indexOf('=')!= token.STRING) token.indexOf('=') + 1, token.length()));\n                 }\n             }\n \n             // single hyphen\n             else if (\"-\".equals(token))\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (token.indexOf('=')!= -1) { token.indexOf('=') + 1, token.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-20/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 17:10:51.976959022 +0200\n+++ /tmp/tmpehick5hb.java\t2022-07-19 17:10:52.000958891 +0200\n@@ -109,18 +109,11 @@\n             String token = (String) iter.next();\n \n             // handle long option --foo or --foo=bar\n             if (token.startsWith(\"--\"))\n             {\n-                if (token.indexOf('=') != -1)\n-                {\n-                    tokens.add(token.substring(0, token.indexOf('=')));\n-                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n-                }\n-                else\n-                {\n-                    tokens.add(token);\n+if (token.indexOf('=')!= -1) { token.indexOf('=') + 1, token.length()));\n                 }\n             }\n \n             // single hyphen\n             else if (\"-\".equals(token))\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (token.indexOf('=')!= token.substring(token.indexOf('=') + 1, token.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-20/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 17:10:53.584950303 +0200\n+++ /tmp/tmp7j65lv08.java\t2022-07-19 17:10:53.584950303 +0200\n@@ -109,18 +109,11 @@\n             String token = (String) iter.next();\n \n             // handle long option --foo or --foo=bar\n             if (token.startsWith(\"--\"))\n             {\n-                if (token.indexOf('=') != -1)\n-                {\n-                    tokens.add(token.substring(0, token.indexOf('=')));\n-                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n-                }\n-                else\n-                {\n-                    tokens.add(token);\n+if (token.indexOf('=')!= token.substring(token.indexOf('=') + 1, token.length()));\n                 }\n             }\n \n             // single hyphen\n             else if (\"-\".equals(token))\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (token.indexOf('=')!= -1) { tokens.indexOf('=') + 1, token.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-20/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 17:10:54.964942821 +0200\n+++ /tmp/tmplj85kipc.java\t2022-07-19 17:10:54.964942821 +0200\n@@ -109,18 +109,11 @@\n             String token = (String) iter.next();\n \n             // handle long option --foo or --foo=bar\n             if (token.startsWith(\"--\"))\n             {\n-                if (token.indexOf('=') != -1)\n-                {\n-                    tokens.add(token.substring(0, token.indexOf('=')));\n-                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n-                }\n-                else\n-                {\n-                    tokens.add(token);\n+if (token.indexOf('=')!= -1) { tokens.indexOf('=') + 1, token.length()));\n                 }\n             }\n \n             // single hyphen\n             else if (\"-\".equals(token))\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (token.indexOf('=')!= token.substring(0, token.length - 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-20/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 17:10:56.392935077 +0200\n+++ /tmp/tmpt7vhopt5.java\t2022-07-19 17:10:56.396935053 +0200\n@@ -109,18 +109,11 @@\n             String token = (String) iter.next();\n \n             // handle long option --foo or --foo=bar\n             if (token.startsWith(\"--\"))\n             {\n-                if (token.indexOf('=') != -1)\n-                {\n-                    tokens.add(token.substring(0, token.indexOf('=')));\n-                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n-                }\n-                else\n-                {\n-                    tokens.add(token);\n+if (token.indexOf('=')!= token.substring(0, token.length - 1) {\n                 }\n             }\n \n             // single hyphen\n             else if (\"-\".equals(token))\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (token.indexOf('=') != -1) { tokens.add(token.substring(0, token.indexOf('='))); tokens.add(token.substring(token.indexOf('=') + 1, token.length())); } else { tokens.add(token);",
        "fixed_line": "int pos = token.indexOf('='); String opt = pos == -1 ? token : token.substring(0, pos); // --foo if (!options.hasOption(opt) && stopAtNonOption) { process(token); } else { tokens.add(opt); if (pos != -1) { tokens.add(token.substring(pos + 1)); }"
    },
    "Closure-42": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if (loopNode.getFirstChild().getType() == Token.FOR) { if (loopNode.getLastChild().getString().equals(loopNode.getFirstChild())) { return newNode; } } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode.getLastChild()); } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode, transform(loopNode); } }",
                "patch_diff": "// if (loopNode.getFirstChild().getType() == Token.FOR) { if (loopNode.getLastChild().getString().equals(loopNode.getFirstChild())) { return newNode; } } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode.getLastChild()); } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode, transform(loopNode); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// if (loopNode.getFirstChild().getType() == Token.FOR) { if (loopNode.getLastChild().getString().equals(loopNode.getFirstChild())) { return newNode; } } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode.getLastChild()); } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode, transform(loopNode.getLastChild()); } }",
                "patch_diff": "// if (loopNode.getFirstChild().getType() == Token.FOR) { if (loopNode.getLastChild().getString().equals(loopNode.getFirstChild())) { return newNode; } } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode.getLastChild()); } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode, transform(loopNode.getLastChild()); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if (loopNode.getFirstChild().getType() == Token.FOR) { if (loopNode.getLastChild().getString().equals(loopNode.getFirstChild())) { return newNode; } } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode.getLastChild()); } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode); } }",
                "patch_diff": "// if (loopNode.getFirstChild().getType() == Token.FOR) { if (loopNode.getLastChild().getString().equals(loopNode.getFirstChild())) { return newNode; } } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode.getLastChild()); } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// if (loopNode.getFirstChild().getType() == Token.FOR) { if (loopNode.getLastChild().getString().equals(loopNode.getFirstChild())) { return newNode; } } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode.getLastChild()); } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode.getLastChild()); } }",
                "patch_diff": "// if (loopNode.getFirstChild().getType() == Token.FOR) { if (loopNode.getLastChild().getString().equals(loopNode.getFirstChild())) { return newNode; } } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode.getLastChild()); } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode.getLastChild()); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// if (loopNode.getFirstChild().getType() == Token.FOR) { if (loopNode.getLastChild().getString().equals(loopNode.getFirstChild())) { return newNode; } } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode, transform(loopNode); } }",
                "patch_diff": "// if (loopNode.getFirstChild().getType() == Token.FOR) { if (loopNode.getLastChild().getString().equals(loopNode.getFirstChild())) { return newNode; } } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode, transform(loopNode); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if (loopNode.getFirstChild().getType() == Token.FOR) { if (loopNode.getLastChild().getString().equals(loopNode.getFirstChild())) { return newNode; } } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode.getLastChild()); } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode, transform(loopNode.getLastChild()); } } }",
                "patch_diff": "// if (loopNode.getFirstChild().getType() == Token.FOR) { if (loopNode.getLastChild().getString().equals(loopNode.getFirstChild())) { return newNode; } } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode.getLastChild()); } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode, transform(loopNode.getLastChild()); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// if (loopNode.getFirstChild().getType() == Token.FOR) { if (loopNode.getLastChild().getString().equals(loopNode.getFirstChild())) { return newNode; } } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode.getLastChild()); } else if (loopNode.getNext().getType() == Token.FOR) { return newNode(loopNode.getLastChild()); } }",
                "patch_diff": "// if (loopNode.getFirstChild().getType() == Token.FOR) { if (loopNode.getLastChild().getString().equals(loopNode.getFirstChild())) { return newNode; } } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode.getLastChild()); } else if (loopNode.getNext().getType() == Token.FOR) { return newNode(loopNode.getLastChild()); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// if (loopNode.getFirstChild().getType() == Token.FOR) { if (loopNode.getLastChild().getString().equals(loopNode.getFirstChild())) { return newNode; } } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode.getLastChild()); } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode.getLastChild()); } } }",
                "patch_diff": "// if (loopNode.getFirstChild().getType() == Token.FOR) { if (loopNode.getLastChild().getString().equals(loopNode.getFirstChild())) { return newNode; } } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode.getLastChild()); } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode.getLastChild()); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// if (loopNode.getFirstChild().getType() == Token.FOR) { if (loopNode.getLastChild().getString().equals(loopNode.getFirstChild())) { return newNode; } } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode, transform(loopNode.getLastChild()); } }",
                "patch_diff": "// if (loopNode.getFirstChild().getType() == Token.FOR) { if (loopNode.getLastChild().getString().equals(loopNode.getFirstChild())) { return newNode; } } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode, transform(loopNode.getLastChild()); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if (loopNode.getFirstChild().getType() == Token.FOR) { if (loopNode.getLastChild().getString().equals(loopNode.getFirstChild())) { return newNode; } } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode.getLastChild()); } else if (loopNode.getLastChild().getType() == Token.FOR, transform(loopNode.getLastChild()); } }",
                "patch_diff": "// if (loopNode.getFirstChild().getType() == Token.FOR) { if (loopNode.getLastChild().getString().equals(loopNode.getFirstChild())) { return newNode; } } else if (loopNode.getNext().getType() == Token.FOR) { return newNodeForInLoop(loopNode.getLastChild()); } else if (loopNode.getLastChild().getType() == Token.FOR, transform(loopNode.getLastChild()); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (loopNode.isForEach()) { errorReporter.error( \"unsupported language extension: for each\", sourceName, loopNode.getLineno(), \"\", 0); // Return the bare minimum to put the AST in a valid state. return newNode(Token.EXPR_RESULT, Node.newNumber(0)); }"
    },
    "JacksonDatabind-62": {
        "fixes": [
            {
                "k": 1,
                "patch": "// [JACKSON-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'canCreateUsingDelegate()', but null)",
                "patch_diff": "// [JACKSON-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'canCreateUsingDelegate()', but null)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// [JACKSON-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'canCreateUsingDelegate()', but null",
                "patch_diff": "// [JACKSON-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'canCreateUsingDelegate()', but null",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// [JACKSON-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'canCreateUsingDelegate()', but null;",
                "patch_diff": "// [JACKSON-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'canCreateUsingDelegate()', but null;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// [JACKSON-creator definition for \"+_collectionType.getName() +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'canCreateUsingDelegate()', but null)",
                "patch_diff": "// [JACKSON-creator definition for \"+_collectionType.getName() +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'canCreateUsingDelegate()', but null)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// [JACKSON-creator definition for \"+_collectionType.getName() +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'canCreateUsingDelegate()', but null",
                "patch_diff": "// [JACKSON-creator definition for \"+_collectionType.getName() +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'canCreateUsingDelegate()', but null",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// [JACKSON-creator definition for \"+_collectionType.getName() +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'canCreateUsingDelegate()', but null;",
                "patch_diff": "// [JACKSON-creator definition for \"+_collectionType.getName() +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'canCreateUsingDelegate()', but null;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// [JACKSON-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'canCreateUsingDelegate()', but null) {",
                "patch_diff": "// [JACKSON-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'canCreateUsingDelegate()', but null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// [JACKSON-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'canCreateUsingDelegate()', but null \"",
                "patch_diff": "// [JACKSON-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'canCreateUsingDelegate()', but null \"",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// [JACKSON-creator definition for \"+_collectionType.getName() +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for '",
                "patch_diff": "// [JACKSON-creator definition for \"+_collectionType.getName() +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for '",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// [JACKSON-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'canCreateUsingDelegate()', but null,",
                "patch_diff": "// [JACKSON-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'canCreateUsingDelegate()', but null,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "} else if (_valueInstantiator.canCreateUsingArrayDelegate()) { JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig()); if (delegateType == null) { throw new IllegalArgumentException(\"Invalid array-delegate-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'canCreateUsingArrayDelegate()', but null for 'getArrayDelegateType()'\"); } delegateDeser = findDeserializer(ctxt, delegateType, property);"
    },
    "JacksonDatabind-40": {
        "fixes": [
            {
                "k": 1,
                "patch": "// remove in 2.7? if (_nullValue == null) { return _nullValue; } else { return _nullValue; } }",
                "patch_diff": "// remove in 2.7? if (_nullValue == null) { return _nullValue; } else { return _nullValue; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// remove in 2.7? return _nullValue; } // [databind#1095]: Should not allow coercion from into null",
                "patch_diff": "// remove in 2.7? return _nullValue; } // [databind#1095]: Should not allow coercion from into null",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// remove in 2.7? return _nullValue; } // [databind#1095]: Should not allow coercion",
                "patch_diff": "// remove in 2.7? return _nullValue; } // [databind#1095]: Should not allow coercion",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// remove in 2.7? if (_nullValue == null) { return _nullValue; } else { return _nullValue; } // [databind#10 } }",
                "patch_diff": "// remove in 2.7? if (_nullValue == null) { return _nullValue; } else { return _nullValue; } // [databind#10 } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// remove in 2.7? return _nullValue; } // [databind#1095]: Should not allow coercion from into null)",
                "patch_diff": "// remove in 2.7? return _nullValue; } // [databind#1095]: Should not allow coercion from into null)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// remove in 2.7? return _nullValue; }",
                "patch_diff": "// remove in 2.7? return _nullValue; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// remove in 2.7? return _nullValue; } // [databind#1095]: Should not allow coercion (toJsonNode)",
                "patch_diff": "// remove in 2.7? return _nullValue; } // [databind#1095]: Should not allow coercion (toJsonNode)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// remove in 2.7? if (_nullValue == null) { return _nullValue; } else { return _nullValue; } // [databind#10...",
                "patch_diff": "// remove in 2.7? if (_nullValue == null) { return _nullValue; } else { return _nullValue; } // [databind#10...",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// remove in 2.7? return _nullValue; } // [databind#1095]: Should not allow coercion (toJsonNode) _nullValue;",
                "patch_diff": "// remove in 2.7? return _nullValue; } // [databind#1095]: Should not allow coercion (toJsonNode) _nullValue;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// remove in 2.7? if (_nullValue == null) { return _nullValue; } else { return _nullValue; } } // [databind#10...",
                "patch_diff": "// remove in 2.7? if (_nullValue == null) { return _nullValue; } else { return _nullValue; } } // [databind#10...",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "@Override public T getEmptyValue(DeserializationContext ctxt) throws JsonMappingException { // [databind#1095]: Should not allow coercion from into null from Empty String // either, if `null` not allowed if (_primitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) { throw ctxt.mappingException( \"Can not map Empty String as null into type %s (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to 'false' to allow)\", handledType().toString()); } return _nullValue; }"
    },
    "Closure-31": {
        "fixes": [
            {
                "k": 1,
                "patch": "!options.skipAllPasses || options.closurePasses) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-31/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 17:11:03.812894819 +0200\n+++ /tmp/tmpp7no1f44.java\t2022-07-19 17:11:03.832894710 +0200\n@@ -1280,11 +1280,11 @@\n       // Check if inputs need to be rebuilt from modules.\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+!options.skipAllPasses || options.closurePasses) {\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "!options.skipAllPasses && options.closurePasses;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-31/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 17:11:08.708868239 +0200\n+++ /tmp/tmprlin92uc.java\t2022-07-19 17:11:08.712868216 +0200\n@@ -1280,11 +1280,11 @@\n       // Check if inputs need to be rebuilt from modules.\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+!options.skipAllPasses && options.closurePasses;\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "!options.skipAllPasses || options.closurePasses;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-31/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 17:11:12.104849796 +0200\n+++ /tmp/tmpg6d_65mz.java\t2022-07-19 17:11:12.108849772 +0200\n@@ -1280,11 +1280,11 @@\n       // Check if inputs need to be rebuilt from modules.\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+!options.skipAllPasses || options.closurePasses;\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "!options.skipAllPasses || s.closurePasses) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-31/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 17:11:15.664830455 +0200\n+++ /tmp/tmpqc51ctus.java\t2022-07-19 17:11:15.664830455 +0200\n@@ -1280,11 +1280,11 @@\n       // Check if inputs need to be rebuilt from modules.\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+!options.skipAllPasses || s.closurePasses) {\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "!options.skipAllPasses && options.closurePasses) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-31/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 17:11:18.996812345 +0200\n+++ /tmp/tmpzi352gjr.java\t2022-07-19 17:11:19.000812324 +0200\n@@ -1280,11 +1280,11 @@\n       // Check if inputs need to be rebuilt from modules.\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+!options.skipAllPasses && options.closurePasses) {\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "!options.skipAllPasses ||options.closurePasses) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-31/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 17:11:22.248794667 +0200\n+++ /tmp/tmpdzx2x4zo.java\t2022-07-19 17:11:22.248794667 +0200\n@@ -1280,11 +1280,11 @@\n       // Check if inputs need to be rebuilt from modules.\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+!options.skipAllPasses ||options.closurePasses) {\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "!options.skipAllPasses ||options.closurePasses;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-31/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 17:11:25.728775742 +0200\n+++ /tmp/tmp0xdssl04.java\t2022-07-19 17:11:25.732775721 +0200\n@@ -1280,11 +1280,11 @@\n       // Check if inputs need to be rebuilt from modules.\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+!options.skipAllPasses ||options.closurePasses;\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "!options.skipAllPasses &&!options.closurePasses;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-31/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 17:11:29.172757008 +0200\n+++ /tmp/tmp43yl8or6.java\t2022-07-19 17:11:29.172757008 +0200\n@@ -1280,11 +1280,11 @@\n       // Check if inputs need to be rebuilt from modules.\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+!options.skipAllPasses &&!options.closurePasses;\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "!options.skipAllPasses || s.closurePasses;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-31/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 17:11:32.604738333 +0200\n+++ /tmp/tmpwa2bf4aw.java\t2022-07-19 17:11:32.604738333 +0200\n@@ -1280,11 +1280,11 @@\n       // Check if inputs need to be rebuilt from modules.\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+!options.skipAllPasses || s.closurePasses;\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "!options.skipAllPasses &&!options.closurePasses) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-31/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 17:11:36.060719522 +0200\n+++ /tmp/tmpe4n_kxf5.java\t2022-07-19 17:11:36.060719522 +0200\n@@ -1280,11 +1280,11 @@\n       // Check if inputs need to be rebuilt from modules.\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+!options.skipAllPasses &&!options.closurePasses) {\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "!options.skipAllPasses &&",
        "fixed_line": ""
    },
    "Closure-44": {
        "fixes": [
            {
                "k": 1,
                "patch": "// can't really modify it was non-literal characters that might be valid (empty be",
                "patch_diff": "// can't really modify it was non-literal characters that might be valid (empty be",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "patch_diff": "// can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if (isWordChar(c) && isWordChar(c)) {",
                "patch_diff": "// if (isWordChar(c) && isWordChar(c)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// if (isWordChar(c) || isWordChar(c)) {",
                "patch_diff": "// if (isWordChar(c) || isWordChar(c)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// can't really modify it was non-literal characters that might be valid (empty be // need to check",
                "patch_diff": "// can't really modify it was non-literal characters that might be valid (empty be // need to check",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// can't really modify it was non-literal characters that might be valid (",
                "patch_diff": "// can't really modify it was non-literal characters that might be valid (",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// can't really modify it was non-literal characters that might be null or EMPTY",
                "patch_diff": "// can't really modify it was non-literal characters that might be null or EMPTY",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// can't really modify it was non-literal characters that might be valid (empty be valid)",
                "patch_diff": "// can't really modify it was non-literal characters that might be valid (empty be valid)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// if (isWordChar(c) && isWordChar(c) {",
                "patch_diff": "// if (isWordChar(c) && isWordChar(c) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// }",
                "patch_diff": "// }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "} else if (c == '/' && getLastChar() == '/') { // Do not allow a forward slash to appear after a DIV. // For example, // REGEXP DIV REGEXP // is valid and should print like // / // / / append(\" \");"
    },
    "Closure-94": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if it was non-literal characters that might be valid (e if it was valid)",
                "patch_diff": "// if it was non-literal characters that might be valid (e if it was valid)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// if it was non-literal characters that might be valid (e if it's",
                "patch_diff": "// if it was non-literal characters that might be valid (e if it's",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if it was non-literal characters that might be valid (empty be valid)",
                "patch_diff": "// if it was non-literal characters that might be valid (empty be valid)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// if it was non-literal characters that might be valid (toJsonNode)",
                "patch_diff": "// if it was non-literal characters that might be valid (toJsonNode)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// if it was non-literal characters that might be valid (empty be // need to check",
                "patch_diff": "// if it was non-literal characters that might be valid (empty be // need to check",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if it was non-literal characters that might be valid (e if it was -->",
                "patch_diff": "// if it was non-literal characters that might be valid (e if it was -->",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// if it's do implicit re-parse",
                "patch_diff": "// if it's do implicit re-parse",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// if it was non-literal characters that might be valid (e if it was valid) {",
                "patch_diff": "// if it was non-literal characters that might be valid (e if it was valid) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// if it was non-literal characters that might be valid (e if it's valid)",
                "patch_diff": "// if it was non-literal characters that might be valid (e if it's valid)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if it was non-literal characters that might be valid (empty be",
                "patch_diff": "// if it was non-literal characters that might be valid (empty be",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "case Token.ADD: case Token.BITAND: case Token.BITNOT: case Token.BITOR: case Token.BITXOR: case Token.DIV: case Token.EQ: case Token.GE: case Token.GT: case Token.LE: case Token.LSH: case Token.LT: case Token.MOD: case Token.MUL: case Token.NE: case Token.RSH: case Token.SHEQ: case Token.SHNE: case Token.SUB: case Token.URSH: return isValidDefineValue(val.getFirstChild(), defines) && isValidDefineValue(val.getLastChild(), defines); // Uniary operators are valid if the child is valid. case Token.NOT: case Token.NEG: case Token.POS:"
    },
    "Lang-31": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int i = 0; i < str.length; i++) { if (searchChars[i] == ch) {",
                "patch_diff": "for (int i = 0; i < str.length; i++) { if (searchChars[i] == ch) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = 0; i < str.length; i++) {",
                "patch_diff": "for (int i = 0; i < str.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0; i < cs.length; i++) { if (searchChars[i] == ch) {",
                "patch_diff": "for (int i = 0; i < cs.length; i++) { if (searchChars[i] == ch) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = 0; i < str.length; i++) { char ch = str.charAt(i); if (searchChars[j] == ch) {",
                "patch_diff": "for (int i = 0; i < str.length; i++) { char ch = str.charAt(i); if (searchChars[j] == ch) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = 0; i < str.length; i++) { char ch = str.charAt(i); if (searchChars[i] == ch) {",
                "patch_diff": "for (int i = 0; i < str.length; i++) { char ch = str.charAt(i); if (searchChars[i] == ch) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = 0; i < cs.length; i++) { if (searchChars[i] == ch) { return false; } } }",
                "patch_diff": "for (int i = 0; i < cs.length; i++) { if (searchChars[i] == ch) { return false; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = 0; i < csLength; i++) { char ch = str.charAt(i); if (searchChars[j] == ch) {",
                "patch_diff": "for (int i = 0; i < csLength; i++) { char ch = str.charAt(i); if (searchChars[j] == ch) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int j = 0; j < searchChars.length; j++) {",
                "patch_diff": "for (int j = 0; j < searchChars.length; j++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int i = 0; i < csLength; i++) { char ch = str.charAt(i); if (searchChars[i] == ch) {",
                "patch_diff": "for (int i = 0; i < csLength; i++) { char ch = str.charAt(i); if (searchChars[i] == ch) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = 0; i < cs.length; i++) { char ch = str.charAt(i); if (searchChars[i] == ch) {",
                "patch_diff": "for (int i = 0; i < cs.length; i++) { char ch = str.charAt(i); if (searchChars[i] == ch) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "int csLastIndex = csLength - 1; int searchLastIndex = searchLength - 1; for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { if (i < csLastIndex && j < searchLastIndex && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { // ch is a supplementary character if (searchChars[j + 1] == cs.charAt(i + 1)) { return true; } } else { // ch is in the Basic Multilingual Plane return true; }"
    },
    "Closure-122": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (comment.getValue().indexOf(\"/* @\") || comment.getValue().indexOf(\"\\n * @+ -1)!= -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2022-07-19 17:11:44.668672643 +0200\n+++ /tmp/tmp9ponwnt1.java\t2022-07-19 17:11:44.688672533 +0200\n@@ -247,11 +247,11 @@\n \n   /**\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+if (comment.getValue().indexOf(\"/* @\") || comment.getValue().indexOf(\"\\n * @+ -1)!= -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n           comment.getLineno(), \"\", 0);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (comment.getValue().indexOf(\"/* @\") || comment.getValue().indexOf(\"\\n * @ @+ -1)!= -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2022-07-19 17:11:49.364647053 +0200\n+++ /tmp/tmpd7cf807a.java\t2022-07-19 17:11:49.364647053 +0200\n@@ -247,11 +247,11 @@\n \n   /**\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+if (comment.getValue().indexOf(\"/* @\") || comment.getValue().indexOf(\"\\n * @ @+ -1)!= -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n           comment.getLineno(), \"\", 0);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @ @ @\")!= -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2022-07-19 17:11:52.836628125 +0200\n+++ /tmp/tmplggge_mf.java\t2022-07-19 17:11:52.836628125 +0200\n@@ -247,11 +247,11 @@\n \n   /**\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @ @ @\")!= -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n           comment.getLineno(), \"\", 0);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (comment.getValue().indexOf(\"/* @\") == -1 || comment.getValue().indexOf(\"\\n * @ @ @\")!= -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2022-07-19 17:12:45.356341143 +0200\n+++ /tmp/tmp85afbpoq.java\t2022-07-19 17:12:45.356341143 +0200\n@@ -247,11 +247,11 @@\n \n   /**\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+if (comment.getValue().indexOf(\"/* @\") == -1 || comment.getValue().indexOf(\"\\n * @ @ @\")!= -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n           comment.getLineno(), \"\", 0);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (comment.getValue().indexOf(\"/* @\") || comment.getValue().indexOf(\"\\n * @ @ @\")!= -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2022-07-19 17:13:34.704070404 +0200\n+++ /tmp/tmpt4rmjy70.java\t2022-07-19 17:13:34.704070404 +0200\n@@ -247,11 +247,11 @@\n \n   /**\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+if (comment.getValue().indexOf(\"/* @\") || comment.getValue().indexOf(\"\\n * @ @ @\")!= -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n           comment.getLineno(), \"\", 0);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (comment.getValue().indexOf(\"/* @\") || comment.getValue().indexOf(\"\\n * -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2022-07-19 17:13:38.664048635 +0200\n+++ /tmp/tmpt2_kqi36.java\t2022-07-19 17:13:38.664048635 +0200\n@@ -247,11 +247,11 @@\n \n   /**\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+if (comment.getValue().indexOf(\"/* @\") || comment.getValue().indexOf(\"\\n * -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n           comment.getLineno(), \"\", 0);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (comment.getValue().indexOf(\"/* @\") || comment.getValue().indexOf(\"\\n * @ @\")!= -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2022-07-19 17:13:42.128029590 +0200\n+++ /tmp/tmp0dr_b4ip.java\t2022-07-19 17:13:42.128029590 +0200\n@@ -247,11 +247,11 @@\n \n   /**\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+if (comment.getValue().indexOf(\"/* @\") || comment.getValue().indexOf(\"\\n * @ @\")!= -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n           comment.getLineno(), \"\", 0);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (comment.getValue().indexOf(\"/* @\") || comment.getValue().indexOf(\"\\n * @\")!= -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2022-07-19 17:13:45.756009637 +0200\n+++ /tmp/tmp35mjf41a.java\t2022-07-19 17:13:45.756009637 +0200\n@@ -247,11 +247,11 @@\n \n   /**\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+if (comment.getValue().indexOf(\"/* @\") || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n           comment.getLineno(), \"\", 0);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (comment.getValue().indexOf(\"/* @\") || comment.getValue().indexOf(\"\\n * @ @ @+ -1)!= -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2022-07-19 17:13:49.471989195 +0200\n+++ /tmp/tmpi6wkeu4j.java\t2022-07-19 17:13:49.471989195 +0200\n@@ -247,11 +247,11 @@\n \n   /**\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+if (comment.getValue().indexOf(\"/* @\") || comment.getValue().indexOf(\"\\n * @ @ @+ -1)!= -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n           comment.getLineno(), \"\", 0);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @ @ @ @\")!= -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2022-07-19 17:13:52.779970991 +0200\n+++ /tmp/tmp_2qww_2l.java\t2022-07-19 17:13:52.779970991 +0200\n@@ -247,11 +247,11 @@\n \n   /**\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @ @ @ @\")!= -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n           comment.getLineno(), \"\", 0);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {",
        "fixed_line": "Pattern p = Pattern.compile(\"(/|(\\n[ \\t]*))\\\\*[ \\t]*@[a-zA-Z]\"); if (p.matcher(comment.getValue()).find()) {"
    },
    "Cli-38": {
        "fixes": [
            {
                "k": 1,
                "patch": "return options.hasShortOption;optName!= JsonToken. return options.hasShortOption;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-38/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-19 17:14:42.979694268 +0200\n+++ /tmp/tmp0_qwh0ye.java\t2022-07-19 17:14:43.091693654 +0200\n@@ -305,11 +305,11 @@\n         }\n \n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n+return options.hasShortOption;optName!= JsonToken. return options.hasShortOption;\n         // check for several concatenated short options\n     }\n \n     /**\n      * Tells if the token looks like a long option.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return options.hasShortOption(optName!= JsonToken. return options.hasShortOption;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-38/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-19 17:14:44.787684285 +0200\n+++ /tmp/tmpi0cexj_8.java\t2022-07-19 17:14:44.787684285 +0200\n@@ -305,11 +305,11 @@\n         }\n \n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n+return options.hasShortOption(optName!= JsonToken. return options.hasShortOption;\n         // check for several concatenated short options\n     }\n \n     /**\n      * Tells if the token looks like a long option.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return options.hasShortOption;optName!= JsonToken. return options.hasShortOption(optName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-38/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-19 17:14:46.323675806 +0200\n+++ /tmp/tmpa0hh5s1v.java\t2022-07-19 17:14:46.323675806 +0200\n@@ -305,11 +305,11 @@\n         }\n \n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n+return options.hasShortOption;optName!= JsonToken. return options.hasShortOption(optName);\n         // check for several concatenated short options\n     }\n \n     /**\n      * Tells if the token looks like a long option.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return options.hasShortOption;optName!= JsonToken. return options.hasShortOption(optName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-38/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-19 17:14:47.799667654 +0200\n+++ /tmp/tmp_fk3x04k.java\t2022-07-19 17:14:47.799667654 +0200\n@@ -305,11 +305,11 @@\n         }\n \n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n+return options.hasShortOption;optName!= JsonToken. return options.hasShortOption(optName;\n         // check for several concatenated short options\n     }\n \n     /**\n      * Tells if the token looks like a long option.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return optName.hasShortOption;optName!= JsonToken. return options.hasShortOption;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-38/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-19 17:14:49.327659212 +0200\n+++ /tmp/tmpxi_160l6.java\t2022-07-19 17:14:49.327659212 +0200\n@@ -305,11 +305,11 @@\n         }\n \n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n+return optName.hasShortOption;optName!= JsonToken. return options.hasShortOption;\n         // check for several concatenated short options\n     }\n \n     /**\n      * Tells if the token looks like a long option.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return options.hasShortOption;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-38/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-19 17:14:50.883650619 +0200\n+++ /tmp/tmpwm_uxob_.java\t2022-07-19 17:14:50.883650619 +0200\n@@ -305,11 +305,11 @@\n         }\n \n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n+return options.hasShortOption;\n         // check for several concatenated short options\n     }\n \n     /**\n      * Tells if the token looks like a long option.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return options.hasShortOption; // skip",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-38/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-19 17:14:52.651640851 +0200\n+++ /tmp/tmpc70xzcm2.java\t2022-07-19 17:14:52.651640851 +0200\n@@ -305,11 +305,11 @@\n         }\n \n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n+return options.hasShortOption; // skip\n         // check for several concatenated short options\n     }\n \n     /**\n      * Tells if the token looks like a long option.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return options.hasShortOption;optName!= JsonToken. return options.hasShortOption(optName!= JsonToken. return options.hasShortOption;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-38/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-19 17:14:54.351631460 +0200\n+++ /tmp/tmppe05y2xb.java\t2022-07-19 17:14:54.351631460 +0200\n@@ -305,11 +305,11 @@\n         }\n \n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n+return options.hasShortOption;optName!= JsonToken. return options.hasShortOption(optName!= JsonToken. return options.hasShortOption;\n         // check for several concatenated short options\n     }\n \n     /**\n      * Tells if the token looks like a long option.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return options.hasShortOption(optName!= JsonToken. return options.hasShortOption(optName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-38/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-19 17:14:55.939622686 +0200\n+++ /tmp/tmpygce7ung.java\t2022-07-19 17:14:55.943622662 +0200\n@@ -305,11 +305,11 @@\n         }\n \n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n+return options.hasShortOption(optName!= JsonToken. return options.hasShortOption(optName;\n         // check for several concatenated short options\n     }\n \n     /**\n      * Tells if the token looks like a long option.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return options.hasShortOption(optName!= JsonToken. return options.hasShortOption(optName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-38/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-19 17:14:57.479614176 +0200\n+++ /tmp/tmpxsk1auh0.java\t2022-07-19 17:14:57.483614152 +0200\n@@ -305,11 +305,11 @@\n         }\n \n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n+return options.hasShortOption(optName!= JsonToken. return options.hasShortOption(optName);\n         // check for several concatenated short options\n     }\n \n     /**\n      * Tells if the token looks like a long option.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return options.hasShortOption(optName);",
        "fixed_line": "if (options.hasShortOption(optName)) { return true; } // check for several concatenated short options return optName.length() > 0 && options.hasShortOption(String.valueOf(optName.charAt(0)));"
    },
    "Math-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "return MIN_OUT_OF_MONTH_EXTENDED;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-5/src/main/java/org/apache/commons/math3/complex/Complex.java\t2022-07-19 17:14:59.119605113 +0200\n+++ /tmp/tmplg_bjit4.java\t2022-07-19 17:14:59.151604935 +0200\n@@ -300,11 +300,11 @@\n         if (isNaN) {\n             return NaN;\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+return MIN_OUT_OF_MONTH_EXTENDED;\n         }\n \n         if (isInfinite) {\n             return ZERO;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return MIN_OUT_OF_MONTH;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-5/src/main/java/org/apache/commons/math3/complex/Complex.java\t2022-07-19 17:15:01.691590895 +0200\n+++ /tmp/tmpwozxbfg9.java\t2022-07-19 17:15:01.691590895 +0200\n@@ -300,11 +300,11 @@\n         if (isNaN) {\n             return NaN;\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+return MIN_OUT_OF_MONTH;\n         }\n \n         if (isInfinite) {\n             return ZERO;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return MIN_OUT_OF_STREAM;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-5/src/main/java/org/apache/commons/math3/complex/Complex.java\t2022-07-19 17:15:03.883578778 +0200\n+++ /tmp/tmpq7g_srmg.java\t2022-07-19 17:15:03.895578711 +0200\n@@ -300,11 +300,11 @@\n         if (isNaN) {\n             return NaN;\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+return MIN_OUT_OF_STREAM;\n         }\n \n         if (isInfinite) {\n             return ZERO;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return MIN_OUT_OF_BOUND;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-5/src/main/java/org/apache/commons/math3/complex/Complex.java\t2022-07-19 17:15:06.063566725 +0200\n+++ /tmp/tmp_smi5sza.java\t2022-07-19 17:15:06.063566725 +0200\n@@ -300,11 +300,11 @@\n         if (isNaN) {\n             return NaN;\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+return MIN_OUT_OF_BOUND;\n         }\n \n         if (isInfinite) {\n             return ZERO;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return imaginary;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-5/src/main/java/org/apache/commons/math3/complex/Complex.java\t2022-07-19 17:15:08.179555027 +0200\n+++ /tmp/tmpvmfgmwpk.java\t2022-07-19 17:15:08.179555027 +0200\n@@ -300,11 +300,11 @@\n         if (isNaN) {\n             return NaN;\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+return imaginary;\n         }\n \n         if (isInfinite) {\n             return ZERO;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return MIN_OUT_OF_EXTENDED;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-5/src/main/java/org/apache/commons/math3/complex/Complex.java\t2022-07-19 17:15:10.283543390 +0200\n+++ /tmp/tmpg9nx7rco.java\t2022-07-19 17:15:10.283543390 +0200\n@@ -300,11 +300,11 @@\n         if (isNaN) {\n             return NaN;\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+return MIN_OUT_OF_EXTENDED;\n         }\n \n         if (isInfinite) {\n             return ZERO;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return MIN_OUT_OF_CHAR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-5/src/main/java/org/apache/commons/math3/complex/Complex.java\t2022-07-19 17:15:12.435531490 +0200\n+++ /tmp/tmpzsw3qq0y.java\t2022-07-19 17:15:12.435531490 +0200\n@@ -300,11 +300,11 @@\n         if (isNaN) {\n             return NaN;\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+return MIN_OUT_OF_CHAR;\n         }\n \n         if (isInfinite) {\n             return ZERO;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return MIN_OUT_OF_YEAR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-5/src/main/java/org/apache/commons/math3/complex/Complex.java\t2022-07-19 17:15:14.547519807 +0200\n+++ /tmp/tmp4nqq49jo.java\t2022-07-19 17:15:14.547519807 +0200\n@@ -300,11 +300,11 @@\n         if (isNaN) {\n             return NaN;\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+return MIN_OUT_OF_YEAR;\n         }\n \n         if (isInfinite) {\n             return ZERO;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return MIN_OUT_OF_RANGE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-5/src/main/java/org/apache/commons/math3/complex/Complex.java\t2022-07-19 17:15:16.655508146 +0200\n+++ /tmp/tmpdgfugxm6.java\t2022-07-19 17:15:16.655508146 +0200\n@@ -300,11 +300,11 @@\n         if (isNaN) {\n             return NaN;\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+return MIN_OUT_OF_RANGE;\n         }\n \n         if (isInfinite) {\n             return ZERO;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return cinary;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-5/src/main/java/org/apache/commons/math3/complex/Complex.java\t2022-07-19 17:15:18.747496571 +0200\n+++ /tmp/tmpo99ixotl.java\t2022-07-19 17:15:18.747496571 +0200\n@@ -300,11 +300,11 @@\n         if (isNaN) {\n             return NaN;\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+return cinary;\n         }\n \n         if (isInfinite) {\n             return ZERO;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return NaN;",
        "fixed_line": "return INF;"
    },
    "Lang-44": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if (val.startsWith(\"\\\"\\\" is not a valid number.\"); }",
                "patch_diff": "// if (val.startsWith(\"\\\"\\\" is not a valid number.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// throw new NumberFormatException(\"\\\"\\\" is not a valid number.\"); }",
                "patch_diff": "// throw new NumberFormatException(\"\\\"\\\" is not a valid number.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// this is not a valid number.\"); }",
                "patch_diff": "// this is not a valid number.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// if (val.startsWith(\"--\")) { throw new NumberFormatException(\"\\\"\\\" is not a valid number.\"); }",
                "patch_diff": "// if (val.startsWith(\"--\")) { throw new NumberFormatException(\"\\\"\\\" is not a valid number.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// if (val.length() == 0) { throw new NumberFormatException(\"\\\"\\\" is not a valid number.\"); }",
                "patch_diff": "// if (val.length() == 0) { throw new NumberFormatException(\"\\\"\\\" is not a valid number.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if (val.startsWith(\"\\\"\\\" is not a valid number.\"); } else { throw new NumberFormatException(\"\\\"\\\" is not a valid number.\"); }",
                "patch_diff": "// if (val.startsWith(\"\\\"\\\" is not a valid number.\"); } else { throw new NumberFormatException(\"\\\"\\\" is not a valid number.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// if (val.length == 0) { throw new NumberFormatException(\"\\\"\\\" is not a valid number.\"); }",
                "patch_diff": "// if (val.length == 0) { throw new NumberFormatException(\"\\\"\\\" is not a valid number.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// if (val.startsWith(\"\\\"\\\" is not a valid number.\"); } else if (val.startsWith(\"\\\"\\\" is not a valid number.\"); }",
                "patch_diff": "// if (val.startsWith(\"\\\"\\\" is not a valid number.\"); } else if (val.startsWith(\"\\\"\\\" is not a valid number.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// this is a valid number.\"); }",
                "patch_diff": "// this is a valid number.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if (val.startsWith(\"\\\"\\\" is not a valid number.\");",
                "patch_diff": "// if (val.startsWith(\"\\\"\\\" is not a valid number.\");",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (val.length() == 1 && !Character.isDigit(val.charAt(0))) { throw new NumberFormatException(val + \" is not a valid number.\"); }"
    },
    "Closure-101": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (options.process_primitives) { options.closurePass = false; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-101/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 17:15:22.707474655 +0200\n+++ /tmp/tmpajl047x0.java\t2022-07-19 17:15:22.723474568 +0200\n@@ -428,13 +428,11 @@\n     WarningLevel wLevel = flags.warning_level;\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n-    }\n+if (options.process_primitives) { options.closurePass = false; }\n \n     initOptionsFromFlags(options);\n     return options;\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (options.process_primitives) { nopePass = false; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-101/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 17:15:24.891462567 +0200\n+++ /tmp/tmp8rtezw55.java\t2022-07-19 17:15:24.891462567 +0200\n@@ -428,13 +428,11 @@\n     WarningLevel wLevel = flags.warning_level;\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n-    }\n+if (options.process_primitives) { nopePass = false; }\n \n     initOptionsFromFlags(options);\n     return options;\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (options.process_primitives) {(flags.closurePass = false; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-101/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 17:15:26.699452562 +0200\n+++ /tmp/tmpicvoep9q.java\t2022-07-19 17:15:26.703452538 +0200\n@@ -428,13 +428,11 @@\n     WarningLevel wLevel = flags.warning_level;\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n-    }\n+if (options.process_primitives) {(flags.closurePass = false; }\n \n     initOptionsFromFlags(options);\n     return options;\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (options.process_primitives) { options.closurePass = true; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-101/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 17:15:28.279443813 +0200\n+++ /tmp/tmp9aq8sjgk.java\t2022-07-19 17:15:28.283443793 +0200\n@@ -428,13 +428,11 @@\n     WarningLevel wLevel = flags.warning_level;\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n-    }\n+if (options.process_primitives) { options.closurePass = true; }\n \n     initOptionsFromFlags(options);\n     return options;\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (options.remove_closure_primitives) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-101/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 17:15:29.943434602 +0200\n+++ /tmp/tmpul7m_lsm.java\t2022-07-19 17:15:29.943434602 +0200\n@@ -428,13 +428,11 @@\n     WarningLevel wLevel = flags.warning_level;\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n-    }\n+if (options.remove_closure_primitives) {\n \n     initOptionsFromFlags(options);\n     return options;\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (options.process_primitives) { if (options.closurePass = false; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-101/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 17:15:31.467426162 +0200\n+++ /tmp/tmpobesi9to.java\t2022-07-19 17:15:31.467426162 +0200\n@@ -428,13 +428,11 @@\n     WarningLevel wLevel = flags.warning_level;\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n-    }\n+if (options.process_primitives) { if (options.closurePass = false; }\n \n     initOptionsFromFlags(options);\n     return options;\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (options.remove_closure_ = false; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-101/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 17:15:32.987417747 +0200\n+++ /tmp/tmpx50webij.java\t2022-07-19 17:15:32.991417723 +0200\n@@ -428,13 +428,11 @@\n     WarningLevel wLevel = flags.warning_level;\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n-    }\n+if (options.remove_closure_ = false; }\n \n     initOptionsFromFlags(options);\n     return options;\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (options.process_primitives) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-101/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 17:15:34.511409306 +0200\n+++ /tmp/tmpytf21k6w.java\t2022-07-19 17:15:34.515409286 +0200\n@@ -428,13 +428,11 @@\n     WarningLevel wLevel = flags.warning_level;\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n-    }\n+if (options.process_primitives) {\n \n     initOptionsFromFlags(options);\n     return options;\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (options.remove_primitives) { options.closurePass = false; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-101/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 17:15:36.023400932 +0200\n+++ /tmp/tmpmh0zhk24.java\t2022-07-19 17:15:36.023400932 +0200\n@@ -428,13 +428,11 @@\n     WarningLevel wLevel = flags.warning_level;\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n-    }\n+if (options.remove_primitives) { options.closurePass = false; }\n \n     initOptionsFromFlags(options);\n     return options;\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (options.remove_primitives) { nopePass = false; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-101/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 17:15:37.771391250 +0200\n+++ /tmp/tmptgx3qq9t.java\t2022-07-19 17:15:37.771391250 +0200\n@@ -428,13 +428,11 @@\n     WarningLevel wLevel = flags.warning_level;\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n-    }\n+if (options.remove_primitives) { nopePass = false; }\n \n     initOptionsFromFlags(options);\n     return options;\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (flags.process_closure_primitives) { options.closurePass = true; }",
        "fixed_line": "options.closurePass = flags.process_closure_primitives;"
    },
    "JacksonXml-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "_rootNameLookup = src._rootNameLookup._rootNameLookup; // copy from '_next-is",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonXml-5/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 17:15:39.819379907 +0200\n+++ /tmp/tmpfx5sjaqa.java\t2022-07-19 17:15:39.847379751 +0200\n@@ -54,11 +54,11 @@\n      */\n     protected XmlSerializerProvider(XmlSerializerProvider src) {\n         super(src);\n         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n         //    root name lookup as that may link back to diff version, configuration\n-        _rootNameLookup = src._rootNameLookup;\n+_rootNameLookup = src._rootNameLookup._rootNameLookup; // copy from '_next-is\n     }\n \n     /*\n     /**********************************************************************\n     /* Overridden methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "_rootNameLookup = src._rootNameLookup._rootNameLookup; // copy from '_nextAfterNameLookup",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonXml-5/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 17:15:41.711369426 +0200\n+++ /tmp/tmpj_hqdamy.java\t2022-07-19 17:15:41.711369426 +0200\n@@ -54,11 +54,11 @@\n      */\n     protected XmlSerializerProvider(XmlSerializerProvider src) {\n         super(src);\n         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n         //    root name lookup as that may link back to diff version, configuration\n-        _rootNameLookup = src._rootNameLookup;\n+_rootNameLookup = src._rootNameLookup._rootNameLookup; // copy from '_nextAfterNameLookup\n     }\n \n     /*\n     /**********************************************************************\n     /* Overridden methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "_rootNameLookup = src._rootNameLookup; // copy from '_next-rootNameLookup",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonXml-5/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 17:15:43.411360007 +0200\n+++ /tmp/tmp8a35p5en.java\t2022-07-19 17:15:43.411360007 +0200\n@@ -54,11 +54,11 @@\n      */\n     protected XmlSerializerProvider(XmlSerializerProvider src) {\n         super(src);\n         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n         //    root name lookup as that may link back to diff version, configuration\n-        _rootNameLookup = src._rootNameLookup;\n+_rootNameLookup = src._rootNameLookup; // copy from '_next-rootNameLookup\n     }\n \n     /*\n     /**********************************************************************\n     /* Overridden methods\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "_rootNameLookup = src._rootNameLookup._rootNameLookup; // copy from '_next-rootNameLookup",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonXml-5/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 17:15:54.287299727 +0200\n+++ /tmp/tmpn4wgkib3.java\t2022-07-19 17:15:54.287299727 +0200\n@@ -54,11 +54,11 @@\n      */\n     protected XmlSerializerProvider(XmlSerializerProvider src) {\n         super(src);\n         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n         //    root name lookup as that may link back to diff version, configuration\n-        _rootNameLookup = src._rootNameLookup;\n+_rootNameLookup = src._rootNameLookup._rootNameLookup; // copy from '_next-rootNameLookup\n     }\n \n     /*\n     /**********************************************************************\n     /* Overridden methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "_rootNameLookup = src._rootNameLookup; // copy from '_nextAfterNameLookup",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonXml-5/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 17:15:56.031290055 +0200\n+++ /tmp/tmplp6u_4ee.java\t2022-07-19 17:15:56.031290055 +0200\n@@ -54,11 +54,11 @@\n      */\n     protected XmlSerializerProvider(XmlSerializerProvider src) {\n         super(src);\n         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n         //    root name lookup as that may link back to diff version, configuration\n-        _rootNameLookup = src._rootNameLookup;\n+_rootNameLookup = src._rootNameLookup; // copy from '_nextAfterNameLookup\n     }\n \n     /*\n     /**********************************************************************\n     /* Overridden methods\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "_rootNameLookup = src._rootNameLookup; // copy from '_next-rootNameLookup = src._rootNameLookup;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonXml-5/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 17:16:06.015234686 +0200\n+++ /tmp/tmp7n1sk0at.java\t2022-07-19 17:16:06.027234618 +0200\n@@ -54,11 +54,11 @@\n      */\n     protected XmlSerializerProvider(XmlSerializerProvider src) {\n         super(src);\n         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n         //    root name lookup as that may link back to diff version, configuration\n-        _rootNameLookup = src._rootNameLookup;\n+_rootNameLookup = src._rootNameLookup; // copy from '_next-rootNameLookup = src._rootNameLookup;\n     }\n \n     /*\n     /**********************************************************************\n     /* Overridden methods\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "_rootNameLookup = src._rootNameLookup; // copy from '_next-is",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonXml-5/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 17:16:16.035179085 +0200\n+++ /tmp/tmp8sbv_qk7.java\t2022-07-19 17:16:16.035179085 +0200\n@@ -54,11 +54,11 @@\n      */\n     protected XmlSerializerProvider(XmlSerializerProvider src) {\n         super(src);\n         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n         //    root name lookup as that may link back to diff version, configuration\n-        _rootNameLookup = src._rootNameLookup;\n+_rootNameLookup = src._rootNameLookup; // copy from '_next-is\n     }\n \n     /*\n     /**********************************************************************\n     /* Overridden methods\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "_rootNameLookup = src._rootNameLookup._rootNameLookup; // copy from '_nextAfterNameLookup = src._rootNameLookup;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonXml-5/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 17:16:25.935124121 +0200\n+++ /tmp/tmplu9qyeov.java\t2022-07-19 17:16:25.947124054 +0200\n@@ -54,11 +54,11 @@\n      */\n     protected XmlSerializerProvider(XmlSerializerProvider src) {\n         super(src);\n         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n         //    root name lookup as that may link back to diff version, configuration\n-        _rootNameLookup = src._rootNameLookup;\n+_rootNameLookup = src._rootNameLookup._rootNameLookup; // copy from '_nextAfterNameLookup = src._rootNameLookup;\n     }\n \n     /*\n     /**********************************************************************\n     /* Overridden methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "_rootNameLookup = src._rootNameLookup._rootNameLookup; // copy from '_next-empty to do a nameLookup",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonXml-5/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 17:16:27.615114792 +0200\n+++ /tmp/tmplxe3nw4d.java\t2022-07-19 17:16:27.619114769 +0200\n@@ -54,11 +54,11 @@\n      */\n     protected XmlSerializerProvider(XmlSerializerProvider src) {\n         super(src);\n         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n         //    root name lookup as that may link back to diff version, configuration\n-        _rootNameLookup = src._rootNameLookup;\n+_rootNameLookup = src._rootNameLookup._rootNameLookup; // copy from '_next-empty to do a nameLookup\n     }\n \n     /*\n     /**********************************************************************\n     /* Overridden methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "_rootNameLookup = src._rootNameLookup; // copy from '_next-empty to do a nameLookup",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonXml-5/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 17:16:29.275105572 +0200\n+++ /tmp/tmpfxid7vvu.java\t2022-07-19 17:16:29.279105548 +0200\n@@ -54,11 +54,11 @@\n      */\n     protected XmlSerializerProvider(XmlSerializerProvider src) {\n         super(src);\n         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n         //    root name lookup as that may link back to diff version, configuration\n-        _rootNameLookup = src._rootNameLookup;\n+_rootNameLookup = src._rootNameLookup; // copy from '_next-empty to do a nameLookup\n     }\n \n     /*\n     /**********************************************************************\n     /* Overridden methods\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "_rootNameLookup = src._rootNameLookup;",
        "fixed_line": "_rootNameLookup = new XmlRootNameLookup();"
    },
    "Closure-1": {
        "fixes": [
            {
                "k": 1,
                "patch": "// no no, then it's do implicit re-initialized or EMPTY",
                "patch_diff": "// no no, then it's do implicit re-initialized or EMPTY",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// if (function.getType() == Token.ASSIGN && NodeUtil.isFunction(function) {",
                "patch_diff": "// if (function.getType() == Token.ASSIGN && NodeUtil.isFunction(function) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if (function.getType() == Token.FUNCTION) {",
                "patch_diff": "// if (function.getType() == Token.FUNCTION) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// if (function.getType() == Token.ASSIGN && NodeUtil.isFunction(function)) {",
                "patch_diff": "// if (function.getType() == Token.ASSIGN && NodeUtil.isFunction(function)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// if (function.getType() == Token.ASSIGN) {",
                "patch_diff": "// if (function.getType() == Token.ASSIGN) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// no no, then it's do implicit re-parse",
                "patch_diff": "// no no, then it's do implicit re-parse",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// if (function.getType() == Token.ASSIGN && NodeUtil.isFunction(function.getRootNode())) {",
                "patch_diff": "// if (function.getType() == Token.ASSIGN && NodeUtil.isFunction(function.getRootNode())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// if (function.getType() == Token.ASSIGN && NodeUtil.isFunctionType(function)) {",
                "patch_diff": "// if (function.getType() == Token.ASSIGN && NodeUtil.isFunctionType(function)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// if (function.getType() == Token.ASSIGN && NodeUtil.isFunction(parent) {",
                "patch_diff": "// if (function.getType() == Token.ASSIGN && NodeUtil.isFunction(parent) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// no no, then it's do implicit re-initialized (NodeUtil.isFunctionType(function)) {",
                "patch_diff": "// no no, then it's do implicit re-initialized (NodeUtil.isFunctionType(function)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (!removeGlobals) { return; }"
    },
    "Time-15": {
        "fixes": [
            {
                "k": 1,
                "patch": "long val1 = val2; switch (val2) { case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1:",
                "patch_diff": "long val1 = val2; switch (val2) { case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1:",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "long val1 = val2; switch (val2) { case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1:",
                "patch_diff": "long val1 = val2; switch (val2) { case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1:",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "long val1 = val2; switch (val2) { case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1:",
                "patch_diff": "long val1 = val2; switch (val2) { case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1:",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "long val1 = val2; switch (val2) { case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1:",
                "patch_diff": "long val1 = val2; switch (val2) { case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1:",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "long val1 = val2; switch (val2) { case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1:",
                "patch_diff": "long val1 = val2; switch (val2) { case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1:",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "long val1 = val2; switch (val2) { case 0: return 0L; case 1: return 0L; case 1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1:",
                "patch_diff": "long val1 = val2; switch (val2) { case 0: return 0L; case 1: return 0L; case 1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1:",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "long val1 = val2; switch (val2) { case 0: return 0L; case 1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1:",
                "patch_diff": "long val1 = val2; switch (val2) { case 0: return 0L; case 1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1:",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "long val1 = val2; switch (val2) { case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case Integer.MAX_VALUE; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case",
                "patch_diff": "long val1 = val2; switch (val2) { case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case Integer.MAX_VALUE; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "long val1 = val2; switch (val2) { case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case Integer.MAX_VALUE; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case",
                "patch_diff": "long val1 = val2; switch (val2) { case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case Integer.MAX_VALUE; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "long val1 = val2; switch (val2) { case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case Integer.MAX_VALUE; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case",
                "patch_diff": "long val1 = val2; switch (val2) { case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case Integer.MAX_VALUE; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (val1 == Long.MIN_VALUE) { throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2); }"
    },
    "Closure-2": {
        "fixes": [
            {
                "k": 1,
                "patch": "// We can't really modify it was non-literal characters that might be null or EMPTY",
                "patch_diff": "// We can't really modify it was non-literal characters that might be null or EMPTY",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// We can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// We can't really modify it was non-literal characters that might be valid (e if it.",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (e if it.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// We can't really modify it was non-literal characters that might be valid (e if it's",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (e if it's",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// TODO: can't really modify it was non-literal characters that might be null or EMPTY",
                "patch_diff": "// TODO: can't really modify it was non-literal characters that might be null or EMPTY",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// TODO: can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "patch_diff": "// TODO: can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// TODO: can't really modify it was non-literal characters that might be valid (e if it.",
                "patch_diff": "// TODO: can't really modify it was non-literal characters that might be valid (e if it.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// TODO: can't really modify it was non-literal characters that might be valid (e if it's",
                "patch_diff": "// TODO: can't really modify it was non-literal characters that might be valid (e if it's",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// We can't really modify it was non-literal characters that might be valid (empty be // need to check",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (empty be // need to check",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// TODO: we didn't really modify it was non-literal characters that might be valid (toJsonNode)",
                "patch_diff": "// TODO: we didn't really modify it was non-literal characters that might be valid (toJsonNode)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (implicitProto == null) { // This can be the case if interfaceType is proxy to a non-existent // object (which is a bad type annotation, but shouldn't crash). currentPropertyNames = ImmutableSet.of(); } else { currentPropertyNames = implicitProto.getOwnPropertyNames(); }"
    },
    "Math-67": {
        "fixes": [
            {
                "k": 1,
                "patch": "return all.getFunctionValue(); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-67/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\t2022-07-19 17:16:45.231016913 +0200\n+++ /tmp/tmpnxx04pua.java\t2022-07-19 17:16:45.259016759 +0200\n@@ -87,16 +87,11 @@\n         setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getResult() {\n-        return optimizer.getResult();\n+return all.getFunctionValue(); }\n     }\n \n     /** {@inheritDoc} */\n     public double getAbsoluteAccuracy() {\n         return optimizer.getAbsoluteAccuracy();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return namespaces.getFunctionValue(); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-67/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\t2022-07-19 17:16:47.519004196 +0200\n+++ /tmp/tmp5cx4v85c.java\t2022-07-19 17:16:47.519004196 +0200\n@@ -87,16 +87,11 @@\n         setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getResult() {\n-        return optimizer.getResult();\n+return namespaces.getFunctionValue(); }\n     }\n \n     /** {@inheritDoc} */\n     public double getAbsoluteAccuracy() {\n         return optimizer.getAbsoluteAccuracy();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return value.getFunctionValue(); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-67/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\t2022-07-19 17:16:49.510993119 +0200\n+++ /tmp/tmpowc326uf.java\t2022-07-19 17:16:49.510993119 +0200\n@@ -87,16 +87,11 @@\n         setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getResult() {\n-        return optimizer.getResult();\n+return value.getFunctionValue(); }\n     }\n \n     /** {@inheritDoc} */\n     public double getAbsoluteAccuracy() {\n         return optimizer.getAbsoluteAccuracy();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return functionScope.getFunctionValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-67/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\t2022-07-19 17:16:51.490982111 +0200\n+++ /tmp/tmp8jq0g2tr.java\t2022-07-19 17:16:51.490982111 +0200\n@@ -87,16 +87,11 @@\n         setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getResult() {\n-        return optimizer.getResult();\n+return functionScope.getFunctionValue();\n     }\n \n     /** {@inheritDoc} */\n     public double getAbsoluteAccuracy() {\n         return optimizer.getAbsoluteAccuracy();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return MILLISECONDS.getFunctionValue(); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-67/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\t2022-07-19 17:16:53.618970278 +0200\n+++ /tmp/tmp31d6yhya.java\t2022-07-19 17:16:53.622970259 +0200\n@@ -87,16 +87,11 @@\n         setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getResult() {\n-        return optimizer.getResult();\n+return MILLISECONDS.getFunctionValue(); }\n     }\n \n     /** {@inheritDoc} */\n     public double getAbsoluteAccuracy() {\n         return optimizer.getAbsoluteAccuracy();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return root.getFunctionValue(); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-67/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\t2022-07-19 17:16:55.694958733 +0200\n+++ /tmp/tmppvrwxvo7.java\t2022-07-19 17:16:55.698958713 +0200\n@@ -87,16 +87,11 @@\n         setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getResult() {\n-        return optimizer.getResult();\n+return root.getFunctionValue(); }\n     }\n \n     /** {@inheritDoc} */\n     public double getAbsoluteAccuracy() {\n         return optimizer.getAbsoluteAccuracy();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "returnapply.getFunctionValue(); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-67/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\t2022-07-19 17:16:57.754947276 +0200\n+++ /tmp/tmpistmhir3.java\t2022-07-19 17:16:57.758947257 +0200\n@@ -87,16 +87,11 @@\n         setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getResult() {\n-        return optimizer.getResult();\n+returnapply.getFunctionValue(); }\n     }\n \n     /** {@inheritDoc} */\n     public double getAbsoluteAccuracy() {\n         return optimizer.getAbsoluteAccuracy();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return data.getFunctionValue(); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-67/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\t2022-07-19 17:16:59.786935976 +0200\n+++ /tmp/tmp7002x19y.java\t2022-07-19 17:16:59.790935952 +0200\n@@ -87,16 +87,11 @@\n         setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getResult() {\n-        return optimizer.getResult();\n+return data.getFunctionValue(); }\n     }\n \n     /** {@inheritDoc} */\n     public double getAbsoluteAccuracy() {\n         return optimizer.getAbsoluteAccuracy();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return optimizer.getFunctionValue(); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-67/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\t2022-07-19 17:17:01.778924895 +0200\n+++ /tmp/tmp5t7oczay.java\t2022-07-19 17:17:01.782924871 +0200\n@@ -87,16 +87,11 @@\n         setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getResult() {\n-        return optimizer.getResult();\n+return optimizer.getFunctionValue(); }\n     }\n \n     /** {@inheritDoc} */\n     public double getAbsoluteAccuracy() {\n         return optimizer.getAbsoluteAccuracy();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return all.getFunctionValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-67/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\t2022-07-19 17:17:03.790913700 +0200\n+++ /tmp/tmp8s0rgrh6.java\t2022-07-19 17:17:03.790913700 +0200\n@@ -87,16 +87,11 @@\n         setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getResult() {\n-        return optimizer.getResult();\n+return all.getFunctionValue();\n     }\n \n     /** {@inheritDoc} */\n     public double getAbsoluteAccuracy() {\n         return optimizer.getAbsoluteAccuracy();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return optimizer.getFunctionValue(); } /** {@inheritDoc} */ public double getResult() { return optimizer.getResult();",
        "fixed_line": "return optimaValues[0]; } /** {@inheritDoc} */ public double getResult() { return optima[0];"
    },
    "JxPath-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 + p2.parent)\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-5/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\t2022-07-19 17:17:06.174900439 +0200\n+++ /tmp/tmpa89vpyyv.java\t2022-07-19 17:17:06.214900213 +0200\n@@ -660,13 +660,11 @@\n         if (p1 != null && p1.equals(p2)) {\n             return 0;\n         }\n \n         if (depth1 == 1) {\n-            throw new JXPathException(\n-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n-                            + p1 + \"' and '\" + p2 + \"'\");\n+throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 + p2.parent)\");\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n             return r;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"'\"+ and '\" + p2 + p2.parent)\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-5/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\t2022-07-19 17:17:08.318888507 +0200\n+++ /tmp/tmpx0ge9fvs.java\t2022-07-19 17:17:08.318888507 +0200\n@@ -660,13 +660,11 @@\n         if (p1 != null && p1.equals(p2)) {\n             return 0;\n         }\n \n         if (depth1 == 1) {\n-            throw new JXPathException(\n-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n-                            + p1 + \"' and '\" + p2 + \"'\");\n+throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"'\"+ and '\" + p2 + p2.parent)\");\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n             return r;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"'Vars '\" + p2 + \"'\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-5/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\t2022-07-19 17:17:10.078878712 +0200\n+++ /tmp/tmpwafeq3tt.java\t2022-07-19 17:17:10.078878712 +0200\n@@ -660,13 +660,11 @@\n         if (p1 != null && p1.equals(p2)) {\n             return 0;\n         }\n \n         if (depth1 == 1) {\n-            throw new JXPathException(\n-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n-                            + p1 + \"' and '\" + p2 + \"'\");\n+throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"'Vars '\" + p2 + \"'\");\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n             return r;\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p2 + \"' and '\" + p2.parent)\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-5/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\t2022-07-19 17:17:14.942851640 +0200\n+++ /tmp/tmpnk9qcriz.java\t2022-07-19 17:17:14.942851640 +0200\n@@ -660,13 +660,11 @@\n         if (p1 != null && p1.equals(p2)) {\n             return 0;\n         }\n \n         if (depth1 == 1) {\n-            throw new JXPathException(\n-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n-                            + p1 + \"' and '\" + p2 + \"'\");\n+throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p2 + \"' and '\" + p2.parent)\");\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n             return r;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"'base '\" + p2 + \"'\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-5/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\t2022-07-19 17:17:16.622842291 +0200\n+++ /tmp/tmplc_xbvz2.java\t2022-07-19 17:17:16.622842291 +0200\n@@ -660,13 +660,11 @@\n         if (p1 != null && p1.equals(p2)) {\n             return 0;\n         }\n \n         if (depth1 == 1) {\n-            throw new JXPathException(\n-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n-                            + p1 + \"' and '\" + p2 + \"'\");\n+throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"'base '\" + p2 + \"'\");\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n             return r;\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-5/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\t2022-07-19 17:17:21.094817395 +0200\n+++ /tmp/tmpww3cvqkd.java\t2022-07-19 17:17:21.094817395 +0200\n@@ -660,13 +660,11 @@\n         if (p1 != null && p1.equals(p2)) {\n             return 0;\n         }\n \n         if (depth1 == 1) {\n-            throw new JXPathException(\n-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n-                            + p1 + \"' and '\" + p2 + \"'\");\n+throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' {\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n             return r;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 + \"'\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-5/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\t2022-07-19 17:17:22.810807840 +0200\n+++ /tmp/tmpt25ooq6m.java\t2022-07-19 17:17:22.810807840 +0200\n@@ -660,13 +660,11 @@\n         if (p1 != null && p1.equals(p2)) {\n             return 0;\n         }\n \n         if (depth1 == 1) {\n-            throw new JXPathException(\n-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n-                            + p1 + \"' and '\" + p2 + \"'\");\n+throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 + \"'\");\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n             return r;\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"'\"+ and '\" + p2 + \"'\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-5/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\t2022-07-19 17:17:27.310782780 +0200\n+++ /tmp/tmpt4lr7ard.java\t2022-07-19 17:17:27.310782780 +0200\n@@ -660,13 +660,11 @@\n         if (p1 != null && p1.equals(p2)) {\n             return 0;\n         }\n \n         if (depth1 == 1) {\n-            throw new JXPathException(\n-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n-                            + p1 + \"' and '\" + p2 + \"'\");\n+throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"'\"+ and '\" + p2 + \"'\");\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n             return r;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p2 + \"' and '\" + p1 + \"'\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-5/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\t2022-07-19 17:17:29.030773200 +0200\n+++ /tmp/tmpwpz8fjaj.java\t2022-07-19 17:17:29.030773200 +0200\n@@ -660,13 +660,11 @@\n         if (p1 != null && p1.equals(p2)) {\n             return 0;\n         }\n \n         if (depth1 == 1) {\n-            throw new JXPathException(\n-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n-                            + p1 + \"' and '\" + p2 + \"'\");\n+throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p2 + \"' and '\" + p1 + \"'\");\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n             return r;\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 - \"'\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-5/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\t2022-07-19 17:17:33.318749311 +0200\n+++ /tmp/tmpnwa_qobs.java\t2022-07-19 17:17:33.318749311 +0200\n@@ -660,13 +660,11 @@\n         if (p1 != null && p1.equals(p2)) {\n             return 0;\n         }\n \n         if (depth1 == 1) {\n-            throw new JXPathException(\n-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n-                            + p1 + \"' and '\" + p2 + \"'\");\n+throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 - \"'\");\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n             return r;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 + \"'\");",
        "fixed_line": "return 0;"
    },
    "JacksonDatabind-86": {
        "fixes": [
            {
                "k": 1,
                "patch": "throw new IllegalStateException(\"Trying to re-set self for \"+_referencedType+\", new = _referencedType;",
                "patch_diff": "throw new IllegalStateException(\"Trying to re-set self for \"+_referencedType+\", new = _referencedType;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "throw new IllegalStateException(\"Trying to re-set self reference: \"+_referencedType+\", new = _referencedType;",
                "patch_diff": "throw new IllegalStateException(\"Trying to re-set self reference: \"+_referencedType+\", new = _referencedType;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "throw new IllegalStateException(\"Trying to re-set self reference: \"+_referencedType+\", new = _referencedType; }",
                "patch_diff": "throw new IllegalStateException(\"Trying to re-set self reference: \"+_referencedType+\", new = _referencedType; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new IllegalStateException(\"Trying to re-set self for \"+_referencedType+\", new = _referencedType; }",
                "patch_diff": "throw new IllegalStateException(\"Trying to re-set self for \"+_referencedType+\", new = _referencedType; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "throw new IllegalStateException(\"Trying to re-set self-set selfType+\", new = _referencedType;",
                "patch_diff": "throw new IllegalStateException(\"Trying to re-set self-set selfType+\", new = _referencedType;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = _referencedType; i < len; ++i) { if (referencedType == null) { sb.append(\"Trying to re-set self reference\"); } sb.append(\"Trying to re-set self reference\"); } sb = _referencedType; } }",
                "patch_diff": "for (int i = _referencedType; i < len; ++i) { if (referencedType == null) { sb.append(\"Trying to re-set self reference\"); } sb.append(\"Trying to re-set self reference\"); } sb = _referencedType; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "throw new IllegalStateException(\"Trying to re-set self for \"+_referencedType+\", new = \"+ref); }",
                "patch_diff": "throw new IllegalStateException(\"Trying to re-set self for \"+_referencedType+\", new = \"+ref); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = _referencedType; i < len; ++i) { if (referencedType == null) { sb.append(\"Trying to re-set self reference\"); } sb.append(\"Trying to re-set self reference\"); } }",
                "patch_diff": "for (int i = _referencedType; i < len; ++i) { if (referencedType == null) { sb.append(\"Trying to re-set self reference\"); } sb.append(\"Trying to re-set self reference\"); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int i = _referencedType; i < len; ++i) { if (referencedType == null) { sb.append(\"Trying to re-set self reference\"); } sb.append(\"Trying to re-set self\"); } sb = _referencedType; } }",
                "patch_diff": "for (int i = _referencedType; i < len; ++i) { if (referencedType == null) { sb.append(\"Trying to re-set self reference\"); } sb.append(\"Trying to re-set self\"); } sb = _referencedType; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "throw new IllegalStateException(\"Trying to re-set self reference; old value = _referencedType;",
                "patch_diff": "throw new IllegalStateException(\"Trying to re-set self reference; old value = _referencedType;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "@Override public JavaType getSuperClass() { if (_referencedType != null) { return _referencedType.getSuperClass(); } return super.getSuperClass(); }"
    },
    "Math-79": {
        "fixes": [
            {
                "k": 1,
                "patch": "int sum = 0; for (int i = 0; i < p1.length; i++) { return 0;i < p2[i];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-79/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 17:17:37.306727097 +0200\n+++ /tmp/tmpv789h35p.java\t2022-07-19 17:17:37.326726984 +0200\n@@ -1619,13 +1619,11 @@\n      * @param p1 the first point\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+int sum = 0; for (int i = 0; i < p1.length; i++) { return 0;i < p2[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int sum = 0; for (int i = 0; i < p1.length; i++) { return 0;i < p1[i];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-79/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 17:17:40.022711961 +0200\n+++ /tmp/tmptkfdlkr6.java\t2022-07-19 17:17:40.022711961 +0200\n@@ -1619,13 +1619,11 @@\n      * @param p1 the first point\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+int sum = 0; for (int i = 0; i < p1.length; i++) { return 0;i < p1[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p1[i];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-79/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 17:17:42.022700815 +0200\n+++ /tmp/tmp_z9dwai6.java\t2022-07-19 17:17:42.022700815 +0200\n@@ -1619,13 +1619,11 @@\n      * @param p1 the first point\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+int sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p1[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p2[i];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-79/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 17:17:50.674652586 +0200\n+++ /tmp/tmphfxvk33x.java\t2022-07-19 17:17:50.674652586 +0200\n@@ -1619,13 +1619,11 @@\n      * @param p1 the first point\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+int sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p2[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int sum = 0;_int i < p1.length; i++) { final int dp = p1[i];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-79/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 17:17:59.306604453 +0200\n+++ /tmp/tmpkzn_6mqx.java\t2022-07-19 17:17:59.346604233 +0200\n@@ -1619,13 +1619,11 @@\n      * @param p1 the first point\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+int sum = 0;_int i < p1.length; i++) { final int dp = p1[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int sum = 0; if (p1.length - p2.length; i++) { final int dp = p1[i];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-79/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 17:18:02.010589374 +0200\n+++ /tmp/tmpn839xq_o.java\t2022-07-19 17:18:02.014589349 +0200\n@@ -1619,13 +1619,11 @@\n      * @param p1 the first point\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+int sum = 0; if (p1.length - p2.length; i++) { final int dp = p1[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int sum = 0;_int i < p1.length; i++) { final int dp = p2[i];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-79/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 17:18:05.286571100 +0200\n+++ /tmp/tmpsfjl85wz.java\t2022-07-19 17:18:05.286571100 +0200\n@@ -1619,13 +1619,11 @@\n      * @param p1 the first point\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+int sum = 0;_int i < p1.length; i++) { final int dp = p2[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int sum = 0; for (int i < p1.length; i++) { return 0;i < p2[i];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-79/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 17:18:08.066555591 +0200\n+++ /tmp/tmp_v1hdg33.java\t2022-07-19 17:18:08.066555591 +0200\n@@ -1619,13 +1619,11 @@\n      * @param p1 the first point\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+int sum = 0; for (int i < p1.length; i++) { return 0;i < p2[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int sum = 0; for (int i < p1.length; i++) { return 0;i < p1[i];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-79/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 17:18:10.950539500 +0200\n+++ /tmp/tmp9i3ah69r.java\t2022-07-19 17:18:10.990539276 +0200\n@@ -1619,13 +1619,11 @@\n      * @param p1 the first point\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+int sum = 0; for (int i < p1.length; i++) { return 0;i < p1[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int sum = 0; for (int i < p1.length; i++) { final int dp = p1[i];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-79/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 17:18:13.918522938 +0200\n+++ /tmp/tmpkumquzer.java\t2022-07-19 17:18:13.918522938 +0200\n@@ -1619,13 +1619,11 @@\n      * @param p1 the first point\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+int sum = 0; for (int i < p1.length; i++) { final int dp = p1[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "int sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p1[i] - p2[i];",
        "fixed_line": "double sum = 0; for (int i = 0; i < p1.length; i++) { final double dp = p1[i] - p2[i];"
    },
    "Closure-114": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (parent) record.onlyAffectsClassDef) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 17:18:16.846506595 +0200\n+++ /tmp/tmptplv0gmj.java\t2022-07-19 17:18:17.702501821 +0200\n@@ -573,11 +573,11 @@\n           if (parent.getFirstChild().getNext() != n) {\n             recordDepScope(recordNode, ns);\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+} else if (parent) record.onlyAffectsClassDef) {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n           // caller expression, but it could be nested deeper in the caller and\n           // we would still get a bug.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (recordFunction) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 17:18:25.090460579 +0200\n+++ /tmp/tmpq164x2of.java\t2022-07-19 17:18:25.094460556 +0200\n@@ -573,11 +573,11 @@\n           if (parent.getFirstChild().getNext() != n) {\n             recordDepScope(recordNode, ns);\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+} else if (recordFunction) {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n           // caller expression, but it could be nested deeper in the caller and\n           // we would still get a bug.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (recordDepScope) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 17:18:30.882428235 +0200\n+++ /tmp/tmpyx7hhkvh.java\t2022-07-19 17:18:30.882428235 +0200\n@@ -573,11 +573,11 @@\n           if (parent.getFirstChild().getNext() != n) {\n             recordDepScope(recordNode, ns);\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+} else if (recordDepScope) {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n           // caller expression, but it could be nested deeper in the caller and\n           // we would still get a bug.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (elseHasSideEffects) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 17:18:35.910400157 +0200\n+++ /tmp/tmpmcxf23jf.java\t2022-07-19 17:18:35.914400132 +0200\n@@ -573,11 +573,11 @@\n           if (parent.getFirstChild().getNext() != n) {\n             recordDepScope(recordNode, ns);\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+} else if (elseHasSideEffects) {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n           // caller expression, but it could be nested deeper in the caller and\n           // we would still get a bug.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (parent) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 17:18:41.178370730 +0200\n+++ /tmp/tmpovhjd5nr.java\t2022-07-19 17:18:41.178370730 +0200\n@@ -573,11 +573,11 @@\n           if (parent.getFirstChild().getNext() != n) {\n             recordDepScope(recordNode, ns);\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+} else if (parent) {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n           // caller expression, but it could be nested deeper in the caller and\n           // we would still get a bug.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (recordParent) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 17:18:46.586340515 +0200\n+++ /tmp/tmpe8fjoqa4.java\t2022-07-19 17:18:46.586340515 +0200\n@@ -573,11 +573,11 @@\n           if (parent.getFirstChild().getNext() != n) {\n             recordDepScope(recordNode, ns);\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+} else if (recordParent) {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n           // caller expression, but it could be nested deeper in the caller and\n           // we would still get a bug.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (recordInfo) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 17:18:52.118309599 +0200\n+++ /tmp/tmpo_nk_pwj.java\t2022-07-19 17:18:52.118309599 +0200\n@@ -573,11 +573,11 @@\n           if (parent.getFirstChild().getNext() != n) {\n             recordDepScope(recordNode, ns);\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+} else if (recordInfo) {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n           // caller expression, but it could be nested deeper in the caller and\n           // we would still get a bug.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (recordOnly) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 17:18:58.470293486 +0200\n+++ /tmp/tmpbdvf5yi6.java\t2022-07-19 17:18:58.474293477 +0200\n@@ -573,11 +573,11 @@\n           if (parent.getFirstChild().getNext() != n) {\n             recordDepScope(recordNode, ns);\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+} else if (recordOnly) {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n           // caller expression, but it could be nested deeper in the caller and\n           // we would still get a bug.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (recordNode) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 17:19:03.442282772 +0200\n+++ /tmp/tmp_3ig7z7i.java\t2022-07-19 17:19:03.446282763 +0200\n@@ -573,11 +573,11 @@\n           if (parent.getFirstChild().getNext() != n) {\n             recordDepScope(recordNode, ns);\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+} else if (recordNode) {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n           // caller expression, but it could be nested deeper in the caller and\n           // we would still get a bug.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (elseHasScope) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 17:19:09.198270184 +0200\n+++ /tmp/tmpaa6w6_bg.java\t2022-07-19 17:19:09.198270184 +0200\n@@ -573,11 +573,11 @@\n           if (parent.getFirstChild().getNext() != n) {\n             recordDepScope(recordNode, ns);\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+} else if (elseHasScope) {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n           // caller expression, but it could be nested deeper in the caller and\n           // we would still get a bug.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "} else {",
        "fixed_line": "} else if (!(parent.isCall() && parent.getFirstChild() == n)) {"
    },
    "JacksonDatabind-70": {
        "fixes": [
            {
                "k": 1,
                "patch": "found = ctor_TYPE.equals(prop.getName());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-70/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\t2022-07-19 17:19:14.630258121 +0200\n+++ /tmp/tmpbd0g5ly6.java\t2022-07-19 17:19:14.846257641 +0200\n@@ -435,11 +435,11 @@\n                 continue;\n             }\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+found = ctor_TYPE.equals(prop.getName());\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n                     continue;\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "found = t.equals(prop.getName());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-70/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\t2022-07-19 17:19:18.126250280 +0200\n+++ /tmp/tmpxx533xeu.java\t2022-07-19 17:19:18.130250271 +0200\n@@ -435,11 +435,11 @@\n                 continue;\n             }\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+found = t.equals(prop.getName());\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n                     continue;\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "found = NULL.equals(prop.getName());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-70/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\t2022-07-19 17:19:21.070243620 +0200\n+++ /tmp/tmpa_hiez6w.java\t2022-07-19 17:19:21.074243611 +0200\n@@ -435,11 +435,11 @@\n                 continue;\n             }\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+found = NULL.equals(prop.getName());\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n                     continue;\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "found = _props.equals(prop.getName());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-70/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\t2022-07-19 17:19:23.146238893 +0200\n+++ /tmp/tmpvhr3mmov.java\t2022-07-19 17:19:23.146238893 +0200\n@@ -435,11 +435,11 @@\n                 continue;\n             }\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+found = _props.equals(prop.getName());\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n                     continue;\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "found = ctor_TYPE.equals(key.getName());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-70/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\t2022-07-19 17:19:25.906232574 +0200\n+++ /tmp/tmp05eohldi.java\t2022-07-19 17:19:25.906232574 +0200\n@@ -435,11 +435,11 @@\n                 continue;\n             }\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+found = ctor_TYPE.equals(key.getName());\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n                     continue;\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "found = reference.equals(prop.getName());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-70/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\t2022-07-19 17:19:29.014225407 +0200\n+++ /tmp/tmp8m_dvzw6.java\t2022-07-19 17:19:29.086225234 +0200\n@@ -435,11 +435,11 @@\n                 continue;\n             }\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+found = reference.equals(prop.getName());\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n                     continue;\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "found = ctor_NOT_EMPTY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-70/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\t2022-07-19 17:19:31.386219900 +0200\n+++ /tmp/tmp3_iktlfx.java\t2022-07-19 17:19:31.386219900 +0200\n@@ -435,11 +435,11 @@\n                 continue;\n             }\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+found = ctor_NOT_EMPTY;\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n                     continue;\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "found =ClassType.equals(prop.getName());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-70/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\t2022-07-19 17:19:33.166215751 +0200\n+++ /tmp/tmp2u51s8gk.java\t2022-07-19 17:19:33.166215751 +0200\n@@ -435,11 +435,11 @@\n                 continue;\n             }\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+found =ClassType.equals(prop.getName());\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n                     continue;\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "found = slot.equals(key.getName());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-70/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\t2022-07-19 17:19:35.210210962 +0200\n+++ /tmp/tmpujka87es.java\t2022-07-19 17:19:35.210210962 +0200\n@@ -435,11 +435,11 @@\n                 continue;\n             }\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+found = slot.equals(key.getName());\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n                     continue;\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "found = t.equals(key.getName());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-70/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\t2022-07-19 17:19:37.166206358 +0200\n+++ /tmp/tmpsox_vkcd.java\t2022-07-19 17:19:37.166206358 +0200\n@@ -435,11 +435,11 @@\n                 continue;\n             }\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+found = t.equals(key.getName());\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n                     continue;\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "found = key.equals(prop.getName());",
        "fixed_line": "found = key.equals(_hashArea[i-1]);"
    },
    "Lang-57": {
        "fixes": [
            {
                "k": 1,
                "patch": "return cAvailableLocaleSet.containsNoLocaleSet.contains(\"\\LocaleSet.contains(locale;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-57/src/java/org/apache/commons/lang/LocaleUtils.java\t2022-07-19 17:19:39.294201326 +0200\n+++ /tmp/tmpyxpiynl7.java\t2022-07-19 17:19:39.406201057 +0200\n@@ -218,11 +218,11 @@\n      *\n      * @param locale the Locale object to check if it is available\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+return cAvailableLocaleSet.containsNoLocaleSet.contains(\"\\LocaleSet.contains(locale;\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Obtains the list of languages supported for a given country.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return cAvailableLocaleSet.contains(\"\\LocaleSet.contains(\"\\LocaleSet.contains(locale;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-57/src/java/org/apache/commons/lang/LocaleUtils.java\t2022-07-19 17:19:41.586195878 +0200\n+++ /tmp/tmp61kem57v.java\t2022-07-19 17:19:41.586195878 +0200\n@@ -218,11 +218,11 @@\n      *\n      * @param locale the Locale object to check if it is available\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+return cAvailableLocaleSet.contains(\"\\LocaleSet.contains(\"\\LocaleSet.contains(locale;\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Obtains the list of languages supported for a given country.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return cAvailableLocaleSet.containsNoLocaleSet.contains(locale;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-57/src/java/org/apache/commons/lang/LocaleUtils.java\t2022-07-19 17:19:43.122192212 +0200\n+++ /tmp/tmpee3lvte4.java\t2022-07-19 17:19:43.122192212 +0200\n@@ -218,11 +218,11 @@\n      *\n      * @param locale the Locale object to check if it is available\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+return cAvailableLocaleSet.containsNoLocaleSet.contains(locale;\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Obtains the list of languages supported for a given country.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return cAvailableLocaleSet.contains(\"\\LocaleSet.contains(locale;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-57/src/java/org/apache/commons/lang/LocaleUtils.java\t2022-07-19 17:19:44.690188455 +0200\n+++ /tmp/tmph0ojrwnd.java\t2022-07-19 17:19:44.694188443 +0200\n@@ -218,11 +218,11 @@\n      *\n      * @param locale the Locale object to check if it is available\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+return cAvailableLocaleSet.contains(\"\\LocaleSet.contains(locale;\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Obtains the list of languages supported for a given country.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return cAvailableLocaleSet.contains(\"\\LocaleSet.containsNoLocaleSet.contains(locale;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-57/src/java/org/apache/commons/lang/LocaleUtils.java\t2022-07-19 17:19:46.262184674 +0200\n+++ /tmp/tmp43bfv1w8.java\t2022-07-19 17:19:46.262184674 +0200\n@@ -218,11 +218,11 @@\n      *\n      * @param locale the Locale object to check if it is available\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+return cAvailableLocaleSet.contains(\"\\LocaleSet.containsNoLocaleSet.contains(locale;\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Obtains the list of languages supported for a given country.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return cAvailableLocaleSet.containsNoLocaleSet.contains(\"\\LocaleSet.contains(locale);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-57/src/java/org/apache/commons/lang/LocaleUtils.java\t2022-07-19 17:19:48.118180199 +0200\n+++ /tmp/tmpehiy1f2l.java\t2022-07-19 17:19:48.122180186 +0200\n@@ -218,11 +218,11 @@\n      *\n      * @param locale the Locale object to check if it is available\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+return cAvailableLocaleSet.containsNoLocaleSet.contains(\"\\LocaleSet.contains(locale);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Obtains the list of languages supported for a given country.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return cAvailableLocaleSet.contains(\"\\LocaleSet.contains(\"\\LocaleSet.contains(locale);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-57/src/java/org/apache/commons/lang/LocaleUtils.java\t2022-07-19 17:19:49.786176157 +0200\n+++ /tmp/tmp2rjcwhoj.java\t2022-07-19 17:19:49.786176157 +0200\n@@ -218,11 +218,11 @@\n      *\n      * @param locale the Locale object to check if it is available\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+return cAvailableLocaleSet.contains(\"\\LocaleSet.contains(\"\\LocaleSet.contains(locale);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Obtains the list of languages supported for a given country.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return cAvailableLocaleSet.containsNoLocaleSet.contains(locale);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-57/src/java/org/apache/commons/lang/LocaleUtils.java\t2022-07-19 17:19:51.590171769 +0200\n+++ /tmp/tmpb8s30ih_.java\t2022-07-19 17:19:51.590171769 +0200\n@@ -218,11 +218,11 @@\n      *\n      * @param locale the Locale object to check if it is available\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+return cAvailableLocaleSet.containsNoLocaleSet.contains(locale);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Obtains the list of languages supported for a given country.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return cAvailableLocaleSet.containsNoLocaleSet.containsNoLocaleSet.contains(locale;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-57/src/java/org/apache/commons/lang/LocaleUtils.java\t2022-07-19 17:19:53.346167482 +0200\n+++ /tmp/tmpnkzl_c8a.java\t2022-07-19 17:19:53.346167482 +0200\n@@ -218,11 +218,11 @@\n      *\n      * @param locale the Locale object to check if it is available\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+return cAvailableLocaleSet.containsNoLocaleSet.containsNoLocaleSet.contains(locale;\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Obtains the list of languages supported for a given country.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return cAvailableLocaleSet.contains(\"\\LocaleSet.contains(locale);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-57/src/java/org/apache/commons/lang/LocaleUtils.java\t2022-07-19 17:19:54.942163551 +0200\n+++ /tmp/tmpo505hayt.java\t2022-07-19 17:19:54.942163551 +0200\n@@ -218,11 +218,11 @@\n      *\n      * @param locale the Locale object to check if it is available\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+return cAvailableLocaleSet.contains(\"\\LocaleSet.contains(locale);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Obtains the list of languages supported for a given country.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return cAvailableLocaleSet.contains(locale);",
        "fixed_line": "return availableLocaleList().contains(locale);"
    },
    "JacksonDatabind-27": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (externsPropertyValue(jp, ctxt, propName, buffer) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-27/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 17:19:56.646159314 +0200\n+++ /tmp/tmpvwqv2pkd.java\t2022-07-19 17:19:56.706159160 +0200\n@@ -789,11 +789,11 @@\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+if (externsPropertyValue(jp, ctxt, propName, buffer) {\n                     ;\n                 } else {\n                     // Last creator property to set?\n                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                         t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (externsRoot.handlePropertyValue(jp, ctxt, propName, buffer)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-27/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 17:19:58.726154120 +0200\n+++ /tmp/tmppjs5dgdp.java\t2022-07-19 17:19:58.726154120 +0200\n@@ -789,11 +789,11 @@\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+if (externsRoot.handlePropertyValue(jp, ctxt, propName, buffer)) {\n                     ;\n                 } else {\n                     // Last creator property to set?\n                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                         t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (ext.handlePropertyValue(jp, ctxt, propName, buffer) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-27/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 17:20:00.942148561 +0200\n+++ /tmp/tmpymik54uh.java\t2022-07-19 17:20:00.942148561 +0200\n@@ -789,11 +789,11 @@\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+if (ext.handlePropertyValue(jp, ctxt, propName, buffer) {\n                     ;\n                 } else {\n                     // Last creator property to set?\n                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                         t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (externsPropertyValue(jp, ctxt, propName, buffer)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-27/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 17:20:02.618144341 +0200\n+++ /tmp/tmp_b3172eu.java\t2022-07-19 17:20:02.618144341 +0200\n@@ -789,11 +789,11 @@\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+if (externsPropertyValue(jp, ctxt, propName, buffer)) {\n                     ;\n                 } else {\n                     // Last creator property to set?\n                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                         t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (ext.handlePropertyValue(jp, ctxt, propName, buffer, propName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-27/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 17:20:04.558139438 +0200\n+++ /tmp/tmpvyxn03cq.java\t2022-07-19 17:20:04.562139428 +0200\n@@ -789,11 +789,11 @@\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+if (ext.handlePropertyValue(jp, ctxt, propName, buffer, propName);\n                     ;\n                 } else {\n                     // Last creator property to set?\n                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                         t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (externsPropertyValue(jp, ctxt, propName, buffer, propName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-27/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 17:20:06.226135205 +0200\n+++ /tmp/tmpfeayaqmh.java\t2022-07-19 17:20:06.226135205 +0200\n@@ -789,11 +789,11 @@\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+if (externsPropertyValue(jp, ctxt, propName, buffer, propName);\n                     ;\n                 } else {\n                     // Last creator property to set?\n                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                         t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (ext.handlePropertyValue(jp, ctxt, propName, buffer)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-27/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 17:20:07.778131258 +0200\n+++ /tmp/tmpzpdqyc_s.java\t2022-07-19 17:20:07.778131258 +0200\n@@ -789,11 +789,11 @@\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+if (ext.handlePropertyValue(jp, ctxt, propName, buffer)) {\n                     ;\n                 } else {\n                     // Last creator property to set?\n                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                         t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (ext.handlePropertyValue(jp, ctxt, propName, bean);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-27/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 17:20:09.674126418 +0200\n+++ /tmp/tmpv1sx13lf.java\t2022-07-19 17:20:09.678126407 +0200\n@@ -789,11 +789,11 @@\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+if (ext.handlePropertyValue(jp, ctxt, propName, bean);\n                     ;\n                 } else {\n                     // Last creator property to set?\n                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                         t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (externsRoot.handlePropertyValue(jp, ctxt, propName, buffer) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-27/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 17:20:11.322122195 +0200\n+++ /tmp/tmpzxxujflp.java\t2022-07-19 17:20:11.326122183 +0200\n@@ -789,11 +789,11 @@\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+if (externsRoot.handlePropertyValue(jp, ctxt, propName, buffer) {\n                     ;\n                 } else {\n                     // Last creator property to set?\n                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                         t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (ext.handlePropertyValue(jp, ctxt, propName, buffer);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-27/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 17:20:13.030117805 +0200\n+++ /tmp/tmp046ckv3a.java\t2022-07-19 17:20:13.030117805 +0200\n@@ -789,11 +789,11 @@\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+if (ext.handlePropertyValue(jp, ctxt, propName, buffer);\n                     ;\n                 } else {\n                     // Last creator property to set?\n                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                         t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {",
        "fixed_line": "if (ext.handlePropertyValue(p, ctxt, propName, null)) {"
    },
    "Mockito-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "return Token.ASSIGN_PROTOTYPE_MEMBER_DEPRECATED;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-11/src/org/mockito/internal/creation/DelegatingMethod.java\t2022-07-19 17:20:14.930112909 +0200\n+++ /tmp/tmpqg4wmah9.java\t2022-07-19 17:20:15.014112689 +0200\n@@ -55,8 +55,8 @@\n             return method.equals(o);\n     }\n \n     @Override\n     public int hashCode() {\n-        return 1;\n+return Token.ASSIGN_PROTOTYPE_MEMBER_DEPRECATED;\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return Token.ASSIGN_PROTOTYPE_MEMBER_DELTA;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-11/src/org/mockito/internal/creation/DelegatingMethod.java\t2022-07-19 17:20:29.002076057 +0200\n+++ /tmp/tmpsdbrwam1.java\t2022-07-19 17:20:29.002076057 +0200\n@@ -55,8 +55,8 @@\n             return method.equals(o);\n     }\n \n     @Override\n     public int hashCode() {\n-        return 1;\n+return Token.ASSIGN_PROTOTYPE_MEMBER_DELTA;\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return Token.ASSIGN_PROTOTYPE_INTERFACES;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-11/src/org/mockito/internal/creation/DelegatingMethod.java\t2022-07-19 17:20:38.774049909 +0200\n+++ /tmp/tmpxn6v4sh_.java\t2022-07-19 17:20:38.778049898 +0200\n@@ -55,8 +55,8 @@\n             return method.equals(o);\n     }\n \n     @Override\n     public int hashCode() {\n-        return 1;\n+return Token.ASSIGN_PROTOTYPE_INTERFACES;\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return Token.ASSIGN_PROTOTYPE_WITH;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-11/src/org/mockito/internal/creation/DelegatingMethod.java\t2022-07-19 17:20:48.270024067 +0200\n+++ /tmp/tmp4iv5qc3w.java\t2022-07-19 17:20:48.274024056 +0200\n@@ -55,8 +55,8 @@\n             return method.equals(o);\n     }\n \n     @Override\n     public int hashCode() {\n-        return 1;\n+return Token.ASSIGN_PROTOTYPE_WITH;\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return Token.ASSIGN_PROTOTYPE_NON_OBJECT;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-11/src/org/mockito/internal/creation/DelegatingMethod.java\t2022-07-19 17:20:58.229996514 +0200\n+++ /tmp/tmpg5mqm2ch.java\t2022-07-19 17:20:58.229996514 +0200\n@@ -55,8 +55,8 @@\n             return method.equals(o);\n     }\n \n     @Override\n     public int hashCode() {\n-        return 1;\n+return Token.ASSIGN_PROTOTYPE_NON_OBJECT;\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return Token.ASSIGN_PROTOTYPE_MEMBERS;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-11/src/org/mockito/internal/creation/DelegatingMethod.java\t2022-07-19 17:21:07.753969746 +0200\n+++ /tmp/tmpc4c84fi4.java\t2022-07-19 17:21:07.753969746 +0200\n@@ -55,8 +55,8 @@\n             return method.equals(o);\n     }\n \n     @Override\n     public int hashCode() {\n-        return 1;\n+return Token.ASSIGN_PROTOTYPE_MEMBERS;\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return Token.ASSIGN_PROTOTYPE_EMPTY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-11/src/org/mockito/internal/creation/DelegatingMethod.java\t2022-07-19 17:21:17.461942048 +0200\n+++ /tmp/tmpmv8_fkz6.java\t2022-07-19 17:21:17.461942048 +0200\n@@ -55,8 +55,8 @@\n             return method.equals(o);\n     }\n \n     @Override\n     public int hashCode() {\n-        return 1;\n+return Token.ASSIGN_PROTOTYPE_EMPTY;\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return Token.ASSIGN_PROTOTYPE_MEMBER_DELEGATE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-11/src/org/mockito/internal/creation/DelegatingMethod.java\t2022-07-19 17:21:27.049914285 +0200\n+++ /tmp/tmpkkrb4zz1.java\t2022-07-19 17:21:27.049914285 +0200\n@@ -55,8 +55,8 @@\n             return method.equals(o);\n     }\n \n     @Override\n     public int hashCode() {\n-        return 1;\n+return Token.ASSIGN_PROTOTYPE_MEMBER_DELEGATE;\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return Token.ASSIGN_PROTOTYPE_MEMBER;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-11/src/org/mockito/internal/creation/DelegatingMethod.java\t2022-07-19 17:21:36.753885785 +0200\n+++ /tmp/tmp1chirvlp.java\t2022-07-19 17:21:36.753885785 +0200\n@@ -55,8 +55,8 @@\n             return method.equals(o);\n     }\n \n     @Override\n     public int hashCode() {\n-        return 1;\n+return Token.ASSIGN_PROTOTYPE_MEMBER;\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return Token.ASSIGN_PROTOTYPE_ANNOTATION;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-11/src/org/mockito/internal/creation/DelegatingMethod.java\t2022-07-19 17:21:46.161857776 +0200\n+++ /tmp/tmpfft4uoar.java\t2022-07-19 17:21:46.165857764 +0200\n@@ -55,8 +55,8 @@\n             return method.equals(o);\n     }\n \n     @Override\n     public int hashCode() {\n-        return 1;\n+return Token.ASSIGN_PROTOTYPE_ANNOTATION;\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return 1;",
        "fixed_line": "if (this == o) { return true; } if (o instanceof DelegatingMethod) { DelegatingMethod that = (DelegatingMethod) o; return method.equals(that.method); } else { return method.equals(o); } } @Override public int hashCode() { return method.hashCode();"
    },
    "Jsoup-32": {
        "fixes": [
            {
                "k": 1,
                "patch": "clone.classNames if (clone.classNamesFor(clone.classNames();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-32/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 17:21:56.033827991 +0200\n+++ /tmp/tmpfulswah5.java\t2022-07-19 17:21:56.061827907 +0200\n@@ -1133,9 +1133,9 @@\n     }\n \n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames();\n+clone.classNames if (clone.classNamesFor(clone.classNames();\n         return clone;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "clone.classNamesFor(clone.classNamesFor(clone.classNames();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-32/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 17:21:58.117821653 +0200\n+++ /tmp/tmpe9csgss3.java\t2022-07-19 17:21:58.117821653 +0200\n@@ -1133,9 +1133,9 @@\n     }\n \n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames();\n+clone.classNamesFor(clone.classNamesFor(clone.classNames();\n         return clone;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "clone.classNames if (clone.classNames();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-32/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 17:21:59.481817494 +0200\n+++ /tmp/tmp77asp7zd.java\t2022-07-19 17:21:59.481817494 +0200\n@@ -1133,9 +1133,9 @@\n     }\n \n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames();\n+clone.classNames if (clone.classNames();\n         return clone;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "clone.classNamesFor(clone.classNamesFor(this.classNames);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-32/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 17:22:00.981812915 +0200\n+++ /tmp/tmpy4udz6ry.java\t2022-07-19 17:22:00.981812915 +0200\n@@ -1133,9 +1133,9 @@\n     }\n \n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames();\n+clone.classNamesFor(clone.classNamesFor(this.classNames);\n         return clone;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "clone.classNamesFor(clone.classNames();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-32/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 17:22:02.585808005 +0200\n+++ /tmp/tmpotj7bfy1.java\t2022-07-19 17:22:02.589807993 +0200\n@@ -1133,9 +1133,9 @@\n     }\n \n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames();\n+clone.classNamesFor(clone.classNames();\n         return clone;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "clone.classNames if (clone.classNamesFor(clone.classNamesFor(clone.classNames();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-32/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 17:22:04.209803024 +0200\n+++ /tmp/tmpkroaxz2a.java\t2022-07-19 17:22:04.209803024 +0200\n@@ -1133,9 +1133,9 @@\n     }\n \n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames();\n+clone.classNames if (clone.classNamesFor(clone.classNamesFor(clone.classNames();\n         return clone;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "clone.classNamesFor(clone.classNames;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-32/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 17:22:06.001797517 +0200\n+++ /tmp/tmp2pgj5smz.java\t2022-07-19 17:22:06.001797517 +0200\n@@ -1133,9 +1133,9 @@\n     }\n \n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames();\n+clone.classNamesFor(clone.classNames;\n         return clone;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "clone.classNames = clone;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-32/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 17:22:07.677792354 +0200\n+++ /tmp/tmpm6evq3rv.java\t2022-07-19 17:22:07.677792354 +0200\n@@ -1133,9 +1133,9 @@\n     }\n \n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames();\n+clone.classNames = clone;\n         return clone;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "clone.classNamesFor(clone.classNames);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-32/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 17:22:09.629786324 +0200\n+++ /tmp/tmpotl72pkm.java\t2022-07-19 17:22:09.629786324 +0200\n@@ -1133,9 +1133,9 @@\n     }\n \n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames();\n+clone.classNamesFor(clone.classNames);\n         return clone;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "clone.classNamesFor(clone.classNamesFor(clone.classNamesFor(clone.classNames();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-32/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 17:22:11.621780159 +0200\n+++ /tmp/tmpfn91xmpr.java\t2022-07-19 17:22:11.625780146 +0200\n@@ -1133,9 +1133,9 @@\n     }\n \n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames();\n+clone.classNamesFor(clone.classNamesFor(clone.classNamesFor(clone.classNames();\n         return clone;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "clone.classNames();",
        "fixed_line": "clone.classNames = null; // derived on first hit, otherwise gets a pointer to source classnames"
    },
    "Mockito-26": {
        "fixes": [
            {
                "k": 1,
                "patch": "primitiveValues.put12(double.class, varValues);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-26/src/org/mockito/internal/util/Primitives.java\t2022-07-19 17:22:13.457774459 +0200\n+++ /tmp/tmpmr5bz4b_.java\t2022-07-19 17:22:13.505774311 +0200\n@@ -61,8 +61,8 @@\n         primitiveValues.put(byte.class, (byte) 0);\n         primitiveValues.put(short.class, (short) 0);\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+primitiveValues.put12(double.class, varValues);\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "primitiveValues.put12(double.class,state.class);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-26/src/org/mockito/internal/util/Primitives.java\t2022-07-19 17:22:18.265759479 +0200\n+++ /tmp/tmpak5p0xxl.java\t2022-07-19 17:22:18.265759479 +0200\n@@ -61,8 +61,8 @@\n         primitiveValues.put(byte.class, (byte) 0);\n         primitiveValues.put(short.class, (short) 0);\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+primitiveValues.put12(double.class,state.class);\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "primitiveValues.putdouble(double.class,state.class);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-26/src/org/mockito/internal/util/Primitives.java\t2022-07-19 17:22:20.985750964 +0200\n+++ /tmp/tmp_gvwoezc.java\t2022-07-19 17:22:20.985750964 +0200\n@@ -61,8 +61,8 @@\n         primitiveValues.put(byte.class, (byte) 0);\n         primitiveValues.put(short.class, (short) 0);\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+primitiveValues.putdouble(double.class,state.class);\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "primitiveValues.put(double.class,state.class);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-26/src/org/mockito/internal/util/Primitives.java\t2022-07-19 17:22:23.469743161 +0200\n+++ /tmp/tmpz8w76r9v.java\t2022-07-19 17:22:23.469743161 +0200\n@@ -61,8 +61,8 @@\n         primitiveValues.put(byte.class, (byte) 0);\n         primitiveValues.put(short.class, (short) 0);\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+primitiveValues.put(double.class,state.class);\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "primitiveValues.put(double.class,state.class, 0);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-26/src/org/mockito/internal/util/Primitives.java\t2022-07-19 17:22:25.789735854 +0200\n+++ /tmp/tmpadibtycg.java\t2022-07-19 17:22:25.789735854 +0200\n@@ -61,8 +61,8 @@\n         primitiveValues.put(byte.class, (byte) 0);\n         primitiveValues.put(short.class, (short) 0);\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+primitiveValues.put(double.class,state.class, 0);\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "primitiveValues.put12(double.class, 0);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-26/src/org/mockito/internal/util/Primitives.java\t2022-07-19 17:22:28.345727779 +0200\n+++ /tmp/tmpnkr0eeku.java\t2022-07-19 17:22:28.345727779 +0200\n@@ -61,8 +61,8 @@\n         primitiveValues.put(byte.class, (byte) 0);\n         primitiveValues.put(short.class, (short) 0);\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+primitiveValues.put12(double.class, 0);\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "primitiveValues.put12(double.class,state.class, 0);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-26/src/org/mockito/internal/util/Primitives.java\t2022-07-19 17:22:30.801719997 +0200\n+++ /tmp/tmpgz4sctjh.java\t2022-07-19 17:22:30.801719997 +0200\n@@ -61,8 +61,8 @@\n         primitiveValues.put(byte.class, (byte) 0);\n         primitiveValues.put(short.class, (short) 0);\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+primitiveValues.put12(double.class,state.class, 0);\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "primitiveValues.putdouble(double.class,state.class, 0);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-26/src/org/mockito/internal/util/Primitives.java\t2022-07-19 17:22:33.281712115 +0200\n+++ /tmp/tmpbnot6uvk.java\t2022-07-19 17:22:33.281712115 +0200\n@@ -61,8 +61,8 @@\n         primitiveValues.put(byte.class, (byte) 0);\n         primitiveValues.put(short.class, (short) 0);\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+primitiveValues.putdouble(double.class,state.class, 0);\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "primitiveValues.putdouble(double.class, varValues);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-26/src/org/mockito/internal/util/Primitives.java\t2022-07-19 17:22:35.793704108 +0200\n+++ /tmp/tmp3o415acn.java\t2022-07-19 17:22:35.793704108 +0200\n@@ -61,8 +61,8 @@\n         primitiveValues.put(byte.class, (byte) 0);\n         primitiveValues.put(short.class, (short) 0);\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+primitiveValues.putdouble(double.class, varValues);\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "primitiveValues.put(double.class, varValues);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-26/src/org/mockito/internal/util/Primitives.java\t2022-07-19 17:22:38.285696141 +0200\n+++ /tmp/tmpt21a1k_0.java\t2022-07-19 17:22:38.285696141 +0200\n@@ -61,8 +61,8 @@\n         primitiveValues.put(byte.class, (byte) 0);\n         primitiveValues.put(short.class, (short) 0);\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+primitiveValues.put(double.class, varValues);\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "primitiveValues.put(double.class, 0);",
        "fixed_line": "primitiveValues.put(double.class, 0D);"
    },
    "Closure-46": {
        "fixes": [
            {
                "k": 1,
                "patch": "@Override public JSType getLeastSupertype = that.isRecordType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-46/src/com/google/javascript/rhino/jstype/RecordType.java\t2022-07-19 17:22:41.165686905 +0200\n+++ /tmp/tmp6796x6tz.java\t2022-07-19 17:22:41.249686636 +0200\n@@ -135,26 +135,11 @@\n \n     return super.defineProperty(propertyName, type, inferred,\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+@Override public JSType getLeastSupertype = that.isRecordType;\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "@Override public JSType getLeastSupertype = that.buildType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-46/src/com/google/javascript/rhino/jstype/RecordType.java\t2022-07-19 17:22:46.109670978 +0200\n+++ /tmp/tmp15q764r9.java\t2022-07-19 17:22:46.109670978 +0200\n@@ -135,26 +135,11 @@\n \n     return super.defineProperty(propertyName, type, inferred,\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+@Override public JSType getLeastSupertype = that.buildType;\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "@Override public JSType getLeastSupertype(JSType) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-46/src/com/google/javascript/rhino/jstype/RecordType.java\t2022-07-19 17:22:49.833658922 +0200\n+++ /tmp/tmprsyetduf.java\t2022-07-19 17:22:49.837658909 +0200\n@@ -135,26 +135,11 @@\n \n     return super.defineProperty(propertyName, type, inferred,\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+@Override public JSType getLeastSupertype(JSType) {\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "@Override public JSType getLeastSupertype = that.build;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-46/src/com/google/javascript/rhino/jstype/RecordType.java\t2022-07-19 17:22:53.301647649 +0200\n+++ /tmp/tmpey4an1ez.java\t2022-07-19 17:22:53.301647649 +0200\n@@ -135,26 +135,11 @@\n \n     return super.defineProperty(propertyName, type, inferred,\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+@Override public JSType getLeastSupertype = that.build;\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "@Override public JSType getLeastSupertype = this.buildType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-46/src/com/google/javascript/rhino/jstype/RecordType.java\t2022-07-19 17:22:56.841636097 +0200\n+++ /tmp/tmpj7kkwddl.java\t2022-07-19 17:22:56.841636097 +0200\n@@ -135,26 +135,11 @@\n \n     return super.defineProperty(propertyName, type, inferred,\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+@Override public JSType getLeastSupertype = this.buildType;\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "@Override public JSType getLeastSupertype(property) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-46/src/com/google/javascript/rhino/jstype/RecordType.java\t2022-07-19 17:23:00.349624605 +0200\n+++ /tmp/tmpco0mtjvw.java\t2022-07-19 17:23:00.445624286 +0200\n@@ -135,26 +135,11 @@\n \n     return super.defineProperty(propertyName, type, inferred,\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+@Override public JSType getLeastSupertype(property) {\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "@Override public JSType getLeastSupertype;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-46/src/com/google/javascript/rhino/jstype/RecordType.java\t2022-07-19 17:23:03.957612739 +0200\n+++ /tmp/tmp6qwz4zbo.java\t2022-07-19 17:23:03.961612727 +0200\n@@ -135,26 +135,11 @@\n \n     return super.defineProperty(propertyName, type, inferred,\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+@Override public JSType getLeastSupertype;\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "@Override public JSType getLeastSupertype = this.build;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-46/src/com/google/javascript/rhino/jstype/RecordType.java\t2022-07-19 17:23:07.777600126 +0200\n+++ /tmp/tmp0pug02ob.java\t2022-07-19 17:23:07.777600126 +0200\n@@ -135,26 +135,11 @@\n \n     return super.defineProperty(propertyName, type, inferred,\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+@Override public JSType getLeastSupertype = this.build;\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "@Override public JSType getLeastSupertype;STRING) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-46/src/com/google/javascript/rhino/jstype/RecordType.java\t2022-07-19 17:23:11.189588818 +0200\n+++ /tmp/tmprgjn3vmh.java\t2022-07-19 17:23:11.189588818 +0200\n@@ -135,26 +135,11 @@\n \n     return super.defineProperty(propertyName, type, inferred,\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+@Override public JSType getLeastSupertype;STRING) {\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "@Override public JSType getLeastSupertype = this.isRecordType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-46/src/com/google/javascript/rhino/jstype/RecordType.java\t2022-07-19 17:23:14.777576882 +0200\n+++ /tmp/tmphr84fc7c.java\t2022-07-19 17:23:14.777576882 +0200\n@@ -135,26 +135,11 @@\n \n     return super.defineProperty(propertyName, type, inferred,\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+@Override public JSType getLeastSupertype = this.isRecordType;\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "@Override public JSType getLeastSupertype(JSType that) { if (!that.isRecordType()) { return super.getLeastSupertype(that); } RecordTypeBuilder builder = new RecordTypeBuilder(registry); for (String property : properties.keySet()) { if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property))) { builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } } return builder.build(); }",
        "fixed_line": ""
    },
    "Gson-2": {
        "fixes": [
            {
                "k": 1,
                "patch": "return (TypeAdapter<T2>? typeAdapter.T2>;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\t2022-07-19 17:23:18.741563646 +0200\n+++ /tmp/tmp1fdg5llg.java\t2022-07-19 17:23:18.789563485 +0200\n@@ -828,11 +828,11 @@\n       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n         final Class<? super T2> requestedType = typeToken.getRawType();\n         if (!clazz.isAssignableFrom(requestedType)) {\n           return null;\n         }\n-        return (TypeAdapter<T2>) typeAdapter;\n+return (TypeAdapter<T2>? typeAdapter.T2>;\n \n       }\n       @Override public String toString() {\n         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return (TypeAdapter<T2>? typeAdapter;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\t2022-07-19 17:23:20.701557075 +0200\n+++ /tmp/tmp2cezks74.java\t2022-07-19 17:23:20.701557075 +0200\n@@ -828,11 +828,11 @@\n       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n         final Class<? super T2> requestedType = typeToken.getRawType();\n         if (!clazz.isAssignableFrom(requestedType)) {\n           return null;\n         }\n-        return (TypeAdapter<T2>) typeAdapter;\n+return (TypeAdapter<T2>? typeAdapter;\n \n       }\n       @Override public String toString() {\n         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return (TypeAdapter<T2>? typeAdapterTypeAdapter.T2>;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\t2022-07-19 17:23:22.509551007 +0200\n+++ /tmp/tmpiu8mqxb_.java\t2022-07-19 17:23:22.513550993 +0200\n@@ -828,11 +828,11 @@\n       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n         final Class<? super T2> requestedType = typeToken.getRawType();\n         if (!clazz.isAssignableFrom(requestedType)) {\n           return null;\n         }\n-        return (TypeAdapter<T2>) typeAdapter;\n+return (TypeAdapter<T2>? typeAdapterTypeAdapter.T2>;\n \n       }\n       @Override public String toString() {\n         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return (TypeAdapter<T2> || typeAdapter;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\t2022-07-19 17:23:24.001545991 +0200\n+++ /tmp/tmpawnw4vpc.java\t2022-07-19 17:23:24.005545977 +0200\n@@ -828,11 +828,11 @@\n       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n         final Class<? super T2> requestedType = typeToken.getRawType();\n         if (!clazz.isAssignableFrom(requestedType)) {\n           return null;\n         }\n-        return (TypeAdapter<T2>) typeAdapter;\n+return (TypeAdapter<T2> || typeAdapter;\n \n       }\n       @Override public String toString() {\n         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return (TypeAdapter<T2> || typeAdapter.T2>;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\t2022-07-19 17:23:25.801539928 +0200\n+++ /tmp/tmpsl3goxvw.java\t2022-07-19 17:23:25.805539915 +0200\n@@ -828,11 +828,11 @@\n       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n         final Class<? super T2> requestedType = typeToken.getRawType();\n         if (!clazz.isAssignableFrom(requestedType)) {\n           return null;\n         }\n-        return (TypeAdapter<T2>) typeAdapter;\n+return (TypeAdapter<T2> || typeAdapter.T2>;\n \n       }\n       @Override public String toString() {\n         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return (TypeAdapter<T2>? typeAdapterTypeAdapter;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\t2022-07-19 17:23:27.337534746 +0200\n+++ /tmp/tmpk2g3xzaz.java\t2022-07-19 17:23:27.337534746 +0200\n@@ -828,11 +828,11 @@\n       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n         final Class<? super T2> requestedType = typeToken.getRawType();\n         if (!clazz.isAssignableFrom(requestedType)) {\n           return null;\n         }\n-        return (TypeAdapter<T2>) typeAdapter;\n+return (TypeAdapter<T2>? typeAdapterTypeAdapter;\n \n       }\n       @Override public String toString() {\n         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return (TypeAdapter<T2> = typeAdapter;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\t2022-07-19 17:23:28.937529340 +0200\n+++ /tmp/tmpv5iqv_in.java\t2022-07-19 17:23:28.941529327 +0200\n@@ -828,11 +828,11 @@\n       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n         final Class<? super T2> requestedType = typeToken.getRawType();\n         if (!clazz.isAssignableFrom(requestedType)) {\n           return null;\n         }\n-        return (TypeAdapter<T2>) typeAdapter;\n+return (TypeAdapter<T2> = typeAdapter;\n \n       }\n       @Override public String toString() {\n         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return (TypeAdapter<T2>): typeAdapter;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\t2022-07-19 17:23:30.573523803 +0200\n+++ /tmp/tmps4wdsz_d.java\t2022-07-19 17:23:30.573523803 +0200\n@@ -828,11 +828,11 @@\n       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n         final Class<? super T2> requestedType = typeToken.getRawType();\n         if (!clazz.isAssignableFrom(requestedType)) {\n           return null;\n         }\n-        return (TypeAdapter<T2>) typeAdapter;\n+return (TypeAdapter<T2>): typeAdapter;\n \n       }\n       @Override public String toString() {\n         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return (TypeAdapter<T2>, typeAdapter;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\t2022-07-19 17:23:32.113518583 +0200\n+++ /tmp/tmptejt98ee.java\t2022-07-19 17:23:32.113518583 +0200\n@@ -828,11 +828,11 @@\n       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n         final Class<? super T2> requestedType = typeToken.getRawType();\n         if (!clazz.isAssignableFrom(requestedType)) {\n           return null;\n         }\n-        return (TypeAdapter<T2>) typeAdapter;\n+return (TypeAdapter<T2>, typeAdapter;\n \n       }\n       @Override public String toString() {\n         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return (TypeAdapter<T2>) typeAdapter;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\t2022-07-19 17:23:33.745513042 +0200\n+++ /tmp/tmpzkmzuvee.java\t2022-07-19 17:23:33.745513042 +0200\n@@ -828,11 +828,11 @@\n       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n         final Class<? super T2> requestedType = typeToken.getRawType();\n         if (!clazz.isAssignableFrom(requestedType)) {\n           return null;\n         }\n-        return (TypeAdapter<T2>) typeAdapter;\n+return (TypeAdapter<T2>) typeAdapter;\n \n       }\n       @Override public String toString() {\n         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return (TypeAdapter<T2>) typeAdapter;",
        "fixed_line": "return (TypeAdapter<T2>) new TypeAdapter<T1>() { @Override public void write(JsonWriter out, T1 value) throws IOException { typeAdapter.write(out, value); } @Override public T1 read(JsonReader in) throws IOException { T1 result = typeAdapter.read(in); if (result != null && !requestedType.isInstance(result)) { throw new JsonSyntaxException(\"Expected a \" + requestedType.getName() + \" but was \" + result.getClass().getName()); } return result; } };"
    },
    "JacksonCore-26": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int i = start; i < len; ++i) { _inputEnd = end; _inputBuffer[_inputPtr++] = end; }",
                "patch_diff": "for (int i = start; i < len; ++i) { _inputEnd = end; _inputBuffer[_inputPtr++] = end; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = start; i < len; ++i) { _inputEnd = end; _inputBuffer[_inputPtr++] = end; _inputEnd = end; _inputBuffer[_inputPtr++] = end; }",
                "patch_diff": "for (int i = start; i < len; ++i) { _inputEnd = end; _inputBuffer[_inputPtr++] = end; _inputEnd = end; _inputBuffer[_inputPtr++] = end; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = start; i < len; ++i) { _inputEnd = end; _inputBuffer[_inputPtr++] = end; } }",
                "patch_diff": "for (int i = start; i < len; ++i) { _inputEnd = end; _inputBuffer[_inputPtr++] = end; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = start; i < len; ++i) { _inputEnd = end; _inputBuffer[_inputPtr++] = end; _inputEnd = end; }",
                "patch_diff": "for (int i = start; i < len; ++i) { _inputEnd = end; _inputBuffer[_inputPtr++] = end; _inputEnd = end; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = start; i < len; ++i) { _inputEnd = end; _inputBuffer[_inputPtr++] = end; _inputEnd = end - start; }",
                "patch_diff": "for (int i = start; i < len; ++i) { _inputEnd = end; _inputBuffer[_inputPtr++] = end; _inputEnd = end - start; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = start; i < len; ++i) { if (start > end) { _inputEnd = end; _inputBuffer[_inputPtr++] = end; } } }",
                "patch_diff": "for (int i = start; i < len; ++i) { if (start > end) { _inputEnd = end; _inputBuffer[_inputPtr++] = end; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = start; i < len; ++i) { if (start > end) { _inputEnd = end; _inputBuffer[_inputPtr++] = end; } }",
                "patch_diff": "for (int i = start; i < len; ++i) { if (start > end) { _inputEnd = end; _inputBuffer[_inputPtr++] = end; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// _currInputRowStart = _inputEnd - _inputPtr; _inputEnd = end - start; }",
                "patch_diff": "// _currInputRowStart = _inputEnd - _inputPtr; _inputEnd = end - start; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// _currInputRowStart = _inputEnd - _inputStart; _inputEnd = end; _inputBufferLen = end - start; }",
                "patch_diff": "// _currInputRowStart = _inputEnd - _inputStart; _inputEnd = end; _inputBufferLen = end - start; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// _currInputRowStart = _inputEnd - _inputPtr; _inputEnd = end; _inputBufferLen = end - start; }",
                "patch_diff": "// _currInputRowStart = _inputEnd - _inputPtr; _inputEnd = end; _inputBufferLen = end - start; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "_currBufferStart = start;"
    },
    "Math-80": {
        "fixes": [
            {
                "k": 1,
                "patch": "int j = k * n / 4 - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2022-07-19 17:23:40.173491133 +0200\n+++ /tmp/tmphpz_jqjh.java\t2022-07-19 17:23:40.205491022 +0200\n@@ -1130,11 +1130,11 @@\n      * @return true if qd array was flipped\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+int j = k * n / 4 - 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int j = k * n / 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2022-07-19 17:23:43.041481312 +0200\n+++ /tmp/tmp7s3zksvr.java\t2022-07-19 17:23:43.041481312 +0200\n@@ -1130,11 +1130,11 @@\n      * @return true if qd array was flipped\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+int j = k * n / 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int j = n / 4 - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2022-07-19 17:23:45.305473541 +0200\n+++ /tmp/tmp6yq3ge8t.java\t2022-07-19 17:23:45.305473541 +0200\n@@ -1130,11 +1130,11 @@\n      * @return true if qd array was flipped\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+int j = n / 4 - 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 4,
                "patch": "int j = k * n / 2;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2022-07-19 17:23:52.673448136 +0200\n+++ /tmp/tmpn7zpu16f.java\t2022-07-19 17:23:52.677448122 +0200\n@@ -1130,11 +1130,11 @@\n      * @return true if qd array was flipped\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+int j = k * n / 2;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int j = n / n - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2022-07-19 17:23:55.073439822 +0200\n+++ /tmp/tmpsca4jyx1.java\t2022-07-19 17:23:55.077439808 +0200\n@@ -1130,11 +1130,11 @@\n      * @return true if qd array was flipped\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+int j = n / n - 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 6,
                "patch": "int j = n / 3;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2022-07-19 17:24:01.885416126 +0200\n+++ /tmp/tmpjz0rkjj5.java\t2022-07-19 17:24:01.889416112 +0200\n@@ -1130,11 +1130,11 @@\n      * @return true if qd array was flipped\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+int j = n / 3;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 7,
                "patch": "int j = k * n - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2022-07-19 17:24:08.625392535 +0200\n+++ /tmp/tmp4ups9edj.java\t2022-07-19 17:24:08.625392535 +0200\n@@ -1130,11 +1130,11 @@\n      * @return true if qd array was flipped\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+int j = k * n - 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int j = n / 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2022-07-19 17:24:11.017384127 +0200\n+++ /tmp/tmpxlb3rjpf.java\t2022-07-19 17:24:11.017384127 +0200\n@@ -1130,11 +1130,11 @@\n      * @return true if qd array was flipped\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+int j = n / 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int j = k * n / n - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2022-07-19 17:24:17.821360116 +0200\n+++ /tmp/tmp9rsfvx2k.java\t2022-07-19 17:24:17.825360102 +0200\n@@ -1130,11 +1130,11 @@\n      * @return true if qd array was flipped\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+int j = k * n / n - 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int j = k * n / 3;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2022-07-19 17:24:20.109352011 +0200\n+++ /tmp/tmpntqvuzkk.java\t2022-07-19 17:24:20.109352011 +0200\n@@ -1130,11 +1130,11 @@\n      * @return true if qd array was flipped\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+int j = k * n / 3;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "int j = 4 * n - 1;",
        "fixed_line": "int j = 4 * (n - 1);"
    },
    "Time-23": {
        "fixes": [
            {
                "k": 1,
                "patch": "map.put(\"Horizontal/ET\", map.putputputputputputputputput12DST\", \"Linenoenoenoenoeno);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-23/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 17:24:22.853342267 +0200\n+++ /tmp/tmpe5fftxr3.java\t2022-07-19 17:24:22.905342083 +0200\n@@ -567,27 +567,11 @@\n             map.put(\"PST\", \"America/Los_Angeles\");\n             map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indianapolis\");\n-            map.put(\"PRT\", \"America/Puerto_Rico\");\n-            map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Buenos_Aires\");\n-            map.put(\"BET\", \"America/Sao_Paulo\");\n-            map.put(\"WET\", \"Europe/London\");\n-            map.put(\"ECT\", \"Europe/Paris\");\n-            map.put(\"ART\", \"Africa/Cairo\");\n-            map.put(\"CAT\", \"Africa/Harare\");\n-            map.put(\"EET\", \"Europe/Bucharest\");\n-            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n-            map.put(\"MET\", \"Asia/Tehran\");\n-            map.put(\"NET\", \"Asia/Yerevan\");\n-            map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Calcutta\");\n-            map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Saigon\");\n+map.put(\"Horizontal/ET\", map.putputputputputputputputput12DST\", \"Linenoenoenoenoeno);\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n             map.put(\"AET\", \"Australia/Sydney\");\n             map.put(\"SST\", \"Pacific/Guadalcanal\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "map.put(\"Horizontal/ET\", map.putputputputputputputputput12DST\", \"Linenoenoenoenoenoeno);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-23/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 17:24:24.921334911 +0200\n+++ /tmp/tmpl9vln_84.java\t2022-07-19 17:24:24.921334911 +0200\n@@ -567,27 +567,11 @@\n             map.put(\"PST\", \"America/Los_Angeles\");\n             map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indianapolis\");\n-            map.put(\"PRT\", \"America/Puerto_Rico\");\n-            map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Buenos_Aires\");\n-            map.put(\"BET\", \"America/Sao_Paulo\");\n-            map.put(\"WET\", \"Europe/London\");\n-            map.put(\"ECT\", \"Europe/Paris\");\n-            map.put(\"ART\", \"Africa/Cairo\");\n-            map.put(\"CAT\", \"Africa/Harare\");\n-            map.put(\"EET\", \"Europe/Bucharest\");\n-            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n-            map.put(\"MET\", \"Asia/Tehran\");\n-            map.put(\"NET\", \"Asia/Yerevan\");\n-            map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Calcutta\");\n-            map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Saigon\");\n+map.put(\"Horizontal/ET\", map.putputputputputputputputput12DST\", \"Linenoenoenoenoenoeno);\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n             map.put(\"AET\", \"Australia/Sydney\");\n             map.put(\"SST\", \"Pacific/Guadalcanal\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "map.put(\"Horizontal/ET\", map.putputputputputputputput12DST\", \"Linenoenoenoenoeno);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-23/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 17:24:26.561329066 +0200\n+++ /tmp/tmpwm6gx84z.java\t2022-07-19 17:24:26.561329066 +0200\n@@ -567,27 +567,11 @@\n             map.put(\"PST\", \"America/Los_Angeles\");\n             map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indianapolis\");\n-            map.put(\"PRT\", \"America/Puerto_Rico\");\n-            map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Buenos_Aires\");\n-            map.put(\"BET\", \"America/Sao_Paulo\");\n-            map.put(\"WET\", \"Europe/London\");\n-            map.put(\"ECT\", \"Europe/Paris\");\n-            map.put(\"ART\", \"Africa/Cairo\");\n-            map.put(\"CAT\", \"Africa/Harare\");\n-            map.put(\"EET\", \"Europe/Bucharest\");\n-            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n-            map.put(\"MET\", \"Asia/Tehran\");\n-            map.put(\"NET\", \"Asia/Yerevan\");\n-            map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Calcutta\");\n-            map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Saigon\");\n+map.put(\"Horizontal/ET\", map.putputputputputputputput12DST\", \"Linenoenoenoenoeno);\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n             map.put(\"AET\", \"Australia/Sydney\");\n             map.put(\"SST\", \"Pacific/Guadalcanal\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "map.put(\"Horizontal/ET\", map.putputputputputputputput12DST\", \"Linenoenoenoenoenoeno);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-23/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 17:24:28.261323001 +0200\n+++ /tmp/tmp047ffhqb.java\t2022-07-19 17:24:28.261323001 +0200\n@@ -567,27 +567,11 @@\n             map.put(\"PST\", \"America/Los_Angeles\");\n             map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indianapolis\");\n-            map.put(\"PRT\", \"America/Puerto_Rico\");\n-            map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Buenos_Aires\");\n-            map.put(\"BET\", \"America/Sao_Paulo\");\n-            map.put(\"WET\", \"Europe/London\");\n-            map.put(\"ECT\", \"Europe/Paris\");\n-            map.put(\"ART\", \"Africa/Cairo\");\n-            map.put(\"CAT\", \"Africa/Harare\");\n-            map.put(\"EET\", \"Europe/Bucharest\");\n-            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n-            map.put(\"MET\", \"Asia/Tehran\");\n-            map.put(\"NET\", \"Asia/Yerevan\");\n-            map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Calcutta\");\n-            map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Saigon\");\n+map.put(\"Horizontal/ET\", map.putputputputputputputput12DST\", \"Linenoenoenoenoenoeno);\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n             map.put(\"AET\", \"Australia/Sydney\");\n             map.put(\"SST\", \"Pacific/Guadalcanal\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "map.put(\"Horizontal/ET\", map.putputputputputputputputputput12DST\", \"Linenoenoenoenoenoeno);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-23/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 17:24:30.065316553 +0200\n+++ /tmp/tmpzuuz0k4_.java\t2022-07-19 17:24:30.065316553 +0200\n@@ -567,27 +567,11 @@\n             map.put(\"PST\", \"America/Los_Angeles\");\n             map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indianapolis\");\n-            map.put(\"PRT\", \"America/Puerto_Rico\");\n-            map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Buenos_Aires\");\n-            map.put(\"BET\", \"America/Sao_Paulo\");\n-            map.put(\"WET\", \"Europe/London\");\n-            map.put(\"ECT\", \"Europe/Paris\");\n-            map.put(\"ART\", \"Africa/Cairo\");\n-            map.put(\"CAT\", \"Africa/Harare\");\n-            map.put(\"EET\", \"Europe/Bucharest\");\n-            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n-            map.put(\"MET\", \"Asia/Tehran\");\n-            map.put(\"NET\", \"Asia/Yerevan\");\n-            map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Calcutta\");\n-            map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Saigon\");\n+map.put(\"Horizontal/ET\", map.putputputputputputputputputput12DST\", \"Linenoenoenoenoenoeno);\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n             map.put(\"AET\", \"Australia/Sydney\");\n             map.put(\"SST\", \"Pacific/Guadalcanal\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "map.put(\"Horizontal/ET\", map.putputputputputputputputputput12DST\", \"Linenoenoenoenoeno);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-23/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 17:24:31.697310713 +0200\n+++ /tmp/tmpk4atbb88.java\t2022-07-19 17:24:31.697310713 +0200\n@@ -567,27 +567,11 @@\n             map.put(\"PST\", \"America/Los_Angeles\");\n             map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indianapolis\");\n-            map.put(\"PRT\", \"America/Puerto_Rico\");\n-            map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Buenos_Aires\");\n-            map.put(\"BET\", \"America/Sao_Paulo\");\n-            map.put(\"WET\", \"Europe/London\");\n-            map.put(\"ECT\", \"Europe/Paris\");\n-            map.put(\"ART\", \"Africa/Cairo\");\n-            map.put(\"CAT\", \"Africa/Harare\");\n-            map.put(\"EET\", \"Europe/Bucharest\");\n-            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n-            map.put(\"MET\", \"Asia/Tehran\");\n-            map.put(\"NET\", \"Asia/Yerevan\");\n-            map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Calcutta\");\n-            map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Saigon\");\n+map.put(\"Horizontal/ET\", map.putputputputputputputputputput12DST\", \"Linenoenoenoenoeno);\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n             map.put(\"AET\", \"Australia/Sydney\");\n             map.put(\"SST\", \"Pacific/Guadalcanal\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "map.put(\"Horizontal/ET\", map.putputputputputputputputput12DST\", \"Linenoenoenoenoenoenoeno);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-23/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 17:24:33.545304089 +0200\n+++ /tmp/tmpug6u284o.java\t2022-07-19 17:24:33.545304089 +0200\n@@ -567,27 +567,11 @@\n             map.put(\"PST\", \"America/Los_Angeles\");\n             map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indianapolis\");\n-            map.put(\"PRT\", \"America/Puerto_Rico\");\n-            map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Buenos_Aires\");\n-            map.put(\"BET\", \"America/Sao_Paulo\");\n-            map.put(\"WET\", \"Europe/London\");\n-            map.put(\"ECT\", \"Europe/Paris\");\n-            map.put(\"ART\", \"Africa/Cairo\");\n-            map.put(\"CAT\", \"Africa/Harare\");\n-            map.put(\"EET\", \"Europe/Bucharest\");\n-            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n-            map.put(\"MET\", \"Asia/Tehran\");\n-            map.put(\"NET\", \"Asia/Yerevan\");\n-            map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Calcutta\");\n-            map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Saigon\");\n+map.put(\"Horizontal/ET\", map.putputputputputputputputput12DST\", \"Linenoenoenoenoenoenoeno);\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n             map.put(\"AET\", \"Australia/Sydney\");\n             map.put(\"SST\", \"Pacific/Guadalcanal\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "map.put(\"Horizontal/ET\", map.putputputputputputputputput12DST\", \"Linenoenoenoeno);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-23/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 17:24:35.177298232 +0200\n+++ /tmp/tmpn645dl_k.java\t2022-07-19 17:24:35.177298232 +0200\n@@ -567,27 +567,11 @@\n             map.put(\"PST\", \"America/Los_Angeles\");\n             map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indianapolis\");\n-            map.put(\"PRT\", \"America/Puerto_Rico\");\n-            map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Buenos_Aires\");\n-            map.put(\"BET\", \"America/Sao_Paulo\");\n-            map.put(\"WET\", \"Europe/London\");\n-            map.put(\"ECT\", \"Europe/Paris\");\n-            map.put(\"ART\", \"Africa/Cairo\");\n-            map.put(\"CAT\", \"Africa/Harare\");\n-            map.put(\"EET\", \"Europe/Bucharest\");\n-            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n-            map.put(\"MET\", \"Asia/Tehran\");\n-            map.put(\"NET\", \"Asia/Yerevan\");\n-            map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Calcutta\");\n-            map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Saigon\");\n+map.put(\"Horizontal/ET\", map.putputputputputputputputput12DST\", \"Linenoenoenoeno);\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n             map.put(\"AET\", \"Australia/Sydney\");\n             map.put(\"SST\", \"Pacific/Guadalcanal\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "map.put(\"Horizontal/ET\", map.putputputputputputputput12DST\", \"Linenoenoenoenoenoenoeno);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-23/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 17:24:36.925291948 +0200\n+++ /tmp/tmp19f4hzf1.java\t2022-07-19 17:24:36.925291948 +0200\n@@ -567,27 +567,11 @@\n             map.put(\"PST\", \"America/Los_Angeles\");\n             map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indianapolis\");\n-            map.put(\"PRT\", \"America/Puerto_Rico\");\n-            map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Buenos_Aires\");\n-            map.put(\"BET\", \"America/Sao_Paulo\");\n-            map.put(\"WET\", \"Europe/London\");\n-            map.put(\"ECT\", \"Europe/Paris\");\n-            map.put(\"ART\", \"Africa/Cairo\");\n-            map.put(\"CAT\", \"Africa/Harare\");\n-            map.put(\"EET\", \"Europe/Bucharest\");\n-            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n-            map.put(\"MET\", \"Asia/Tehran\");\n-            map.put(\"NET\", \"Asia/Yerevan\");\n-            map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Calcutta\");\n-            map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Saigon\");\n+map.put(\"Horizontal/ET\", map.putputputputputputputput12DST\", \"Linenoenoenoenoenoenoeno);\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n             map.put(\"AET\", \"Australia/Sydney\");\n             map.put(\"SST\", \"Pacific/Guadalcanal\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "map.put(\"Horizontal/ET\", map.putputputputputputputput12DST\", \"Linenoenoenoeno);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-23/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 17:24:38.577286003 +0200\n+++ /tmp/tmpugkdzf81.java\t2022-07-19 17:24:38.577286003 +0200\n@@ -567,27 +567,11 @@\n             map.put(\"PST\", \"America/Los_Angeles\");\n             map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indianapolis\");\n-            map.put(\"PRT\", \"America/Puerto_Rico\");\n-            map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Buenos_Aires\");\n-            map.put(\"BET\", \"America/Sao_Paulo\");\n-            map.put(\"WET\", \"Europe/London\");\n-            map.put(\"ECT\", \"Europe/Paris\");\n-            map.put(\"ART\", \"Africa/Cairo\");\n-            map.put(\"CAT\", \"Africa/Harare\");\n-            map.put(\"EET\", \"Europe/Bucharest\");\n-            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n-            map.put(\"MET\", \"Asia/Tehran\");\n-            map.put(\"NET\", \"Asia/Yerevan\");\n-            map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Calcutta\");\n-            map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Saigon\");\n+map.put(\"Horizontal/ET\", map.putputputputputputputput12DST\", \"Linenoenoenoeno);\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n             map.put(\"AET\", \"Australia/Sydney\");\n             map.put(\"SST\", \"Pacific/Guadalcanal\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "map.put(\"IET\", \"America/Indianapolis\"); map.put(\"PRT\", \"America/Puerto_Rico\"); map.put(\"CNT\", \"America/St_Johns\"); map.put(\"AGT\", \"America/Buenos_Aires\"); map.put(\"BET\", \"America/Sao_Paulo\"); map.put(\"WET\", \"Europe/London\"); map.put(\"ECT\", \"Europe/Paris\"); map.put(\"ART\", \"Africa/Cairo\"); map.put(\"CAT\", \"Africa/Harare\"); map.put(\"EET\", \"Europe/Bucharest\"); map.put(\"EAT\", \"Africa/Addis_Ababa\"); map.put(\"MET\", \"Asia/Tehran\"); map.put(\"NET\", \"Asia/Yerevan\"); map.put(\"PLT\", \"Asia/Karachi\"); map.put(\"IST\", \"Asia/Calcutta\"); map.put(\"BST\", \"Asia/Dhaka\"); map.put(\"VST\", \"Asia/Saigon\");",
        "fixed_line": "map.put(\"WET\", \"WET\"); map.put(\"CET\", \"CET\"); map.put(\"MET\", \"CET\"); map.put(\"ECT\", \"CET\"); map.put(\"EET\", \"EET\"); map.put(\"MIT\", \"Pacific/Apia\"); map.put(\"HST\", \"Pacific/Honolulu\"); // JDK 1.1 compatible map.put(\"AST\", \"America/Anchorage\"); map.put(\"PST\", \"America/Los_Angeles\"); map.put(\"MST\", \"America/Denver\"); // JDK 1.1 compatible map.put(\"PNT\", \"America/Phoenix\"); map.put(\"CST\", \"America/Chicago\"); map.put(\"EST\", \"America/New_York\"); // JDK 1.1 compatible map.put(\"IET\", \"America/Indiana/Indianapolis\"); map.put(\"PRT\", \"America/Puerto_Rico\"); map.put(\"CNT\", \"America/St_Johns\"); map.put(\"AGT\", \"America/Argentina/Buenos_Aires\"); map.put(\"BET\", \"America/Sao_Paulo\"); map.put(\"ART\", \"Africa/Cairo\"); map.put(\"CAT\", \"Africa/Harare\"); map.put(\"EAT\", \"Africa/Addis_Ababa\"); map.put(\"NET\", \"Asia/Yerevan\"); map.put(\"PLT\", \"Asia/Karachi\"); map.put(\"IST\", \"Asia/Kolkata\"); map.put(\"BST\", \"Asia/Dhaka\"); map.put(\"VST\", \"Asia/Ho_Chi_Minh\");"
    },
    "Mockito-28": {
        "fixes": [
            {
                "k": 1,
                "patch": "mockCandidateFilter.filterCandidate(mocks, fieldInstance).thenInject());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-28/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\t2022-07-19 17:24:40.397279442 +0200\n+++ /tmp/tmp4b1hzqhs.java\t2022-07-19 17:24:40.417279370 +0200\n@@ -88,11 +88,11 @@\n         }\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+mockCandidateFilter.filterCandidate(mocks, fieldInstance).thenInject());\n         }\n     }\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "mockCandidateFilter.filterCandidate(mocks, fieldInstance).thenInjectContext();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-28/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\t2022-07-19 17:24:43.085269735 +0200\n+++ /tmp/tmp4yhi1e20.java\t2022-07-19 17:24:43.085269735 +0200\n@@ -88,11 +88,11 @@\n         }\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+mockCandidateFilter.filterCandidate(mocks, fieldInstance).thenInjectContext();\n         }\n     }\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "mockCandidateFilter.filterCandidate(mocks, fieldInstance).thenInjectContext);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-28/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\t2022-07-19 17:24:45.529260892 +0200\n+++ /tmp/tmpcfoz6dl2.java\t2022-07-19 17:24:45.529260892 +0200\n@@ -88,11 +88,11 @@\n         }\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+mockCandidateFilter.filterCandidate(mocks, fieldInstance).thenInjectContext);\n         }\n     }\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "mockCandidateFilter.filterCandidate(mocks, objInstance).thenInject();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-28/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\t2022-07-19 17:24:47.429254005 +0200\n+++ /tmp/tmp0o7b2r_l.java\t2022-07-19 17:24:47.429254005 +0200\n@@ -88,11 +88,11 @@\n         }\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+mockCandidateFilter.filterCandidate(mocks, objInstance).thenInject();\n         }\n     }\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "mockCandidateFilter.filterCandidate(mocks, fieldInstance).thenInjectAccessor();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-28/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\t2022-07-19 17:24:50.009244637 +0200\n+++ /tmp/tmp5h3p6xf3.java\t2022-07-19 17:24:50.009244637 +0200\n@@ -88,11 +88,11 @@\n         }\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+mockCandidateFilter.filterCandidate(mocks, fieldInstance).thenInjectAccessor();\n         }\n     }\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "mockCandidateFilter.filterCandidate(mocks, fieldInstance).thenInject();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-28/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\t2022-07-19 17:24:52.569235320 +0200\n+++ /tmp/tmp1cniuezu.java\t2022-07-19 17:24:52.569235320 +0200\n@@ -88,11 +88,11 @@\n         }\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+mockCandidateFilter.filterCandidate(mocks, fieldInstance).thenInject();\n         }\n     }\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "mockCandidateFilter.filterCandidate(mocks, objInstance).thenInject(fieldInstance).\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-28/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\t2022-07-19 17:24:54.997226469 +0200\n+++ /tmp/tmp7k_bou20.java\t2022-07-19 17:24:54.997226469 +0200\n@@ -88,11 +88,11 @@\n         }\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+mockCandidateFilter.filterCandidate(mocks, objInstance).thenInject(fieldInstance).\");\n         }\n     }\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "mockCandidateFilter.filterCandidate(mocks, fieldInstance).thenInject(fieldInstance).\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-28/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\t2022-07-19 17:24:56.821219807 +0200\n+++ /tmp/tmpvncc1rcc.java\t2022-07-19 17:24:56.825219793 +0200\n@@ -88,11 +88,11 @@\n         }\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+mockCandidateFilter.filterCandidate(mocks, fieldInstance).thenInject(fieldInstance).\");\n         }\n     }\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "mockCandidateFilter.filterCandidate(mocks, fieldInstance).\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-28/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\t2022-07-19 17:24:58.773212667 +0200\n+++ /tmp/tmpmh4mp_am.java\t2022-07-19 17:24:58.773212667 +0200\n@@ -88,11 +88,11 @@\n         }\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+mockCandidateFilter.filterCandidate(mocks, fieldInstance).\");\n         }\n     }\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "mockCandidateFilter.filterCandidate( fieldInstance, objInstance).thenInject();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-28/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\t2022-07-19 17:25:00.797205253 +0200\n+++ /tmp/tmp6slpamm4.java\t2022-07-19 17:25:00.797205253 +0200\n@@ -88,11 +88,11 @@\n         }\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+mockCandidateFilter.filterCandidate( fieldInstance, objInstance).thenInject();\n         }\n     }\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();",
        "fixed_line": "Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(); mocks.remove(injected);"
    },
    "JacksonDatabind-2": {
        "fixes": [
            {
                "k": 1,
                "patch": "// can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "// can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// can't really modify it was non-literal characters that might be valid (empty be valid)",
                "patch_diff": "// can't really modify it was non-literal characters that might be valid (empty be valid)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// can't really modify it was non-literal characters that might be valid (empty be",
                "patch_diff": "// can't really modify it was non-literal characters that might be valid (empty be",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "patch_diff": "// can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (tatu:: declaredType.isEnabled(Feature.VALUE_EMBEDDED_OBJECT, value)) {",
                "patch_diff": "if (tatu:: declaredType.isEnabled(Feature.VALUE_EMBEDDED_OBJECT, value)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// can't really modify it was non-literal characters that might be valid (e if it.",
                "patch_diff": "// can't really modify it was non-literal characters that might be valid (e if it.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = 0, len = value.length; i < len; ++i) {",
                "patch_diff": "for (int i = 0, len = value.length; i < len; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (tatu:: declaredType.isEnabled(Feature.VALUE_EMBEDDED_OBJECT, value);",
                "patch_diff": "if (tatu:: declaredType.isEnabled(Feature.VALUE_EMBEDDED_OBJECT, value);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (tatu:: declaredType.isEnabled(Feature.MILLIS_EMBEDDED_OBJECT, value)) {",
                "patch_diff": "if (tatu:: declaredType.isEnabled(Feature.MILLIS_EMBEDDED_OBJECT, value)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (tatu:: declaredType.isEnabled(Feature.MILLIS_EMBEDDED_OBJECT, value);",
                "patch_diff": "if (tatu:: declaredType.isEnabled(Feature.MILLIS_EMBEDDED_OBJECT, value);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (value == null) { writeNull(); return; } Class<?> raw = value.getClass(); if (raw == byte[].class) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); return; } else if (_objectCodec == null) { /* 28-May-2014, tatu: Tricky choice here; if no codec, should we * err out, or just embed? For now, do latter. */ // throw new JsonMappingException(\"No ObjectCodec configured for TokenBuffer, writeObject() called\"); _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else { _objectCodec.writeValue(this, value); } } @Override public void writeTree(TreeNode node) throws IOException { if (node == null) { writeNull(); return; } if (_objectCodec == null) { // as with 'writeObject()', is codec optional? _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else { _objectCodec.writeTree(this, node); }"
    },
    "Cli-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (options.hasOption(arg.substring(0, 2))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-12/src/java/org/apache/commons/cli/GnuParser.java\t2022-07-19 17:25:05.505187963 +0200\n+++ /tmp/tmpfjr6by_h.java\t2022-07-19 17:25:05.593187637 +0200\n@@ -76,11 +76,11 @@\n                 {\n                     tokens.add(arg);\n                 }\n                 else\n                 {\n-                    if (options.hasOption(arg.substring(0, 2)))\n+if (options.hasOption(arg.substring(0, 2))) {\n                     {\n                         // the format is --foo=value or -foo=value\n                         // the format is a special properties option (-Dproperty=value)\n                         tokens.add(arg.substring(0, 2)); // -D\n                         tokens.add(arg.substring(2)); // property=value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (arg.hasOption(arg.substring(0, 2))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-12/src/java/org/apache/commons/cli/GnuParser.java\t2022-07-19 17:25:07.477180703 +0200\n+++ /tmp/tmp1zbz4cvu.java\t2022-07-19 17:25:07.477180703 +0200\n@@ -76,11 +76,11 @@\n                 {\n                     tokens.add(arg);\n                 }\n                 else\n                 {\n-                    if (options.hasOption(arg.substring(0, 2)))\n+if (arg.hasOption(arg.substring(0, 2))) {\n                     {\n                         // the format is --foo=value or -foo=value\n                         // the format is a special properties option (-Dproperty=value)\n                         tokens.add(arg.substring(0, 2)); // -D\n                         tokens.add(arg.substring(2)); // property=value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (options.hasOption_OBJECT_ARRAY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-12/src/java/org/apache/commons/cli/GnuParser.java\t2022-07-19 17:25:08.885175510 +0200\n+++ /tmp/tmp41o4unke.java\t2022-07-19 17:25:08.889175496 +0200\n@@ -76,11 +76,11 @@\n                 {\n                     tokens.add(arg);\n                 }\n                 else\n                 {\n-                    if (options.hasOption(arg.substring(0, 2)))\n+if (options.hasOption_OBJECT_ARRAY;\n                     {\n                         // the format is --foo=value or -foo=value\n                         // the format is a special properties option (-Dproperty=value)\n                         tokens.add(arg.substring(0, 2)); // -D\n                         tokens.add(arg.substring(2)); // property=value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (arg.hasOption_OBJECT_ARRAY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-12/src/java/org/apache/commons/cli/GnuParser.java\t2022-07-19 17:25:10.337170153 +0200\n+++ /tmp/tmpsetwh67v.java\t2022-07-19 17:25:10.337170153 +0200\n@@ -76,11 +76,11 @@\n                 {\n                     tokens.add(arg);\n                 }\n                 else\n                 {\n-                    if (options.hasOption(arg.substring(0, 2)))\n+if (arg.hasOption_OBJECT_ARRAY;\n                     {\n                         // the format is --foo=value or -foo=value\n                         // the format is a special properties option (-Dproperty=value)\n                         tokens.add(arg.substring(0, 2)); // -D\n                         tokens.add(arg.substring(2)); // property=value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (options.hasOption;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-12/src/java/org/apache/commons/cli/GnuParser.java\t2022-07-19 17:25:11.761164891 +0200\n+++ /tmp/tmpw1er5h1q.java\t2022-07-19 17:25:11.761164891 +0200\n@@ -76,11 +76,11 @@\n                 {\n                     tokens.add(arg);\n                 }\n                 else\n                 {\n-                    if (options.hasOption(arg.substring(0, 2)))\n+if (options.hasOption;\n                     {\n                         // the format is --foo=value or -foo=value\n                         // the format is a special properties option (-Dproperty=value)\n                         tokens.add(arg.substring(0, 2)); // -D\n                         tokens.add(arg.substring(2)); // property=value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (options.hasOption) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-12/src/java/org/apache/commons/cli/GnuParser.java\t2022-07-19 17:25:13.309159166 +0200\n+++ /tmp/tmp049z_5c5.java\t2022-07-19 17:25:13.309159166 +0200\n@@ -76,11 +76,11 @@\n                 {\n                     tokens.add(arg);\n                 }\n                 else\n                 {\n-                    if (options.hasOption(arg.substring(0, 2)))\n+if (options.hasOption) {\n                     {\n                         // the format is --foo=value or -foo=value\n                         // the format is a special properties option (-Dproperty=value)\n                         tokens.add(arg.substring(0, 2)); // -D\n                         tokens.add(arg.substring(2)); // property=value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (arg.hasOption;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-12/src/java/org/apache/commons/cli/GnuParser.java\t2022-07-19 17:25:14.725153922 +0200\n+++ /tmp/tmpvonc9_3w.java\t2022-07-19 17:25:14.725153922 +0200\n@@ -76,11 +76,11 @@\n                 {\n                     tokens.add(arg);\n                 }\n                 else\n                 {\n-                    if (options.hasOption(arg.substring(0, 2)))\n+if (arg.hasOption;\n                     {\n                         // the format is --foo=value or -foo=value\n                         // the format is a special properties option (-Dproperty=value)\n                         tokens.add(arg.substring(0, 2)); // -D\n                         tokens.add(arg.substring(2)); // property=value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (arg.hasOption) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-12/src/java/org/apache/commons/cli/GnuParser.java\t2022-07-19 17:25:16.301148081 +0200\n+++ /tmp/tmp9l3v4jye.java\t2022-07-19 17:25:16.301148081 +0200\n@@ -76,11 +76,11 @@\n                 {\n                     tokens.add(arg);\n                 }\n                 else\n                 {\n-                    if (options.hasOption(arg.substring(0, 2)))\n+if (arg.hasOption) {\n                     {\n                         // the format is --foo=value or -foo=value\n                         // the format is a special properties option (-Dproperty=value)\n                         tokens.add(arg.substring(0, 2)); // -D\n                         tokens.add(arg.substring(2)); // property=value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (arg.hasOption(arg.substring(0, 2];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-12/src/java/org/apache/commons/cli/GnuParser.java\t2022-07-19 17:25:17.721142812 +0200\n+++ /tmp/tmpnvf3tsco.java\t2022-07-19 17:25:17.721142812 +0200\n@@ -76,11 +76,11 @@\n                 {\n                     tokens.add(arg);\n                 }\n                 else\n                 {\n-                    if (options.hasOption(arg.substring(0, 2)))\n+if (arg.hasOption(arg.substring(0, 2];\n                     {\n                         // the format is --foo=value or -foo=value\n                         // the format is a special properties option (-Dproperty=value)\n                         tokens.add(arg.substring(0, 2)); // -D\n                         tokens.add(arg.substring(2)); // property=value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (options.hasOption || options.substring(0, 2))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-12/src/java/org/apache/commons/cli/GnuParser.java\t2022-07-19 17:25:19.113137641 +0200\n+++ /tmp/tmpfo9b42n_.java\t2022-07-19 17:25:19.117137624 +0200\n@@ -76,11 +76,11 @@\n                 {\n                     tokens.add(arg);\n                 }\n                 else\n                 {\n-                    if (options.hasOption(arg.substring(0, 2)))\n+if (options.hasOption || options.substring(0, 2))) {\n                     {\n                         // the format is --foo=value or -foo=value\n                         // the format is a special properties option (-Dproperty=value)\n                         tokens.add(arg.substring(0, 2)); // -D\n                         tokens.add(arg.substring(2)); // property=value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (options.hasOption(arg.substring(0, 2)))",
        "fixed_line": "if (opt.indexOf('=') != -1 && options.hasOption(opt.substring(0, opt.indexOf('=')))) { // the format is --foo=value or -foo=value tokens.add(arg.substring(0, arg.indexOf('='))); // --foo tokens.add(arg.substring(arg.indexOf('=') + 1)); // value } else if (options.hasOption(arg.substring(0, 2))) {"
    },
    "Lang-28": {
        "fixes": [
            {
                "k": 1,
                "patch": "return (start + (end - start) + (isHex? 1 : 0) + 1; }",
                "patch_diff": "return (start + (end - start) + (isHex? 1 : 0) + 1; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return 2 + (end - start) + (isHex? 1 : 0) + 1; }",
                "patch_diff": "return 2 + (end - start) + (isHex? 1 : 0) + 1; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return index + (end - start) + (isHex? 1 : 0) + 1; }",
                "patch_diff": "return index + (end - start) + (isHex? 1 : 0) + 1; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return 2 * (end - start) + (isHex? 1 : 0) + 1; }",
                "patch_diff": "return 2 * (end - start) + (isHex? 1 : 0) + 1; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return pointer + (end - start) + (isHex? 1 : 0) + 1; }",
                "patch_diff": "return pointer + (end - start) + (isHex? 1 : 0) + 1; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return start + (end - start) + (isHex? 1 : 0) + 1; }",
                "patch_diff": "return start + (end - start) + (isHex? 1 : 0) + 1; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return 2 + (isHex - start) + (isHex? 1 : 0) + 1; }",
                "patch_diff": "return 2 + (isHex - start) + (isHex? 1 : 0) + 1; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return (start + (length - 1) + (isHex? 1 : 0) + 1; }",
                "patch_diff": "return (start + (length - 1) + (isHex? 1 : 0) + 1; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return (start + (end - start) + (isHex? 1 : 0); }",
                "patch_diff": "return (start + (end - start) + (isHex? 1 : 0); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return position + (isHex? 1 : 0) + 1; }",
                "patch_diff": "return position + (isHex? 1 : 0) + 1; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if(entityValue > 0xFFFF) { char[] chrs = Character.toChars(entityValue); out.write(chrs[0]); out.write(chrs[1]); } else { out.write(entityValue); }"
    },
    "JacksonXml-3": {
        "fixes": [
            {
                "k": 1,
                "patch": "_currText = _parsingContext.getText(); _currText = JsonToken.VALUE_STRING; break = JsonToken.VALUE_STRING;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonXml-3/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\t2022-07-19 17:25:22.605124645 +0200\n+++ /tmp/tmpj7gakz_n.java\t2022-07-19 17:25:22.673124393 +0200\n@@ -664,13 +664,11 @@\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _currToken = JsonToken.FIELD_NAME;\n             }\n             break;\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n-            _currText = _xmlTokens.getText();\n-            _currToken = JsonToken.VALUE_STRING;\n-            break;\n+_currText = _parsingContext.getText(); _currText = JsonToken.VALUE_STRING; break = JsonToken.VALUE_STRING;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n                 // Also: must skip following END_ELEMENT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "_currText = _parsingContext.getText(); _currText = JsonToken.VALUE_STRING; break = JsonToken.getText;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonXml-3/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\t2022-07-19 17:25:24.545117410 +0200\n+++ /tmp/tmplyzrqerr.java\t2022-07-19 17:25:24.545117410 +0200\n@@ -664,13 +664,11 @@\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _currToken = JsonToken.FIELD_NAME;\n             }\n             break;\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n-            _currText = _xmlTokens.getText();\n-            _currToken = JsonToken.VALUE_STRING;\n-            break;\n+_currText = _parsingContext.getText(); _currText = JsonToken.VALUE_STRING; break = JsonToken.getText;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n                 // Also: must skip following END_ELEMENT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "_currText = _parsingContext.getText(); _currText = JsonToken.VALUE_STRING; break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonXml-3/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\t2022-07-19 17:25:26.209111198 +0200\n+++ /tmp/tmpdysa0ta9.java\t2022-07-19 17:25:26.213111182 +0200\n@@ -664,13 +664,11 @@\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _currToken = JsonToken.FIELD_NAME;\n             }\n             break;\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n-            _currText = _xmlTokens.getText();\n-            _currToken = JsonToken.VALUE_STRING;\n-            break;\n+_currText = _parsingContext.getText(); _currText = JsonToken.VALUE_STRING; break;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n                 // Also: must skip following END_ELEMENT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "_currText = _parsingContext.getText(); break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonXml-3/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\t2022-07-19 17:25:28.061104275 +0200\n+++ /tmp/tmprzd8x270.java\t2022-07-19 17:25:28.061104275 +0200\n@@ -664,13 +664,11 @@\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _currToken = JsonToken.FIELD_NAME;\n             }\n             break;\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n-            _currText = _xmlTokens.getText();\n-            _currToken = JsonToken.VALUE_STRING;\n-            break;\n+_currText = _parsingContext.getText(); break;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n                 // Also: must skip following END_ELEMENT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "_currText = JsonToken.VALUE_STRING; break = JsonToken.VALUE_STRING;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonXml-3/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\t2022-07-19 17:25:29.809097731 +0200\n+++ /tmp/tmpzylirab5.java\t2022-07-19 17:25:29.809097731 +0200\n@@ -664,13 +664,11 @@\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _currToken = JsonToken.FIELD_NAME;\n             }\n             break;\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n-            _currText = _xmlTokens.getText();\n-            _currToken = JsonToken.VALUE_STRING;\n-            break;\n+_currText = JsonToken.VALUE_STRING; break = JsonToken.VALUE_STRING;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n                 // Also: must skip following END_ELEMENT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "_currText = _parsingContext.getText; break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonXml-3/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\t2022-07-19 17:25:31.353091943 +0200\n+++ /tmp/tmp1pjk5k5n.java\t2022-07-19 17:25:31.353091943 +0200\n@@ -664,13 +664,11 @@\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _currToken = JsonToken.FIELD_NAME;\n             }\n             break;\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n-            _currText = _xmlTokens.getText();\n-            _currToken = JsonToken.VALUE_STRING;\n-            break;\n+_currText = _parsingContext.getText; break;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n                 // Also: must skip following END_ELEMENT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "_currText = _currText; break = JsonToken.VALUE_STRING;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonXml-3/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\t2022-07-19 17:25:33.185085071 +0200\n+++ /tmp/tmp143n2bd2.java\t2022-07-19 17:25:33.185085071 +0200\n@@ -664,13 +664,11 @@\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _currToken = JsonToken.FIELD_NAME;\n             }\n             break;\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n-            _currText = _xmlTokens.getText();\n-            _currToken = JsonToken.VALUE_STRING;\n-            break;\n+_currText = _currText; break = JsonToken.VALUE_STRING;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n                 // Also: must skip following END_ELEMENT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "_currText = _parsingContext.getText(); _parsingContext = JsonToken.VALUE_STRING; break = JsonToken.VALUE_STRING;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonXml-3/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\t2022-07-19 17:25:34.673079483 +0200\n+++ /tmp/tmpd3w87may.java\t2022-07-19 17:25:34.677079466 +0200\n@@ -664,13 +664,11 @@\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _currToken = JsonToken.FIELD_NAME;\n             }\n             break;\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n-            _currText = _xmlTokens.getText();\n-            _currToken = JsonToken.VALUE_STRING;\n-            break;\n+_currText = _parsingContext.getText(); _parsingContext = JsonToken.VALUE_STRING; break = JsonToken.VALUE_STRING;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n                 // Also: must skip following END_ELEMENT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "_currText = _parsingContext.getText(); _currText = JsonToken.VALUE_STRING; break, JsonToken.VALUE_STRING;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonXml-3/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\t2022-07-19 17:25:36.185073797 +0200\n+++ /tmp/tmprjx_tc8q.java\t2022-07-19 17:25:36.185073797 +0200\n@@ -664,13 +664,11 @@\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _currToken = JsonToken.FIELD_NAME;\n             }\n             break;\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n-            _currText = _xmlTokens.getText();\n-            _currToken = JsonToken.VALUE_STRING;\n-            break;\n+_currText = _parsingContext.getText(); _currText = JsonToken.VALUE_STRING; break, JsonToken.VALUE_STRING;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n                 // Also: must skip following END_ELEMENT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "_currText = _parsingContext.getText(); _currText = JsonToken.VALUE_STRING; break = JsonToken.START_OBJECT;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonXml-3/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\t2022-07-19 17:25:37.917067276 +0200\n+++ /tmp/tmplpqz36lz.java\t2022-07-19 17:25:37.917067276 +0200\n@@ -664,13 +664,11 @@\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _currToken = JsonToken.FIELD_NAME;\n             }\n             break;\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n-            _currText = _xmlTokens.getText();\n-            _currToken = JsonToken.VALUE_STRING;\n-            break;\n+_currText = _parsingContext.getText(); _currText = JsonToken.VALUE_STRING; break = JsonToken.START_OBJECT;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n                 // Also: must skip following END_ELEMENT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "_currText = _xmlTokens.getText(); _currToken = JsonToken.VALUE_STRING; break;",
        "fixed_line": "return (_currText = _xmlTokens.getText());"
    },
    "JacksonDatabind-34": {
        "fixes": [
            {
                "k": 1,
                "patch": "visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-34/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\t2022-07-19 17:25:39.849059989 +0200\n+++ /tmp/tmpoo4_vu5g.java\t2022-07-19 17:25:39.881059872 +0200\n@@ -76,11 +76,11 @@\n         if (_isInt) {\n             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER;\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "visitFloatFormat(typeHint, h, JsonParser.NumberType.BIG_INTEGER;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-34/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\t2022-07-19 17:25:42.097051507 +0200\n+++ /tmp/tmp89bdh_wp.java\t2022-07-19 17:25:42.097051507 +0200\n@@ -76,11 +76,11 @@\n         if (_isInt) {\n             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+visitFloatFormat(typeHint, h, JsonParser.NumberType.BIG_INTEGER;\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-34/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\t2022-07-19 17:25:43.737045307 +0200\n+++ /tmp/tmp7polwz08.java\t2022-07-19 17:25:43.737045307 +0200\n@@ -76,11 +76,11 @@\n         if (_isInt) {\n             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER)\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "visitFloatFormat(typeHint, _typeHint, JsonParser.NumberType.BIG_INTEGER;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-34/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\t2022-07-19 17:25:45.485038691 +0200\n+++ /tmp/tmp75bngf3n.java\t2022-07-19 17:25:45.485038691 +0200\n@@ -76,11 +76,11 @@\n         if (_isInt) {\n             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+visitFloatFormat(typeHint, _typeHint, JsonParser.NumberType.BIG_INTEGER;\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER =",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-34/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\t2022-07-19 17:25:47.149032385 +0200\n+++ /tmp/tmp4ufzsozv.java\t2022-07-19 17:25:47.149032385 +0200\n@@ -76,11 +76,11 @@\n         if (_isInt) {\n             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER =\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "visitFloatFormat = _typeHint, h, JsonParser.NumberType.BIG_INTEGER;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-34/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\t2022-07-19 17:25:48.933025620 +0200\n+++ /tmp/tmpzlmcrmo2.java\t2022-07-19 17:25:48.933025620 +0200\n@@ -76,11 +76,11 @@\n         if (_isInt) {\n             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+visitFloatFormat = _typeHint, h, JsonParser.NumberType.BIG_INTEGER;\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "visitFloatFormat(typeHint, h, JsonParser.NumberType.BIG_INTEGER);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-34/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\t2022-07-19 17:25:50.561019436 +0200\n+++ /tmp/tmpyrk9egi4.java\t2022-07-19 17:25:50.561019436 +0200\n@@ -76,11 +76,11 @@\n         if (_isInt) {\n             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+visitFloatFormat(typeHint, h, JsonParser.NumberType.BIG_INTEGER);\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-34/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\t2022-07-19 17:25:52.585011739 +0200\n+++ /tmp/tmphlxq_o3c.java\t2022-07-19 17:25:52.585011739 +0200\n@@ -76,11 +76,11 @@\n         if (_isInt) {\n             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "visitFloatFormat (visitor, typeHint, JsonParser.NumberType.BIG_INTEGER;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-34/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\t2022-07-19 17:26:41.300823436 +0200\n+++ /tmp/tmpk5_h5aad.java\t2022-07-19 17:26:41.300823436 +0200\n@@ -76,11 +76,11 @@\n         if (_isInt) {\n             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+visitFloatFormat (visitor, typeHint, JsonParser.NumberType.BIG_INTEGER;\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "visitFloatFormat = _typeHint, h, JsonParser.NumberType.BIG_INTEGER);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-34/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\t2022-07-19 17:26:43.968812964 +0200\n+++ /tmp/tmp4j3ny1dd.java\t2022-07-19 17:26:43.968812964 +0200\n@@ -76,11 +76,11 @@\n         if (_isInt) {\n             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+visitFloatFormat = _typeHint, h, JsonParser.NumberType.BIG_INTEGER);\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);",
        "fixed_line": "visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);"
    },
    "Codec-4": {
        "fixes": [
            {
                "k": 1,
                "patch": "this(DEFAULT_TABLE_SIZE);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-4/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 17:26:46.464803142 +0200\n+++ /tmp/tmpdxrh31ju.java\t2022-07-19 17:26:46.740802056 +0200\n@@ -220,11 +220,11 @@\n      * <p>\n      * When decoding all variants are supported.\n      * </p>\n      */\n     public Base64() {\n-        this(false);\n+this(DEFAULT_TABLE_SIZE);\n     }\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "this(DEFAULT_TABLE_SIZE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-4/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 17:26:49.480791264 +0200\n+++ /tmp/tmp387ow5eb.java\t2022-07-19 17:26:49.480791264 +0200\n@@ -220,11 +220,11 @@\n      * <p>\n      * When decoding all variants are supported.\n      * </p>\n      */\n     public Base64() {\n-        this(false);\n+this(DEFAULT_TABLE_SIZE;\n     }\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "this(DEFAULT_MAXIMUM_CACHE_SIZE);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-4/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 17:26:52.072781041 +0200\n+++ /tmp/tmp_i5gphh4.java\t2022-07-19 17:26:52.240780374 +0200\n@@ -220,11 +220,11 @@\n      * <p>\n      * When decoding all variants are supported.\n      * </p>\n      */\n     public Base64() {\n-        this(false);\n+this(DEFAULT_MAXIMUM_CACHE_SIZE);\n     }\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "this(DEFAULT_MAXIMUM_CACHE_SIZE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-4/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 17:26:54.912769817 +0200\n+++ /tmp/tmppkqq2a4s.java\t2022-07-19 17:26:54.916769801 +0200\n@@ -220,11 +220,11 @@\n      * <p>\n      * When decoding all variants are supported.\n      * </p>\n      */\n     public Base64() {\n-        this(false);\n+this(DEFAULT_MAXIMUM_CACHE_SIZE;\n     }\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "this(true);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-4/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 17:26:57.688758829 +0200\n+++ /tmp/tmph9d6so8i.java\t2022-07-19 17:26:57.720758702 +0200\n@@ -220,11 +220,11 @@\n      * <p>\n      * When decoding all variants are supported.\n      * </p>\n      */\n     public Base64() {\n-        this(false);\n+this(true);\n     }\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "this(false);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-4/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 17:27:04.096733395 +0200\n+++ /tmp/tmpijxtqhum.java\t2022-07-19 17:27:04.096733395 +0200\n@@ -220,11 +220,11 @@\n      * <p>\n      * When decoding all variants are supported.\n      * </p>\n      */\n     public Base64() {\n-        this(false);\n+this(false);\n     }\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "this(DEFAULT_MAXIMUM_VALUE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-4/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 17:27:09.532711751 +0200\n+++ /tmp/tmp4lq58ypt.java\t2022-07-19 17:27:09.532711751 +0200\n@@ -220,11 +220,11 @@\n      * <p>\n      * When decoding all variants are supported.\n      * </p>\n      */\n     public Base64() {\n-        this(false);\n+this(DEFAULT_MAXIMUM_VALUE;\n     }\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "this(false;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-4/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 17:27:11.792702734 +0200\n+++ /tmp/tmplrfydlpk.java\t2022-07-19 17:27:11.792702734 +0200\n@@ -220,11 +220,11 @@\n      * <p>\n      * When decoding all variants are supported.\n      * </p>\n      */\n     public Base64() {\n-        this(false);\n+this(false;\n     }\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "this(true;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-4/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 17:27:14.120693434 +0200\n+++ /tmp/tmp99gervp1.java\t2022-07-19 17:27:14.120693434 +0200\n@@ -220,11 +220,11 @@\n      * <p>\n      * When decoding all variants are supported.\n      * </p>\n      */\n     public Base64() {\n-        this(false);\n+this(true;\n     }\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "this.true;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-4/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 17:27:16.812682665 +0200\n+++ /tmp/tmprektwaui.java\t2022-07-19 17:27:16.812682665 +0200\n@@ -220,11 +220,11 @@\n      * <p>\n      * When decoding all variants are supported.\n      * </p>\n      */\n     public Base64() {\n-        this(false);\n+this.true;\n     }\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "this(false);",
        "fixed_line": "this(0);"
    },
    "JacksonDatabind-44": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if (subclass == _typeFactory.class) { // can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "// if (subclass == _typeFactory.class) { // can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// if (tatu: declaredType.isAssignableFrom(subclass, _typeHandler, _asStatic);",
                "patch_diff": "// if (tatu: declaredType.isAssignableFrom(subclass, _typeHandler, _asStatic);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if (subclass == _typeFactory.class) { // can't really modify it's do implicit re-parse",
                "patch_diff": "// if (subclass == _typeFactory.class) { // can't really modify it's do implicit re-parse",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// if (subclass == _typeFactory.class) { // can't really modify it was non-literal characters that might be valid (empty be // can't really modify it's do implicit re-parse",
                "patch_diff": "// if (subclass == _typeFactory.class) { // can't really modify it was non-literal characters that might be valid (empty be // can't really modify it's do implicit re-parse",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// if (subclass == _typeFactory.class) { // can't really modify it was non-literal characters that might be valid (empty be",
                "patch_diff": "// if (subclass == _typeFactory.class) { // can't really modify it was non-literal characters that might be valid (empty be",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if (subclass == _typeFactory.class) { // can't really modify it was non-literal characters that might be valid (empty be // can't really modify it was non-literal characters that might be valid (empty be",
                "patch_diff": "// if (subclass == _typeFactory.class) { // can't really modify it was non-literal characters that might be valid (empty be // can't really modify it was non-literal characters that might be valid (empty be",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// if (subclass == _typeFactory.class) { // can't really modify it was non-literal characters that might be valid (empty be // can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "patch_diff": "// if (subclass == _typeFactory.class) { // can't really modify it was non-literal characters that might be valid (empty be // can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// if (subclass == _typeFactory.class) { // can't really modify it was non-literal characters that might be valid (empty be // can't really modify it was non-literal characters that might be valid (empty be valid)",
                "patch_diff": "// if (subclass == _typeFactory.class) { // can't really modify it was non-literal characters that might be valid (empty be // can't really modify it was non-literal characters that might be valid (empty be valid)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// if (subclass == _typeFactory.class) { // can't really modify it was non-literal characters that might be valid (empty be // need to check",
                "patch_diff": "// if (subclass == _typeFactory.class) { // can't really modify it was non-literal characters that might be valid (empty be // need to check",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if (subclass == _typeFactory.class) { // can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "patch_diff": "// if (subclass == _typeFactory.class) { // can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (!_class.isAssignableFrom(subclass)) { /* throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \" +_class.getName()); */ return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic); } // Otherwise, stitch together the hierarchy. First, super-class Class<?> next = subclass.getSuperclass(); if (next == _class) { // straight up parent class? Great. return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic); } if ((next != null) && _class.isAssignableFrom(next)) { JavaType superb = _narrow(next); return new SimpleType(subclass, _bindings, superb, null, _valueHandler, _typeHandler, _asStatic); } // if not found, try a super-interface Class<?>[] nextI = subclass.getInterfaces(); for (Class<?> iface : nextI) { if (iface == _class) { // directly implemented return new SimpleType(subclass, _bindings, null, new JavaType[] { this }, _valueHandler, _typeHandler, _asStatic); } if (_class.isAssignableFrom(iface)) { // indirect, so recurse JavaType superb = _narrow(iface); return new SimpleType(subclass, _bindings, null, new JavaType[] { superb }, _valueHandler, _typeHandler, _asStatic); } } // should not get here but... throw new IllegalArgumentException(\"Internal error: Can not resolve sub-type for Class \"+subclass.getName()+\" to \" +_class.getName());"
    },
    "Chart-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "PathIterator iterator2 = p2.getPathIterator(p1.getPathIterators2);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-11/source/org/jfree/chart/util/ShapeUtilities.java\t2022-07-19 17:27:22.580659532 +0200\n+++ /tmp/tmp2977e4u8.java\t2022-07-19 17:27:22.788658689 +0200\n@@ -270,11 +270,11 @@\n         }\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+PathIterator iterator2 = p2.getPathIterator(p1.getPathIterators2);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n         while (!done) {\n             if (iterator1.isDone() != iterator2.isDone()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "PathIterator iterator2 = p2.getPathIterator(p1.getPathIterator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-11/source/org/jfree/chart/util/ShapeUtilities.java\t2022-07-19 17:27:25.944646016 +0200\n+++ /tmp/tmpweweyagx.java\t2022-07-19 17:27:25.948646000 +0200\n@@ -270,11 +270,11 @@\n         }\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+PathIterator iterator2 = p2.getPathIterator(p1.getPathIterator;\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n         while (!done) {\n             if (iterator1.isDone() != iterator2.isDone()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "PathIterator iterator2 = p2.getPathIterator(q2);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-11/source/org/jfree/chart/util/ShapeUtilities.java\t2022-07-19 17:27:28.320636452 +0200\n+++ /tmp/tmpv27h_boq.java\t2022-07-19 17:27:28.320636452 +0200\n@@ -270,11 +270,11 @@\n         }\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+PathIterator iterator2 = p2.getPathIterator(q2);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n         while (!done) {\n             if (iterator1.isDone() != iterator2.isDone()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "PathIterator iterator2 = p1.getPathIterator(p2.getPathIterators2);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-11/source/org/jfree/chart/util/ShapeUtilities.java\t2022-07-19 17:27:30.480627746 +0200\n+++ /tmp/tmpdhjl15zc.java\t2022-07-19 17:27:30.484627730 +0200\n@@ -270,11 +270,11 @@\n         }\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+PathIterator iterator2 = p1.getPathIterator(p2.getPathIterators2);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n         while (!done) {\n             if (iterator1.isDone() != iterator2.isDone()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "PathIterator iterator2 = p1.getPathIterator(p2.getPathIterator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-11/source/org/jfree/chart/util/ShapeUtilities.java\t2022-07-19 17:27:33.092617207 +0200\n+++ /tmp/tmpnu1tl0l_.java\t2022-07-19 17:27:33.092617207 +0200\n@@ -270,11 +270,11 @@\n         }\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+PathIterator iterator2 = p1.getPathIterator(p2.getPathIterator;\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n         while (!done) {\n             if (iterator1.isDone() != iterator2.isDone()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "PathIterator iterator2 = p2.getPathIterator(args2);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-11/source/org/jfree/chart/util/ShapeUtilities.java\t2022-07-19 17:27:35.196608706 +0200\n+++ /tmp/tmp9zhf4a2_.java\t2022-07-19 17:27:35.256608463 +0200\n@@ -270,11 +270,11 @@\n         }\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+PathIterator iterator2 = p2.getPathIterator(args2);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n         while (!done) {\n             if (iterator1.isDone() != iterator2.isDone()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "PathIterator iterator2 = p2.getPathIterator(null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-11/source/org/jfree/chart/util/ShapeUtilities.java\t2022-07-19 17:27:37.436599644 +0200\n+++ /tmp/tmpx3_j64uz.java\t2022-07-19 17:27:37.436599644 +0200\n@@ -270,11 +270,11 @@\n         }\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+PathIterator iterator2 = p2.getPathIterator(null);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n         while (!done) {\n             if (iterator1.isDone() != iterator2.isDone()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 8,
                "patch": "PathIterator iterator2 = p2.getPathIterator(q1.getPathIterator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-11/source/org/jfree/chart/util/ShapeUtilities.java\t2022-07-19 17:27:47.320559542 +0200\n+++ /tmp/tmp1mw841br.java\t2022-07-19 17:27:47.320559542 +0200\n@@ -270,11 +270,11 @@\n         }\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+PathIterator iterator2 = p2.getPathIterator(q1.getPathIterator;\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n         while (!done) {\n             if (iterator1.isDone() != iterator2.isDone()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "PathIterator iterator2 = p1.getPathIterator(q2.getPathIterator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-11/source/org/jfree/chart/util/ShapeUtilities.java\t2022-07-19 17:27:48.936552967 +0200\n+++ /tmp/tmp8z1f5a8x.java\t2022-07-19 17:27:48.936552967 +0200\n@@ -270,11 +270,11 @@\n         }\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+PathIterator iterator2 = p1.getPathIterator(q2.getPathIterator;\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n         while (!done) {\n             if (iterator1.isDone() != iterator2.isDone()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "PathIterator iterator2 = p1.getPathIterator(q2.getPathIterators2);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-11/source/org/jfree/chart/util/ShapeUtilities.java\t2022-07-19 17:27:50.524546500 +0200\n+++ /tmp/tmpitk7mgeo.java\t2022-07-19 17:27:50.524546500 +0200\n@@ -270,11 +270,11 @@\n         }\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+PathIterator iterator2 = p1.getPathIterator(q2.getPathIterators2);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n         while (!done) {\n             if (iterator1.isDone() != iterator2.isDone()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "PathIterator iterator2 = p1.getPathIterator(null);",
        "fixed_line": "PathIterator iterator2 = p2.getPathIterator(null);"
    },
    "JacksonDatabind-97": {
        "fixes": [
            {
                "k": 1,
                "patch": "gen.writeObject(_value); // value is this to 0",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-97/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\t2022-07-19 17:27:52.384538916 +0200\n+++ /tmp/tmpt8yvrrxr.java\t2022-07-19 17:27:52.420538771 +0200\n@@ -109,11 +109,11 @@\n         } else if (_value instanceof JsonSerializable) {\n             ((JsonSerializable) _value).serialize(gen, ctxt);\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            gen.writeObject(_value);\n+gen.writeObject(_value); // value is this to 0\n         }\n     }\n \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "gen.writeObject(_value); // value is lower case",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-97/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\t2022-07-19 17:28:50.808297358 +0200\n+++ /tmp/tmph84itrnh.java\t2022-07-19 17:28:50.812297343 +0200\n@@ -109,11 +109,11 @@\n         } else if (_value instanceof JsonSerializable) {\n             ((JsonSerializable) _value).serialize(gen, ctxt);\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            gen.writeObject(_value);\n+gen.writeObject(_value); // value is lower case\n         }\n     }\n \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "gen.writeObject(_value, instance);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-97/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\t2022-07-19 17:29:44.396070363 +0200\n+++ /tmp/tmpeld1arn6.java\t2022-07-19 17:29:44.396070363 +0200\n@@ -109,11 +109,11 @@\n         } else if (_value instanceof JsonSerializable) {\n             ((JsonSerializable) _value).serialize(gen, ctxt);\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            gen.writeObject(_value);\n+gen.writeObject(_value, instance);\n         }\n     }\n \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "gen.writeObject(_valueInputRow;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-97/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\t2022-07-19 17:29:46.144062879 +0200\n+++ /tmp/tmp1vsqytl9.java\t2022-07-19 17:29:46.144062879 +0200\n@@ -109,11 +109,11 @@\n         } else if (_value instanceof JsonSerializable) {\n             ((JsonSerializable) _value).serialize(gen, ctxt);\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            gen.writeObject(_value);\n+gen.writeObject(_valueInputRow;\n         }\n     }\n \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "gen.writeObject(_value); // value is to 0",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-97/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\t2022-07-19 17:29:47.756055972 +0200\n+++ /tmp/tmp4q6w3dge.java\t2022-07-19 17:29:47.756055972 +0200\n@@ -109,11 +109,11 @@\n         } else if (_value instanceof JsonSerializable) {\n             ((JsonSerializable) _value).serialize(gen, ctxt);\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            gen.writeObject(_value);\n+gen.writeObject(_value); // value is to 0\n         }\n     }\n \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "gen.writeObject(_valueType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-97/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\t2022-07-19 17:30:42.375819525 +0200\n+++ /tmp/tmpasnabx5m.java\t2022-07-19 17:30:42.375819525 +0200\n@@ -109,11 +109,11 @@\n         } else if (_value instanceof JsonSerializable) {\n             ((JsonSerializable) _value).serialize(gen, ctxt);\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            gen.writeObject(_value);\n+gen.writeObject(_valueType;\n         }\n     }\n \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "gen.writeObject(_value); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-97/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\t2022-07-19 17:30:43.975812532 +0200\n+++ /tmp/tmp23ju31ia.java\t2022-07-19 17:30:43.975812532 +0200\n@@ -109,11 +109,11 @@\n         } else if (_value instanceof JsonSerializable) {\n             ((JsonSerializable) _value).serialize(gen, ctxt);\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            gen.writeObject(_value);\n+gen.writeObject(_value); }\n         }\n     }\n \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "gen.writeObject(_value instanceof gen;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-97/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\t2022-07-19 17:30:45.547805656 +0200\n+++ /tmp/tmp20kh87ne.java\t2022-07-19 17:30:45.547805656 +0200\n@@ -109,11 +109,11 @@\n         } else if (_value instanceof JsonSerializable) {\n             ((JsonSerializable) _value).serialize(gen, ctxt);\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            gen.writeObject(_value);\n+gen.writeObject(_value instanceof gen;\n         }\n     }\n \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "gen.writeObject(_value);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-97/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\t2022-07-19 17:30:47.071798988 +0200\n+++ /tmp/tmpapj8p5dt.java\t2022-07-19 17:30:47.075798970 +0200\n@@ -109,11 +109,11 @@\n         } else if (_value instanceof JsonSerializable) {\n             ((JsonSerializable) _value).serialize(gen, ctxt);\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            gen.writeObject(_value);\n+gen.writeObject(_value);\n         }\n     }\n \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "gen.writeObject(_value;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-97/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\t2022-07-19 17:31:41.975556600 +0200\n+++ /tmp/tmpewaeh3hh.java\t2022-07-19 17:31:41.975556600 +0200\n@@ -109,11 +109,11 @@\n         } else if (_value instanceof JsonSerializable) {\n             ((JsonSerializable) _value).serialize(gen, ctxt);\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            gen.writeObject(_value);\n+gen.writeObject(_value;\n         }\n     }\n \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "gen.writeObject(_value);",
        "fixed_line": "ctxt.defaultSerializeValue(_value, gen);"
    },
    "JacksonDatabind-91": {
        "fixes": [
            {
                "k": 1,
                "patch": "return (ct.getValueHandler!= null && (ct.getTypeHandler!= null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-91/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\t2022-07-19 17:31:43.767548620 +0200\n+++ /tmp/tmpa407u0h6.java\t2022-07-19 17:31:43.803548457 +0200\n@@ -536,11 +536,11 @@\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+return (ct.getValueHandler!= null && (ct.getTypeHandler!= null);\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n             }\n         }\n         return false;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return (ct.getValueHandler!= null &&ct.getTypeHandler()!= null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-91/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\t2022-07-19 17:31:45.947538908 +0200\n+++ /tmp/tmppze5rkjw.java\t2022-07-19 17:31:45.947538908 +0200\n@@ -536,11 +536,11 @@\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+return (ct.getValueHandler!= null &&ct.getTypeHandler()!= null);\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n             }\n         }\n         return false;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return (ct.getValueHandler!= null && (ct.getTypeHandler()!= null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-91/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\t2022-07-19 17:31:48.027529635 +0200\n+++ /tmp/tmpxkfh29it.java\t2022-07-19 17:31:48.027529635 +0200\n@@ -536,11 +536,11 @@\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+return (ct.getValueHandler!= null && (ct.getTypeHandler()!= null);\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n             }\n         }\n         return false;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return (ct.getValueHandler!= null && (ct.getTypeHandler)!= null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-91/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\t2022-07-19 17:31:49.643522428 +0200\n+++ /tmp/tmpvphejrhg.java\t2022-07-19 17:31:49.643522428 +0200\n@@ -536,11 +536,11 @@\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+return (ct.getValueHandler!= null && (ct.getTypeHandler)!= null);\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n             }\n         }\n         return false;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return (ct.getValueHandler!= null && (ct.getTypeHandler() == null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-91/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\t2022-07-19 17:31:51.367514735 +0200\n+++ /tmp/tmp_kkz8g1x.java\t2022-07-19 17:31:51.367514735 +0200\n@@ -536,11 +536,11 @@\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+return (ct.getValueHandler!= null && (ct.getTypeHandler() == null);\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n             }\n         }\n         return false;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return (ct.getValueHandler!= null &&ct.getTypeHandler() == null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-91/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\t2022-07-19 17:31:52.939507716 +0200\n+++ /tmp/tmpo4awglhx.java\t2022-07-19 17:31:52.939507716 +0200\n@@ -536,11 +536,11 @@\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+return (ct.getValueHandler!= null &&ct.getTypeHandler() == null);\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n             }\n         }\n         return false;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return (ct.getValueHandler!= null) || (ct.getTypeHandler()!= null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-91/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\t2022-07-19 17:31:54.655500052 +0200\n+++ /tmp/tmp_4tklx24.java\t2022-07-19 17:31:54.659500034 +0200\n@@ -536,11 +536,11 @@\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+return (ct.getValueHandler!= null) || (ct.getTypeHandler()!= null);\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n             }\n         }\n         return false;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return (ct.getValueHandler!= null) || (ct.getTypeHandler!= null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-91/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\t2022-07-19 17:31:56.427492134 +0200\n+++ /tmp/tmpj1wwyudu.java\t2022-07-19 17:31:56.427492134 +0200\n@@ -536,11 +536,11 @@\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+return (ct.getValueHandler!= null) || (ct.getTypeHandler!= null);\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n             }\n         }\n         return false;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return (ct.getValueHandler()!= null) || (ct.getTypeHandler()!= null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-91/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\t2022-07-19 17:31:58.151484425 +0200\n+++ /tmp/tmp3fc7bang.java\t2022-07-19 17:31:58.155484408 +0200\n@@ -536,11 +536,11 @@\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+return (ct.getValueHandler()!= null) || (ct.getTypeHandler()!= null);\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n             }\n         }\n         return false;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return (ct.getValueHandler()!= null) || (ct.getTypeHandler!= null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-91/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\t2022-07-19 17:32:43.251281505 +0200\n+++ /tmp/tmp5t67zmhr.java\t2022-07-19 17:32:43.279281379 +0200\n@@ -536,11 +536,11 @@\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+return (ct.getValueHandler()!= null) || (ct.getTypeHandler!= null);\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n             }\n         }\n         return false;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);",
        "fixed_line": "if ((ct.getValueHandler() != null) || (ct.getTypeHandler() != null)) { return true; } } // Second: map(-like) types may have value handler for key (but not type; keys are untyped) if (t.isMapLikeType()) { JavaType kt = t.getKeyType(); if (kt.getValueHandler() != null) { return true; }"
    },
    "Closure-8": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int i = 0; i < scope.getScope; i++) {",
                "patch_diff": "for (int i = 0; i < scope.getScope; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = 0; i < s.getString; i++) {",
                "patch_diff": "for (int i = 0; i < s.getString; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0; i < var.length; i++) {",
                "patch_diff": "for (int i = 0; i < var.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = 0; i < scope.getScope() &&!blacklistedVars.contains(var;",
                "patch_diff": "for (int i = 0; i < scope.getScope() &&!blacklistedVars.contains(var;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = 0; i < scope.getScope() &&!blacklistedVars.contains(var)) {",
                "patch_diff": "for (int i = 0; i < scope.getScope() &&!blacklistedVars.contains(var)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = 0; i < s.length; i++) {",
                "patch_diff": "for (int i = 0; i < s.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = 0; i < scope.getScope() &&!blacklistedVars.contains(var); }",
                "patch_diff": "for (int i = 0; i < scope.getScope() &&!blacklistedVars.contains(var); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = 0; i < var.getScope() &&!blacklistedVars.contains(var;",
                "patch_diff": "for (int i = 0; i < var.getScope() &&!blacklistedVars.contains(var;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int i = 0; i < var.getScope() &&!blacklistedVars.contains(var)) {",
                "patch_diff": "for (int i = 0; i < var.getScope() &&!blacklistedVars.contains(var)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = 0; i < scope.getScope() &&!blacklistedVars.contains(var);",
                "patch_diff": "for (int i = 0; i < scope.getScope() &&!blacklistedVars.contains(var);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "&& !isNamedParameter(var) && !blacklistedVars.contains(var); } } private boolean isNamedParameter(Var v) { return v.getParentNode().isParamList(); }"
    },
    "JacksonDatabind-85": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (m == JsonFormat.Shape.OBJECT || format.hasPattern;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-85/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 17:32:46.855265185 +0200\n+++ /tmp/tmp4_rnxez9.java\t2022-07-19 17:32:46.879265076 +0200\n@@ -62,38 +62,11 @@\n             return withFormat(Boolean.TRUE, null);\n         }\n \n         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n         // First: custom pattern will override things\n-                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n-                                || format.hasLocale() || format.hasTimeZone()) {\n-                    TimeZone tz = format.getTimeZone();\n-                    final String pattern = format.hasPattern()\n-                                    ? format.getPattern()\n-                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n-            final Locale loc = format.hasLocale()\n-                            ? format.getLocale()\n-                            : serializers.getLocale();\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n-                    if (tz == null) {\n-                        tz = serializers.getTimeZone();\n-                    }\n-            df.setTimeZone(tz);\n-            return withFormat(Boolean.FALSE, df);\n-        }\n-\n-        // Otherwise, need one of these changes:\n-\n-\n-        // Jackson's own `StdDateFormat` is quite easy to deal with...\n-\n-        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-        //    So: require it be `SimpleDateFormat`; can't config other types\n-//            serializers.reportBadDefinition(handledType(), String.format(\n-            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        return this;\n+if (m == JsonFormat.Shape.OBJECT || format.hasPattern;\n     }\n \n     /*\n     /**********************************************************\n     /* Accessors\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (format == JsonFormat.Shape.OBJECT || format.hasPattern;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-85/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 17:32:48.843256179 +0200\n+++ /tmp/tmpkz58wga3.java\t2022-07-19 17:32:48.843256179 +0200\n@@ -62,38 +62,11 @@\n             return withFormat(Boolean.TRUE, null);\n         }\n \n         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n         // First: custom pattern will override things\n-                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n-                                || format.hasLocale() || format.hasTimeZone()) {\n-                    TimeZone tz = format.getTimeZone();\n-                    final String pattern = format.hasPattern()\n-                                    ? format.getPattern()\n-                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n-            final Locale loc = format.hasLocale()\n-                            ? format.getLocale()\n-                            : serializers.getLocale();\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n-                    if (tz == null) {\n-                        tz = serializers.getTimeZone();\n-                    }\n-            df.setTimeZone(tz);\n-            return withFormat(Boolean.FALSE, df);\n-        }\n-\n-        // Otherwise, need one of these changes:\n-\n-\n-        // Jackson's own `StdDateFormat` is quite easy to deal with...\n-\n-        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-        //    So: require it be `SimpleDateFormat`; can't config other types\n-//            serializers.reportBadDefinition(handledType(), String.format(\n-            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        return this;\n+if (format == JsonFormat.Shape.OBJECT || format.hasPattern;\n     }\n \n     /*\n     /**********************************************************\n     /* Accessors\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (m == JsonFormat.Shape.OBJECT || format.hasPattern) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-85/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 17:32:50.391249163 +0200\n+++ /tmp/tmp4hu8x207.java\t2022-07-19 17:32:50.391249163 +0200\n@@ -62,38 +62,11 @@\n             return withFormat(Boolean.TRUE, null);\n         }\n \n         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n         // First: custom pattern will override things\n-                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n-                                || format.hasLocale() || format.hasTimeZone()) {\n-                    TimeZone tz = format.getTimeZone();\n-                    final String pattern = format.hasPattern()\n-                                    ? format.getPattern()\n-                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n-            final Locale loc = format.hasLocale()\n-                            ? format.getLocale()\n-                            : serializers.getLocale();\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n-                    if (tz == null) {\n-                        tz = serializers.getTimeZone();\n-                    }\n-            df.setTimeZone(tz);\n-            return withFormat(Boolean.FALSE, df);\n-        }\n-\n-        // Otherwise, need one of these changes:\n-\n-\n-        // Jackson's own `StdDateFormat` is quite easy to deal with...\n-\n-        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-        //    So: require it be `SimpleDateFormat`; can't config other types\n-//            serializers.reportBadDefinition(handledType(), String.format(\n-            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        return this;\n+if (m == JsonFormat.Shape.OBJECT || format.hasPattern) {\n     }\n \n     /*\n     /**********************************************************\n     /* Accessors\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (format == JsonFormat.Shape.OBJECT || format.hasPattern) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-85/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 17:32:51.875242431 +0200\n+++ /tmp/tmpgq00mwc9.java\t2022-07-19 17:32:51.875242431 +0200\n@@ -62,38 +62,11 @@\n             return withFormat(Boolean.TRUE, null);\n         }\n \n         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n         // First: custom pattern will override things\n-                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n-                                || format.hasLocale() || format.hasTimeZone()) {\n-                    TimeZone tz = format.getTimeZone();\n-                    final String pattern = format.hasPattern()\n-                                    ? format.getPattern()\n-                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n-            final Locale loc = format.hasLocale()\n-                            ? format.getLocale()\n-                            : serializers.getLocale();\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n-                    if (tz == null) {\n-                        tz = serializers.getTimeZone();\n-                    }\n-            df.setTimeZone(tz);\n-            return withFormat(Boolean.FALSE, df);\n-        }\n-\n-        // Otherwise, need one of these changes:\n-\n-\n-        // Jackson's own `StdDateFormat` is quite easy to deal with...\n-\n-        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-        //    So: require it be `SimpleDateFormat`; can't config other types\n-//            serializers.reportBadDefinition(handledType(), String.format(\n-            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        return this;\n+if (format == JsonFormat.Shape.OBJECT || format.hasPattern) {\n     }\n \n     /*\n     /**********************************************************\n     /* Accessors\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (m!= JsonFormat.Shape.STRING) || format.hasPattern;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-85/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 17:32:53.363235683 +0200\n+++ /tmp/tmpt7_fbole.java\t2022-07-19 17:32:53.367235662 +0200\n@@ -62,38 +62,11 @@\n             return withFormat(Boolean.TRUE, null);\n         }\n \n         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n         // First: custom pattern will override things\n-                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n-                                || format.hasLocale() || format.hasTimeZone()) {\n-                    TimeZone tz = format.getTimeZone();\n-                    final String pattern = format.hasPattern()\n-                                    ? format.getPattern()\n-                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n-            final Locale loc = format.hasLocale()\n-                            ? format.getLocale()\n-                            : serializers.getLocale();\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n-                    if (tz == null) {\n-                        tz = serializers.getTimeZone();\n-                    }\n-            df.setTimeZone(tz);\n-            return withFormat(Boolean.FALSE, df);\n-        }\n-\n-        // Otherwise, need one of these changes:\n-\n-\n-        // Jackson's own `StdDateFormat` is quite easy to deal with...\n-\n-        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-        //    So: require it be `SimpleDateFormat`; can't config other types\n-//            serializers.reportBadDefinition(handledType(), String.format(\n-            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        return this;\n+if (m!= JsonFormat.Shape.STRING) || format.hasPattern;\n     }\n \n     /*\n     /**********************************************************\n     /* Accessors\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (m!= JsonFormat.Shape.OBJECT || format.hasPattern;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-85/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 17:32:54.943228513 +0200\n+++ /tmp/tmp_vo0d1g3.java\t2022-07-19 17:32:54.947228492 +0200\n@@ -62,38 +62,11 @@\n             return withFormat(Boolean.TRUE, null);\n         }\n \n         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n         // First: custom pattern will override things\n-                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n-                                || format.hasLocale() || format.hasTimeZone()) {\n-                    TimeZone tz = format.getTimeZone();\n-                    final String pattern = format.hasPattern()\n-                                    ? format.getPattern()\n-                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n-            final Locale loc = format.hasLocale()\n-                            ? format.getLocale()\n-                            : serializers.getLocale();\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n-                    if (tz == null) {\n-                        tz = serializers.getTimeZone();\n-                    }\n-            df.setTimeZone(tz);\n-            return withFormat(Boolean.FALSE, df);\n-        }\n-\n-        // Otherwise, need one of these changes:\n-\n-\n-        // Jackson's own `StdDateFormat` is quite easy to deal with...\n-\n-        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-        //    So: require it be `SimpleDateFormat`; can't config other types\n-//            serializers.reportBadDefinition(handledType(), String.format(\n-            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        return this;\n+if (m!= JsonFormat.Shape.OBJECT || format.hasPattern;\n     }\n \n     /*\n     /**********************************************************\n     /* Accessors\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (format == JsonFormat.Shape.STRING) || format.hasPattern;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-85/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 17:32:56.475221555 +0200\n+++ /tmp/tmp6nzphejh.java\t2022-07-19 17:32:56.479221537 +0200\n@@ -62,38 +62,11 @@\n             return withFormat(Boolean.TRUE, null);\n         }\n \n         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n         // First: custom pattern will override things\n-                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n-                                || format.hasLocale() || format.hasTimeZone()) {\n-                    TimeZone tz = format.getTimeZone();\n-                    final String pattern = format.hasPattern()\n-                                    ? format.getPattern()\n-                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n-            final Locale loc = format.hasLocale()\n-                            ? format.getLocale()\n-                            : serializers.getLocale();\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n-                    if (tz == null) {\n-                        tz = serializers.getTimeZone();\n-                    }\n-            df.setTimeZone(tz);\n-            return withFormat(Boolean.FALSE, df);\n-        }\n-\n-        // Otherwise, need one of these changes:\n-\n-\n-        // Jackson's own `StdDateFormat` is quite easy to deal with...\n-\n-        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-        //    So: require it be `SimpleDateFormat`; can't config other types\n-//            serializers.reportBadDefinition(handledType(), String.format(\n-            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        return this;\n+if (format == JsonFormat.Shape.STRING) || format.hasPattern;\n     }\n \n     /*\n     /**********************************************************\n     /* Accessors\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (format == JsonFormat.Shape.STRING) && format.hasPattern;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-85/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 17:32:58.115214106 +0200\n+++ /tmp/tmpqhgm5qzp.java\t2022-07-19 17:32:58.115214106 +0200\n@@ -62,38 +62,11 @@\n             return withFormat(Boolean.TRUE, null);\n         }\n \n         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n         // First: custom pattern will override things\n-                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n-                                || format.hasLocale() || format.hasTimeZone()) {\n-                    TimeZone tz = format.getTimeZone();\n-                    final String pattern = format.hasPattern()\n-                                    ? format.getPattern()\n-                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n-            final Locale loc = format.hasLocale()\n-                            ? format.getLocale()\n-                            : serializers.getLocale();\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n-                    if (tz == null) {\n-                        tz = serializers.getTimeZone();\n-                    }\n-            df.setTimeZone(tz);\n-            return withFormat(Boolean.FALSE, df);\n-        }\n-\n-        // Otherwise, need one of these changes:\n-\n-\n-        // Jackson's own `StdDateFormat` is quite easy to deal with...\n-\n-        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-        //    So: require it be `SimpleDateFormat`; can't config other types\n-//            serializers.reportBadDefinition(handledType(), String.format(\n-            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        return this;\n+if (format == JsonFormat.Shape.STRING) && format.hasPattern;\n     }\n \n     /*\n     /**********************************************************\n     /* Accessors\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (m == JsonFormat.Shape.STRING) || format.hasPattern;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-85/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 17:32:59.703206893 +0200\n+++ /tmp/tmp0f5kbru3.java\t2022-07-19 17:32:59.703206893 +0200\n@@ -62,38 +62,11 @@\n             return withFormat(Boolean.TRUE, null);\n         }\n \n         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n         // First: custom pattern will override things\n-                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n-                                || format.hasLocale() || format.hasTimeZone()) {\n-                    TimeZone tz = format.getTimeZone();\n-                    final String pattern = format.hasPattern()\n-                                    ? format.getPattern()\n-                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n-            final Locale loc = format.hasLocale()\n-                            ? format.getLocale()\n-                            : serializers.getLocale();\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n-                    if (tz == null) {\n-                        tz = serializers.getTimeZone();\n-                    }\n-            df.setTimeZone(tz);\n-            return withFormat(Boolean.FALSE, df);\n-        }\n-\n-        // Otherwise, need one of these changes:\n-\n-\n-        // Jackson's own `StdDateFormat` is quite easy to deal with...\n-\n-        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-        //    So: require it be `SimpleDateFormat`; can't config other types\n-//            serializers.reportBadDefinition(handledType(), String.format(\n-            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        return this;\n+if (m == JsonFormat.Shape.STRING) || format.hasPattern;\n     }\n \n     /*\n     /**********************************************************\n     /* Accessors\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (m!= JsonFormat.Shape.OBJECT || format.hasPattern) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-85/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 17:33:01.271199764 +0200\n+++ /tmp/tmp4bjw5upp.java\t2022-07-19 17:33:01.271199764 +0200\n@@ -62,38 +62,11 @@\n             return withFormat(Boolean.TRUE, null);\n         }\n \n         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n         // First: custom pattern will override things\n-                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n-                                || format.hasLocale() || format.hasTimeZone()) {\n-                    TimeZone tz = format.getTimeZone();\n-                    final String pattern = format.hasPattern()\n-                                    ? format.getPattern()\n-                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n-            final Locale loc = format.hasLocale()\n-                            ? format.getLocale()\n-                            : serializers.getLocale();\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n-                    if (tz == null) {\n-                        tz = serializers.getTimeZone();\n-                    }\n-            df.setTimeZone(tz);\n-            return withFormat(Boolean.FALSE, df);\n-        }\n-\n-        // Otherwise, need one of these changes:\n-\n-\n-        // Jackson's own `StdDateFormat` is quite easy to deal with...\n-\n-        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-        //    So: require it be `SimpleDateFormat`; can't config other types\n-//            serializers.reportBadDefinition(handledType(), String.format(\n-            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        return this;\n+if (m!= JsonFormat.Shape.OBJECT || format.hasPattern) {\n     }\n \n     /*\n     /**********************************************************\n     /* Accessors\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if ((shape == JsonFormat.Shape.STRING) || format.hasPattern() || format.hasLocale() || format.hasTimeZone()) { TimeZone tz = format.getTimeZone(); final String pattern = format.hasPattern() ? format.getPattern() : StdDateFormat.DATE_FORMAT_STR_ISO8601; final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(pattern, loc); if (tz == null) { tz = serializers.getTimeZone(); } df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } // Otherwise, need one of these changes: // Jackson's own `StdDateFormat` is quite easy to deal with... // 08-Jun-2017, tatu: Unfortunately there's no generally usable // mechanism for changing `DateFormat` instances (or even clone()ing) // So: require it be `SimpleDateFormat`; can't config other types // serializers.reportBadDefinition(handledType(), String.format( // Ugh. No way to change `Locale`, create copy; must re-crete completely: return this;",
        "fixed_line": "if (format.hasPattern()) { final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc); TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone(); df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } // Otherwise, need one of these changes: final boolean hasLocale = format.hasLocale(); final boolean hasTZ = format.hasTimeZone(); final boolean asString = (shape == JsonFormat.Shape.STRING); if (!hasLocale && !hasTZ && !asString) { return this; } DateFormat df0 = serializers.getConfig().getDateFormat(); // Jackson's own `StdDateFormat` is quite easy to deal with... if (df0 instanceof StdDateFormat) { StdDateFormat std = (StdDateFormat) df0; if (format.hasLocale()) { std = std.withLocale(format.getLocale()); } if (format.hasTimeZone()) { std = std.withTimeZone(format.getTimeZone()); } return withFormat(Boolean.FALSE, std); } // 08-Jun-2017, tatu: Unfortunately there's no generally usable // mechanism for changing `DateFormat` instances (or even clone()ing) // So: require it be `SimpleDateFormat`; can't config other types if (!(df0 instanceof SimpleDateFormat)) { // serializers.reportBadDefinition(handledType(), String.format( serializers.reportMappingProblem( \"Configured `DateFormat` (%s) not a `SimpleDateFormat`; can not configure `Locale` or `TimeZone`\", df0.getClass().getName()); } SimpleDateFormat df = (SimpleDateFormat) df0; if (hasLocale) { // Ugh. No way to change `Locale`, create copy; must re-crete completely: df = new SimpleDateFormat(df.toPattern(), format.getLocale()); } else { df = (SimpleDateFormat) df.clone(); } TimeZone newTz = format.getTimeZone(); boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone()); if (changeTZ) { df.setTimeZone(newTz); } return withFormat(Boolean.FALSE, df);"
    },
    "JacksonDatabind-17": {
        "fixes": [
            {
                "k": 1,
                "patch": "|| m.class.isAssignableFrom(t.getRawClass()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-17/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\t2022-07-19 17:33:03.011191854 +0200\n+++ /tmp/tmpp_bwkoju.java\t2022-07-19 17:33:03.083191525 +0200\n@@ -175,11 +175,11 @@\n             case OBJECT_AND_NON_CONCRETE:\n //                return t.isJavaLangObject() || \n                 return (t.getRawClass() == Object.class)\n                         || (!t.isConcrete()\n                                 // [databind#88] Should not apply to JSON tree models:\n-                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n+|| m.class.isAssignableFrom(t.getRawClass()));\n \n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "||Is.class.isAssignableFrom(t.getRawClass()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-17/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\t2022-07-19 17:33:05.507180497 +0200\n+++ /tmp/tmpmmliucjr.java\t2022-07-19 17:33:05.507180497 +0200\n@@ -175,11 +175,11 @@\n             case OBJECT_AND_NON_CONCRETE:\n //                return t.isJavaLangObject() || \n                 return (t.getRawClass() == Object.class)\n                         || (!t.isConcrete()\n                                 // [databind#88] Should not apply to JSON tree models:\n-                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n+||Is.class.isAssignableFrom(t.getRawClass()));\n \n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "||Conflict.class.isAssignableFrom(t.getRawClass()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-17/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\t2022-07-19 17:33:07.423171776 +0200\n+++ /tmp/tmplgw1i8hm.java\t2022-07-19 17:33:07.427171759 +0200\n@@ -175,11 +175,11 @@\n             case OBJECT_AND_NON_CONCRETE:\n //                return t.isJavaLangObject() || \n                 return (t.getRawClass() == Object.class)\n                         || (!t.isConcrete()\n                                 // [databind#88] Should not apply to JSON tree models:\n-                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n+||Conflict.class.isAssignableFrom(t.getRawClass()));\n \n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "|| serial.class.isAssignableFrom(t.getRawClass()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-17/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\t2022-07-19 17:33:09.355162977 +0200\n+++ /tmp/tmp9ay7kf24.java\t2022-07-19 17:33:09.355162977 +0200\n@@ -175,11 +175,11 @@\n             case OBJECT_AND_NON_CONCRETE:\n //                return t.isJavaLangObject() || \n                 return (t.getRawClass() == Object.class)\n                         || (!t.isConcrete()\n                                 // [databind#88] Should not apply to JSON tree models:\n-                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n+|| serial.class.isAssignableFrom(t.getRawClass()));\n \n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "|| mocked.class.isAssignableFrom(t.getRawClass()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-17/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\t2022-07-19 17:33:11.247154357 +0200\n+++ /tmp/tmpw9rmf42x.java\t2022-07-19 17:33:11.251154341 +0200\n@@ -175,11 +175,11 @@\n             case OBJECT_AND_NON_CONCRETE:\n //                return t.isJavaLangObject() || \n                 return (t.getRawClass() == Object.class)\n                         || (!t.isConcrete()\n                                 // [databind#88] Should not apply to JSON tree models:\n-                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n+|| mocked.class.isAssignableFrom(t.getRawClass()));\n \n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "|| TreeNode.class.isAssignableFrom(t.getRawClass()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-17/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\t2022-07-19 17:33:13.127145788 +0200\n+++ /tmp/tmp1nq4sa7s.java\t2022-07-19 17:33:13.127145788 +0200\n@@ -175,11 +175,11 @@\n             case OBJECT_AND_NON_CONCRETE:\n //                return t.isJavaLangObject() || \n                 return (t.getRawClass() == Object.class)\n                         || (!t.isConcrete()\n                                 // [databind#88] Should not apply to JSON tree models:\n-                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n+|| TreeNode.class.isAssignableFrom(t.getRawClass()));\n \n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "||Specified.class.isAssignableFrom(t.getRawClass()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-17/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\t2022-07-19 17:33:43.007009089 +0200\n+++ /tmp/tmpzabj_ekx.java\t2022-07-19 17:33:43.007009089 +0200\n@@ -175,11 +175,11 @@\n             case OBJECT_AND_NON_CONCRETE:\n //                return t.isJavaLangObject() || \n                 return (t.getRawClass() == Object.class)\n                         || (!t.isConcrete()\n                                 // [databind#88] Should not apply to JSON tree models:\n-                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n+||Specified.class.isAssignableFrom(t.getRawClass()));\n \n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "|| getMode.class.isAssignableFrom(t.getRawClass()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-17/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\t2022-07-19 17:33:44.843000661 +0200\n+++ /tmp/tmpt40zdu0f.java\t2022-07-19 17:33:44.843000661 +0200\n@@ -175,11 +175,11 @@\n             case OBJECT_AND_NON_CONCRETE:\n //                return t.isJavaLangObject() || \n                 return (t.getRawClass() == Object.class)\n                         || (!t.isConcrete()\n                                 // [databind#88] Should not apply to JSON tree models:\n-                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n+|| getMode.class.isAssignableFrom(t.getRawClass()));\n \n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "|| getL.class.isAssignableFrom(t.getRawClass()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-17/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\t2022-07-19 17:33:46.710992081 +0200\n+++ /tmp/tmpy_gkt259.java\t2022-07-19 17:33:46.714992061 +0200\n@@ -175,11 +175,11 @@\n             case OBJECT_AND_NON_CONCRETE:\n //                return t.isJavaLangObject() || \n                 return (t.getRawClass() == Object.class)\n                         || (!t.isConcrete()\n                                 // [databind#88] Should not apply to JSON tree models:\n-                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n+|| getL.class.isAssignableFrom(t.getRawClass()));\n \n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "|| function.class.isAssignableFrom(t.getRawClass()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-17/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\t2022-07-19 17:33:48.626983275 +0200\n+++ /tmp/tmpqdpd67d1.java\t2022-07-19 17:33:48.626983275 +0200\n@@ -175,11 +175,11 @@\n             case OBJECT_AND_NON_CONCRETE:\n //                return t.isJavaLangObject() || \n                 return (t.getRawClass() == Object.class)\n                         || (!t.isConcrete()\n                                 // [databind#88] Should not apply to JSON tree models:\n-                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n+|| function.class.isAssignableFrom(t.getRawClass()));\n \n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "|| TreeNode.class.isAssignableFrom(t.getRawClass()));",
        "fixed_line": "&& !TreeNode.class.isAssignableFrom(t.getRawClass()));"
    },
    "Chart-3": {
        "fixes": [
            {
                "k": 1,
                "patch": "throw new IllegalArgumentException(\"Requires start <= end; index++) {",
                "patch_diff": "throw new IllegalArgumentException(\"Requires start <= end; index++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// } TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index);",
                "patch_diff": "// } TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "TimeSeriesDataItem item = start; index = (TimeSeriesDataItem) this.data.get(index);",
                "patch_diff": "TimeSeriesDataItem item = start; index = (TimeSeriesDataItem) this.data.get(index);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (TimeSeriesDataItem item = start; index <= end; index++) {",
                "patch_diff": "for (TimeSeriesDataItem item = start; index <= end; index++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// } TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.clone();",
                "patch_diff": "// } TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.clone();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "end = (TimeSeriesDataItem) this.data.get(index);",
                "patch_diff": "end = (TimeSeriesDataItem) this.data.get(index);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "end = (TimeSeriesDataItem) this.data.size; index = (TimeSeriesDataItem) this.data.get(index);",
                "patch_diff": "end = (TimeSeriesDataItem) this.data.size; index = (TimeSeriesDataItem) this.data.get(index);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "end = (TimeSeriesDataItem) this.data.clone; index = (TimeSeriesDataItem) this.data.get(index);",
                "patch_diff": "end = (TimeSeriesDataItem) this.data.clone; index = (TimeSeriesDataItem) this.data.get(index);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "TimeSeriesDataItem item = start; index = (TimeSeriesDataItem) this.data.get(index); }",
                "patch_diff": "TimeSeriesDataItem item = start; index = (TimeSeriesDataItem) this.data.get(index); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "TimeSeriesDataItem item = start; index = (TimeSeriesDataItem) this.data.clone();",
                "patch_diff": "TimeSeriesDataItem item = start; index = (TimeSeriesDataItem) this.data.clone();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "copy.minY = Double.NaN; copy.maxY = Double.NaN;"
    },
    "Lang-37": {
        "fixes": [
            {
                "k": 1,
                "patch": "System.arraycopy(array1, 0, joinedArray, 0, array1.length); System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);",
                "patch_diff": "System.arraycopy(array1, 0, joinedArray, 0, array1.length); System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);",
                "patch_diff": "System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); System.arraycopy(array1, 0, joinedArray, array1.length, array2.length);",
                "patch_diff": "System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); System.arraycopy(array1, 0, joinedArray, array1.length, array2.length);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); System.arraycopy(array1, 0, joinedArray, 0, array1.length);",
                "patch_diff": "System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); System.arraycopy(array1, 0, joinedArray, 0, array1.length);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "System.arraycopy(array1, 0, joinedArray, 0, array1.length); System.arraycopy(array1, 0, joinedArray, array1.length, array2.length);",
                "patch_diff": "System.arraycopy(array1, 0, joinedArray, 0, array1.length); System.arraycopy(array1, 0, joinedArray, array1.length, array2.length);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);",
                "patch_diff": "System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "System.arraycopy(array1, 0, joinedArray, 0, array1.length); System.arraycopy(array1, 0, joinedArray, 0, array1.length);",
                "patch_diff": "System.arraycopy(array1, 0, joinedArray, 0, array1.length); System.arraycopy(array1, 0, joinedArray, 0, array1.length);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "System.arraycopy(array1, 0, joinedArray, 0, array1.length); System.arraycopy(array2, 0, joinedArray, array2.length);",
                "patch_diff": "System.arraycopy(array1, 0, joinedArray, 0, array1.length); System.arraycopy(array2, 0, joinedArray, array2.length);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "System.arraycopy(array1, 0, joinedArray, 0, array1.length); System.arraycopy(array2, 0, joinedArray, array1.length);",
                "patch_diff": "System.arraycopy(array1, 0, joinedArray, 0, array1.length); System.arraycopy(array2, 0, joinedArray, array1.length);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "System.arraycopy(array1, 0, joinedArray, 0, array1.length); System.arraycopy(array1, 0, joinedArray, array1.length);",
                "patch_diff": "System.arraycopy(array1, 0, joinedArray, 0, array1.length); System.arraycopy(array1, 0, joinedArray, array1.length);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "try { System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); } catch (ArrayStoreException ase) { // Check if problem is incompatible types final Class<?> type2 = array2.getClass().getComponentType(); if (!type1.isAssignableFrom(type2)){ throw new IllegalArgumentException(\"Cannot store \"+type2.getName()+\" in an array of \"+type1.getName()); } throw ase; // No, so rethrow original }"
    },
    "Math-32": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (state.getAttributeFor tree.getAttributeFor tree.getAttribute) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2022-07-19 17:33:54.174957760 +0200\n+++ /tmp/tmpuj6g0klx.java\t2022-07-19 17:33:54.202957631 +0200\n@@ -131,11 +131,11 @@\n \n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+if (state.getAttributeFor tree.getAttributeFor tree.getAttribute) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (state.getAttributeFor tree.getAttributeFor tree.getAttributeFor tree.getAttribute) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2022-07-19 17:33:56.574946713 +0200\n+++ /tmp/tmpzbnn2k9r.java\t2022-07-19 17:33:56.574946713 +0200\n@@ -131,11 +131,11 @@\n \n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+if (state.getAttributeFor tree.getAttributeFor tree.getAttributeFor tree.getAttribute) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (state.getAttributeFor tree.getAttributeFor tree) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2022-07-19 17:33:58.618937301 +0200\n+++ /tmp/tmpt0hy04_n.java\t2022-07-19 17:33:58.618937301 +0200\n@@ -131,11 +131,11 @@\n \n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+if (state.getAttributeFor tree.getAttributeFor tree) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (state.getAttributeFor tree.getAttributeFor tree.getAttribute || tree.getAttribute) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2022-07-19 17:34:00.638927994 +0200\n+++ /tmp/tmpqylhulw0.java\t2022-07-19 17:34:00.638927994 +0200\n@@ -131,11 +131,11 @@\n \n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+if (state.getAttributeFor tree.getAttributeFor tree.getAttribute || tree.getAttribute) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (state.getAttributeFor tree.getAttributeFor tree.getAttributeFor tree) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2022-07-19 17:34:02.598918962 +0200\n+++ /tmp/tmpt83i3amn.java\t2022-07-19 17:34:02.598918962 +0200\n@@ -131,11 +131,11 @@\n \n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+if (state.getAttributeFor tree.getAttributeFor tree.getAttributeFor tree) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (state.getAttributeFor tree.getAttributeFor tree.getAttribute()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2022-07-19 17:34:04.594909757 +0200\n+++ /tmp/tmp_iwe5c6z.java\t2022-07-19 17:34:04.594909757 +0200\n@@ -131,11 +131,11 @@\n \n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+if (state.getAttributeFor tree.getAttributeFor tree.getAttribute()) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (state.getAttributeFor tree.getAttributeFor tree.getAttributeFor tree.getAttribute()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2022-07-19 17:34:06.618900422 +0200\n+++ /tmp/tmpqqt6w0fy.java\t2022-07-19 17:34:06.618900422 +0200\n@@ -131,11 +131,11 @@\n \n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+if (state.getAttributeFor tree.getAttributeFor tree.getAttributeFor tree.getAttribute()) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (wanted.getAttribute || tree.getAttribute) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2022-07-19 17:34:08.682890897 +0200\n+++ /tmp/tmp8695b8tb.java\t2022-07-19 17:34:08.686890877 +0200\n@@ -131,11 +131,11 @@\n \n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+if (wanted.getAttribute || tree.getAttribute) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (state.getAttributeFor tree.getAttribute || tree.getAttribute) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2022-07-19 17:34:10.882880738 +0200\n+++ /tmp/tmprk13kgi6.java\t2022-07-19 17:34:10.882880738 +0200\n@@ -131,11 +131,11 @@\n \n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+if (state.getAttributeFor tree.getAttribute || tree.getAttribute) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (state.getAttributeFor tree.getAttributeFor tree.getAttributeFor tree.getAttributeFor tree) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2022-07-19 17:34:12.878871518 +0200\n+++ /tmp/tmpz_97el7q.java\t2022-07-19 17:34:12.878871518 +0200\n@@ -131,11 +131,11 @@\n \n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+if (state.getAttributeFor tree.getAttributeFor tree.getAttributeFor tree.getAttributeFor tree) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if ((Boolean) tree.getAttribute()) {",
        "fixed_line": "if (tree.getCut() == null && (Boolean) tree.getAttribute()) {"
    },
    "Gson-13": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (millis >= 1 && fitsInLong || (value instanceof Long.MIN_VALUE || negative)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-13/gson/src/main/java/com/google/gson/stream/JsonReader.java\t2022-07-19 17:34:15.166860946 +0200\n+++ /tmp/tmph2cesgrk.java\t2022-07-19 17:34:15.242860593 +0200\n@@ -726,11 +726,11 @@\n         }\n       }\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+if (millis >= 1 && fitsInLong || (value instanceof Long.MIN_VALUE || negative)) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n         || last == NUMBER_CHAR_EXP_DIGIT) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (millis >= 1 && fitsInLong || (value < Long.MIN_VALUE || negative)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-13/gson/src/main/java/com/google/gson/stream/JsonReader.java\t2022-07-19 17:34:17.250851313 +0200\n+++ /tmp/tmp1p94nukw.java\t2022-07-19 17:34:17.250851313 +0200\n@@ -726,11 +726,11 @@\n         }\n       }\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+if (millis >= 1 && fitsInLong || (value < Long.MIN_VALUE || negative)) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n         || last == NUMBER_CHAR_EXP_DIGIT) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (millis >= 1 && fitsInLong || (value < Long.MIN_VALUE || negative > Long.MAX_VALUE) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-13/gson/src/main/java/com/google/gson/stream/JsonReader.java\t2022-07-19 17:34:19.042843024 +0200\n+++ /tmp/tmp7wyft41d.java\t2022-07-19 17:34:19.042843024 +0200\n@@ -726,11 +726,11 @@\n         }\n       }\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+if (millis >= 1 && fitsInLong || (value < Long.MIN_VALUE || negative > Long.MAX_VALUE) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n         || last == NUMBER_CHAR_EXP_DIGIT) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (millis >= 1 && fitsInLong || (value instanceof Long.MIN_VALUE || negative == Long.MAX_VALUE) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-13/gson/src/main/java/com/google/gson/stream/JsonReader.java\t2022-07-19 17:34:20.566835974 +0200\n+++ /tmp/tmpc6wpfj5h.java\t2022-07-19 17:34:20.566835974 +0200\n@@ -726,11 +726,11 @@\n         }\n       }\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+if (millis >= 1 && fitsInLong || (value instanceof Long.MIN_VALUE || negative == Long.MAX_VALUE) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n         || last == NUMBER_CHAR_EXP_DIGIT) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (millis >= 1 && fitsInLong || (value instanceof Long.MIN_VALUE || negative == Long.MIN_VALUE) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-13/gson/src/main/java/com/google/gson/stream/JsonReader.java\t2022-07-19 17:34:22.038829159 +0200\n+++ /tmp/tmp8swol6b5.java\t2022-07-19 17:34:22.038829159 +0200\n@@ -726,11 +726,11 @@\n         }\n       }\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+if (millis >= 1 && fitsInLong || (value instanceof Long.MIN_VALUE || negative == Long.MIN_VALUE) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n         || last == NUMBER_CHAR_EXP_DIGIT) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (millis >= 1 && fitsInLong || (value instanceof Long.MIN_VALUE && value)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-13/gson/src/main/java/com/google/gson/stream/JsonReader.java\t2022-07-19 17:34:23.662821644 +0200\n+++ /tmp/tmpo2hrx7mm.java\t2022-07-19 17:34:23.666821623 +0200\n@@ -726,11 +726,11 @@\n         }\n       }\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+if (millis >= 1 && fitsInLong || (value instanceof Long.MIN_VALUE && value)) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n         || last == NUMBER_CHAR_EXP_DIGIT) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (millis >= 1 && fitsInLong && (value < Long.MIN_VALUE || negative > Long.MAX_VALUE) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-13/gson/src/main/java/com/google/gson/stream/JsonReader.java\t2022-07-19 17:34:25.346813842 +0200\n+++ /tmp/tmpgqb0kd9t.java\t2022-07-19 17:34:25.350813826 +0200\n@@ -726,11 +726,11 @@\n         }\n       }\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+if (millis >= 1 && fitsInLong && (value < Long.MIN_VALUE || negative > Long.MAX_VALUE) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n         || last == NUMBER_CHAR_EXP_DIGIT) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (millis >= 1 && value <= Long.MIN_VALUE || negative == Long.MIN_VALUE) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-13/gson/src/main/java/com/google/gson/stream/JsonReader.java\t2022-07-19 17:34:26.938806470 +0200\n+++ /tmp/tmp7o7_s_tp.java\t2022-07-19 17:34:26.942806450 +0200\n@@ -726,11 +726,11 @@\n         }\n       }\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+if (millis >= 1 && value <= Long.MIN_VALUE || negative == Long.MIN_VALUE) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n         || last == NUMBER_CHAR_EXP_DIGIT) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (millis >= 1 && lowerBoundVal < Long.MIN_VALUE || negative)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-13/gson/src/main/java/com/google/gson/stream/JsonReader.java\t2022-07-19 17:34:28.782797925 +0200\n+++ /tmp/tmp7oue6v4i.java\t2022-07-19 17:34:28.786797904 +0200\n@@ -726,11 +726,11 @@\n         }\n       }\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+if (millis >= 1 && lowerBoundVal < Long.MIN_VALUE || negative)) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n         || last == NUMBER_CHAR_EXP_DIGIT) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (millis >= 1 && fitsInLong && (value < Long.MIN_VALUE || negative)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-13/gson/src/main/java/com/google/gson/stream/JsonReader.java\t2022-07-19 17:34:30.378790524 +0200\n+++ /tmp/tmp195q1u54.java\t2022-07-19 17:34:30.378790524 +0200\n@@ -726,11 +726,11 @@\n         }\n       }\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+if (millis >= 1 && fitsInLong && (value < Long.MIN_VALUE || negative)) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n         || last == NUMBER_CHAR_EXP_DIGIT) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {",
        "fixed_line": "if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) {"
    },
    "Cli-27": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (selected == null || selected.equals(option.getOpt())) { selected = option.getOptOpt",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-27/src/java/org/apache/commons/cli/OptionGroup.java\t2022-07-19 17:34:32.358781345 +0200\n+++ /tmp/tmpbo4oipw0.java\t2022-07-19 17:34:32.390781193 +0200\n@@ -93,13 +93,11 @@\n         }\n         \n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if (selected == null || selected.equals(option.getOpt()))\n-        {\n-            selected = option.getOpt();\n+if (selected == null || selected.equals(option.getOpt())) { selected = option.getOptOpt\n         }\n         else\n         {\n             throw new AlreadySelectedException(this, option);\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (selected == null || selected.equals(option.getOpt())) { selected = option.getOpt",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-27/src/java/org/apache/commons/cli/OptionGroup.java\t2022-07-19 17:34:34.058773457 +0200\n+++ /tmp/tmpajnceoo2.java\t2022-07-19 17:34:34.058773457 +0200\n@@ -93,13 +93,11 @@\n         }\n         \n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if (selected == null || selected.equals(option.getOpt()))\n-        {\n-            selected = option.getOpt();\n+if (selected == null || selected.equals(option.getOpt())) { selected = option.getOpt\n         }\n         else\n         {\n             throw new AlreadySelectedException(this, option);\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (selected == null ||selected.equals(option.getOpt())) { selected = option.getOptOpt",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-27/src/java/org/apache/commons/cli/OptionGroup.java\t2022-07-19 17:34:35.546766550 +0200\n+++ /tmp/tmph51altli.java\t2022-07-19 17:34:35.550766534 +0200\n@@ -93,13 +93,11 @@\n         }\n         \n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if (selected == null || selected.equals(option.getOpt()))\n-        {\n-            selected = option.getOpt();\n+if (selected == null ||selected.equals(option.getOpt())) { selected = option.getOptOpt\n         }\n         else\n         {\n             throw new AlreadySelectedException(this, option);\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (selected == null ||selected.equals(option.getOpt())) { selected = option.getOpt",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-27/src/java/org/apache/commons/cli/OptionGroup.java\t2022-07-19 17:34:37.070759476 +0200\n+++ /tmp/tmpcl5cdjmv.java\t2022-07-19 17:34:37.070759476 +0200\n@@ -93,13 +93,11 @@\n         }\n         \n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if (selected == null || selected.equals(option.getOpt()))\n-        {\n-            selected = option.getOpt();\n+if (selected == null ||selected.equals(option.getOpt())) { selected = option.getOpt\n         }\n         else\n         {\n             throw new AlreadySelectedException(this, option);\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (selected == null || selected.equals(option.getOpt())) { selected = option.getOpt();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-27/src/java/org/apache/commons/cli/OptionGroup.java\t2022-07-19 17:34:38.610752325 +0200\n+++ /tmp/tmpayi7mwyh.java\t2022-07-19 17:34:38.610752325 +0200\n@@ -93,13 +93,11 @@\n         }\n         \n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if (selected == null || selected.equals(option.getOpt()))\n-        {\n-            selected = option.getOpt();\n+if (selected == null || selected.equals(option.getOpt())) { selected = option.getOpt();\n         }\n         else\n         {\n             throw new AlreadySelectedException(this, option);\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (selected == null || other.equals(option.getOpt())) { selected = option.getOpt",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-27/src/java/org/apache/commons/cli/OptionGroup.java\t2022-07-19 17:34:41.142740563 +0200\n+++ /tmp/tmpsw77wrow.java\t2022-07-19 17:34:41.142740563 +0200\n@@ -93,13 +93,11 @@\n         }\n         \n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if (selected == null || selected.equals(option.getOpt()))\n-        {\n-            selected = option.getOpt();\n+if (selected == null || other.equals(option.getOpt())) { selected = option.getOpt\n         }\n         else\n         {\n             throw new AlreadySelectedException(this, option);\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (selected == null || other.equals(option.getOpt())) { selected = option.getOptOpt",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-27/src/java/org/apache/commons/cli/OptionGroup.java\t2022-07-19 17:34:42.578733890 +0200\n+++ /tmp/tmp6o9xydv5.java\t2022-07-19 17:34:42.578733890 +0200\n@@ -93,13 +93,11 @@\n         }\n         \n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if (selected == null || selected.equals(option.getOpt()))\n-        {\n-            selected = option.getOpt();\n+if (selected == null || other.equals(option.getOpt())) { selected = option.getOptOpt\n         }\n         else\n         {\n             throw new AlreadySelectedException(this, option);\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (selected == null ||selected.equals(option.getOpt())) { selected = option.getOpt();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-27/src/java/org/apache/commons/cli/OptionGroup.java\t2022-07-19 17:34:44.014727217 +0200\n+++ /tmp/tmplec8mj_s.java\t2022-07-19 17:34:44.014727217 +0200\n@@ -93,13 +93,11 @@\n         }\n         \n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if (selected == null || selected.equals(option.getOpt()))\n-        {\n-            selected = option.getOpt();\n+if (selected == null ||selected.equals(option.getOpt())) { selected = option.getOpt();\n         }\n         else\n         {\n             throw new AlreadySelectedException(this, option);\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (selected == null || selected.equals(option.getOpt())) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-27/src/java/org/apache/commons/cli/OptionGroup.java\t2022-07-19 17:34:46.450715887 +0200\n+++ /tmp/tmpptekbrv7.java\t2022-07-19 17:34:46.450715887 +0200\n@@ -93,13 +93,11 @@\n         }\n         \n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if (selected == null || selected.equals(option.getOpt()))\n-        {\n-            selected = option.getOpt();\n+if (selected == null || selected.equals(option.getOpt())) {\n         }\n         else\n         {\n             throw new AlreadySelectedException(this, option);\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (selected == null || other.equals(option.getOpt())) { selected = option.getOpt();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-27/src/java/org/apache/commons/cli/OptionGroup.java\t2022-07-19 17:34:48.806704927 +0200\n+++ /tmp/tmpnsb1hf74.java\t2022-07-19 17:34:48.806704927 +0200\n@@ -93,13 +93,11 @@\n         }\n         \n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if (selected == null || selected.equals(option.getOpt()))\n-        {\n-            selected = option.getOpt();\n+if (selected == null || other.equals(option.getOpt())) { selected = option.getOpt();\n         }\n         else\n         {\n             throw new AlreadySelectedException(this, option);\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (selected == null || selected.equals(option.getOpt())) { selected = option.getOpt();",
        "fixed_line": "if (selected == null || selected.equals(option.getKey())) { selected = option.getKey();"
    },
    "Csv-10": {
        "fixes": [
            {
                "k": 1,
                "patch": "// this.out = out; this.format = null; this.format = this.format; this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = this.format =",
                "patch_diff": "// this.out = out; this.format = null; this.format = this.format; this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = this.format =",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// this.out = out; this.format = null; this.format = this.format; this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format =",
                "patch_diff": "// this.out = out; this.format = null; this.format = this.format; this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format =",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// this.out = out; this.format = null; this.format = this.format; this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = out; this.format = null; this.format = this.format = this.format; this.format = null; this.format = null; this.format = this.format =",
                "patch_diff": "// this.out = out; this.format = null; this.format = this.format; this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = out; this.format = null; this.format = this.format = this.format; this.format = null; this.format = null; this.format = this.format =",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// this.out = out; this.format = null; this.format = this.format; this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = out; this.",
                "patch_diff": "// this.out = out; this.format = null; this.format = this.format; this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = out; this.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// this.out = out; this.format = null; this.format = this.format; this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.",
                "patch_diff": "// this.out = out; this.format = null; this.format = this.format; this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// this.out = out; this.format = null; this.format = this.format; this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = out; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.",
                "patch_diff": "// this.out = out; this.format = null; this.format = this.format; this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = out; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// this.out = out; this.format = null; this.format = this.format; this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = null; this.format = this.",
                "patch_diff": "// this.out = out; this.format = null; this.format = this.format; this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = null; this.format = this.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// this.out = out; this.format = null; this.format = this.format; this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = this.format;",
                "patch_diff": "// this.out = out; this.format = null; this.format = this.format; this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = this.format;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// this.out = out; this.format = null; this.format = this.format; this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = this.format.",
                "patch_diff": "// this.out = out; this.format = null; this.format = this.format; this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = this.format.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// this.out = out; this.format = null; this.format = this.format; this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null;",
                "patch_diff": "// this.out = out; this.format = null; this.format = this.format; this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null; this.format = this.format = this.format; this.format = null;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (format.getHeader() != null) { this.printRecord((Object[]) format.getHeader()); }"
    },
    "Closure-59": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (options.checkGlobalThis ||options.checkGlobalThis ||options.checkGlobalThisLevel) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-59/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 17:34:52.998685414 +0200\n+++ /tmp/tmpwlxhu_ja.java\t2022-07-19 17:34:53.046685191 +0200\n@@ -250,11 +250,11 @@\n           DiagnosticGroup.forType(\n               RhinoErrorReporter.TYPE_PARSE_ERROR),\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+if (options.checkGlobalThis ||options.checkGlobalThis ||options.checkGlobalThisLevel) {\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (options.checkGlobalThis ||options.checkGlobalThis ||options.checkGlobalThis ||options.checkGlobalThisLevel) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-59/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 17:34:58.382660326 +0200\n+++ /tmp/tmp_5bbx_y_.java\t2022-07-19 17:34:58.382660326 +0200\n@@ -250,11 +250,11 @@\n           DiagnosticGroup.forType(\n               RhinoErrorReporter.TYPE_PARSE_ERROR),\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+if (options.checkGlobalThis ||options.checkGlobalThis ||options.checkGlobalThis ||options.checkGlobalThisLevel) {\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (options.checkGlobalThis ||options.checkGlobalThisLevel.isOn()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-59/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 17:35:01.978643559 +0200\n+++ /tmp/tmpkufcis80.java\t2022-07-19 17:35:01.982643538 +0200\n@@ -250,11 +250,11 @@\n           DiagnosticGroup.forType(\n               RhinoErrorReporter.TYPE_PARSE_ERROR),\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+if (options.checkGlobalThis ||options.checkGlobalThisLevel.isOn()) {\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (options.checkGlobalThis ||options.checkGlobalThisLevel.isOnRoot) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-59/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 17:35:05.614626590 +0200\n+++ /tmp/tmpkdwgf9se.java\t2022-07-19 17:35:05.618626573 +0200\n@@ -250,11 +250,11 @@\n           DiagnosticGroup.forType(\n               RhinoErrorReporter.TYPE_PARSE_ERROR),\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+if (options.checkGlobalThis ||options.checkGlobalThisLevel.isOnRoot) {\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (options.checkGlobalThis ||options.checkGlobalThisLevel) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-59/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 17:35:09.298609389 +0200\n+++ /tmp/tmptbpc6xp8.java\t2022-07-19 17:35:09.298609389 +0200\n@@ -250,11 +250,11 @@\n           DiagnosticGroup.forType(\n               RhinoErrorReporter.TYPE_PARSE_ERROR),\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+if (options.checkGlobalThis ||options.checkGlobalThisLevel) {\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (options.checkGlobalThisLevel.isOnCallLevel) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-59/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 17:35:12.746593275 +0200\n+++ /tmp/tmpuv_2g52j.java\t2022-07-19 17:35:12.746593275 +0200\n@@ -250,11 +250,11 @@\n           DiagnosticGroup.forType(\n               RhinoErrorReporter.TYPE_PARSE_ERROR),\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+if (options.checkGlobalThisLevel.isOnCallLevel) {\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (options.checkGlobalThis ||options.checkGlobalThis ||options.checkGlobalThis ||options.checkGlobalThis ||options.checkGlobalThisLevel) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-59/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 17:35:16.342576463 +0200\n+++ /tmp/tmpacjzcj4t.java\t2022-07-19 17:35:16.342576463 +0200\n@@ -250,11 +250,11 @@\n           DiagnosticGroup.forType(\n               RhinoErrorReporter.TYPE_PARSE_ERROR),\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+if (options.checkGlobalThis ||options.checkGlobalThis ||options.checkGlobalThis ||options.checkGlobalThis ||options.checkGlobalThisLevel) {\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (options.checkGlobalThisLevel.isOnRoot ||options.checkGlobalThisLevel) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-59/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 17:35:19.898559826 +0200\n+++ /tmp/tmpkdpljhzj.java\t2022-07-19 17:35:19.898559826 +0200\n@@ -250,11 +250,11 @@\n           DiagnosticGroup.forType(\n               RhinoErrorReporter.TYPE_PARSE_ERROR),\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+if (options.checkGlobalThisLevel.isOnRoot ||options.checkGlobalThisLevel) {\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (options.checkGlobalThisLevel.isOn {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-59/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 17:35:23.402543421 +0200\n+++ /tmp/tmp54atv1jy.java\t2022-07-19 17:35:23.402543421 +0200\n@@ -250,11 +250,11 @@\n           DiagnosticGroup.forType(\n               RhinoErrorReporter.TYPE_PARSE_ERROR),\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+if (options.checkGlobalThisLevel.isOn {\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (options.checkGlobalThis ||options.checkGlobalThisLevel.isOnCallLevel) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-59/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 17:35:26.710527924 +0200\n+++ /tmp/tmpmpf0omf3.java\t2022-07-19 17:35:26.710527924 +0200\n@@ -250,11 +250,11 @@\n           DiagnosticGroup.forType(\n               RhinoErrorReporter.TYPE_PARSE_ERROR),\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+if (options.checkGlobalThis ||options.checkGlobalThisLevel.isOnCallLevel) {\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (options.checkGlobalThisLevel.isOn()) {",
        "fixed_line": "if (options.checkGlobalThisLevel.isOn() && !options.disables(DiagnosticGroups.GLOBAL_THIS)) {"
    },
    "JacksonDatabind-51": {
        "fixes": [
            {
                "k": 1,
                "patch": "// } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); }",
                "patch_diff": "// } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); }",
                "patch_diff": "// } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException e; }",
                "patch_diff": "// } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException e; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException e) { throw ctxt.mappingException(",
                "patch_diff": "// } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException e) { throw ctxt.mappingException(",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// } catch (Exception e) { throw ctxt.mappingException(_baseType, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "// } catch (Exception e) { throw ctxt.mappingException(_baseType, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); }",
                "patch_diff": "// } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e)",
                "patch_diff": "// } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException e; }",
                "patch_diff": "// } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException e; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException e",
                "patch_diff": "// } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException e",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException e) { throw ctxt.mappingException(_",
                "patch_diff": "// } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException(e); } catch (Exception e) { throw ctxt.mappingException e) { throw ctxt.mappingException(_",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (!type.hasGenericTypes()) { type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass()); }"
    },
    "Lang-21": {
        "fixes": [
            {
                "k": 1,
                "patch": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-21/src/main/java/org/apache/commons/lang3/time/DateUtils.java\t2022-07-19 17:35:33.058498161 +0200\n+++ /tmp/tmpg2iaina5.java\t2022-07-19 17:35:33.102497954 +0200\n@@ -260,11 +260,11 @@\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR;\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                 cal1.getClass() == cal2.getClass());\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-21/src/main/java/org/apache/commons/lang3/time/DateUtils.java\t2022-07-19 17:35:34.834489825 +0200\n+++ /tmp/tmpnuwpjnps.java\t2022-07-19 17:35:34.834489825 +0200\n@@ -260,11 +260,11 @@\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR)\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                 cal1.getClass() == cal2.getClass());\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_MONTH;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-21/src/main/java/org/apache/commons/lang3/time/DateUtils.java\t2022-07-19 17:35:36.394482507 +0200\n+++ /tmp/tmpxpmdihl4.java\t2022-07-19 17:35:36.394482507 +0200\n@@ -260,11 +260,11 @@\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_MONTH;\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                 cal1.getClass() == cal2.getClass());\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.HOUR) == cal2.get(Calendar.DAY_OF_YEAR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-21/src/main/java/org/apache/commons/lang3/time/DateUtils.java\t2022-07-19 17:35:37.990475014 +0200\n+++ /tmp/tmpl3pwrszy.java\t2022-07-19 17:35:37.990475014 +0200\n@@ -260,11 +260,11 @@\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.HOUR) == cal2.get(Calendar.DAY_OF_YEAR;\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                 cal1.getClass() == cal2.getClass());\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.MINUTE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-21/src/main/java/org/apache/commons/lang3/time/DateUtils.java\t2022-07-19 17:35:39.478468024 +0200\n+++ /tmp/tmp55unur4o.java\t2022-07-19 17:35:39.478468024 +0200\n@@ -260,11 +260,11 @@\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.MINUTE;\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                 cal1.getClass() == cal2.getClass());\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.HOUR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-21/src/main/java/org/apache/commons/lang3/time/DateUtils.java\t2022-07-19 17:35:41.018460793 +0200\n+++ /tmp/tmp4ixpnx6z.java\t2022-07-19 17:35:41.018460793 +0200\n@@ -260,11 +260,11 @@\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.HOUR;\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                 cal1.getClass() == cal2.getClass());\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.HOUR) == cal2.get(Calendar.DAY_OF_YEAR)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-21/src/main/java/org/apache/commons/lang3/time/DateUtils.java\t2022-07-19 17:35:42.574453482 +0200\n+++ /tmp/tmpeictyajc.java\t2022-07-19 17:35:42.578453463 +0200\n@@ -260,11 +260,11 @@\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.HOUR) == cal2.get(Calendar.DAY_OF_YEAR)\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                 cal1.getClass() == cal2.getClass());\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.HOUR) == cal2.get(Calendar.DAY_OF_MONTH;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-21/src/main/java/org/apache/commons/lang3/time/DateUtils.java\t2022-07-19 17:35:44.098446318 +0200\n+++ /tmp/tmps0pqlixd.java\t2022-07-19 17:35:44.102446302 +0200\n@@ -260,11 +260,11 @@\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.HOUR) == cal2.get(Calendar.DAY_OF_MONTH;\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                 cal1.getClass() == cal2.getClass());\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.HOUR)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-21/src/main/java/org/apache/commons/lang3/time/DateUtils.java\t2022-07-19 17:35:45.634439100 +0200\n+++ /tmp/tmpoir83mw_.java\t2022-07-19 17:35:45.634439100 +0200\n@@ -260,11 +260,11 @@\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.HOUR)\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                 cal1.getClass() == cal2.getClass());\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_MONTH;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-21/src/main/java/org/apache/commons/lang3/time/DateUtils.java\t2022-07-19 17:35:47.294431294 +0200\n+++ /tmp/tmpihobpcna.java\t2022-07-19 17:35:47.298431273 +0200\n@@ -260,11 +260,11 @@\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_MONTH;\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                 cal1.getClass() == cal2.getClass());\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&",
        "fixed_line": "cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&"
    },
    "Math-56": {
        "fixes": [
            {
                "k": 1,
                "patch": "int idx = index < N; ++idx; ++idx; ++idx) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-56/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\t2022-07-19 17:35:49.110422750 +0200\n+++ /tmp/tmpb072b2fx.java\t2022-07-19 17:35:49.142422602 +0200\n@@ -232,17 +232,11 @@\n             --idx;\n             count -= offset;\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n-        indices[last] = idx;\n+int idx = index < N; ++idx; ++idx; ++idx) {\n \n         return indices;\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int idx = index < indices.length; ++idx; ++idx) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-56/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\t2022-07-19 17:35:51.902409615 +0200\n+++ /tmp/tmpf682rx4t.java\t2022-07-19 17:35:51.902409615 +0200\n@@ -232,17 +232,11 @@\n             --idx;\n             count -= offset;\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n-        indices[last] = idx;\n+int idx = index < indices.length; ++idx; ++idx) {\n \n         return indices;\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int idx = index < N; ++idx; ++idx) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-56/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\t2022-07-19 17:35:54.006399709 +0200\n+++ /tmp/tmp38wfd8d0.java\t2022-07-19 17:35:54.018399654 +0200\n@@ -232,17 +232,11 @@\n             --idx;\n             count -= offset;\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n-        indices[last] = idx;\n+int idx = index < N; ++idx; ++idx) {\n \n         return indices;\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int idx = index < N; ++idx; ++idx; ++idx; ++idx) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-56/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\t2022-07-19 17:35:56.770386696 +0200\n+++ /tmp/tmp8r1tzbqx.java\t2022-07-19 17:35:56.770386696 +0200\n@@ -232,17 +232,11 @@\n             --idx;\n             count -= offset;\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n-        indices[last] = idx;\n+int idx = index < N; ++idx; ++idx; ++idx; ++idx) {\n \n         return indices;\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int idx = index < indices.length; ++idx; ++idx; ++idx) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-56/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\t2022-07-19 17:35:59.442374107 +0200\n+++ /tmp/tmpnjhx367i.java\t2022-07-19 17:35:59.486373897 +0200\n@@ -232,17 +232,11 @@\n             --idx;\n             count -= offset;\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n-        indices[last] = idx;\n+int idx = index < indices.length; ++idx; ++idx; ++idx) {\n \n         return indices;\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int idx = index < indicesIndex; ++idx; ++idx; ++idx) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-56/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\t2022-07-19 17:36:02.074361699 +0200\n+++ /tmp/tmpezu0ed6q.java\t2022-07-19 17:36:02.074361699 +0200\n@@ -232,17 +232,11 @@\n             --idx;\n             count -= offset;\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n-        indices[last] = idx;\n+int idx = index < indicesIndex; ++idx; ++idx; ++idx) {\n \n         return indices;\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int idx = index < indicesIndex; ++idx; ++idx) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-56/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\t2022-07-19 17:36:05.030347762 +0200\n+++ /tmp/tmpr3l2hm9c.java\t2022-07-19 17:36:05.074347555 +0200\n@@ -232,17 +232,11 @@\n             --idx;\n             count -= offset;\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n-        indices[last] = idx;\n+int idx = index < indicesIndex; ++idx; ++idx) {\n \n         return indices;\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int idx = index < N; ++idx) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-56/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\t2022-07-19 17:36:07.842334494 +0200\n+++ /tmp/tmpxxuor33y.java\t2022-07-19 17:36:07.846334478 +0200\n@@ -232,17 +232,11 @@\n             --idx;\n             count -= offset;\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n-        indices[last] = idx;\n+int idx = index < N; ++idx) {\n \n         return indices;\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int idx = index < N; ++idx; ++idx; ++idx; ++idx; ++idx) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-56/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\t2022-07-19 17:36:10.602321469 +0200\n+++ /tmp/tmpt47i37qg.java\t2022-07-19 17:36:10.602321469 +0200\n@@ -232,17 +232,11 @@\n             --idx;\n             count -= offset;\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n-        indices[last] = idx;\n+int idx = index < N; ++idx; ++idx; ++idx; ++idx; ++idx) {\n \n         return indices;\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int idx = index < indices.length; ++idx) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-56/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\t2022-07-19 17:36:13.290308776 +0200\n+++ /tmp/tmpprppglgo.java\t2022-07-19 17:36:13.290308776 +0200\n@@ -232,17 +232,11 @@\n             --idx;\n             count -= offset;\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n-        indices[last] = idx;\n+int idx = index < indices.length; ++idx) {\n \n         return indices;\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "int idx = 1; while (count < index) { count += idx; ++idx; } --idx; indices[last] = idx;",
        "fixed_line": "indices[last] = index - count;"
    },
    "Lang-24": {
        "fixes": [
            {
                "k": 1,
                "patch": "return foundDigit &&!hasExp; // we need to check whether a digit after the",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-24/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 17:36:16.186295095 +0200\n+++ /tmp/tmpej_gyb96.java\t2022-07-19 17:36:16.378294191 +0200\n@@ -1408,11 +1408,11 @@\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+return foundDigit &&!hasExp; // we need to check whether a digit after the\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return foundDigit &&!allowSigns;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-24/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 17:36:29.662231351 +0200\n+++ /tmp/tmp7k9mhlys.java\t2022-07-19 17:36:29.662231351 +0200\n@@ -1408,11 +1408,11 @@\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+return foundDigit &&!allowSigns;\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return foundDigit &&!hasExp; // we need to do a digit after the",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-24/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 17:36:41.258176393 +0200\n+++ /tmp/tmpu4qia59c.java\t2022-07-19 17:36:41.262176374 +0200\n@@ -1408,11 +1408,11 @@\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+return foundDigit &&!hasExp; // we need to do a digit after the\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return foundDigit &&!hasExp; // we need to check whether a digit after type",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-24/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 17:36:53.486118334 +0200\n+++ /tmp/tmpthfqsts4.java\t2022-07-19 17:36:53.486118334 +0200\n@@ -1408,11 +1408,11 @@\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+return foundDigit &&!hasExp; // we need to check whether a digit after type\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return foundDigit &&!hasExp; // we need to do a digit after type",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-24/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 17:37:06.554056172 +0200\n+++ /tmp/tmpx235_rmt.java\t2022-07-19 17:37:06.554056172 +0200\n@@ -1408,11 +1408,11 @@\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+return foundDigit &&!hasExp; // we need to do a digit after type\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return foundDigit &&!hasExp; // we need to check whether a digit after the E",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-24/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 17:37:18.889997385 +0200\n+++ /tmp/tmp8trmm760.java\t2022-07-19 17:37:18.889997385 +0200\n@@ -1408,11 +1408,11 @@\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+return foundDigit &&!hasExp; // we need to check whether a digit after the E\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return foundDigit &&!hasExp; // we need to do a digit after the E",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-24/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 17:37:30.849940292 +0200\n+++ /tmp/tmpdsggrk88.java\t2022-07-19 17:37:30.853940272 +0200\n@@ -1408,11 +1408,11 @@\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+return foundDigit &&!hasExp; // we need to do a digit after the E\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return foundDigit &&!hasExp; // we need to check whether a digit after the foundDigit",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-24/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 17:37:42.145886282 +0200\n+++ /tmp/tmpxsner6lg.java\t2022-07-19 17:37:42.145886282 +0200\n@@ -1408,11 +1408,11 @@\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+return foundDigit &&!hasExp; // we need to check whether a digit after the foundDigit\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return foundDigit &&!hasExp; // we need to do a digit after the foundDigit",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-24/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 17:37:51.649840778 +0200\n+++ /tmp/tmpb_9zgjpp.java\t2022-07-19 17:37:51.649840778 +0200\n@@ -1408,11 +1408,11 @@\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+return foundDigit &&!hasExp; // we need to do a digit after the foundDigit\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return foundDigit &&!hasExp; // we need a digit after the foundDigit",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-24/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 17:38:01.165795160 +0200\n+++ /tmp/tmpeyp3a62v.java\t2022-07-19 17:38:01.165795160 +0200\n@@ -1408,11 +1408,11 @@\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+return foundDigit &&!hasExp; // we need a digit after the foundDigit\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return foundDigit && !hasExp;",
        "fixed_line": "return foundDigit && !hasExp && !hasDecPoint;"
    },
    "Lang-42": {
        "fixes": [
            {
                "k": 1,
                "patch": "char c = str.charAt(i; String entityName = this.entityName; if (c > 0x7F) {",
                "patch_diff": "char c = str.charAt(i; String entityName = this.entityName; if (c > 0x7F) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "char c = str.charAt(i); String entityName = this.entityName; if (c > 0x7F) {",
                "patch_diff": "char c = str.charAt(i); String entityName = this.entityName; if (c > 0x7F) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "char c = str.charAt(i); String entityName = this.entityName; if (entityName == null) {",
                "patch_diff": "char c = str.charAt(i); String entityName = this.entityName; if (entityName == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "char c = str.charAt(i; String entityName = this.entityName; if (entityName == null) {",
                "patch_diff": "char c = str.charAt(i; String entityName = this.entityName; if (entityName == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "char c = str.charAt(i; String entityName = this.entityName; if (c < 0x7F) {",
                "patch_diff": "char c = str.charAt(i; String entityName = this.entityName; if (c < 0x7F) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "char c = str.charAt(i); String entityName = this.entityName; if (c < 0x7F) {",
                "patch_diff": "char c = str.charAt(i); String entityName = this.entityName; if (c < 0x7F) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "char c = str.charAt(i; String entityName = this.entityName; if (c == 0x7F) {",
                "patch_diff": "char c = str.charAt(i; String entityName = this.entityName; if (c == 0x7F) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "char c = str.charAt(i; String entityName = this.entityName;",
                "patch_diff": "char c = str.charAt(i; String entityName = this.entityName;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "char c = str.charAt(i); String entityName = this.entityName; if (entity == null) {",
                "patch_diff": "char c = str.charAt(i); String entityName = this.entityName; if (entity == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "char c = str.charAt(i); String entityName = this.entityName;",
                "patch_diff": "char c = str.charAt(i); String entityName = this.entityName;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "char c = str.charAt(i); String entityName = this.entityName(c); if (entityName == null) { if (c > 0x7F) {",
        "fixed_line": "int c = Character.codePointAt(str, i); String entityName = this.entityName(c); if (entityName == null) { if (c >= 0x010000 && i < len - 1) { writer.write(\"&#\"); writer.write(Integer.toString(c, 10)); writer.write(';'); i++; } else if (c > 0x7F) {"
    },
    "Math-9": {
        "fixes": [
            {
                "k": 1,
                "patch": "final Line reverted = new Line2Ddirectiondirection, iValues;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-9/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\t2022-07-19 17:38:11.669744742 +0200\n+++ /tmp/tmpfso0ugml.java\t2022-07-19 17:38:11.713744531 +0200\n@@ -82,11 +82,11 @@\n \n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n+final Line reverted = new Line2Ddirectiondirection, iValues;\n         return reverted;\n     }\n \n     /** Get the normalized direction vector.\n      * @return normalized direction vector\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "final Line reverted = new Line2Ddirection, iValues;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-9/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\t2022-07-19 17:38:14.025733424 +0200\n+++ /tmp/tmpw8gsxyof.java\t2022-07-19 17:38:14.025733424 +0200\n@@ -82,11 +82,11 @@\n \n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n+final Line reverted = new Line2Ddirection, iValues;\n         return reverted;\n     }\n \n     /** Get the normalized direction vector.\n      * @return normalized direction vector\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "final Line reverted = new Line2DUPed;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-9/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\t2022-07-19 17:38:16.017723853 +0200\n+++ /tmp/tmpa_7k43dz.java\t2022-07-19 17:38:16.017723853 +0200\n@@ -82,11 +82,11 @@\n \n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n+final Line reverted = new Line2DUPed;\n         return reverted;\n     }\n \n     /** Get the normalized direction vector.\n      * @return normalized direction vector\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "final Line reverted = new Line2Ddirection, this.direction));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-9/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\t2022-07-19 17:38:18.029714182 +0200\n+++ /tmp/tmp9f2kbad8.java\t2022-07-19 17:38:18.029714182 +0200\n@@ -82,11 +82,11 @@\n \n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n+final Line reverted = new Line2Ddirection, this.direction));\n         return reverted;\n     }\n \n     /** Get the normalized direction vector.\n      * @return normalized direction vector\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "final Line reverted = new Line2Ddirectiondirection, this.direction));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-9/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\t2022-07-19 17:38:19.933705029 +0200\n+++ /tmp/tmpelwc_qrn.java\t2022-07-19 17:38:19.933705029 +0200\n@@ -82,11 +82,11 @@\n \n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n+final Line reverted = new Line2Ddirectiondirection, this.direction));\n         return reverted;\n     }\n \n     /** Get the normalized direction vector.\n      * @return normalized direction vector\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "final Line reverted = new Line2Ddirectiondirection;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-9/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\t2022-07-19 17:38:21.857695776 +0200\n+++ /tmp/tmpl71r2ho1.java\t2022-07-19 17:38:21.857695776 +0200\n@@ -82,11 +82,11 @@\n \n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n+final Line reverted = new Line2Ddirectiondirection;\n         return reverted;\n     }\n \n     /** Get the normalized direction vector.\n      * @return normalized direction vector\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "final Line reverted = new Line2D(0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-9/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\t2022-07-19 17:38:23.865686119 +0200\n+++ /tmp/tmpe0emsrlc.java\t2022-07-19 17:38:23.865686119 +0200\n@@ -82,11 +82,11 @@\n \n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n+final Line reverted = new Line2D(0) {\n         return reverted;\n     }\n \n     /** Get the normalized direction vector.\n      * @return normalized direction vector\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "final Line reverted = new Line2DUMMYed;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-9/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\t2022-07-19 17:38:25.845676593 +0200\n+++ /tmp/tmp3oxj2dm4.java\t2022-07-19 17:38:25.845676593 +0200\n@@ -82,11 +82,11 @@\n \n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n+final Line reverted = new Line2DUMMYed;\n         return reverted;\n     }\n \n     /** Get the normalized direction vector.\n      * @return normalized direction vector\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "final Line reverted = new Line2Ddirection;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-9/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\t2022-07-19 17:38:27.869666852 +0200\n+++ /tmp/tmp1hsxnc_8.java\t2022-07-19 17:38:27.869666852 +0200\n@@ -82,11 +82,11 @@\n \n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n+final Line reverted = new Line2Ddirection;\n         return reverted;\n     }\n \n     /** Get the normalized direction vector.\n      * @return normalized direction vector\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "final Line reverted = new Line2Ddirection, this.direction;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-9/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\t2022-07-19 17:38:29.833657400 +0200\n+++ /tmp/tmpp00ewdu6.java\t2022-07-19 17:38:29.833657400 +0200\n@@ -82,11 +82,11 @@\n \n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n+final Line reverted = new Line2Ddirection, this.direction;\n         return reverted;\n     }\n \n     /** Get the normalized direction vector.\n      * @return normalized direction vector\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "final Line reverted = new Line(zero, zero.subtract(direction));",
        "fixed_line": "final Line reverted = new Line(this); reverted.direction = reverted.direction.negate();"
    },
    "Lang-38": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int i = 0; i < calendar.length; i++) { if (mTimeZone.setTimeZone(mTimeZone); } else { calendar.setTimeZone(mTimeZone); } }",
                "patch_diff": "for (int i = 0; i < calendar.length; i++) { if (mTimeZone.setTimeZone(mTimeZone); } else { calendar.setTimeZone(mTimeZone); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = 0; i < calendar.length; i++) { if (mTimeZone.setTimeZone(mTimeZone); } else { calendar.setTimeZone(mTimeZone); } } return applyRules(calendar, buf); }",
                "patch_diff": "for (int i = 0; i < calendar.length; i++) { if (mTimeZone.setTimeZone(mTimeZone); } else { calendar.setTimeZone(mTimeZone); } } return applyRules(calendar, buf); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0; i < calendar.length; i++) { if (mTimeZone == null) { calendar.setTimeZone(mTimeZone); } else { calendar.setTimeZone(mTimeZone); } }",
                "patch_diff": "for (int i = 0; i < calendar.length; i++) { if (mTimeZone == null) { calendar.setTimeZone(mTimeZone); } else { calendar.setTimeZone(mTimeZone); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = 0; i < calendar.length; i++) {",
                "patch_diff": "for (int i = 0; i < calendar.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = 0; i < calendar.length; i++) { if (mTimeZone == null) { calendar.setTimeZone(mTimeZone); } else { calendar.setTimeZone(mTimeZone); } } return applyRules(calendar, buf); }",
                "patch_diff": "for (int i = 0; i < calendar.length; i++) { if (mTimeZone == null) { calendar.setTimeZone(mTimeZone); } else { calendar.setTimeZone(mTimeZone); } } return applyRules(calendar, buf); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = 0; i < calendar.length; i++) { if (mTimeZone == null) { calendar.setTimeZone(mTimeZone); } buf.setTimeZone(mTimeZone); } return applyRules(calendar, buf); }",
                "patch_diff": "for (int i = 0; i < calendar.length; i++) { if (mTimeZone == null) { calendar.setTimeZone(mTimeZone); } buf.setTimeZone(mTimeZone); } return applyRules(calendar, buf); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = 0; i < calendar.length; i++) { if (mTimeZone == null) { calendar.setTimeZone(mTimeZone); } buf.setTimeZone(mTimeZone); } return applyRules(calendar, buf); } return applyRules(calendar); }",
                "patch_diff": "for (int i = 0; i < calendar.length; i++) { if (mTimeZone == null) { calendar.setTimeZone(mTimeZone); } buf.setTimeZone(mTimeZone); } return applyRules(calendar, buf); } return applyRules(calendar); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = 0; i < calendar.length; i++) { if (mTimeZone.setTimeZone(mTimeZone); } buf.setTimeZone(mTimeZone); } return applyRules(calendar, buf); }",
                "patch_diff": "for (int i = 0; i < calendar.length; i++) { if (mTimeZone.setTimeZone(mTimeZone); } buf.setTimeZone(mTimeZone); } return applyRules(calendar, buf); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (mTimeZone == null) { calendar = (Calendar) calendar.clone(); } else { calendar.setTimeZone(mTimeZone); } return applyRules(calendar, buf); }",
                "patch_diff": "if (mTimeZone == null) { calendar = (Calendar) calendar.clone(); } else { calendar.setTimeZone(mTimeZone); } return applyRules(calendar, buf); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = 0; i < calendar.length; i++) { if (mTimeZone.setTimeZone(mTimeZone); } else { calendar.setTimeZone(mTimeZone); } buf.setTimeZone(mTimeZone); } return applyRules(calendar, buf); }",
                "patch_diff": "for (int i = 0; i < calendar.length; i++) { if (mTimeZone.setTimeZone(mTimeZone); } else { calendar.setTimeZone(mTimeZone); } buf.setTimeZone(mTimeZone); } return applyRules(calendar, buf); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "calendar.getTime(); /// LANG-538"
    },
    "Jsoup-15": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \"Xoframes\", \"style\").5) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-15/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 17:38:34.197636388 +0200\n+++ /tmp/tmp3bots2qt.java\t2022-07-19 17:38:34.269636039 +0200\n@@ -278,11 +278,11 @@\n                         Element html = tb.getStack().getFirst();\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n+} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \"Xoframes\", \"style\").5) {\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                         LinkedList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \"Xoframes\", \"style\") ||!isrames\", \"title\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-15/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 17:38:35.961627889 +0200\n+++ /tmp/tmpz_ns8350.java\t2022-07-19 17:38:35.961627889 +0200\n@@ -278,11 +278,11 @@\n                         Element html = tb.getStack().getFirst();\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n+} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \"Xoframes\", \"style\") ||!isrames\", \"title\")) {\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                         LinkedList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \" \"Xoframes\", \"style\").5) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-15/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 17:38:37.413620894 +0200\n+++ /tmp/tmphxvk9qmr.java\t2022-07-19 17:38:37.413620894 +0200\n@@ -278,11 +278,11 @@\n                         Element html = tb.getStack().getFirst();\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n+} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \" \"Xoframes\", \"style\").5) {\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                         LinkedList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \"Xoframes\", \"style\", \"title\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-15/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 17:38:39.157612489 +0200\n+++ /tmp/tmp5tokqupp.java\t2022-07-19 17:38:39.157612489 +0200\n@@ -278,11 +278,11 @@\n                         Element html = tb.getStack().getFirst();\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n+} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \"Xoframes\", \"style\", \"title\")) {\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                         LinkedList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (StringUtil.ineno, \"base\", \"bgsound\", \"link\", \"meta\", \"style\") ||!isrames\", \"title\", \"style\", \"plot\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-15/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 17:38:40.805604546 +0200\n+++ /tmp/tmpb_08y7ll.java\t2022-07-19 17:38:40.809604527 +0200\n@@ -278,11 +278,11 @@\n                         Element html = tb.getStack().getFirst();\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n+} else if (StringUtil.ineno, \"base\", \"bgsound\", \"link\", \"meta\", \"style\") ||!isrames\", \"title\", \"style\", \"plot\")) {\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                         LinkedList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \"Xoframes\", \"style\") {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-15/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 17:38:42.429596718 +0200\n+++ /tmp/tmpnazfuasl.java\t2022-07-19 17:38:42.433596699 +0200\n@@ -278,11 +278,11 @@\n                         Element html = tb.getStack().getFirst();\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n+} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \"Xoframes\", \"style\") {\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                         LinkedList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \" \"Xoframes\", \"style\") ||!isrames\", \"title\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-15/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 17:38:44.125588541 +0200\n+++ /tmp/tmp9whtevtr.java\t2022-07-19 17:38:44.125588541 +0200\n@@ -278,11 +278,11 @@\n                         Element html = tb.getStack().getFirst();\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n+} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \" \"Xoframes\", \"style\") ||!isrames\", \"title\")) {\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                         LinkedList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \" \"Xoframes\", \"style\", \"title\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-15/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 17:38:45.749580709 +0200\n+++ /tmp/tmpgtzj4pwf.java\t2022-07-19 17:38:45.749580709 +0200\n@@ -278,11 +278,11 @@\n                         Element html = tb.getStack().getFirst();\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n+} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \" \"Xoframes\", \"style\", \"title\")) {\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                         LinkedList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \" \"Xoframes\", \"style\") {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-15/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 17:38:47.401572740 +0200\n+++ /tmp/tmp4io04zgj.java\t2022-07-19 17:38:47.401572740 +0200\n@@ -278,11 +278,11 @@\n                         Element html = tb.getStack().getFirst();\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n+} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \" \"Xoframes\", \"style\") {\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                         LinkedList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \"Xoframes\", \"style\", \"plot\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-15/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 17:38:49.013564964 +0200\n+++ /tmp/tmp3bmytexy.java\t2022-07-19 17:38:49.017564945 +0200\n@@ -278,11 +278,11 @@\n                         Element html = tb.getStack().getFirst();\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n+} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \"Xoframes\", \"style\", \"plot\")) {\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                         LinkedList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "} else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {",
        "fixed_line": "} else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {"
    },
    "Jsoup-45": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (\"-name\".equals(name) && \"td\".equals(name) &&!last)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-45/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2022-07-19 17:38:50.833556182 +0200\n+++ /tmp/tmpjccodmme.java\t2022-07-19 17:38:50.865556027 +0200\n@@ -389,11 +389,11 @@\n             }\n             String name = node.nodeName();\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+} else if (\"-name\".equals(name) && \"td\".equals(name) &&!last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InRow);\n                 break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (\"+\".equals(name) && \"td\".equals(name) &&!last)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-45/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2022-07-19 17:38:52.849546451 +0200\n+++ /tmp/tmp2tak5vq0.java\t2022-07-19 17:38:52.849546451 +0200\n@@ -389,11 +389,11 @@\n             }\n             String name = node.nodeName();\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+} else if (\"+\".equals(name) && \"td\".equals(name) &&!last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InRow);\n                 break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (\"-name\".equals(name) || \"td\".equals(name) &&!last)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-45/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2022-07-19 17:38:54.361539152 +0200\n+++ /tmp/tmpnsv00dpa.java\t2022-07-19 17:38:54.361539152 +0200\n@@ -389,11 +389,11 @@\n             }\n             String name = node.nodeName();\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+} else if (\"-name\".equals(name) || \"td\".equals(name) &&!last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InRow);\n                 break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (\"+\".equals(name) || \"td\".equals(name) &&!last)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-45/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2022-07-19 17:38:55.857531930 +0200\n+++ /tmp/tmpl_yjtfns.java\t2022-07-19 17:38:55.857531930 +0200\n@@ -389,11 +389,11 @@\n             }\n             String name = node.nodeName();\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+} else if (\"+\".equals(name) || \"td\".equals(name) &&!last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InRow);\n                 break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if ((\"td\".equals(name) && \"td\".equals(name) &&!last)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-45/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2022-07-19 17:38:57.581523604 +0200\n+++ /tmp/tmp6s2h10rc.java\t2022-07-19 17:38:57.581523604 +0200\n@@ -389,11 +389,11 @@\n             }\n             String name = node.nodeName();\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+} else if ((\"td\".equals(name) && \"td\".equals(name) &&!last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InRow);\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (\"-td\".equals(name) && \"td\".equals(name) &&!last)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-45/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2022-07-19 17:39:01.373505286 +0200\n+++ /tmp/tmpormy6keq.java\t2022-07-19 17:39:01.373505286 +0200\n@@ -389,11 +389,11 @@\n             }\n             String name = node.nodeName();\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+} else if (\"-td\".equals(name) && \"td\".equals(name) &&!last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InRow);\n                 break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (\"-i\".equals(name) && \"td\".equals(name) &&!last)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-45/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2022-07-19 17:39:02.953497652 +0200\n+++ /tmp/tmprc72kwq9.java\t2022-07-19 17:39:02.953497652 +0200\n@@ -389,11 +389,11 @@\n             }\n             String name = node.nodeName();\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+} else if (\"-i\".equals(name) && \"td\".equals(name) &&!last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InRow);\n                 break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (\"-i\".equals(name) || \"td\".equals(name) &&!last)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-45/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2022-07-19 17:39:04.585489764 +0200\n+++ /tmp/tmpguqpkgt3.java\t2022-07-19 17:39:04.585489764 +0200\n@@ -389,11 +389,11 @@\n             }\n             String name = node.nodeName();\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+} else if (\"-i\".equals(name) || \"td\".equals(name) &&!last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InRow);\n                 break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (\"-td\".equals(name) || \"td\".equals(name) &&!last)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-45/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2022-07-19 17:39:06.113482377 +0200\n+++ /tmp/tmpyz72p_lw.java\t2022-07-19 17:39:06.113482377 +0200\n@@ -389,11 +389,11 @@\n             }\n             String name = node.nodeName();\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+} else if (\"-td\".equals(name) || \"td\".equals(name) &&!last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InRow);\n                 break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (\"-td\".equals(name) && \"td\".equals(name) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-45/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2022-07-19 17:39:07.749474469 +0200\n+++ /tmp/tmprgy9mvz4.java\t2022-07-19 17:39:07.753474450 +0200\n@@ -389,11 +389,11 @@\n             }\n             String name = node.nodeName();\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+} else if (\"-td\".equals(name) && \"td\".equals(name) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InRow);\n                 break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "} else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {",
        "fixed_line": "} else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {"
    },
    "Codec-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "// for (int i = 0; i < 6; i++) {",
                "patch_diff": "// for (int i = 0; i < 6; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// for (int i = 0; i < 6; i++) { char ch = str.charAt(i); if (x == 0) {",
                "patch_diff": "// for (int i = 0; i < 6; i++) { char ch = str.charAt(i); if (x == 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// for (int i = 0; i < 6; i++) { for (int j = 0; j < 6; j++) { x = x << 6; } }",
                "patch_diff": "// for (int i = 0; i < 6; i++) { for (int j = 0; j < 6; j++) { x = x << 6; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// for (int i = 0; i < 6; i++) { for (int j = 0; j < 6; j++) { if (b64variant.isEnabled(MapperFeature.CANONICALIZE_OVERRIDE, declaredType); } } }",
                "patch_diff": "// for (int i = 0; i < 6; i++) { for (int j = 0; j < 6; j++) { if (b64variant.isEnabled(MapperFeature.CANONICALIZE_OVERRIDE, declaredType); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// for (int i = 0; i < 6; i++) { for (int j = 0; j < 6; j++) { if (b64variant.isEnabled(MapperFeature.CANONICALIZE_OVERRIDE, 2 : x; } } }",
                "patch_diff": "// for (int i = 0; i < 6; i++) { for (int j = 0; j < 6; j++) { if (b64variant.isEnabled(MapperFeature.CANONICALIZE_OVERRIDE, 2 : x; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// for (int i = 0; i < 6; i++) { for (int j = 0; j < 6; j++) { if (b64variant.isEnabled(MapperFeature.CANONICALIZE_OVEROVER, 2 : x; } } }",
                "patch_diff": "// for (int i = 0; i < 6; i++) { for (int j = 0; j < 6; j++) { if (b64variant.isEnabled(MapperFeature.CANONICALIZE_OVEROVER, 2 : x; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// for (int i = 0; i < 6; i++) { for (int j = 0; j < 6; j++) { if (x == null) { x = x << 6; } } }",
                "patch_diff": "// for (int i = 0; i < 6; i++) { for (int j = 0; j < 6; j++) { if (x == null) { x = x << 6; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// for (int i = 0; i < 6; i++) { for (int j = 0; j < 6; j++) { if (b64variant.isEnabled(MapperFeature.CANONICALIZE_OVERRIDE, 2 : x; } }",
                "patch_diff": "// for (int i = 0; i < 6; i++) { for (int j = 0; j < 6; j++) { if (b64variant.isEnabled(MapperFeature.CANONICALIZE_OVERRIDE, 2 : x; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// for (int i = 0; i < 6; i++) { for (int j = 0; j < 6; j++) { x = x << 6; } } }",
                "patch_diff": "// for (int i = 0; i < 6; i++) { for (int j = 0; j < 6; j++) { x = x << 6; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// for (int i = 0; i < 6; i++) { for (int j = 0; j < 6; j++) { if (b64variant.isEnabled(MapperFeature.CANONICALIZE_OVEROVER, declaredType); } } }",
                "patch_diff": "// for (int i = 0; i < 6; i++) { for (int j = 0; j < 6; j++) { if (b64variant.isEnabled(MapperFeature.CANONICALIZE_OVEROVER, declaredType); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (buffer == null || buffer.length - pos < decodeSize) { resizeBuffer(); }"
    },
    "Cli-32": {
        "fixes": [
            {
                "k": 1,
                "patch": "while (pos < text.length || ((c = text.charAt(pospos - 1)!='') && (c!= '\\n') || (c!= '\\r')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-32/src/main/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 17:39:11.509456284 +0200\n+++ /tmp/tmpyfm572f0.java\t2022-07-19 17:39:11.645455626 +0200\n@@ -932,15 +932,11 @@\n             return pos;\n         }\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n-        {\n-            ++pos;\n-        }        \n+while (pos < text.length || ((c = text.charAt(pospos - 1)!='') && (c!= '\\n') || (c!= '\\r')) {\n         return pos == text.length() ? -1 : pos;\n     }\n \n     /**\n      * Return a String of padding of length <code>len</code>.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "while (pos < text.length || ((c = text.charAt(pospos - 1)!='') && (c!= '\\n') && (c!= '\\r')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-32/src/main/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 17:39:13.293447654 +0200\n+++ /tmp/tmpnirci3jv.java\t2022-07-19 17:39:13.293447654 +0200\n@@ -932,15 +932,11 @@\n             return pos;\n         }\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n-        {\n-            ++pos;\n-        }        \n+while (pos < text.length || ((c = text.charAt(pospos - 1)!='') && (c!= '\\n') && (c!= '\\r')) {\n         return pos == text.length() ? -1 : pos;\n     }\n \n     /**\n      * Return a String of padding of length <code>len</code>.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "while (pos < text.length || ((c = text.charAt(pospos - 1)!='') && (c!= '\\n') || (c == '\\r')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-32/src/main/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 17:39:14.893439913 +0200\n+++ /tmp/tmp9tc3tn9l.java\t2022-07-19 17:39:14.893439913 +0200\n@@ -932,15 +932,11 @@\n             return pos;\n         }\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n-        {\n-            ++pos;\n-        }        \n+while (pos < text.length || ((c = text.charAt(pospos - 1)!='') && (c!= '\\n') || (c == '\\r')) {\n         return pos == text.length() ? -1 : pos;\n     }\n \n     /**\n      * Return a String of padding of length <code>len</code>.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "while (pos < text.length || ((c = text.charAt(pos - 1)!='') && (c!= '\\n') || (c!= '\\r')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-32/src/main/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 17:39:16.437432441 +0200\n+++ /tmp/tmpi3atu5ho.java\t2022-07-19 17:39:16.437432441 +0200\n@@ -932,15 +932,11 @@\n             return pos;\n         }\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n-        {\n-            ++pos;\n-        }        \n+while (pos < text.length || ((c = text.charAt(pos - 1)!='') && (c!= '\\n') || (c!= '\\r')) {\n         return pos == text.length() ? -1 : pos;\n     }\n \n     /**\n      * Return a String of padding of length <code>len</code>.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "while (pos < text.length || ((c = text.charAt(pos - 1)!='') && (c!= '\\n') && (c!= '\\r')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-32/src/main/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 17:39:18.041424677 +0200\n+++ /tmp/tmp5wslboze.java\t2022-07-19 17:39:18.041424677 +0200\n@@ -932,15 +932,11 @@\n             return pos;\n         }\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n-        {\n-            ++pos;\n-        }        \n+while (pos < text.length || ((c = text.charAt(pos - 1)!='') && (c!= '\\n') && (c!= '\\r')) {\n         return pos == text.length() ? -1 : pos;\n     }\n \n     /**\n      * Return a String of padding of length <code>len</code>.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "while (pos < text.length || ((c = text.charAt(pos - 1)!='') && (c!= '\\n') || (c == '\\r')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-32/src/main/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 17:39:19.701416641 +0200\n+++ /tmp/tmpcc7gr5t3.java\t2022-07-19 17:39:19.705416621 +0200\n@@ -932,15 +932,11 @@\n             return pos;\n         }\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n-        {\n-            ++pos;\n-        }        \n+while (pos < text.length || ((c = text.charAt(pos - 1)!='') && (c!= '\\n') || (c == '\\r')) {\n         return pos == text.length() ? -1 : pos;\n     }\n \n     /**\n      * Return a String of padding of length <code>len</code>.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "while (pos < text.length()) || ((c = text.charAt(pospos - 1)!= '\\n') && (c!= '\\r')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-32/src/main/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 17:39:21.493407969 +0200\n+++ /tmp/tmp3xjcgper.java\t2022-07-19 17:39:21.497407949 +0200\n@@ -932,15 +932,11 @@\n             return pos;\n         }\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n-        {\n-            ++pos;\n-        }        \n+while (pos < text.length()) || ((c = text.charAt(pospos - 1)!= '\\n') && (c!= '\\r')) {\n         return pos == text.length() ? -1 : pos;\n     }\n \n     /**\n      * Return a String of padding of length <code>len</code>.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "while (pos < text.length || ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-32/src/main/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 17:39:23.117400100 +0200\n+++ /tmp/tmp3zy8l842.java\t2022-07-19 17:39:23.117400100 +0200\n@@ -932,15 +932,11 @@\n             return pos;\n         }\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n-        {\n-            ++pos;\n-        }        \n+while (pos < text.length || ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) {\n         return pos == text.length() ? -1 : pos;\n     }\n \n     /**\n      * Return a String of padding of length <code>len</code>.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "while (pos < text.length || ((c = text.charAt(pos))!='') && (c!= '\\n') || (c!= '\\r')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-32/src/main/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 17:39:24.793391981 +0200\n+++ /tmp/tmpofyi5igb.java\t2022-07-19 17:39:24.793391981 +0200\n@@ -932,15 +932,11 @@\n             return pos;\n         }\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n-        {\n-            ++pos;\n-        }        \n+while (pos < text.length || ((c = text.charAt(pos))!='') && (c!= '\\n') || (c!= '\\r')) {\n         return pos == text.length() ? -1 : pos;\n     }\n \n     /**\n      * Return a String of padding of length <code>len</code>.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "while (pos < text.length()) || ((c =='') && (c!= '\\n') && (c!= '\\r')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-32/src/main/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 17:39:26.325384559 +0200\n+++ /tmp/tmpzymhl9yz.java\t2022-07-19 17:39:26.325384559 +0200\n@@ -932,15 +932,11 @@\n             return pos;\n         }\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n-        {\n-            ++pos;\n-        }        \n+while (pos < text.length()) || ((c =='') && (c!= '\\n') && (c!= '\\r')) {\n         return pos == text.length() ? -1 : pos;\n     }\n \n     /**\n      * Return a String of padding of length <code>len</code>.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ') && (c != '\\n') && (c != '\\r')) { ++pos; }",
        "fixed_line": ""
    },
    "Closure-88": {
        "fixes": [
            {
                "k": 1,
                "patch": "// We can't really modify it was non-empty's do implicit re-parse",
                "patch_diff": "// We can't really modify it was non-empty's do implicit re-parse",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// We can't really modify it was non-literal characters that might be valid (NodeUtil.isLhs(n, parent)) {",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (NodeUtil.isLhs(n, parent)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// We can't really modify it was non-literal characters that might be valid (NodeUtil.isLhs(n) && n.getString().equals(varName)) {",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (NodeUtil.isLhs(n) && n.getString().equals(varName)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// We can't really modify it was non-literal characters that might be valid (NodeUtil.isLhs(n) && n.getString())) {",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (NodeUtil.isLhs(n) && n.getString())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// We can't really modify it was non-literal characters that might be valid (NodeUtil.isLhs(n) && n.getParent())) {",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (NodeUtil.isLhs(n) && n.getParent())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// We can't really modify it was non-literal characters that might be valid (NodeUtil.isLhs(n) && n.getString().equals(varName;",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (NodeUtil.isLhs(n) && n.getString().equals(varName;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// We can't really modify it was non-literal characters that might be valid (NodeUtil.isFunction(parent) && n.getParent())) {",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (NodeUtil.isFunction(parent) && n.getParent())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// We can't really modify it was non-literal characters that might be valid (NodeUtil.isLhs(n, parent) && n.getParent())) {",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (NodeUtil.isLhs(n, parent) && n.getParent())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// We can't really modify it was non-literal characters that might be valid (NodeUtil.isFunction(n, parent)) {",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (NodeUtil.isFunction(n, parent)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// We can't really modify it was non-literal characters that might be valid (NodeUtil.isLhs(n) && n.getString().equals(varName) {",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (NodeUtil.isLhs(n) && n.getString().equals(varName) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); // The expression to which the assignment is made is evaluated before // the RHS is evaluated (normal left to right evaluation) but the KILL // occurs after the RHS is evaluated. Node rhs = n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) { return state; }"
    },
    "JacksonDatabind-76": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (ctxt.assignParameter(creatorProp, bean bean;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-76/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\t2022-07-19 17:39:29.853367463 +0200\n+++ /tmp/tmpsfjdof06.java\t2022-07-19 17:39:29.945367017 +0200\n@@ -578,31 +578,11 @@\n             String propName = p.getCurrentName();\n             p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n-                }\n+if (ctxt.assignParameter(creatorProp, bean bean;\n                 continue;\n             }\n             // Object Id property?\n             if (buffer.readIdProperty(propName)) {\n                 continue;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (ctxt.assignParameter(creatorProp, bean = _beanType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-76/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\t2022-07-19 17:39:32.141356373 +0200\n+++ /tmp/tmp2y6wbcuu.java\t2022-07-19 17:39:32.145356354 +0200\n@@ -578,31 +578,11 @@\n             String propName = p.getCurrentName();\n             p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n-                }\n+if (ctxt.assignParameter(creatorProp, bean = _beanType;\n                 continue;\n             }\n             // Object Id property?\n             if (buffer.readIdProperty(propName)) {\n                 continue;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (ctxt.assignParameter(creatorProp, bean, propName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-76/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\t2022-07-19 17:39:33.921347743 +0200\n+++ /tmp/tmpmmzd1_zf.java\t2022-07-19 17:39:33.921347743 +0200\n@@ -578,31 +578,11 @@\n             String propName = p.getCurrentName();\n             p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n-                }\n+if (ctxt.assignParameter(creatorProp, bean, propName);\n                 continue;\n             }\n             // Object Id property?\n             if (buffer.readIdProperty(propName)) {\n                 continue;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (ctxt.assignParameter(creatorProp, bean) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-76/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\t2022-07-19 17:39:35.573339731 +0200\n+++ /tmp/tmpznxbec5y.java\t2022-07-19 17:39:35.573339731 +0200\n@@ -578,31 +578,11 @@\n             String propName = p.getCurrentName();\n             p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n-                }\n+if (ctxt.assignParameter(creatorProp, bean) {\n                 continue;\n             }\n             // Object Id property?\n             if (buffer.readIdProperty(propName)) {\n                 continue;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (ctxt.assignParameter(creatorProp, _beanType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-76/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\t2022-07-19 17:39:37.321331251 +0200\n+++ /tmp/tmp_27na4pf.java\t2022-07-19 17:39:37.321331251 +0200\n@@ -578,31 +578,11 @@\n             String propName = p.getCurrentName();\n             p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n-                }\n+if (ctxt.assignParameter(creatorProp, _beanType;\n                 continue;\n             }\n             // Object Id property?\n             if (buffer.readIdProperty(propName)) {\n                 continue;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (ctxt.assignParameter(creatorProp, bean)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-76/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\t2022-07-19 17:39:38.965323277 +0200\n+++ /tmp/tmpuo98cfvi.java\t2022-07-19 17:39:38.965323277 +0200\n@@ -578,31 +578,11 @@\n             String propName = p.getCurrentName();\n             p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n-                }\n+if (ctxt.assignParameter(creatorProp, bean)) {\n                 continue;\n             }\n             // Object Id property?\n             if (buffer.readIdProperty(propName)) {\n                 continue;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (ctxt.assignParameter(creatorProp, bean;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-76/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\t2022-07-19 17:39:40.469315978 +0200\n+++ /tmp/tmpekcgfha1.java\t2022-07-19 17:39:40.469315978 +0200\n@@ -578,31 +578,11 @@\n             String propName = p.getCurrentName();\n             p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n-                }\n+if (ctxt.assignParameter(creatorProp, bean;\n                 continue;\n             }\n             // Object Id property?\n             if (buffer.readIdProperty(propName)) {\n                 continue;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (type == TYPE_ARRAY) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-76/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\t2022-07-19 17:39:42.105308039 +0200\n+++ /tmp/tmp6wjma4tc.java\t2022-07-19 17:39:42.105308039 +0200\n@@ -578,31 +578,11 @@\n             String propName = p.getCurrentName();\n             p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n-                }\n+if (type == TYPE_ARRAY) {\n                 continue;\n             }\n             // Object Id property?\n             if (buffer.readIdProperty(propName)) {\n                 continue;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (ctxt.assignParameter(creatorProp, bean bean bean;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-76/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\t2022-07-19 17:39:43.761300003 +0200\n+++ /tmp/tmplvnef0pz.java\t2022-07-19 17:39:43.761300003 +0200\n@@ -578,31 +578,11 @@\n             String propName = p.getCurrentName();\n             p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n-                }\n+if (ctxt.assignParameter(creatorProp, bean bean bean;\n                 continue;\n             }\n             // Object Id property?\n             if (buffer.readIdProperty(propName)) {\n                 continue;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (t == JsonToken.FIELD_NAME) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-76/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\t2022-07-19 17:39:45.361292235 +0200\n+++ /tmp/tmppvkbc0qc.java\t2022-07-19 17:39:45.361292235 +0200\n@@ -578,31 +578,11 @@\n             String propName = p.getCurrentName();\n             p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n-                }\n+if (t == JsonToken.FIELD_NAME) {\n                 continue;\n             }\n             // Object Id property?\n             if (buffer.readIdProperty(propName)) {\n                 continue;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) { t = p.nextToken(); Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); continue; } while (t == JsonToken.FIELD_NAME) { p.nextToken(); tokens.copyCurrentStructure(p); t = p.nextToken(); } tokens.writeEndObject(); if (bean.getClass() != _beanType.getRawClass()) { ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\"); return null; } return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); }",
        "fixed_line": "buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));"
    },
    "Math-48": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if (f0 *= (f1 / (f1 + fx); break;",
                "patch_diff": "// if (f0 *= (f1 / (f1 + fx); break;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// }",
                "patch_diff": "// }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if (f0 *= (f1 / (f1 + fx); break; case REGULA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIB",
                "patch_diff": "// if (f0 *= (f1 / (f1 + fx); break; case REGULA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIB",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// if (f0 *= (f1 / (f1 + fx); break; case REGULA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIB_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIB",
                "patch_diff": "// if (f0 *= (f1 / (f1 + fx); break; case REGULA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIB_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIB",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// if (f0 *= (f1 / (f1 + fx); break; case REGULA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIB_FALSIA_FALSIB",
                "patch_diff": "// if (f0 *= (f1 / (f1 + fx); break; case REGULA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIB_FALSIA_FALSIB",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if (f0 *= (f1 / (f1 + fx);",
                "patch_diff": "// if (f0 *= (f1 / (f1 + fx);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// if (f0 *= (f1 / (f1 + fx); break; case REGULA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIB_FALSIA_FALSIA_FALSIA_FALSIA_FALSIB",
                "patch_diff": "// if (f0 *= (f1 / (f1 + fx); break; case REGULA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIB_FALSIA_FALSIA_FALSIA_FALSIA_FALSIB",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// if (f0 *= (f1 / (f1 + fx); break; case REGULA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIB_FALSIB",
                "patch_diff": "// if (f0 *= (f1 / (f1 + fx); break; case REGULA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIB_FALSIB",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// if (f0 *= (f1 / (f1 + fx); break; case REGULA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA",
                "patch_diff": "// if (f0 *= (f1 / (f1 + fx); break; case REGULA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if (f0 *= (f1 / (f1 + fx); break; case REGULA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIB",
                "patch_diff": "// if (f0 *= (f1 / (f1 + fx); break; case REGULA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIA_FALSIB",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (x == x1) { throw new ConvergenceException(); }"
    },
    "Math-95": {
        "fixes": [
            {
                "k": 1,
                "patch": "double ret = this.enominator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2022-07-19 17:39:49.325272988 +0200\n+++ /tmp/tmpz99h0lat.java\t2022-07-19 17:39:49.469272287 +0200\n@@ -139,11 +139,11 @@\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+double ret = this.enominator;\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "double ret = p.enom;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2022-07-19 17:39:52.029259853 +0200\n+++ /tmp/tmpjy1uz3dz.java\t2022-07-19 17:39:52.033259834 +0200\n@@ -139,11 +139,11 @@\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+double ret = p.enom;\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "double ret = p.enominator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2022-07-19 17:39:54.249249068 +0200\n+++ /tmp/tmporaxv61h.java\t2022-07-19 17:39:54.253249048 +0200\n@@ -139,11 +139,11 @@\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+double ret = p.enominator;\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "double p = this.enominator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2022-07-19 17:39:56.297239114 +0200\n+++ /tmp/tmpk438miah.java\t2022-07-19 17:39:56.297239114 +0200\n@@ -139,11 +139,11 @@\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+double p = this.enominator;\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "double denominator = p.enom;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2022-07-19 17:39:58.501228403 +0200\n+++ /tmp/tmpzhoc8h_l.java\t2022-07-19 17:39:58.501228403 +0200\n@@ -139,11 +139,11 @@\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+double denominator = p.enom;\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "double denominator = this.enominator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2022-07-19 17:40:00.725217590 +0200\n+++ /tmp/tmpczc_5gfv.java\t2022-07-19 17:40:00.725217590 +0200\n@@ -139,11 +139,11 @@\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+double denominator = this.enominator;\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "double p = p.enominator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2022-07-19 17:40:02.869207164 +0200\n+++ /tmp/tmpfau33brp.java\t2022-07-19 17:40:02.869207164 +0200\n@@ -139,11 +139,11 @@\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+double p = p.enominator;\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "double denominator = p.enominator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2022-07-19 17:40:05.057196522 +0200\n+++ /tmp/tmpmgukn4i3.java\t2022-07-19 17:40:05.057196522 +0200\n@@ -139,11 +139,11 @@\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+double denominator = p.enominator;\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "double p = p.enom;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2022-07-19 17:40:07.213186033 +0200\n+++ /tmp/tmp26g1rav3.java\t2022-07-19 17:40:07.213186033 +0200\n@@ -139,11 +139,11 @@\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+double p = p.enom;\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "double ret = p;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2022-07-19 17:40:09.361175580 +0200\n+++ /tmp/tmpvdqqkq5m.java\t2022-07-19 17:40:09.361175580 +0200\n@@ -139,11 +139,11 @@\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+double ret = p;\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "double ret;",
        "fixed_line": "double ret = 1.0; double d = getDenominatorDegreesOfFreedom(); if (d > 2.0) { // use mean ret = d / (d - 2.0); }"
    },
    "Chart-6": {
        "fixes": [
            {
                "k": 1,
                "patch": "return super.equalsParent.equals(objType.obj);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-6/source/org/jfree/chart/util/ShapeList.java\t2022-07-19 17:40:17.117137824 +0200\n+++ /tmp/tmpqd6yiwzp.java\t2022-07-19 17:40:17.153137647 +0200\n@@ -106,11 +106,11 @@\n             return true;\n         }\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+return super.equalsParent.equals(objType.obj);\n \n     }\n \n     /**\n      * Returns a hash code value for the object.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return super.object.equals(objType.obj;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-6/source/org/jfree/chart/util/ShapeList.java\t2022-07-19 17:40:19.721125138 +0200\n+++ /tmp/tmphur6i1xa.java\t2022-07-19 17:40:19.721125138 +0200\n@@ -106,11 +106,11 @@\n             return true;\n         }\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+return super.object.equals(objType.obj;\n \n     }\n \n     /**\n      * Returns a hash code value for the object.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return super.equalsParent.equals;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-6/source/org/jfree/chart/util/ShapeList.java\t2022-07-19 17:40:21.445116741 +0200\n+++ /tmp/tmp82kvvo2g.java\t2022-07-19 17:40:21.449116721 +0200\n@@ -106,11 +106,11 @@\n             return true;\n         }\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+return super.equalsParent.equals;\n \n     }\n \n     /**\n      * Returns a hash code value for the object.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return super.equalsParent.equals(objType.obj;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-6/source/org/jfree/chart/util/ShapeList.java\t2022-07-19 17:40:23.301107698 +0200\n+++ /tmp/tmp6pgftnzc.java\t2022-07-19 17:40:23.301107698 +0200\n@@ -106,11 +106,11 @@\n             return true;\n         }\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+return super.equalsParent.equals(objType.obj;\n \n     }\n \n     /**\n      * Returns a hash code value for the object.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return typeList.equals(objType.obj;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-6/source/org/jfree/chart/util/ShapeList.java\t2022-07-19 17:40:24.877100016 +0200\n+++ /tmp/tmpr8qr_1q6.java\t2022-07-19 17:40:24.877100016 +0200\n@@ -106,11 +106,11 @@\n             return true;\n         }\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+return typeList.equals(objType.obj;\n \n     }\n \n     /**\n      * Returns a hash code value for the object.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return super.equalsParent.equals(obj);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-6/source/org/jfree/chart/util/ShapeList.java\t2022-07-19 17:40:26.557091828 +0200\n+++ /tmp/tmpigrw96y5.java\t2022-07-19 17:40:26.557091828 +0200\n@@ -106,11 +106,11 @@\n             return true;\n         }\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+return super.equalsParent.equals(obj);\n \n     }\n \n     /**\n      * Returns a hash code value for the object.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return super.equalsParent.equals(objType.objType.obj);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-6/source/org/jfree/chart/util/ShapeList.java\t2022-07-19 17:40:28.365083014 +0200\n+++ /tmp/tmp03u4q_s7.java\t2022-07-19 17:40:28.369082995 +0200\n@@ -106,11 +106,11 @@\n             return true;\n         }\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+return super.equalsParent.equals(objType.objType.obj);\n \n     }\n \n     /**\n      * Returns a hash code value for the object.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return super.object.equalsParent.equals(objType.obj);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-6/source/org/jfree/chart/util/ShapeList.java\t2022-07-19 17:40:30.157074276 +0200\n+++ /tmp/tmpzf3vv5th.java\t2022-07-19 17:40:30.157074276 +0200\n@@ -106,11 +106,11 @@\n             return true;\n         }\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+return super.object.equalsParent.equals(objType.obj);\n \n     }\n \n     /**\n      * Returns a hash code value for the object.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return super.equalsParent.equals(objType.objType.obj;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-6/source/org/jfree/chart/util/ShapeList.java\t2022-07-19 17:40:31.901065772 +0200\n+++ /tmp/tmp957271pq.java\t2022-07-19 17:40:31.905065753 +0200\n@@ -106,11 +106,11 @@\n             return true;\n         }\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+return super.equalsParent.equals(objType.objType.obj;\n \n     }\n \n     /**\n      * Returns a hash code value for the object.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return typeList.equalsParent.equals(objType.obj);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-6/source/org/jfree/chart/util/ShapeList.java\t2022-07-19 17:40:33.489058027 +0200\n+++ /tmp/tmpprpirqw1.java\t2022-07-19 17:40:33.489058027 +0200\n@@ -106,11 +106,11 @@\n             return true;\n         }\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+return typeList.equalsParent.equals(objType.obj);\n \n     }\n \n     /**\n      * Returns a hash code value for the object.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return super.equals(obj);",
        "fixed_line": "ShapeList that = (ShapeList) obj; int listSize = size(); for (int i = 0; i < listSize; i++) { if (!ShapeUtilities.equal((Shape) get(i), (Shape) that.get(i))) { return false; } } return true;"
    },
    "Closure-78": {
        "fixes": [
            {
                "k": 1,
                "patch": "error.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 17:40:35.513048153 +0200\n+++ /tmp/tmphdy1s_2j.java\t2022-07-19 17:40:35.565047900 +0200\n@@ -706,18 +706,11 @@\n       case Token.MUL:\n         result = lval * rval;\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+error.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right;\n           return null;\n         }\n         result = lval / rval;\n         break;\n       default:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "error.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right; break default",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 17:40:39.109030607 +0200\n+++ /tmp/tmp75vpfi3_.java\t2022-07-19 17:40:39.113030588 +0200\n@@ -706,18 +706,11 @@\n       case Token.MUL:\n         result = lval * rval;\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+error.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right; break default\n           return null;\n         }\n         result = lval / rval;\n         break;\n       default:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "error(JSType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 17:40:41.697017975 +0200\n+++ /tmp/tmpzb499a84.java\t2022-07-19 17:40:41.697017975 +0200\n@@ -706,18 +706,11 @@\n       case Token.MUL:\n         result = lval * rval;\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+error(JSType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right;\n           return null;\n         }\n         result = lval / rval;\n         break;\n       default:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "errorReporterType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 17:40:44.169005908 +0200\n+++ /tmp/tmp_5zeq7wi.java\t2022-07-19 17:40:44.173005889 +0200\n@@ -706,18 +706,11 @@\n       case Token.MUL:\n         result = lval * rval;\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+errorReporterType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right;\n           return null;\n         }\n         result = lval / rval;\n         break;\n       default:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "error(JSType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right; break default",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 17:40:46.604994011 +0200\n+++ /tmp/tmp0i_kfg7q.java\t2022-07-19 17:40:46.604994011 +0200\n@@ -706,18 +706,11 @@\n       case Token.MUL:\n         result = lval * rval;\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+error(JSType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right; break default\n           return null;\n         }\n         result = lval / rval;\n         break;\n       default:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "errorReporterType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right; break default",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 17:40:49.248981097 +0200\n+++ /tmp/tmpjsifmqpz.java\t2022-07-19 17:40:49.248981097 +0200\n@@ -706,18 +706,11 @@\n       case Token.MUL:\n         result = lval * rval;\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+errorReporterType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right; break default\n           return null;\n         }\n         result = lval / rval;\n         break;\n       default:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "error.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), rightType.error;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 17:40:51.944967928 +0200\n+++ /tmp/tmpmlc7lzul.java\t2022-07-19 17:40:51.948967906 +0200\n@@ -706,18 +706,11 @@\n       case Token.MUL:\n         result = lval * rval;\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+error.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), rightType.error;\n           return null;\n         }\n         result = lval / rval;\n         break;\n       default:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "error.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by lval % rval == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 17:40:54.464955612 +0200\n+++ /tmp/tmp9jg89d_x.java\t2022-07-19 17:40:54.464955612 +0200\n@@ -706,18 +706,11 @@\n       case Token.MUL:\n         result = lval * rval;\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+error.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by lval % rval == 0) {\n           return null;\n         }\n         result = lval / rval;\n         break;\n       default:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "error(JSType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), rightType.error;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 17:40:57.136942552 +0200\n+++ /tmp/tmpqjjqoss5.java\t2022-07-19 17:40:57.136942552 +0200\n@@ -706,18 +706,11 @@\n       case Token.MUL:\n         result = lval * rval;\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+error(JSType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), rightType.error;\n           return null;\n         }\n         result = lval / rval;\n         break;\n       default:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "errorReporterType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), rightType.error;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 17:40:59.592930547 +0200\n+++ /tmp/tmpb0udguu5.java\t2022-07-19 17:40:59.592930547 +0200\n@@ -706,18 +706,11 @@\n       case Token.MUL:\n         result = lval * rval;\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+errorReporterType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), rightType.error;\n           return null;\n         }\n         result = lval / rval;\n         break;\n       default:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right); return null; } result = lval % rval; break; case Token.DIV: if (rval == 0) { error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);",
        "fixed_line": ""
    },
    "Codec-3": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (escapeic --// contains(value, index + 1, 4, \"IER) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-3/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\t2022-07-19 17:41:02.248917559 +0200\n+++ /tmp/tmpbgthxoob.java\t2022-07-19 17:41:02.276917421 +0200\n@@ -450,11 +450,11 @@\n                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n             //-- Italian \"biaggi\" --//\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+} else if (escapeic --// contains(value, index + 1, 4, \"IER) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n             }\n             index += 2;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (escapeic --// contains(value, index + 1, 4, \"IER\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-3/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\t2022-07-19 17:41:03.972909126 +0200\n+++ /tmp/tmpfnb3aky3.java\t2022-07-19 17:41:03.976909107 +0200\n@@ -450,11 +450,11 @@\n                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n             //-- Italian \"biaggi\" --//\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+} else if (escapeic --// contains(value, index + 1, 4, \"IER\")) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n             }\n             index += 2;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (VARSON.contains(value, index + 1, 4, \"IER) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-3/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\t2022-07-19 17:41:05.452901887 +0200\n+++ /tmp/tmpc8fwux4h.java\t2022-07-19 17:41:05.452901887 +0200\n@@ -450,11 +450,11 @@\n                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n             //-- Italian \"biaggi\" --//\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+} else if (VARSON.contains(value, index + 1, 4, \"IER) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n             }\n             index += 2;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (VARSON.contains(value, index + 1, 4, \"IER\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-3/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\t2022-07-19 17:41:06.992894355 +0200\n+++ /tmp/tmpava7wjo7.java\t2022-07-19 17:41:06.992894355 +0200\n@@ -450,11 +450,11 @@\n                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n             //-- Italian \"biaggi\" --//\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+} else if (VARSON.contains(value, index + 1, 4, \"IER\")) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n             }\n             index += 2;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (contains(value, index + 1, 4, \"IER) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-3/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\t2022-07-19 17:41:08.744885781 +0200\n+++ /tmp/tmpy0gnfuy4.java\t2022-07-19 17:41:08.744885781 +0200\n@@ -450,11 +450,11 @@\n                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n             //-- Italian \"biaggi\" --//\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+} else if (contains(value, index + 1, 4, \"IER) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n             }\n             index += 2;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (contains(value, index + 1, 3, \"IER\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-3/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\t2022-07-19 17:41:10.296878186 +0200\n+++ /tmp/tmptsj13k29.java\t2022-07-19 17:41:10.296878186 +0200\n@@ -450,11 +450,11 @@\n                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n             //-- Italian \"biaggi\" --//\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+} else if (contains(value, index + 1, 3, \"IER\")) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n             }\n             index += 2;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 7,
                "patch": "} else if (contains(value, index + 1, 4, \"IER\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-3/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\t2022-07-19 17:41:13.308863444 +0200\n+++ /tmp/tmp58xptze2.java\t2022-07-19 17:41:13.312863425 +0200\n@@ -450,11 +450,11 @@\n                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n             //-- Italian \"biaggi\" --//\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+} else if (contains(value, index + 1, 4, \"IER\")) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n             }\n             index += 2;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (contains(value, index + 1, 3, \"IER) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-3/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\t2022-07-19 17:41:16.120849677 +0200\n+++ /tmp/tmp6l1s1hpl.java\t2022-07-19 17:41:16.124849658 +0200\n@@ -450,11 +450,11 @@\n                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n             //-- Italian \"biaggi\" --//\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+} else if (contains(value, index + 1, 3, \"IER) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n             }\n             index += 2;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (isInline(value, index + 1, 4, \"IER) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-3/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\t2022-07-19 17:41:17.616842352 +0200\n+++ /tmp/tmp6j2vn12n.java\t2022-07-19 17:41:17.620842333 +0200\n@@ -450,11 +450,11 @@\n                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n             //-- Italian \"biaggi\" --//\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+} else if (isInline(value, index + 1, 4, \"IER) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n             }\n             index += 2;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (isInline(value, index + 1, 4, \"IER\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-3/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\t2022-07-19 17:41:19.144834868 +0200\n+++ /tmp/tmpwnanf7ss.java\t2022-07-19 17:41:19.144834868 +0200\n@@ -450,11 +450,11 @@\n                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n             //-- Italian \"biaggi\" --//\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+} else if (isInline(value, index + 1, 4, \"IER\")) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n             }\n             index += 2;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "} else if (contains(value, index + 1, 4, \"IER\")) {",
        "fixed_line": "} else if (contains(value, index + 1, 3, \"IER\")) {"
    },
    "Codec-15": {
        "fixes": [
            {
                "k": 1,
                "patch": "final char hwChar = str.charAt(index - 1) == mappedChar || 'W' == preHWChar || 'W' == preHWChar) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-15/src/main/java/org/apache/commons/codec/language/Soundex.java\t2022-07-19 17:41:21.200824796 +0200\n+++ /tmp/tmp69eez6yb.java\t2022-07-19 17:41:21.352824052 +0200\n@@ -183,15 +183,11 @@\n     private char getMappingCode(final String str, final int index) {\n         // map() throws IllegalArgumentException\n         final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            final char hwChar = str.charAt(index - 1);\n-            if ('H' == hwChar || 'W' == hwChar) {\n-                final char preHWChar = str.charAt(index - 2);\n-                final char firstCode = this.map(preHWChar);\n-                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n+final char hwChar = str.charAt(index - 1) == mappedChar || 'W' == preHWChar || 'W' == preHWChar) {\n                     return 0;\n                 }\n             }\n         }\n         return mappedChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "final char hwChar = str.charAt(index - 1) == mappedChar || 'W' == preHWChar || 'W' == preHWChar)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-15/src/main/java/org/apache/commons/codec/language/Soundex.java\t2022-07-19 17:41:23.248814765 +0200\n+++ /tmp/tmpu0jo91n4.java\t2022-07-19 17:41:23.248814765 +0200\n@@ -183,15 +183,11 @@\n     private char getMappingCode(final String str, final int index) {\n         // map() throws IllegalArgumentException\n         final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            final char hwChar = str.charAt(index - 1);\n-            if ('H' == hwChar || 'W' == hwChar) {\n-                final char preHWChar = str.charAt(index - 2);\n-                final char firstCode = this.map(preHWChar);\n-                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n+final char hwChar = str.charAt(index - 1) == mappedChar || 'W' == preHWChar || 'W' == preHWChar)) {\n                     return 0;\n                 }\n             }\n         }\n         return mappedChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "final char hwChar = str.charAt(index - 1) == ':'WChar || 'W' == preHWChar || 'W' == preHWChar) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-15/src/main/java/org/apache/commons/codec/language/Soundex.java\t2022-07-19 17:41:24.760807356 +0200\n+++ /tmp/tmp8gb2_puw.java\t2022-07-19 17:41:24.760807356 +0200\n@@ -183,15 +183,11 @@\n     private char getMappingCode(final String str, final int index) {\n         // map() throws IllegalArgumentException\n         final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            final char hwChar = str.charAt(index - 1);\n-            if ('H' == hwChar || 'W' == hwChar) {\n-                final char preHWChar = str.charAt(index - 2);\n-                final char firstCode = this.map(preHWChar);\n-                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n+final char hwChar = str.charAt(index - 1) == ':'WChar || 'W' == preHWChar || 'W' == preHWChar) {\n                     return 0;\n                 }\n             }\n         }\n         return mappedChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "final char hwChar = str.charAt(index - 1) == hwChar || 'W' == preHWChar || 'W' == preHWChar) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-15/src/main/java/org/apache/commons/codec/language/Soundex.java\t2022-07-19 17:41:26.272799948 +0200\n+++ /tmp/tmpxv16azje.java\t2022-07-19 17:41:26.276799928 +0200\n@@ -183,15 +183,11 @@\n     private char getMappingCode(final String str, final int index) {\n         // map() throws IllegalArgumentException\n         final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            final char hwChar = str.charAt(index - 1);\n-            if ('H' == hwChar || 'W' == hwChar) {\n-                final char preHWChar = str.charAt(index - 2);\n-                final char firstCode = this.map(preHWChar);\n-                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n+final char hwChar = str.charAt(index - 1) == hwChar || 'W' == preHWChar || 'W' == preHWChar) {\n                     return 0;\n                 }\n             }\n         }\n         return mappedChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "final char hwChar = str.charAt(index - 1) == namesChar || 'W' == preHWChar || 'W' == preHWChar) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-15/src/main/java/org/apache/commons/codec/language/Soundex.java\t2022-07-19 17:41:27.828792321 +0200\n+++ /tmp/tmp8haks0bc.java\t2022-07-19 17:41:27.832792302 +0200\n@@ -183,15 +183,11 @@\n     private char getMappingCode(final String str, final int index) {\n         // map() throws IllegalArgumentException\n         final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            final char hwChar = str.charAt(index - 1);\n-            if ('H' == hwChar || 'W' == hwChar) {\n-                final char preHWChar = str.charAt(index - 2);\n-                final char firstCode = this.map(preHWChar);\n-                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n+final char hwChar = str.charAt(index - 1) == namesChar || 'W' == preHWChar || 'W' == preHWChar) {\n                     return 0;\n                 }\n             }\n         }\n         return mappedChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "final char hwChar = str.charAt(index - 1) == hwChar || 'W' == preHWChar || 'W' == preHWChar)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-15/src/main/java/org/apache/commons/codec/language/Soundex.java\t2022-07-19 17:41:29.296785126 +0200\n+++ /tmp/tmppscw2oen.java\t2022-07-19 17:41:29.296785126 +0200\n@@ -183,15 +183,11 @@\n     private char getMappingCode(final String str, final int index) {\n         // map() throws IllegalArgumentException\n         final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            final char hwChar = str.charAt(index - 1);\n-            if ('H' == hwChar || 'W' == hwChar) {\n-                final char preHWChar = str.charAt(index - 2);\n-                final char firstCode = this.map(preHWChar);\n-                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n+final char hwChar = str.charAt(index - 1) == hwChar || 'W' == preHWChar || 'W' == preHWChar)) {\n                     return 0;\n                 }\n             }\n         }\n         return mappedChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "final char hwChar = str.charAt(index - 1) ===0Char || 'W' == preHWChar || 'W' == preHWChar) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-15/src/main/java/org/apache/commons/codec/language/Soundex.java\t2022-07-19 17:41:30.828777616 +0200\n+++ /tmp/tmpasbydkze.java\t2022-07-19 17:41:30.828777616 +0200\n@@ -183,15 +183,11 @@\n     private char getMappingCode(final String str, final int index) {\n         // map() throws IllegalArgumentException\n         final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            final char hwChar = str.charAt(index - 1);\n-            if ('H' == hwChar || 'W' == hwChar) {\n-                final char preHWChar = str.charAt(index - 2);\n-                final char firstCode = this.map(preHWChar);\n-                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n+final char hwChar = str.charAt(index - 1) ===0Char || 'W' == preHWChar || 'W' == preHWChar) {\n                     return 0;\n                 }\n             }\n         }\n         return mappedChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "final char hwChar = str.charAt(index - 1) == initChar || 'W' == preHWChar || 'W' == preHWChar) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-15/src/main/java/org/apache/commons/codec/language/Soundex.java\t2022-07-19 17:41:32.396769930 +0200\n+++ /tmp/tmphqvlf1af.java\t2022-07-19 17:41:32.396769930 +0200\n@@ -183,15 +183,11 @@\n     private char getMappingCode(final String str, final int index) {\n         // map() throws IllegalArgumentException\n         final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            final char hwChar = str.charAt(index - 1);\n-            if ('H' == hwChar || 'W' == hwChar) {\n-                final char preHWChar = str.charAt(index - 2);\n-                final char firstCode = this.map(preHWChar);\n-                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n+final char hwChar = str.charAt(index - 1) == initChar || 'W' == preHWChar || 'W' == preHWChar) {\n                     return 0;\n                 }\n             }\n         }\n         return mappedChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "final char hwChar = str.charAt(index - 1) == hwChar || 'W' == preHWChar || 'W' == preHWChar;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-15/src/main/java/org/apache/commons/codec/language/Soundex.java\t2022-07-19 17:41:33.920762456 +0200\n+++ /tmp/tmpb9iohjeu.java\t2022-07-19 17:41:33.920762456 +0200\n@@ -183,15 +183,11 @@\n     private char getMappingCode(final String str, final int index) {\n         // map() throws IllegalArgumentException\n         final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            final char hwChar = str.charAt(index - 1);\n-            if ('H' == hwChar || 'W' == hwChar) {\n-                final char preHWChar = str.charAt(index - 2);\n-                final char firstCode = this.map(preHWChar);\n-                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n+final char hwChar = str.charAt(index - 1) == hwChar || 'W' == preHWChar || 'W' == preHWChar;\n                     return 0;\n                 }\n             }\n         }\n         return mappedChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "final char hwChar = str.charAt(index - 1) == ':'WChar || 'W' == preHWChar || 'W' == preHWChar)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-15/src/main/java/org/apache/commons/codec/language/Soundex.java\t2022-07-19 17:41:35.416755119 +0200\n+++ /tmp/tmpn2uk9t80.java\t2022-07-19 17:41:35.416755119 +0200\n@@ -183,15 +183,11 @@\n     private char getMappingCode(final String str, final int index) {\n         // map() throws IllegalArgumentException\n         final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            final char hwChar = str.charAt(index - 1);\n-            if ('H' == hwChar || 'W' == hwChar) {\n-                final char preHWChar = str.charAt(index - 2);\n-                final char firstCode = this.map(preHWChar);\n-                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n+final char hwChar = str.charAt(index - 1) == ':'WChar || 'W' == preHWChar || 'W' == preHWChar)) {\n                     return 0;\n                 }\n             }\n         }\n         return mappedChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "final char hwChar = str.charAt(index - 1); if ('H' == hwChar || 'W' == hwChar) { final char preHWChar = str.charAt(index - 2); final char firstCode = this.map(preHWChar); if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {",
        "fixed_line": "for (int i=index-1 ; i>=0 ; i--) { final char prevChar = str.charAt(i); if (this.map(prevChar)==mappedChar) { return 0; } if ('H'!=prevChar && 'W'!=prevChar) { break; }"
    },
    "Mockito-18": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class",
                "patch_diff": "// if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// if (type == HashSet.class) { return Primitives.class; } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class",
                "patch_diff": "// if (type == HashSet.class) { return Primitives.class; } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if (type == HashSet.class) { return Primitives.class; } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class",
                "patch_diff": "// if (type == HashSet.class) { return Primitives.class; } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// if (type == HashSet.class) { return Primitives.class; } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class",
                "patch_diff": "// if (type == HashSet.class) { return Primitives.class; } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == Type.class",
                "patch_diff": "// if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == Type.class",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if (type == HashSet.class) { return Primitives.class; } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == Type.class",
                "patch_diff": "// if (type == HashSet.class) { return Primitives.class; } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == Type.class",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// if (type == HashSet.class) { return Primitives.class; } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == Type.class",
                "patch_diff": "// if (type == HashSet.class) { return Primitives.class; } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == Type.class",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// if (type == HashSet.class) { return Primitives.class; } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class",
                "patch_diff": "// if (type == HashSet.class) { return Primitives.class; } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) {",
                "patch_diff": "// if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if (type == HashSet.class) { return Primitives.class; } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == Type.class",
                "patch_diff": "// if (type == HashSet.class) { return Primitives.class; } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == Type.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == Type.class",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "} else if (type == Iterable.class) { return new ArrayList<Object>(0);"
    },
    "Closure-17": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (parent.getJSType() == null &&!rValue.getJSType().isUnknownType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-17/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 17:41:39.368735735 +0200\n+++ /tmp/tmp085qv0du.java\t2022-07-19 17:41:39.388735636 +0200\n@@ -1286,11 +1286,11 @@\n         } else {\n           // Check if this is constant, and if it has a known type.\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n+if (parent.getJSType() == null &&!rValue.getJSType().isUnknownType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n               } else if (rValue.isOr()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (parent.getJSType()!= null &&!rValue.getJSType().isUnknownType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-17/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 17:41:44.552710297 +0200\n+++ /tmp/tmp56tsc9nm.java\t2022-07-19 17:41:44.552710297 +0200\n@@ -1286,11 +1286,11 @@\n         } else {\n           // Check if this is constant, and if it has a known type.\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n+if (parent.getJSType()!= null &&!rValue.getJSType().isUnknownType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n               } else if (rValue.isOr()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (rValue.getJSType!= null &&!rValue.getJSType().isUnknownType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-17/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 17:41:48.512690859 +0200\n+++ /tmp/tmpdgfqpw43.java\t2022-07-19 17:41:48.512690859 +0200\n@@ -1286,11 +1286,11 @@\n         } else {\n           // Check if this is constant, and if it has a known type.\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n+if (rValue.getJSType!= null &&!rValue.getJSType().isUnknownType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n               } else if (rValue.isOr()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (rValue.getJSType() == null &&!rValue.getJSType().isUnknownType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-17/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 17:41:52.152672985 +0200\n+++ /tmp/tmp5boedkam.java\t2022-07-19 17:41:52.152672985 +0200\n@@ -1286,11 +1286,11 @@\n         } else {\n           // Check if this is constant, and if it has a known type.\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n+if (rValue.getJSType() == null &&!rValue.getJSType().isUnknownType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n               } else if (rValue.isOr()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (parent.getJSType() == null ||!rValue.getJSType().isUnknownType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-17/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 17:42:33.696468635 +0200\n+++ /tmp/tmpghapg8iw.java\t2022-07-19 17:42:33.700468616 +0200\n@@ -1286,11 +1286,11 @@\n         } else {\n           // Check if this is constant, and if it has a known type.\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n+if (parent.getJSType() == null ||!rValue.getJSType().isUnknownType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n               } else if (rValue.isOr()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (instanceType == null ||!rValue.getJSType().isUnknownType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-17/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 17:42:37.336450699 +0200\n+++ /tmp/tmp7ctgnib8.java\t2022-07-19 17:42:37.336450699 +0200\n@@ -1286,11 +1286,11 @@\n         } else {\n           // Check if this is constant, and if it has a known type.\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n+if (instanceType == null ||!rValue.getJSType().isUnknownType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n               } else if (rValue.isOr()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (rValue.getJSType()!= null &&!rValue.getJSType().isUnknownType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-17/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 17:42:41.068432306 +0200\n+++ /tmp/tmpq3mc7oe2.java\t2022-07-19 17:42:41.068432306 +0200\n@@ -1286,11 +1286,11 @@\n         } else {\n           // Check if this is constant, and if it has a known type.\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n+if (rValue.getJSType()!= null &&!rValue.getJSType().isUnknownType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n               } else if (rValue.isOr()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (rValue.getJSType() == null ||!rValue.getJSType().isUnknownType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-17/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 17:43:20.932235533 +0200\n+++ /tmp/tmphpojf42c.java\t2022-07-19 17:43:20.932235533 +0200\n@@ -1286,11 +1286,11 @@\n         } else {\n           // Check if this is constant, and if it has a known type.\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n+if (rValue.getJSType() == null ||!rValue.getJSType().isUnknownType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n               } else if (rValue.isOr()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (type == null ||!rValue.getJSType().isUnknownType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-17/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 17:44:00.292040735 +0200\n+++ /tmp/tmpt4gvevz2.java\t2022-07-19 17:44:00.296040713 +0200\n@@ -1286,11 +1286,11 @@\n         } else {\n           // Check if this is constant, and if it has a known type.\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n+if (type == null ||!rValue.getJSType().isUnknownType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n               } else if (rValue.isOr()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (rValue!= null &&!rValue.getJSType().isUnknownType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-17/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 17:44:03.860023053 +0200\n+++ /tmp/tmp7zsuo6hb.java\t2022-07-19 17:44:03.860023053 +0200\n@@ -1286,11 +1286,11 @@\n         } else {\n           // Check if this is constant, and if it has a known type.\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n+if (rValue!= null &&!rValue.getJSType().isUnknownType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n               } else if (rValue.isOr()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {",
        "fixed_line": "JSDocInfo rValueInfo = rValue.getJSDocInfo(); if (rValueInfo != null && rValueInfo.hasType()) { // If rValue has a type-cast, we use the type in the type-cast. return rValueInfo.getType().evaluate(scope, typeRegistry); } else if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {"
    },
    "Mockito-29": {
        "fixes": [
            {
                "k": 1,
                "patch": "description.appendText;wanted isQu.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-29/src/org/mockito/internal/matchers/Same.java\t2022-07-19 17:44:43.595825873 +0200\n+++ /tmp/tmpmsfvzity.java\t2022-07-19 17:44:43.643825631 +0200\n@@ -24,11 +24,11 @@\n     }\n \n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+description.appendText;wanted isQu.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n \n     private void appendQuoting(Description description) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "description.appendText;wanted forText.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-29/src/org/mockito/internal/matchers/Same.java\t2022-07-19 17:44:46.363812120 +0200\n+++ /tmp/tmpuiyixafk.java\t2022-07-19 17:44:46.363812120 +0200\n@@ -24,11 +24,11 @@\n     }\n \n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+description.appendText;wanted forText.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n \n     private void appendQuoting(Description description) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "description.appendText; this.wanted forText.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-29/src/org/mockito/internal/matchers/Same.java\t2022-07-19 17:44:48.191803036 +0200\n+++ /tmp/tmprcmx9dyp.java\t2022-07-19 17:44:48.191803036 +0200\n@@ -24,11 +24,11 @@\n     }\n \n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+description.appendText; this.wanted forText.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n \n     private void appendQuoting(Description description) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "description.appendText;wanted.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-29/src/org/mockito/internal/matchers/Same.java\t2022-07-19 17:44:50.007794011 +0200\n+++ /tmp/tmpkm53ih26.java\t2022-07-19 17:44:50.007794011 +0200\n@@ -24,11 +24,11 @@\n     }\n \n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+description.appendText;wanted.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n \n     private void appendQuoting(Description description) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "description.appendText; appendQu.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-29/src/org/mockito/internal/matchers/Same.java\t2022-07-19 17:44:51.707785562 +0200\n+++ /tmp/tmpam8jfpun.java\t2022-07-19 17:44:51.707785562 +0200\n@@ -24,11 +24,11 @@\n     }\n \n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+description.appendText; appendQu.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n \n     private void appendQuoting(Description description) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "description.appendText(_wanted.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-29/src/org/mockito/internal/matchers/Same.java\t2022-07-19 17:44:53.483776734 +0200\n+++ /tmp/tmpcqwvne48.java\t2022-07-19 17:44:53.483776734 +0200\n@@ -24,11 +24,11 @@\n     }\n \n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+description.appendText(_wanted.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n \n     private void appendQuoting(Description description) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "description.appendText(description.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-29/src/org/mockito/internal/matchers/Same.java\t2022-07-19 17:44:55.955764446 +0200\n+++ /tmp/tmpp7lyygnz.java\t2022-07-19 17:44:55.955764446 +0200\n@@ -24,11 +24,11 @@\n     }\n \n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+description.appendText(description.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n \n     private void appendQuoting(Description description) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "description.appendText(wanted.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-29/src/org/mockito/internal/matchers/Same.java\t2022-07-19 17:45:15.423667612 +0200\n+++ /tmp/tmpurnkhk07.java\t2022-07-19 17:45:15.423667612 +0200\n@@ -24,11 +24,11 @@\n     }\n \n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+description.appendText(wanted.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n \n     private void appendQuoting(Description description) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "description.appendText;wanted isText.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-29/src/org/mockito/internal/matchers/Same.java\t2022-07-19 17:45:34.659571835 +0200\n+++ /tmp/tmpg_nfr9r1.java\t2022-07-19 17:45:34.659571835 +0200\n@@ -24,11 +24,11 @@\n     }\n \n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+description.appendText;wanted isText.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n \n     private void appendQuoting(Description description) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "description.appendText(description;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-29/src/org/mockito/internal/matchers/Same.java\t2022-07-19 17:45:36.495562688 +0200\n+++ /tmp/tmp8_72hxst.java\t2022-07-19 17:45:36.495562688 +0200\n@@ -24,11 +24,11 @@\n     }\n \n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+description.appendText(description;\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n \n     private void appendQuoting(Description description) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "description.appendText(wanted.toString());",
        "fixed_line": "description.appendText(wanted == null ? \"null\" : wanted.toString());"
    },
    "Closure-52": {
        "fixes": [
            {
                "k": 1,
                "patch": "return index % 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-52/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 17:45:38.327553560 +0200\n+++ /tmp/tmpvpfyqey7.java\t2022-07-19 17:45:38.351553443 +0200\n@@ -740,11 +740,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0;\n+return index % 0;\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return index >= 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-52/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 17:45:43.531527631 +0200\n+++ /tmp/tmpsucgjn44.java\t2022-07-19 17:45:43.531527631 +0200\n@@ -740,11 +740,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0;\n+return index >= 0;\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return len > 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-52/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 17:45:47.035510166 +0200\n+++ /tmp/tmp7oov3ls5.java\t2022-07-19 17:45:47.035510166 +0200\n@@ -740,11 +740,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0;\n+return len > 0;\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return index > 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-52/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 17:46:26.059315460 +0200\n+++ /tmp/tmp3fc49ozi.java\t2022-07-19 17:46:26.059315460 +0200\n@@ -740,11 +740,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0;\n+return index > 0;\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return index + 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-52/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 17:46:29.567297940 +0200\n+++ /tmp/tmpc4oyh4ss.java\t2022-07-19 17:46:29.567297940 +0200\n@@ -740,11 +740,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0;\n+return index + 0;\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return index + 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-52/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 17:46:33.171279939 +0200\n+++ /tmp/tmprxx5balf.java\t2022-07-19 17:46:33.171279939 +0200\n@@ -740,11 +740,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0;\n+return index + 1;\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return index < 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-52/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 17:46:36.875261432 +0200\n+++ /tmp/tmpvjipk_e8.java\t2022-07-19 17:46:36.875261432 +0200\n@@ -740,11 +740,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0;\n+return index < 0;\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return c > 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-52/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 17:46:40.643242604 +0200\n+++ /tmp/tmp0jdt9m71.java\t2022-07-19 17:46:40.643242604 +0200\n@@ -740,11 +740,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0;\n+return c > 0;\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return index!= 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-52/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 17:46:44.299224333 +0200\n+++ /tmp/tmpti7iag7l.java\t2022-07-19 17:46:44.299224333 +0200\n@@ -740,11 +740,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0;\n+return index!= 0;\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-52/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 17:46:47.959206041 +0200\n+++ /tmp/tmp55tr9a7s.java\t2022-07-19 17:46:47.959206041 +0200\n@@ -740,11 +740,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0;\n+return 0;\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return len > 0;",
        "fixed_line": "return len > 0 && s.charAt(0) != '0';"
    },
    "Gson-10": {
        "fixes": [
            {
                "k": 1,
                "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(fieldType, typeAdapter, serializationType.getType());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\t2022-07-19 17:46:51.963186024 +0200\n+++ /tmp/tmpb__f_frf.java\t2022-07-19 17:46:52.043185622 +0200\n@@ -117,12 +117,11 @@\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n+TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(fieldType, typeAdapter, serializationType.getType());\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(fieldType, typeAdapter, elementValue.getType());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\t2022-07-19 17:46:54.235174664 +0200\n+++ /tmp/tmp4nqat0gd.java\t2022-07-19 17:46:54.235174664 +0200\n@@ -117,12 +117,11 @@\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n+TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(fieldType, typeAdapter, elementValue.getType());\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(fieldType, typeAdapter,Pointer.getType());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\t2022-07-19 17:46:55.943166121 +0200\n+++ /tmp/tmp5yt9xi7_.java\t2022-07-19 17:46:55.943166121 +0200\n@@ -117,12 +117,11 @@\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n+TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(fieldType, typeAdapter,Pointer.getType());\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(fieldType, value, typeAdapter.getType());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\t2022-07-19 17:46:57.687157402 +0200\n+++ /tmp/tmpni7jdaq1.java\t2022-07-19 17:46:57.687157402 +0200\n@@ -117,12 +117,11 @@\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n+TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(fieldType, value, typeAdapter.getType());\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(fieldType, typeAdapter, context.getType());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\t2022-07-19 17:46:59.571147977 +0200\n+++ /tmp/tmpwpequ4zn.java\t2022-07-19 17:46:59.571147977 +0200\n@@ -117,12 +117,11 @@\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n+TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(fieldType, typeAdapter, context.getType());\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(fieldType, typeAdapter, field.getType());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\t2022-07-19 17:47:01.211139777 +0200\n+++ /tmp/tmp6o36t3to.java\t2022-07-19 17:47:01.211139777 +0200\n@@ -117,12 +117,11 @@\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n+TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(fieldType, typeAdapter, field.getType());\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(typeAdapter, fieldValue, locale.getType());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\t2022-07-19 17:47:02.835131652 +0200\n+++ /tmp/tmp_yb5ptoe.java\t2022-07-19 17:47:02.839131633 +0200\n@@ -117,12 +117,11 @@\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n+TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(typeAdapter, fieldValue, locale.getType());\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(fieldType, typeAdapter, elementValue);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\t2022-07-19 17:47:04.471123468 +0200\n+++ /tmp/tmpg66vvqh5.java\t2022-07-19 17:47:04.475123448 +0200\n@@ -117,12 +117,11 @@\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n+TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(fieldType, typeAdapter, elementValue);\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(typeAdapter, value, typeAdapter.getType());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\t2022-07-19 17:47:06.119115224 +0200\n+++ /tmp/tmp3ulu6b8s.java\t2022-07-19 17:47:06.119115224 +0200\n@@ -117,12 +117,11 @@\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n+TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(typeAdapter, value, typeAdapter.getType());\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(typeAdapter, fieldValue, value.getType());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\t2022-07-19 17:47:07.727107182 +0200\n+++ /tmp/tmpohazgs_4.java\t2022-07-19 17:47:07.727107182 +0200\n@@ -117,12 +117,11 @@\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n+TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(typeAdapter, fieldValue, value.getType());\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());",
        "fixed_line": "TypeAdapter t = jsonAdapterPresent ? typeAdapter : new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());"
    },
    "Cli-37": {
        "fixes": [
            {
                "k": 1,
                "patch": "return options.startsWith(\"-\") || token.length() >= 2 && options.hasShortOption;token.substring));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-37/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-19 17:47:09.651097556 +0200\n+++ /tmp/tmpvbygj0ty.java\t2022-07-19 17:47:09.731097152 +0200\n@@ -297,11 +297,11 @@\n      * @param token\n      */\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n+return options.startsWith(\"-\") || token.length() >= 2 && options.hasShortOption;token.substring));\n \n         // remove leading \"-\" and \"=value\"\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return options.startsWith(\"-\") || token.length() >= 2 && options.hasShortOption;token.substring(1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-37/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-19 17:47:11.443088586 +0200\n+++ /tmp/tmpfxxpmk4m.java\t2022-07-19 17:47:11.443088586 +0200\n@@ -297,11 +297,11 @@\n      * @param token\n      */\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n+return options.startsWith(\"-\") || token.length() >= 2 && options.hasShortOption;token.substring(1);\n \n         // remove leading \"-\" and \"=value\"\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return options.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption;token.substring));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-37/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-19 17:47:13.127080162 +0200\n+++ /tmp/tmp6h8c5rea.java\t2022-07-19 17:47:13.127080162 +0200\n@@ -297,11 +297,11 @@\n      * @param token\n      */\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n+return options.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption;token.substring));\n \n         // remove leading \"-\" and \"=value\"\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return options.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption;token.substring(1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-37/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-19 17:47:14.691072333 +0200\n+++ /tmp/tmp2o0jxse3.java\t2022-07-19 17:47:14.691072333 +0200\n@@ -297,11 +297,11 @@\n      * @param token\n      */\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n+return options.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption;token.substring(1);\n \n         // remove leading \"-\" and \"=value\"\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return options.startsWith(\"-\") || token.length() >= 2 && options.hasShortOption(token.substring(1, 2));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-37/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-19 17:47:16.375063907 +0200\n+++ /tmp/tmpymfc37kw.java\t2022-07-19 17:47:16.379063884 +0200\n@@ -297,11 +297,11 @@\n      * @param token\n      */\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n+return options.startsWith(\"-\") || token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n \n         // remove leading \"-\" and \"=value\"\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return options.startsWith(\"-\") || token.length() >= 2 && options.hasShortOption;token.substring(1, tokenBegin));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-37/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-19 17:47:18.015055697 +0200\n+++ /tmp/tmpur3z0c4d.java\t2022-07-19 17:47:18.019055679 +0200\n@@ -297,11 +297,11 @@\n      * @param token\n      */\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n+return options.startsWith(\"-\") || token.length() >= 2 && options.hasShortOption;token.substring(1, tokenBegin));\n \n         // remove leading \"-\" and \"=value\"\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return options.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-37/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-19 17:47:19.583047848 +0200\n+++ /tmp/tmpvqznu9yw.java\t2022-07-19 17:47:19.587047829 +0200\n@@ -297,11 +297,11 @@\n      * @param token\n      */\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n+return options.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n \n         // remove leading \"-\" and \"=value\"\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return options.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption;token.substring(1, tokenBegin));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-37/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-19 17:47:21.211039699 +0200\n+++ /tmp/tmpu3lu28le.java\t2022-07-19 17:47:21.211039699 +0200\n@@ -297,11 +297,11 @@\n      * @param token\n      */\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n+return options.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption;token.substring(1, tokenBegin));\n \n         // remove leading \"-\" and \"=value\"\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return options.startsWith(\"-\") || token.length() >= 2 && options.hasShortOption;token.substring(1, tokenLen));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-37/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-19 17:47:22.811031691 +0200\n+++ /tmp/tmp25p0ksi8.java\t2022-07-19 17:47:22.811031691 +0200\n@@ -297,11 +297,11 @@\n      * @param token\n      */\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n+return options.startsWith(\"-\") || token.length() >= 2 && options.hasShortOption;token.substring(1, tokenLen));\n \n         // remove leading \"-\" and \"=value\"\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return options.startsWith(\"-\") && token.length() > 2 && options.hasShortOption(token.substring(1, 2));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-37/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-19 17:47:24.403023721 +0200\n+++ /tmp/tmppu2ovjvi.java\t2022-07-19 17:47:24.403023721 +0200\n@@ -297,11 +297,11 @@\n      * @param token\n      */\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n+return options.startsWith(\"-\") && token.length() > 2 && options.hasShortOption(token.substring(1, 2));\n \n         // remove leading \"-\" and \"=value\"\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));",
        "fixed_line": "if (!token.startsWith(\"-\") || token.length() == 1) { return false; } // remove leading \"-\" and \"=value\" int pos = token.indexOf(\"=\"); String optName = pos == -1 ? token.substring(1) : token.substring(1, pos); return options.hasShortOption(optName);"
    },
    "Jsoup-44": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int i = start.length; i < len; ++i) {",
                "patch_diff": "for (int i = start.length; i < len; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return name;",
                "patch_diff": "return name;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = start.length; i < len; ++i) { String name = name.substring(start, attrs); if (start.contains(name)) { start.addChildToBack(name, attrs); } } }",
                "patch_diff": "for (int i = start.length; i < len; ++i) { String name = name.substring(start, attrs); if (start.contains(name)) { start.addChildToBack(name, attrs); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = start.length; i < len; ++i) { String name = name.substring(start, attrs); if (start.contains(name)) { start.addChildToBack(name); } } }",
                "patch_diff": "for (int i = start.length; i < len; ++i) { String name = name.substring(start, attrs); if (start.contains(name)) { start.addChildToBack(name); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = start.length; i < len; ++i) { String name = name.substring(start, attrs); if (start.contains(name)) { start.add(name, attrs); } } }",
                "patch_diff": "for (int i = start.length; i < len; ++i) { String name = name.substring(start, attrs); if (start.contains(name)) { start.add(name, attrs); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "start.reset().name(name, -1);",
                "patch_diff": "start.reset().name(name, -1);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = start.length; i < len; ++i) { String name = name.substring(start, attrs); if (start.length() > 0) { return name; } } }",
                "patch_diff": "for (int i = start.length; i < len; ++i) { String name = name.substring(start, attrs); if (start.length() > 0) { return name; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = start.length; i < len; ++i) { String name = name.substring(start, attrs); if (start.contains(name)) { start.add(name); } } }",
                "patch_diff": "for (int i = start.length; i < len; ++i) { String name = name.substring(start, attrs); if (start.contains(name)) { start.add(name); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int i = start.length; i < len; ++i) { String name = name.substring(start, attrs); if (start.contains(name)) { start.addChildToBack(name, attrs); } }",
                "patch_diff": "for (int i = start.length; i < len; ++i) { String name = name.substring(start, attrs); if (start.contains(name)) { start.addChildToBack(name, attrs); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = start.length; i < end.length; i++) {",
                "patch_diff": "for (int i = start.length; i < end.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (currentToken == start) { // don't recycle an in-use token return process(new Token.StartTag().name(name)); } return process(start.reset().name(name)); } public boolean processStartTag(String name, Attributes attrs) { if (currentToken == start) { // don't recycle an in-use token return process(new Token.StartTag().nameAttr(name, attrs)); } start.reset(); start.nameAttr(name, attrs); return process(start); } protected boolean processEndTag(String name) { if (currentToken == end) { // don't recycle an in-use token return process(new Token.EndTag().name(name)); }"
    },
    "Chart-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "this.dataset = dataset; // the dataset when the dataset is to the dataset is to the dataset (this.dataset)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2022-07-19 17:47:28.191004755 +0200\n+++ /tmp/tmpl78uuwp9.java\t2022-07-19 17:47:28.239004514 +0200\n@@ -140,11 +140,11 @@\n      *\n      * @param dataset  the dataset (<code>null</code> permitted).\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+this.dataset = dataset; // the dataset when the dataset is to the dataset is to the dataset (this.dataset)\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "this.dataset = dataset; // the dataset when the dataset is to the dataset (this.dataset = dataset;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2022-07-19 17:47:38.354953848 +0200\n+++ /tmp/tmph1xdn3a1.java\t2022-07-19 17:47:38.358953830 +0200\n@@ -140,11 +140,11 @@\n      *\n      * @param dataset  the dataset (<code>null</code> permitted).\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+this.dataset = dataset; // the dataset when the dataset is to the dataset (this.dataset = dataset;\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "this.dataset = dataset; // the dataset when the dataset is to the dataset is to the dataset (this.dataset;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2022-07-19 17:47:46.306914009 +0200\n+++ /tmp/tmp198ophmt.java\t2022-07-19 17:47:46.310913987 +0200\n@@ -140,11 +140,11 @@\n      *\n      * @param dataset  the dataset (<code>null</code> permitted).\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+this.dataset = dataset; // the dataset when the dataset is to the dataset is to the dataset (this.dataset;\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "this.dataset = dataset; // the dataset when the dataset is to the dataset is to the dataset (dataset) this.dataset;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2022-07-19 17:47:54.222874337 +0200\n+++ /tmp/tmpbfjpwwm3.java\t2022-07-19 17:47:54.226874314 +0200\n@@ -140,11 +140,11 @@\n      *\n      * @param dataset  the dataset (<code>null</code> permitted).\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+this.dataset = dataset; // the dataset when the dataset is to the dataset is to the dataset (dataset) this.dataset;\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "this.dataset = dataset; // the dataset when the dataset is to the dataset (this.dataset)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2022-07-19 17:48:02.242834129 +0200\n+++ /tmp/tmp02ml53pk.java\t2022-07-19 17:48:02.242834129 +0200\n@@ -140,11 +140,11 @@\n      *\n      * @param dataset  the dataset (<code>null</code> permitted).\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+this.dataset = dataset; // the dataset when the dataset is to the dataset (this.dataset)\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "this.dataset = dataset; // the dataset when the dataset is to the dataset (dataset) this.dataset;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2022-07-19 17:48:10.318793629 +0200\n+++ /tmp/tmpukv85l3o.java\t2022-07-19 17:48:10.322793611 +0200\n@@ -140,11 +140,11 @@\n      *\n      * @param dataset  the dataset (<code>null</code> permitted).\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+this.dataset = dataset; // the dataset when the dataset is to the dataset (dataset) this.dataset;\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "this.dataset = dataset; // the dataset when the dataset is to the dataset is to the dataset (this.dataset = dataset;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2022-07-19 17:48:18.274753719 +0200\n+++ /tmp/tmps_859fa_.java\t2022-07-19 17:48:18.274753719 +0200\n@@ -140,11 +140,11 @@\n      *\n      * @param dataset  the dataset (<code>null</code> permitted).\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+this.dataset = dataset; // the dataset when the dataset is to the dataset is to the dataset (this.dataset = dataset;\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "this.dataset = dataset; // the dataset when the dataset is to the dataset (this.dataset;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2022-07-19 17:48:26.438712757 +0200\n+++ /tmp/tmps89k8pso.java\t2022-07-19 17:48:26.438712757 +0200\n@@ -140,11 +140,11 @@\n      *\n      * @param dataset  the dataset (<code>null</code> permitted).\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+this.dataset = dataset; // the dataset when the dataset is to the dataset (this.dataset;\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "this.dataset = dataset; // the dataset when the dataset is to the dataset when the dataset is to the dataset (this.dataset)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2022-07-19 17:48:34.454672523 +0200\n+++ /tmp/tmpbg6ohtxq.java\t2022-07-19 17:48:34.454672523 +0200\n@@ -140,11 +140,11 @@\n      *\n      * @param dataset  the dataset (<code>null</code> permitted).\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+this.dataset = dataset; // the dataset when the dataset is to the dataset when the dataset is to the dataset (this.dataset)\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "this.dataset = dataset; // the dataset when the dataset is to the dataset (this.dataset) this.dataset;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2022-07-19 17:48:42.338632939 +0200\n+++ /tmp/tmppj4dnluz.java\t2022-07-19 17:48:42.338632939 +0200\n@@ -140,11 +140,11 @@\n      *\n      * @param dataset  the dataset (<code>null</code> permitted).\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+this.dataset = dataset; // the dataset when the dataset is to the dataset (this.dataset) this.dataset;\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "this.dataset = dataset;",
        "fixed_line": "setDataset(dataset);"
    },
    "Cli-23": {
        "fixes": [
            {
                "k": 1,
                "patch": "int lastPos = pos + text.substring(pos).trim(pos).trim(pos);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-23/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 17:48:50.602591439 +0200\n+++ /tmp/tmpcuw_xi8c.java\t2022-07-19 17:48:50.718590851 +0200\n@@ -819,23 +819,11 @@\n         // characters\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n-            int lastPos = pos;\n-            text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, 0);\n-\n-            if (pos == -1)\n-            {\n-                sb.append(text);\n-\n-                return sb;\n-            } else\n-            if (pos == lastPos)\n-            {\n-                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n+int lastPos = pos + text.substring(pos).trim(pos).trim(pos);\n             }\n \n             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int lastPos = pos + text.substring(pos).trim();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-23/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 17:48:52.434582237 +0200\n+++ /tmp/tmp6irxdomb.java\t2022-07-19 17:48:52.434582237 +0200\n@@ -819,23 +819,11 @@\n         // characters\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n-            int lastPos = pos;\n-            text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, 0);\n-\n-            if (pos == -1)\n-            {\n-                sb.append(text);\n-\n-                return sb;\n-            } else\n-            if (pos == lastPos)\n-            {\n-                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n+int lastPos = pos + text.substring(pos).trim();\n             }\n \n             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int lastPos = pos + text.substring(pos).trim(pos).trim(pos - padding);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-23/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 17:48:53.886574940 +0200\n+++ /tmp/tmpte4mg5lp.java\t2022-07-19 17:48:53.886574940 +0200\n@@ -819,23 +819,11 @@\n         // characters\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n-            int lastPos = pos;\n-            text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, 0);\n-\n-            if (pos == -1)\n-            {\n-                sb.append(text);\n-\n-                return sb;\n-            } else\n-            if (pos == lastPos)\n-            {\n-                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n+int lastPos = pos + text.substring(pos).trim(pos).trim(pos - padding);\n             }\n \n             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int lastPos = pos + text.substring(pos).trim(pos).trim(pos).trim(pos);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-23/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 17:48:55.354567566 +0200\n+++ /tmp/tmpachsop18.java\t2022-07-19 17:48:55.354567566 +0200\n@@ -819,23 +819,11 @@\n         // characters\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n-            int lastPos = pos;\n-            text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, 0);\n-\n-            if (pos == -1)\n-            {\n-                sb.append(text);\n-\n-                return sb;\n-            } else\n-            if (pos == lastPos)\n-            {\n-                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n+int lastPos = pos + text.substring(pos).trim(pos).trim(pos).trim(pos);\n             }\n \n             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int lastPos = pos + text.substring(pos).trim(pos - padding);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-23/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 17:48:56.834560133 +0200\n+++ /tmp/tmps0ut8dt9.java\t2022-07-19 17:48:56.838560110 +0200\n@@ -819,23 +819,11 @@\n         // characters\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n-            int lastPos = pos;\n-            text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, 0);\n-\n-            if (pos == -1)\n-            {\n-                sb.append(text);\n-\n-                return sb;\n-            } else\n-            if (pos == lastPos)\n-            {\n-                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n+int lastPos = pos + text.substring(pos).trim(pos - padding);\n             }\n \n             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int lastPos = pos + text.substring(pos).trim(pos).trim(pos)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-23/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 17:48:58.354552497 +0200\n+++ /tmp/tmpurtw7uct.java\t2022-07-19 17:48:58.358552474 +0200\n@@ -819,23 +819,11 @@\n         // characters\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n-            int lastPos = pos;\n-            text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, 0);\n-\n-            if (pos == -1)\n-            {\n-                sb.append(text);\n-\n-                return sb;\n-            } else\n-            if (pos == lastPos)\n-            {\n-                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n+int lastPos = pos + text.substring(pos).trim(pos).trim(pos)) {\n             }\n \n             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int lastPos = pos + text.substring(pos).trim(pos);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-23/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 17:48:59.898544736 +0200\n+++ /tmp/tmpt5ddy3h7.java\t2022-07-19 17:48:59.902544717 +0200\n@@ -819,23 +819,11 @@\n         // characters\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n-            int lastPos = pos;\n-            text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, 0);\n-\n-            if (pos == -1)\n-            {\n-                sb.append(text);\n-\n-                return sb;\n-            } else\n-            if (pos == lastPos)\n-            {\n-                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n+int lastPos = pos + text.substring(pos).trim(pos);\n             }\n \n             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int lastPos = padding + text.substring(pos).trim();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-23/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 17:49:01.402537180 +0200\n+++ /tmp/tmpbfwvdp4d.java\t2022-07-19 17:49:01.402537180 +0200\n@@ -819,23 +819,11 @@\n         // characters\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n-            int lastPos = pos;\n-            text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, 0);\n-\n-            if (pos == -1)\n-            {\n-                sb.append(text);\n-\n-                return sb;\n-            } else\n-            if (pos == lastPos)\n-            {\n-                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n+int lastPos = padding + text.substring(pos).trim();\n             }\n \n             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int lastPos = pos + text.substring(pos).trim(pos).trim();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-23/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 17:49:02.902529645 +0200\n+++ /tmp/tmpak0mmm77.java\t2022-07-19 17:49:02.902529645 +0200\n@@ -819,23 +819,11 @@\n         // characters\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n-            int lastPos = pos;\n-            text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, 0);\n-\n-            if (pos == -1)\n-            {\n-                sb.append(text);\n-\n-                return sb;\n-            } else\n-            if (pos == lastPos)\n-            {\n-                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n+int lastPos = pos + text.substring(pos).trim(pos).trim();\n             }\n \n             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int lastPos = pos + text.substring(pos).trim(pos)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-23/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 17:49:04.458521827 +0200\n+++ /tmp/tmp4eqr9rvh.java\t2022-07-19 17:49:04.458521827 +0200\n@@ -819,23 +819,11 @@\n         // characters\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n-            int lastPos = pos;\n-            text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, 0);\n-\n-            if (pos == -1)\n-            {\n-                sb.append(text);\n-\n-                return sb;\n-            } else\n-            if (pos == lastPos)\n-            {\n-                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n+int lastPos = pos + text.substring(pos).trim(pos)) {\n             }\n \n             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "int lastPos = pos; text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } else if (pos == lastPos) { throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);",
        "fixed_line": "} if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) { sb.append(text); return sb;"
    },
    "Closure-35": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (objType!= null &&constraint.isRecordType = objType.castByNotNullOrUndefined;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-35/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 17:49:06.158513281 +0200\n+++ /tmp/tmpvbilwgln.java\t2022-07-19 17:49:06.278512680 +0200\n@@ -1116,25 +1116,11 @@\n       return;\n     }\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+if (objType!= null &&constraint.isRecordType = objType.castByNotNullOrUndefined;\n     }\n   }\n \n   /**\n    * If we access a property of a symbol, then that symbol is not\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if ( constraintType!= null && objType = objType.castByNotNullOrUndefined;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-35/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 17:49:11.210487893 +0200\n+++ /tmp/tmpmsy3ys7z.java\t2022-07-19 17:49:11.214487871 +0200\n@@ -1116,25 +1116,11 @@\n       return;\n     }\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+if ( constraintType!= null && objType = objType.castByNotNullOrUndefined;\n     }\n   }\n \n   /**\n    * If we access a property of a symbol, then that symbol is not\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (typeToInfer!= null && objType = objType.castByNotNullOrUndefined;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-35/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 17:49:14.790469898 +0200\n+++ /tmp/tmpr20cc0k3.java\t2022-07-19 17:49:14.790469898 +0200\n@@ -1116,25 +1116,11 @@\n       return;\n     }\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+if (typeToInfer!= null && objType = objType.castByNotNullOrUndefined;\n     }\n   }\n \n   /**\n    * If we access a property of a symbol, then that symbol is not\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (typeToInfer!= null && objType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-35/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 17:49:18.550450994 +0200\n+++ /tmp/tmpgig1_6_e.java\t2022-07-19 17:49:18.554450976 +0200\n@@ -1116,25 +1116,11 @@\n       return;\n     }\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+if (typeToInfer!= null && objType;\n     }\n   }\n \n   /**\n    * If we access a property of a symbol, then that symbol is not\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (objType!= null &&constraint.isRecordType = objType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-35/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 17:49:22.474431267 +0200\n+++ /tmp/tmp27eayk1j.java\t2022-07-19 17:49:22.478431245 +0200\n@@ -1116,25 +1116,11 @@\n       return;\n     }\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+if (objType!= null &&constraint.isRecordType = objType;\n     }\n   }\n \n   /**\n    * If we access a property of a symbol, then that symbol is not\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (typeToInfer!= null && objType instanceof ObjectType) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-35/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 17:49:26.198412539 +0200\n+++ /tmp/tmpnt6o08h7.java\t2022-07-19 17:49:26.202412522 +0200\n@@ -1116,25 +1116,11 @@\n       return;\n     }\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+if (typeToInfer!= null && objType instanceof ObjectType) {\n     }\n   }\n \n   /**\n    * If we access a property of a symbol, then that symbol is not\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (typeToInfer == null || typeToInfer) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-35/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 17:49:30.246392182 +0200\n+++ /tmp/tmpykyikgqg.java\t2022-07-19 17:49:30.246392182 +0200\n@@ -1116,25 +1116,11 @@\n       return;\n     }\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+if (typeToInfer == null || typeToInfer) {\n     }\n   }\n \n   /**\n    * If we access a property of a symbol, then that symbol is not\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if ( constraintType!= null && objType = objType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-35/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 17:49:34.106372767 +0200\n+++ /tmp/tmpnx6xqoah.java\t2022-07-19 17:49:34.106372767 +0200\n@@ -1116,25 +1116,11 @@\n       return;\n     }\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+if ( constraintType!= null && objType = objType;\n     }\n   }\n \n   /**\n    * If we access a property of a symbol, then that symbol is not\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (typeToInfer)!= null && objType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-35/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 17:49:37.610355144 +0200\n+++ /tmp/tmpsf2us9q2.java\t2022-07-19 17:49:37.610355144 +0200\n@@ -1116,25 +1116,11 @@\n       return;\n     }\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+if (typeToInfer)!= null && objType;\n     }\n   }\n \n   /**\n    * If we access a property of a symbol, then that symbol is not\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (typeToInfer!= null && objType = objType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-35/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 17:49:40.918338500 +0200\n+++ /tmp/tmp_o4ynrxe.java\t2022-07-19 17:49:40.922338482 +0200\n@@ -1116,25 +1116,11 @@\n       return;\n     }\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+if (typeToInfer!= null && objType = objType;\n     }\n   }\n \n   /**\n    * If we access a property of a symbol, then that symbol is not\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (constraintObj != null && constraintObj.isRecordType()) { ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); if (objType != null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType); } objType.defineInferredProperty(prop, typeToInfer, null); } } }",
        "fixed_line": "if (constraintObj != null) { type.matchConstraint(constraintObj);"
    },
    "JacksonDatabind-93": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (raw.startsWith(\"/Id) { for (raw = cls; cls!= Object.class; cls = cls.getSuperclass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-93/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\t2022-07-19 17:49:44.606319942 +0200\n+++ /tmp/tmpg1knkf4q.java\t2022-07-19 17:49:44.726319341 +0200\n@@ -78,12 +78,11 @@\n             }\n \n             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n             //    for some Spring framework types\n             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n-            if (full.startsWith(PREFIX_STRING)) {\n-                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n+if (raw.startsWith(\"/Id) { for (raw = cls; cls!= Object.class; cls = cls.getSuperclass()) {\n                     String name = cls.getSimpleName();\n                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                             || \"AbstractApplicationContext\".equals(name)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (raw.startsWith(\"/STRING) { for (raw = cls; cls!= Object.class; cls = cls.getSuperclass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-93/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\t2022-07-19 17:49:46.950308151 +0200\n+++ /tmp/tmpoizl63ra.java\t2022-07-19 17:49:46.954308129 +0200\n@@ -78,12 +78,11 @@\n             }\n \n             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n             //    for some Spring framework types\n             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n-            if (full.startsWith(PREFIX_STRING)) {\n-                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n+if (raw.startsWith(\"/STRING) { for (raw = cls; cls!= Object.class; cls = cls.getSuperclass()) {\n                     String name = cls.getSimpleName();\n                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                             || \"AbstractApplicationContext\".equals(name)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (raw.startsWith(\"/ type) { for (raw = cls; cls!= Object.class; cls = cls.getSuperclass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-93/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\t2022-07-19 17:49:48.690299393 +0200\n+++ /tmp/tmp9j2znd1d.java\t2022-07-19 17:49:48.690299393 +0200\n@@ -78,12 +78,11 @@\n             }\n \n             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n             //    for some Spring framework types\n             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n-            if (full.startsWith(PREFIX_STRING)) {\n-                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n+if (raw.startsWith(\"/ type) { for (raw = cls; cls!= Object.class; cls = cls.getSuperclass()) {\n                     String name = cls.getSimpleName();\n                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                             || \"AbstractApplicationContext\".equals(name)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (raw.startsWith(\"/\")) { for (raw<?> cls = raw.class; cls!= Object.class; cls = cls.getSuperclass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-93/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\t2022-07-19 17:49:50.478290398 +0200\n+++ /tmp/tmpxtr22qgo.java\t2022-07-19 17:49:50.478290398 +0200\n@@ -78,12 +78,11 @@\n             }\n \n             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n             //    for some Spring framework types\n             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n-            if (full.startsWith(PREFIX_STRING)) {\n-                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n+if (raw.startsWith(\"/\")) { for (raw<?> cls = raw.class; cls!= Object.class; cls = cls.getSuperclass()) {\n                     String name = cls.getSimpleName();\n                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                             || \"AbstractApplicationContext\".equals(name)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (raw.startsWith(\"/ /*\") || cls = raw.class; cls!= Object.class; cls = cls.getSuperclass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-93/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\t2022-07-19 17:49:52.330281075 +0200\n+++ /tmp/tmpe_6ogpeb.java\t2022-07-19 17:49:52.330281075 +0200\n@@ -78,12 +78,11 @@\n             }\n \n             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n             //    for some Spring framework types\n             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n-            if (full.startsWith(PREFIX_STRING)) {\n-                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n+if (raw.startsWith(\"/ /*\") || cls = raw.class; cls!= Object.class; cls = cls.getSuperclass()) {\n                     String name = cls.getSimpleName();\n                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                             || \"AbstractApplicationContext\".equals(name)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (raw.startsWith(\"/STRING) { for (rawType = raw.class; cls!= Object.class; cls = cls.getSuperclass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-93/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\t2022-07-19 17:49:54.042272461 +0200\n+++ /tmp/tmpw09cn1qw.java\t2022-07-19 17:49:54.042272461 +0200\n@@ -78,12 +78,11 @@\n             }\n \n             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n             //    for some Spring framework types\n             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n-            if (full.startsWith(PREFIX_STRING)) {\n-                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n+if (raw.startsWith(\"/STRING) { for (rawType = raw.class; cls!= Object.class; cls = cls.getSuperclass()) {\n                     String name = cls.getSimpleName();\n                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                             || \"AbstractApplicationContext\".equals(name)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (raw.startsWith(\"/\")) { for (raw<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-93/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\t2022-07-19 17:49:55.578264727 +0200\n+++ /tmp/tmpchvum43n.java\t2022-07-19 17:49:55.578264727 +0200\n@@ -78,12 +78,11 @@\n             }\n \n             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n             //    for some Spring framework types\n             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n-            if (full.startsWith(PREFIX_STRING)) {\n-                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n+if (raw.startsWith(\"/\")) { for (raw<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n                     String name = cls.getSimpleName();\n                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                             || \"AbstractApplicationContext\".equals(name)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (raw.startsWith(\"/\")) { for (rawType = raw.class; cls!= Object.class; cls = cls.getSuperclass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-93/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\t2022-07-19 17:49:57.314255989 +0200\n+++ /tmp/tmpomijgzvc.java\t2022-07-19 17:49:57.314255989 +0200\n@@ -78,12 +78,11 @@\n             }\n \n             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n             //    for some Spring framework types\n             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n-            if (full.startsWith(PREFIX_STRING)) {\n-                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n+if (raw.startsWith(\"/\")) { for (rawType = raw.class; cls!= Object.class; cls = cls.getSuperclass()) {\n                     String name = cls.getSimpleName();\n                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                             || \"AbstractApplicationContext\".equals(name)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (raw.startsWith(\"/\")) { for (raw<?> cls = cls; cls!= Object.class; cls = cls.getSuperclass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-93/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\t2022-07-19 17:49:59.074247130 +0200\n+++ /tmp/tmpa5zshya5.java\t2022-07-19 17:49:59.074247130 +0200\n@@ -78,12 +78,11 @@\n             }\n \n             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n             //    for some Spring framework types\n             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n-            if (full.startsWith(PREFIX_STRING)) {\n-                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n+if (raw.startsWith(\"/\")) { for (raw<?> cls = cls; cls!= Object.class; cls = cls.getSuperclass()) {\n                     String name = cls.getSimpleName();\n                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                             || \"AbstractApplicationContext\".equals(name)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (raw.startsWith(\"/\")) { for (raw = cls; cls!= Object.class; cls = cls.getSuperclass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-93/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\t2022-07-19 17:50:00.722238837 +0200\n+++ /tmp/tmpaefgb_5z.java\t2022-07-19 17:50:00.722238837 +0200\n@@ -78,12 +78,11 @@\n             }\n \n             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n             //    for some Spring framework types\n             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n-            if (full.startsWith(PREFIX_STRING)) {\n-                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n+if (raw.startsWith(\"/\")) { for (raw = cls; cls!= Object.class; cls = cls.getSuperclass()) {\n                     String name = cls.getSimpleName();\n                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                             || \"AbstractApplicationContext\".equals(name)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {",
        "fixed_line": "if (!raw.isInterface() && full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()) {"
    },
    "JacksonDatabind-24": {
        "fixes": [
            {
                "k": 1,
                "patch": "TimeZone tz = (_annotationIntrospector == null)? _visibilityChecker : _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-24/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\t2022-07-19 17:50:02.854228102 +0200\n+++ /tmp/tmpl819s5jb.java\t2022-07-19 17:50:02.970227518 +0200\n@@ -229,14 +229,11 @@\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n         if (_dateFormat == df) {\n             return this;\n         }\n-        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                tz, _defaultBase64);\n+TimeZone tz = (_annotationIntrospector == null)? _visibilityChecker : _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         if (_handlerInstantiator == hi) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "TimeZone tz = (df == null)? _typeFactory : df.getTimeZone, _defaultBase64, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-24/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\t2022-07-19 17:50:04.874217934 +0200\n+++ /tmp/tmpkxfo53kk.java\t2022-07-19 17:50:04.874217934 +0200\n@@ -229,14 +229,11 @@\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n         if (_dateFormat == df) {\n             return this;\n         }\n-        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                tz, _defaultBase64);\n+TimeZone tz = (df == null)? _typeFactory : df.getTimeZone, _defaultBase64, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         if (_handlerInstantiator == hi) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "TimeZone tz = (df == null)? _typeFactory : _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-24/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\t2022-07-19 17:50:06.530209594 +0200\n+++ /tmp/tmp3z57iuo1.java\t2022-07-19 17:50:06.534209576 +0200\n@@ -229,14 +229,11 @@\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n         if (_dateFormat == df) {\n             return this;\n         }\n-        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                tz, _defaultBase64);\n+TimeZone tz = (df == null)? _typeFactory : _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         if (_handlerInstantiator == hi) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "TimeZone tz = (df == null)? _timeZone : df.getTimeZone, _defaultBase64, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-24/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\t2022-07-19 17:50:08.162201376 +0200\n+++ /tmp/tmprt5nqp9o.java\t2022-07-19 17:50:08.162201376 +0200\n@@ -229,14 +229,11 @@\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n         if (_dateFormat == df) {\n             return this;\n         }\n-        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                tz, _defaultBase64);\n+TimeZone tz = (df == null)? _timeZone : df.getTimeZone, _defaultBase64, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         if (_handlerInstantiator == hi) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "TimeZone tz = (df == null)? _typeFactory : _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-24/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\t2022-07-19 17:50:09.810193081 +0200\n+++ /tmp/tmpq2x9oqja.java\t2022-07-19 17:50:09.810193081 +0200\n@@ -229,14 +229,11 @@\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n         if (_dateFormat == df) {\n             return this;\n         }\n-        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                tz, _defaultBase64);\n+TimeZone tz = (df == null)? _typeFactory : _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         if (_handlerInstantiator == hi) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "TimeZone tz = (df == null)? _typeFactory : df.getTimeZone, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-24/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\t2022-07-19 17:50:11.422184961 +0200\n+++ /tmp/tmpmqmb2_ly.java\t2022-07-19 17:50:11.422184961 +0200\n@@ -229,14 +229,11 @@\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n         if (_dateFormat == df) {\n             return this;\n         }\n-        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                tz, _defaultBase64);\n+TimeZone tz = (df == null)? _typeFactory : df.getTimeZone, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         if (_handlerInstantiator == hi) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "TimeZone tz = (df == null)? _timeZone : df.getTimeZone, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-24/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\t2022-07-19 17:50:13.070176663 +0200\n+++ /tmp/tmpyy1xgqg_.java\t2022-07-19 17:50:13.070176663 +0200\n@@ -229,14 +229,11 @@\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n         if (_dateFormat == df) {\n             return this;\n         }\n-        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                tz, _defaultBase64);\n+TimeZone tz = (df == null)? _timeZone : df.getTimeZone, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         if (_handlerInstantiator == hi) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "TimeZone tz = (df == null)? _typeFactory : _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-24/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\t2022-07-19 17:50:14.682168544 +0200\n+++ /tmp/tmp6r0pxxi5.java\t2022-07-19 17:50:14.682168544 +0200\n@@ -229,14 +229,11 @@\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n         if (_dateFormat == df) {\n             return this;\n         }\n-        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                tz, _defaultBase64);\n+TimeZone tz = (df == null)? _typeFactory : _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         if (_handlerInstantiator == hi) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "TimeZone tz = (df == null)? _typeFactory : df.getTimeZone, _defaultBase64, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-24/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\t2022-07-19 17:50:16.310160348 +0200\n+++ /tmp/tmppku82usm.java\t2022-07-19 17:50:16.310160348 +0200\n@@ -229,14 +229,11 @@\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n         if (_dateFormat == df) {\n             return this;\n         }\n-        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                tz, _defaultBase64);\n+TimeZone tz = (df == null)? _typeFactory : df.getTimeZone, _defaultBase64, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         if (_handlerInstantiator == hi) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "TimeZone tz = (df == null)? _typeFactory : df.getTimeZone, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-24/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\t2022-07-19 17:50:17.978151945 +0200\n+++ /tmp/tmpchbc70bp.java\t2022-07-19 17:50:17.978151945 +0200\n@@ -229,14 +229,11 @@\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n         if (_dateFormat == df) {\n             return this;\n         }\n-        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                tz, _defaultBase64);\n+TimeZone tz = (df == null)? _typeFactory : df.getTimeZone, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         if (_handlerInstantiator == hi) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "TimeZone tz = (df == null) ? _timeZone : df.getTimeZone(); return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64);",
        "fixed_line": "_timeZone, _defaultBase64);"
    },
    "Codec-16": {
        "fixes": [
            {
                "k": 1,
                "patch": "25, 25, 5 -1, -1, -1, 0, 3, \"Base token of the 0, -1, -1, }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-16/src/main/java/org/apache/commons/codec/binary/Base32.java\t2022-07-19 17:50:19.834142596 +0200\n+++ /tmp/tmpm2sdg0fn.java\t2022-07-19 17:50:19.870142415 +0200\n@@ -94,11 +94,11 @@\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n-            25, 26, 27, 28, 29, 30, 31, 32,\n+25, 25, 5 -1, -1, -1, 0, 3, \"Base token of the 0, -1, -1, }\n     };\n \n     /**\n      * This array is a lookup table that translates 5-bit positive integer index values into their\n      * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "25, 25, 5 -1, -1, -1, 0, 3, \"Base token of the 0, -1, -1, -1, }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-16/src/main/java/org/apache/commons/codec/binary/Base32.java\t2022-07-19 17:50:21.814132623 +0200\n+++ /tmp/tmpp1faubax.java\t2022-07-19 17:50:21.814132623 +0200\n@@ -94,11 +94,11 @@\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n-            25, 26, 27, 28, 29, 30, 31, 32,\n+25, 25, 5 -1, -1, -1, 0, 3, \"Base token of the 0, -1, -1, -1, }\n     };\n \n     /**\n      * This array is a lookup table that translates 5-bit positive integer index values into their\n      * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "25, 25, 27, 28, -1, -1, 0, 3, \"S as 0, -1, -1, }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-16/src/main/java/org/apache/commons/codec/binary/Base32.java\t2022-07-19 17:50:23.306125110 +0200\n+++ /tmp/tmp88f3k_38.java\t2022-07-19 17:50:23.306125110 +0200\n@@ -94,11 +94,11 @@\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n-            25, 26, 27, 28, 29, 30, 31, 32,\n+25, 25, 27, 28, -1, -1, 0, 3, \"S as 0, -1, -1, }\n     };\n \n     /**\n      * This array is a lookup table that translates 5-bit positive integer index values into their\n      * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "25, 25, 5 -1, -1, -1, -1, 0, 3, \"Base token of the 0, -1, -1, }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-16/src/main/java/org/apache/commons/codec/binary/Base32.java\t2022-07-19 17:50:24.890117130 +0200\n+++ /tmp/tmp5hvf63ie.java\t2022-07-19 17:50:24.890117130 +0200\n@@ -94,11 +94,11 @@\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n-            25, 26, 27, 28, 29, 30, 31, 32,\n+25, 25, 5 -1, -1, -1, -1, 0, 3, \"Base token of the 0, -1, -1, }\n     };\n \n     /**\n      * This array is a lookup table that translates 5-bit positive integer index values into their\n      * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "25, 25, 5 -1, -1, 0, 3, \"Base token of the 0, -1, -1, }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-16/src/main/java/org/apache/commons/codec/binary/Base32.java\t2022-07-19 17:50:26.494109047 +0200\n+++ /tmp/tmp8bmcmei2.java\t2022-07-19 17:50:26.494109047 +0200\n@@ -94,11 +94,11 @@\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n-            25, 26, 27, 28, 29, 30, 31, 32,\n+25, 25, 5 -1, -1, 0, 3, \"Base token of the 0, -1, -1, }\n     };\n \n     /**\n      * This array is a lookup table that translates 5-bit positive integer index values into their\n      * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "25, 25, 5 -1, -1, -1, -1, 0, 3, \"Base token of the 0, -1, -1, -1, }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-16/src/main/java/org/apache/commons/codec/binary/Base32.java\t2022-07-19 17:50:27.946101732 +0200\n+++ /tmp/tmpoqjgt6fi.java\t2022-07-19 17:50:27.946101732 +0200\n@@ -94,11 +94,11 @@\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n-            25, 26, 27, 28, 29, 30, 31, 32,\n+25, 25, 5 -1, -1, -1, -1, 0, 3, \"Base token of the 0, -1, -1, -1, }\n     };\n \n     /**\n      * This array is a lookup table that translates 5-bit positive integer index values into their\n      * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "25, 25, 5 -1, -1, 0, 3, \"Base token of the 0, -1, -1, -1, }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-16/src/main/java/org/apache/commons/codec/binary/Base32.java\t2022-07-19 17:50:29.678093006 +0200\n+++ /tmp/tmpngrfk2xt.java\t2022-07-19 17:50:29.678093006 +0200\n@@ -94,11 +94,11 @@\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n-            25, 26, 27, 28, 29, 30, 31, 32,\n+25, 25, 5 -1, -1, 0, 3, \"Base token of the 0, -1, -1, -1, }\n     };\n \n     /**\n      * This array is a lookup table that translates 5-bit positive integer index values into their\n      * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "25, 25, 5 -1, -1, -1, 0, 3, \"Base token of the 0, -1, -1, -1, -1, }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-16/src/main/java/org/apache/commons/codec/binary/Base32.java\t2022-07-19 17:50:31.230085186 +0200\n+++ /tmp/tmphgra1jve.java\t2022-07-19 17:50:31.230085186 +0200\n@@ -94,11 +94,11 @@\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n-            25, 26, 27, 28, 29, 30, 31, 32,\n+25, 25, 5 -1, -1, -1, 0, 3, \"Base token of the 0, -1, -1, -1, -1, }\n     };\n \n     /**\n      * This array is a lookup table that translates 5-bit positive integer index values into their\n      * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "25, 25, 5 -1, -1, -1, -1, 0, 3, \"Base token of the 0, -1, -1, -1, -1, }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-16/src/main/java/org/apache/commons/codec/binary/Base32.java\t2022-07-19 17:50:32.810077228 +0200\n+++ /tmp/tmpbneu2pt8.java\t2022-07-19 17:50:32.814077205 +0200\n@@ -94,11 +94,11 @@\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n-            25, 26, 27, 28, 29, 30, 31, 32,\n+25, 25, 5 -1, -1, -1, -1, 0, 3, \"Base token of the 0, -1, -1, -1, -1, }\n     };\n \n     /**\n      * This array is a lookup table that translates 5-bit positive integer index values into their\n      * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "25, 25, 27, 28, -1, -1, 0, 3, \"S as 0, -1, -1, -1, }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-16/src/main/java/org/apache/commons/codec/binary/Base32.java\t2022-07-19 17:50:34.442069002 +0200\n+++ /tmp/tmpb7w6avuq.java\t2022-07-19 17:50:34.442069002 +0200\n@@ -94,11 +94,11 @@\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n-            25, 26, 27, 28, 29, 30, 31, 32,\n+25, 25, 27, 28, -1, -1, 0, 3, \"S as 0, -1, -1, -1, }\n     };\n \n     /**\n      * This array is a lookup table that translates 5-bit positive integer index values into their\n      * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "25, 26, 27, 28, 29, 30, 31, 32,",
        "fixed_line": "25, 26, 27, 28, 29, 30, 31, // 50-57 P-V"
    },
    "Chart-13": {
        "fixes": [
            {
                "k": 1,
                "patch": "new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h[2],",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-13/source/org/jfree/chart/block/BorderArrangement.java\t2022-07-19 17:50:36.134060475 +0200\n+++ /tmp/tmpqo3rcnjz.java\t2022-07-19 17:50:36.214060073 +0200\n@@ -450,11 +450,11 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h[2],\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-13/source/org/jfree/chart/block/BorderArrangement.java\t2022-07-19 17:50:38.782047132 +0200\n+++ /tmp/tmplavideds.java\t2022-07-19 17:50:38.782047132 +0200\n@@ -450,11 +450,11 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE)\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h4);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-13/source/org/jfree/chart/block/BorderArrangement.java\t2022-07-19 17:50:40.458038685 +0200\n+++ /tmp/tmp5dx_zmk5.java\t2022-07-19 17:50:40.458038685 +0200\n@@ -450,11 +450,11 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h4);\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h4));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-13/source/org/jfree/chart/block/BorderArrangement.java\t2022-07-19 17:50:42.058030621 +0200\n+++ /tmp/tmpv_qxujof.java\t2022-07-19 17:50:42.062030603 +0200\n@@ -450,11 +450,11 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h4));\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h[2], null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-13/source/org/jfree/chart/block/BorderArrangement.java\t2022-07-19 17:50:43.662022539 +0200\n+++ /tmp/tmpiue9o_yc.java\t2022-07-19 17:50:43.666022516 +0200\n@@ -450,11 +450,11 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h[2], null)\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-13/source/org/jfree/chart/block/BorderArrangement.java\t2022-07-19 17:50:45.334014109 +0200\n+++ /tmp/tmpdih1897k.java\t2022-07-19 17:50:45.338014092 +0200\n@@ -450,11 +450,11 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE;\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE );",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-13/source/org/jfree/chart/block/BorderArrangement.java\t2022-07-19 17:50:46.898006225 +0200\n+++ /tmp/tmprjc6e5gq.java\t2022-07-19 17:50:46.898006225 +0200\n@@ -450,11 +450,11 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE );\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h4),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-13/source/org/jfree/chart/block/BorderArrangement.java\t2022-07-19 17:50:48.657997355 +0200\n+++ /tmp/tmp9f3evm4t.java\t2022-07-19 17:50:48.657997355 +0200\n@@ -450,11 +450,11 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h4),\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-13/source/org/jfree/chart/block/BorderArrangement.java\t2022-07-19 17:50:50.253989308 +0200\n+++ /tmp/tmpidvwc0hq.java\t2022-07-19 17:50:50.253989308 +0200\n@@ -450,11 +450,11 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-13/source/org/jfree/chart/block/BorderArrangement.java\t2022-07-19 17:50:51.933980838 +0200\n+++ /tmp/tmpje9fbn2u.java\t2022-07-19 17:50:51.933980838 +0200\n@@ -450,11 +450,11 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE) {\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "new Range(0.0, constraint.getWidth() - w[2]),",
        "fixed_line": "new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)),"
    },
    "Closure-73": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (c >= 0x0f && c <= 0x7f) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-73/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 17:50:53.829971282 +0200\n+++ /tmp/tmpa8y0qdh3.java\t2022-07-19 17:50:53.849971180 +0200\n@@ -1040,11 +1040,11 @@\n             }\n           } else {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+if (c >= 0x0f && c <= 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n               // or perhaps mangled by proxies along the way,\n               // so we play it safe and unicode escape them.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (c >= 0x1f && c < 0x7f) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-73/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 17:51:36.957753722 +0200\n+++ /tmp/tmpqcwz0h3_.java\t2022-07-19 17:51:36.957753722 +0200\n@@ -1040,11 +1040,11 @@\n             }\n           } else {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+if (c >= 0x1f && c < 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n               // or perhaps mangled by proxies along the way,\n               // so we play it safe and unicode escape them.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 3,
                "patch": "if (c >= 0x1f || c <= 0x7f) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-73/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 17:52:14.417564564 +0200\n+++ /tmp/tmpean9b4l9.java\t2022-07-19 17:52:14.417564564 +0200\n@@ -1040,11 +1040,11 @@\n             }\n           } else {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+if (c >= 0x1f || c <= 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n               // or perhaps mangled by proxies along the way,\n               // so we play it safe and unicode escape them.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (c >= 0x1f && c <= 0x7f) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-73/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 17:52:51.013379615 +0200\n+++ /tmp/tmp4p74mbg3.java\t2022-07-19 17:52:51.017379593 +0200\n@@ -1040,11 +1040,11 @@\n             }\n           } else {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+if (c >= 0x1f && c <= 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n               // or perhaps mangled by proxies along the way,\n               // so we play it safe and unicode escape them.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (c > 0x0f && c <= 0x7f) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-73/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 17:53:23.429215669 +0200\n+++ /tmp/tmpg8l8fdq9.java\t2022-07-19 17:53:23.429215669 +0200\n@@ -1040,11 +1040,11 @@\n             }\n           } else {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+if (c > 0x0f && c <= 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n               // or perhaps mangled by proxies along the way,\n               // so we play it safe and unicode escape them.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (c > 0x1f && c!= 0x7f) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-73/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 17:53:55.541053154 +0200\n+++ /tmp/tmpu7f3a6k2.java\t2022-07-19 17:53:55.545053133 +0200\n@@ -1040,11 +1040,11 @@\n             }\n           } else {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+if (c > 0x1f && c!= 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n               // or perhaps mangled by proxies along the way,\n               // so we play it safe and unicode escape them.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (c > 0x1f && c < 0x7f) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-73/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 17:54:27.680910613 +0200\n+++ /tmp/tmpi18nn34d.java\t2022-07-19 17:54:27.680910613 +0200\n@@ -1040,11 +1040,11 @@\n             }\n           } else {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+if (c > 0x1f && c < 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n               // or perhaps mangled by proxies along the way,\n               // so we play it safe and unicode escape them.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 8,
                "patch": "if (c > 0x1f || c < 0x7f) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-73/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 17:55:00.068770764 +0200\n+++ /tmp/tmpd2orchqk.java\t2022-07-19 17:55:00.068770764 +0200\n@@ -1040,11 +1040,11 @@\n             }\n           } else {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+if (c > 0x1f || c < 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n               // or perhaps mangled by proxies along the way,\n               // so we play it safe and unicode escape them.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (c < 0x1f || c > 0x7f) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-73/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 17:55:32.144630894 +0200\n+++ /tmp/tmptbgf6k6a.java\t2022-07-19 17:55:32.144630894 +0200\n@@ -1040,11 +1040,11 @@\n             }\n           } else {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+if (c < 0x1f || c > 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n               // or perhaps mangled by proxies along the way,\n               // so we play it safe and unicode escape them.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (c > 0x1f && c <= 0x7f) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-73/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 17:56:04.348489177 +0200\n+++ /tmp/tmp2dzc6oab.java\t2022-07-19 17:56:04.352489160 +0200\n@@ -1040,11 +1040,11 @@\n             }\n           } else {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+if (c > 0x1f && c <= 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n               // or perhaps mangled by proxies along the way,\n               // so we play it safe and unicode escape them.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (c > 0x1f && c <= 0x7f) {",
        "fixed_line": "if (c > 0x1f && c < 0x7f) {"
    },
    "JacksonDatabind-89": {
        "fixes": [
            {
                "k": 1,
                "patch": "// }",
                "patch_diff": "// }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) {",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) { for (int j = 0; j < s.length; j++) { s.add(s); } }",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) { for (int j = 0; j < s.length; j++) { s.add(s); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) { for (int j = 0; j < s.length; j++) { if (s.contains(c)) { s.add(s); } } }",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) { for (int j = 0; j < s.length; j++) { if (s.contains(c)) { s.add(s); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) { for (int j = 0; j < s.length; j++) { if (s.equals(s)) { s.add(s); } } }",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) { for (int j = 0; j < s.length; j++) { if (s.equals(s)) { s.add(s); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) { if (s[i]!= null) { s.add(s); } } }",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) { if (s[i]!= null) { s.add(s); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) { for (int j = 0; j < s.length; j++) { if (s.charAt(i++) { s.add(s); } } }",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) { for (int j = 0; j < s.length; j++) { if (s.charAt(i++) { s.add(s); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) { for (int j = 0; j < s.length; j++) { if (s.contains(c)) { s.add(c); } } }",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) { for (int j = 0; j < s.length; j++) { if (s.contains(c)) { s.add(c); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) { if (s[i]!= null) { s.add(s); } }",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) { if (s[i]!= null) { s.add(s); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "s.add(\"java.util.logging.FileHandler\"); s.add(\"java.rmi.server.UnicastRemoteObject\"); // [databind#1737]; 3rd party s.add(\"org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor\"); s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\"); s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\"); s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");"
    },
    "Math-91": {
        "fixes": [
            {
                "k": 1,
                "patch": "double dOn = value; double dOn = object.doubleValue() * dOnData.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-91/src/java/org/apache/commons/math/fraction/Fraction.java\t2022-07-19 17:56:38.332338316 +0200\n+++ /tmp/tmpjcooimkf.java\t2022-07-19 17:56:38.456337765 +0200\n@@ -254,12 +254,11 @@\n      * @param object the object to compare to\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+double dOn = value; double dOn = object.doubleValue() * dOnData.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n     /**\n      * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "double dOn = value; double dOn = object.doubleValue() < dOnData.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-91/src/java/org/apache/commons/math/fraction/Fraction.java\t2022-07-19 17:56:40.932326723 +0200\n+++ /tmp/tmpx17azwfw.java\t2022-07-19 17:56:40.932326723 +0200\n@@ -254,12 +254,11 @@\n      * @param object the object to compare to\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+double dOn = value; double dOn = object.doubleValue() < dOnData.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n     /**\n      * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "double dOn = object.doubleValue() * dOn = object.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-91/src/java/org/apache/commons/math/fraction/Fraction.java\t2022-07-19 17:56:42.928317817 +0200\n+++ /tmp/tmpnj21agrf.java\t2022-07-19 17:56:42.928317817 +0200\n@@ -254,12 +254,11 @@\n      * @param object the object to compare to\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+double dOn = object.doubleValue() * dOn = object.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n     /**\n      * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "double dOn = object.doubleValue() * dOnData.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-91/src/java/org/apache/commons/math/fraction/Fraction.java\t2022-07-19 17:56:45.016308496 +0200\n+++ /tmp/tmpf9y71vd4.java\t2022-07-19 17:56:45.020308478 +0200\n@@ -254,12 +254,11 @@\n      * @param object the object to compare to\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+double dOn = object.doubleValue() * dOnData.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n     /**\n      * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "double dOn = object.doubleValue() < dOnData.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-91/src/java/org/apache/commons/math/fraction/Fraction.java\t2022-07-19 17:56:47.064299348 +0200\n+++ /tmp/tmpnvjqecny.java\t2022-07-19 17:56:47.064299348 +0200\n@@ -254,12 +254,11 @@\n      * @param object the object to compare to\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+double dOn = object.doubleValue() < dOnData.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n     /**\n      * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "double dOn = object.doubleValue() / dOn = object.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-91/src/java/org/apache/commons/math/fraction/Fraction.java\t2022-07-19 17:56:49.152290017 +0200\n+++ /tmp/tmpo6ppl5r_.java\t2022-07-19 17:56:49.152290017 +0200\n@@ -254,12 +254,11 @@\n      * @param object the object to compare to\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+double dOn = object.doubleValue() / dOn = object.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n     /**\n      * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "double dOn = object.doubleValue() - dOn = object.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-91/src/java/org/apache/commons/math/fraction/Fraction.java\t2022-07-19 17:56:51.300280416 +0200\n+++ /tmp/tmpwyewxdai.java\t2022-07-19 17:56:51.300280416 +0200\n@@ -254,12 +254,11 @@\n      * @param object the object to compare to\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+double dOn = object.doubleValue() - dOn = object.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n     /**\n      * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "double dOn = value; double dOn = object.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-91/src/java/org/apache/commons/math/fraction/Fraction.java\t2022-07-19 17:56:53.460270752 +0200\n+++ /tmp/tmp84s4fcbl.java\t2022-07-19 17:56:53.460270752 +0200\n@@ -254,12 +254,11 @@\n      * @param object the object to compare to\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+double dOn = value; double dOn = object.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n     /**\n      * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "double dOnData = object.doubleValue() * dOnData.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-91/src/java/org/apache/commons/math/fraction/Fraction.java\t2022-07-19 17:56:55.640260995 +0200\n+++ /tmp/tmpxrepezwu.java\t2022-07-19 17:56:55.640260995 +0200\n@@ -254,12 +254,11 @@\n      * @param object the object to compare to\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+double dOnData = object.doubleValue() * dOnData.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n     /**\n      * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "double dOn = object.doubleValue() / dOnData.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-91/src/java/org/apache/commons/math/fraction/Fraction.java\t2022-07-19 17:56:57.908250840 +0200\n+++ /tmp/tmp4un_7qhp.java\t2022-07-19 17:56:57.908250840 +0200\n@@ -254,12 +254,11 @@\n      * @param object the object to compare to\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+double dOn = object.doubleValue() / dOnData.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n     /**\n      * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "double nOd = doubleValue(); double dOn = object.doubleValue();",
        "fixed_line": "long nOd = ((long) numerator) * object.denominator; long dOn = ((long) denominator) * object.numerator;"
    },
    "Math-89": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (Comparable<?> v) { addValue((Comparable<?> v) v); }",
                "patch_diff": "for (Comparable<?> v) { addValue((Comparable<?> v) v); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "{ addValue((Comparable<?> v) v); }",
                "patch_diff": "{ addValue((Comparable<?> v) v); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (Comparable<?> v) { addValue((Comparable<?> v)v); }",
                "patch_diff": "for (Comparable<?> v) { addValue((Comparable<?> v)v); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (Comparable<?> v) { addValue((Comparable<?> v)v; }",
                "patch_diff": "for (Comparable<?> v) { addValue((Comparable<?> v)v; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (Comparable<?> v) { addValue((Comparable<?> v) v; }",
                "patch_diff": "for (Comparable<?> v) { addValue((Comparable<?> v) v; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (Comparable<?> v) { addValue((Comparable<?> v) {",
                "patch_diff": "for (Comparable<?> v) { addValue((Comparable<?> v) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// for (Comparable<?> v) { addValue((Comparable<?> v) v); }",
                "patch_diff": "// for (Comparable<?> v) { addValue((Comparable<?> v) v); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (Comparable<?> v) { addValue((Comparable<?>) v); }",
                "patch_diff": "for (Comparable<?> v) { addValue((Comparable<?>) v); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "{ addValue((Comparable<?> v) v; }",
                "patch_diff": "{ addValue((Comparable<?> v) v; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if (v) { addValue((Comparable<?> v) v); }",
                "patch_diff": "// if (v) { addValue((Comparable<?> v) v); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (v instanceof Comparable<?>){ addValue((Comparable<?>) v); } else { throw new IllegalArgumentException(\"Object must implement Comparable\"); }"
    },
    "Jsoup-49": {
        "fixes": [
            {
                "k": 1,
                "patch": "reindexChildren(in = L_NODE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-49/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 17:57:01.708233812 +0200\n+++ /tmp/tmpn84by5sq.java\t2022-07-19 17:57:01.768233543 +0200\n@@ -441,11 +441,11 @@\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren(index);\n+reindexChildren(in = L_NODE;\n     }\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n             childNodes = new ArrayList<Node>(4);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "reindexChildren(lastJump = rep;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-49/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 17:57:03.752224646 +0200\n+++ /tmp/tmpzxsx1w3y.java\t2022-07-19 17:57:03.752224646 +0200\n@@ -441,11 +441,11 @@\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren(index);\n+reindexChildren(lastJump = rep;\n     }\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n             childNodes = new ArrayList<Node>(4);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "reindexChildren(in = rep.length;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-49/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 17:57:05.304217684 +0200\n+++ /tmp/tmpti262_7v.java\t2022-07-19 17:57:05.304217684 +0200\n@@ -441,11 +441,11 @@\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren(index);\n+reindexChildren(in = rep.length;\n     }\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n             childNodes = new ArrayList<Node>(4);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "reindexChildren(in = NO_NODE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-49/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 17:57:06.816210898 +0200\n+++ /tmp/tmpxjchb6uw.java\t2022-07-19 17:57:06.816210898 +0200\n@@ -441,11 +441,11 @@\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren(index);\n+reindexChildren(in = NO_NODE;\n     }\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n             childNodes = new ArrayList<Node>(4);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "reindexChildren(in);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-49/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 17:57:08.392203824 +0200\n+++ /tmp/tmpe8pqfgax.java\t2022-07-19 17:57:08.396203807 +0200\n@@ -441,11 +441,11 @@\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren(index);\n+reindexChildren(in);\n     }\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n             childNodes = new ArrayList<Node>(4);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "reindexChildren(lastJump = 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-49/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 17:57:10.256195453 +0200\n+++ /tmp/tmpli909wwk.java\t2022-07-19 17:57:10.260195435 +0200\n@@ -441,11 +441,11 @@\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren(index);\n+reindexChildren(lastJump = 0;\n     }\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n             childNodes = new ArrayList<Node>(4);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "reindexChildren(lastJump = NO_NODE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-49/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 17:57:11.876188176 +0200\n+++ /tmp/tmp1y2ev6br.java\t2022-07-19 17:57:11.876188176 +0200\n@@ -441,11 +441,11 @@\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren(index);\n+reindexChildren(lastJump = NO_NODE;\n     }\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n             childNodes = new ArrayList<Node>(4);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "reindexChildren(in;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-49/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 17:57:13.520180787 +0200\n+++ /tmp/tmpitg1lbmd.java\t2022-07-19 17:57:13.520180787 +0200\n@@ -441,11 +441,11 @@\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren(index);\n+reindexChildren(in;\n     }\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n             childNodes = new ArrayList<Node>(4);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "reindexChildren(in = rep;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-49/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 17:57:15.024174024 +0200\n+++ /tmp/tmphk07pkwb.java\t2022-07-19 17:57:15.024174024 +0200\n@@ -441,11 +441,11 @@\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren(index);\n+reindexChildren(in = rep;\n     }\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n             childNodes = new ArrayList<Node>(4);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "reindexChildren(lastJump = L_NODE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-49/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 17:57:16.696166506 +0200\n+++ /tmp/tmpir5q3ffn.java\t2022-07-19 17:57:16.696166506 +0200\n@@ -441,11 +441,11 @@\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren(index);\n+reindexChildren(lastJump = L_NODE;\n     }\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n             childNodes = new ArrayList<Node>(4);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "reindexChildren(index);",
        "fixed_line": "reindexChildren(index);"
    },
    "JacksonDatabind-7": {
        "fixes": [
            {
                "k": 1,
                "patch": "/* 28-Oct-2013, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "/* 28-Oct-2013, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "/* 28-Oct-2012, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "/* 28-Oct-2012, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// copy-Oct-2012, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "// copy-Oct-2012, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "/* 28-Oct-2014, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "/* 28-Oct-2014, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// copy-Oct-2013, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "// copy-Oct-2013, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "/* 28-Oct-2013, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "/* 28-Oct-2013, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "/* 28-Oct-2012, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "/* 28-Oct-2012, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "/* 28-Oct-2012, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "/* 28-Oct-2012, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "/* 28-Oct-2013, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "/* 28-Oct-2013, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "/* 28-Oct-2012, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-Oct-2010, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "/* 28-Oct-2012, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-Oct-2010, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (jp.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { copyCurrentStructure(jp); return this; } /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from * FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need * to assume one did exist. */ JsonToken t; writeStartObject(); do { copyCurrentStructure(jp); } while ((t = jp.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) { throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t); } writeEndObject();"
    },
    "Math-102": {
        "fixes": [
            {
                "k": 1,
                "patch": "// for (int i = 0; i < expected.length; i++) {",
                "patch_diff": "// for (int i = 0; i < expected.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// for (int i = 0; i < expected.length; i++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { sumSq += expected[i]; } } }",
                "patch_diff": "// for (int i = 0; i < expected.length; i++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { sumSq += expected[i]; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// for (int i = 0; i < expected.length; i++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { p[i] = sumSq[i]; } } }",
                "patch_diff": "// for (int i = 0; i < expected.length; i++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { p[i] = sumSq[i]; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// for (int i = 0; i < expected.length; i++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { sumSq += expected[i]; } } }",
                "patch_diff": "// for (int i = 0; i < expected.length; i++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { sumSq += expected[i]; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// for (int i = 0; i < expected.length; i++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { p[i] = sumSq[i]; } } }",
                "patch_diff": "// for (int i = 0; i < expected.length; i++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { p[i] = sumSq[i]; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// for (int i = 0; i < expected.length; i++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { sumSq += expected[i]; } } }",
                "patch_diff": "// for (int i = 0; i < expected.length; i++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { sumSq += expected[i]; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// for (int i = 0; i < expected.length; i++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { sumSq += += expected[i]; } } }",
                "patch_diff": "// for (int i = 0; i < expected.length; i++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { sumSq += += expected[i]; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = 0; i < expected.length; i++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { sumSq += expected[i]; } } }",
                "patch_diff": "for (int i = 0; i < expected.length; i++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { sumSq += expected[i]; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// for (int i = 0; i < expected.length; i++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { p[i] = sumSq[i]; } }",
                "patch_diff": "// for (int i = 0; i < expected.length; i++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { p[i] = sumSq[i]; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = 0; i < expected.length; i++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { sumSq += expected[i]; } } }",
                "patch_diff": "for (int i = 0; i < expected.length; i++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { for (int j = 0; j < expected.length; j++) { sumSq += expected[i]; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "double sumExpected = 0d; double sumObserved = 0d; for (int i = 0; i < observed.length; i++) { sumExpected += expected[i]; sumObserved += observed[i]; } double ratio = 1.0d; boolean rescale = false; if (Math.abs(sumExpected - sumObserved) > 10E-6) { ratio = sumObserved / sumExpected; rescale = true; } double sumSq = 0.0d; double dev = 0.0d; for (int i = 0; i < observed.length; i++) { if (rescale) { dev = ((double) observed[i] - ratio * expected[i]); sumSq += dev * dev / (ratio * expected[i]); } else { dev = ((double) observed[i] - expected[i]); sumSq += dev * dev / expected[i]; }"
    },
    "JxPath-10": {
        "fixes": [
            {
                "k": 1,
                "patch": "return computeValue[0].computeValue(context == args[1].computeValue(context? Boolean.TRUEValue :context;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-10/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\t2022-07-19 17:57:22.856138772 +0200\n+++ /tmp/tmpy2e7netx.java\t2022-07-19 17:57:23.008138090 +0200\n@@ -37,11 +37,11 @@\n     protected CoreOperationRelationalExpression(Expression[] args) {\n         super(args);\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n+return computeValue[0].computeValue(context == args[1].computeValue(context? Boolean.TRUEValue :context;\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     protected final int getPrecedence() {\n         return 3;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return computeValue[0].computeValue(context == args[0].computeValue(context? Boolean.TRUEValue :context;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-10/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\t2022-07-19 17:57:24.976129224 +0200\n+++ /tmp/tmpm77i88d2.java\t2022-07-19 17:57:24.976129224 +0200\n@@ -37,11 +37,11 @@\n     protected CoreOperationRelationalExpression(Expression[] args) {\n         super(args);\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n+return computeValue[0].computeValue(context == args[0].computeValue(context? Boolean.TRUEValue :context;\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     protected final int getPrecedence() {\n         return 3;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return computeValue[0].computeValue(context == args[0].computeValue(context? Boolean.TRUEValue : args;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-10/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\t2022-07-19 17:57:26.544122154 +0200\n+++ /tmp/tmp8za46tc1.java\t2022-07-19 17:57:26.544122154 +0200\n@@ -37,11 +37,11 @@\n     protected CoreOperationRelationalExpression(Expression[] args) {\n         super(args);\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n+return computeValue[0].computeValue(context == args[0].computeValue(context? Boolean.TRUEValue : args;\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     protected final int getPrecedence() {\n         return 3;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return computeValue[0].computeValue(context == args[1].computeValue(context? Boolean.TRUEValue : args;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-10/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\t2022-07-19 17:57:28.284114310 +0200\n+++ /tmp/tmp3pnqv2fh.java\t2022-07-19 17:57:28.288114290 +0200\n@@ -37,11 +37,11 @@\n     protected CoreOperationRelationalExpression(Expression[] args) {\n         super(args);\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n+return computeValue[0].computeValue(context == args[1].computeValue(context? Boolean.TRUEValue : args;\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     protected final int getPrecedence() {\n         return 3;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return computeValue[0].computeValue(context == args[1].computeValue(context? Boolean.TRUEValue : context;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-10/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\t2022-07-19 17:57:29.948106804 +0200\n+++ /tmp/tmplp790x0p.java\t2022-07-19 17:57:29.948106804 +0200\n@@ -37,11 +37,11 @@\n     protected CoreOperationRelationalExpression(Expression[] args) {\n         super(args);\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n+return computeValue[0].computeValue(context == args[1].computeValue(context? Boolean.TRUEValue : context;\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     protected final int getPrecedence() {\n         return 3;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return computeValue[0].computeValue(context == args[0].computeValue(context? Boolean.TRUEValue : context;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-10/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\t2022-07-19 17:57:31.636099185 +0200\n+++ /tmp/tmpkeq761c5.java\t2022-07-19 17:57:31.640099168 +0200\n@@ -37,11 +37,11 @@\n     protected CoreOperationRelationalExpression(Expression[] args) {\n         super(args);\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n+return computeValue[0].computeValue(context == args[0].computeValue(context? Boolean.TRUEValue : context;\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     protected final int getPrecedence() {\n         return 3;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return computeValue[0].computeValue(context == args[1].computeValue(context? context :context;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-10/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\t2022-07-19 17:57:33.304091655 +0200\n+++ /tmp/tmpcyd1yb4q.java\t2022-07-19 17:57:33.308091638 +0200\n@@ -37,11 +37,11 @@\n     protected CoreOperationRelationalExpression(Expression[] args) {\n         super(args);\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n+return computeValue[0].computeValue(context == args[1].computeValue(context? context :context;\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     protected final int getPrecedence() {\n         return 3;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return computeValue[0].computeValue(context == args[0].computeValue(context? context : args;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-10/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\t2022-07-19 17:57:34.856084647 +0200\n+++ /tmp/tmppjq89dcv.java\t2022-07-19 17:57:34.856084647 +0200\n@@ -37,11 +37,11 @@\n     protected CoreOperationRelationalExpression(Expression[] args) {\n         super(args);\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n+return computeValue[0].computeValue(context == args[0].computeValue(context? context : args;\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     protected final int getPrecedence() {\n         return 3;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return computeValue[0].computeValue(context == args[0].computeValue(context? context :context;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-10/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\t2022-07-19 17:57:36.340077944 +0200\n+++ /tmp/tmp5y3c15gy.java\t2022-07-19 17:57:36.340077944 +0200\n@@ -37,11 +37,11 @@\n     protected CoreOperationRelationalExpression(Expression[] args) {\n         super(args);\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n+return computeValue[0].computeValue(context == args[0].computeValue(context? context :context;\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     protected final int getPrecedence() {\n         return 3;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return computeValue[0].computeValue(context == args[1].computeValue(context? context : args;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-10/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\t2022-07-19 17:57:37.948070680 +0200\n+++ /tmp/tmpq6ju49dt.java\t2022-07-19 17:57:37.948070680 +0200\n@@ -37,11 +37,11 @@\n     protected CoreOperationRelationalExpression(Expression[] args) {\n         super(args);\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n+return computeValue[0].computeValue(context == args[1].computeValue(context? context : args;\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     protected final int getPrecedence() {\n         return 3;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return compute(args[0].computeValue(context), args[1].computeValue(context))",
        "fixed_line": "return compute(args[0].compute(context), args[1].compute(context))"
    },
    "JacksonDatabind-101": {
        "fixes": [
            {
                "k": 1,
                "patch": "private static final /*day*/int[] p.nextToken!= JsonToken.END_ARRAY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-101/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 17:57:39.688062812 +0200\n+++ /tmp/tmpula1gt79.java\t2022-07-19 17:57:39.740062577 +0200\n@@ -766,11 +766,11 @@\n                     // [databind#631]: Assign current value, to be accessible by custom serializers\n                     p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n-                        p.nextToken();\n+private static final /*day*/int[] p.nextToken!= JsonToken.END_ARRAY;\n                         tokens.copyCurrentStructure(p);\n                         t = p.nextToken();\n                     }\n                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                     //    problems if we maintain invariants\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "private static final /*day*/int[] p.nextToken = _beanType.nextToken();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-101/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 17:57:41.664053876 +0200\n+++ /tmp/tmpxlr36vlo.java\t2022-07-19 17:57:41.668053858 +0200\n@@ -766,11 +766,11 @@\n                     // [databind#631]: Assign current value, to be accessible by custom serializers\n                     p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n-                        p.nextToken();\n+private static final /*day*/int[] p.nextToken = _beanType.nextToken();\n                         tokens.copyCurrentStructure(p);\n                         t = p.nextToken();\n                     }\n                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                     //    problems if we maintain invariants\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "private static final /*day*/int[] items = _beanType.nextToken();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-101/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 17:57:43.252046694 +0200\n+++ /tmp/tmpd53l5kr0.java\t2022-07-19 17:57:43.252046694 +0200\n@@ -766,11 +766,11 @@\n                     // [databind#631]: Assign current value, to be accessible by custom serializers\n                     p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n-                        p.nextToken();\n+private static final /*day*/int[] items = _beanType.nextToken();\n                         tokens.copyCurrentStructure(p);\n                         t = p.nextToken();\n                     }\n                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                     //    problems if we maintain invariants\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "private static final /*day*/int[] items = _beanType.nextToken;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-101/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 17:57:44.752039904 +0200\n+++ /tmp/tmpl7t_7w7h.java\t2022-07-19 17:57:44.752039904 +0200\n@@ -766,11 +766,11 @@\n                     // [databind#631]: Assign current value, to be accessible by custom serializers\n                     p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n-                        p.nextToken();\n+private static final /*day*/int[] items = _beanType.nextToken;\n                         tokens.copyCurrentStructure(p);\n                         t = p.nextToken();\n                     }\n                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                     //    problems if we maintain invariants\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private static final /*day*/int[] p.nextToken = JsonToken.END_ARRAY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-101/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 17:57:46.420032354 +0200\n+++ /tmp/tmpb_9iurop.java\t2022-07-19 17:57:46.420032354 +0200\n@@ -766,11 +766,11 @@\n                     // [databind#631]: Assign current value, to be accessible by custom serializers\n                     p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n-                        p.nextToken();\n+private static final /*day*/int[] p.nextToken = JsonToken.END_ARRAY;\n                         tokens.copyCurrentStructure(p);\n                         t = p.nextToken();\n                     }\n                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                     //    problems if we maintain invariants\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "private static final /*day*/int[] EASTER = _beanType.nextToken();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-101/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 17:57:48.184024365 +0200\n+++ /tmp/tmpobz1wdf_.java\t2022-07-19 17:57:48.184024365 +0200\n@@ -766,11 +766,11 @@\n                     // [databind#631]: Assign current value, to be accessible by custom serializers\n                     p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n-                        p.nextToken();\n+private static final /*day*/int[] EASTER = _beanType.nextToken();\n                         tokens.copyCurrentStructure(p);\n                         t = p.nextToken();\n                     }\n                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                     //    problems if we maintain invariants\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private static final /*day*/int[] items = this.nextToken;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-101/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 17:57:50.812012459 +0200\n+++ /tmp/tmpyen2_oan.java\t2022-07-19 17:57:50.844012314 +0200\n@@ -766,11 +766,11 @@\n                     // [databind#631]: Assign current value, to be accessible by custom serializers\n                     p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n-                        p.nextToken();\n+private static final /*day*/int[] items = this.nextToken;\n                         tokens.copyCurrentStructure(p);\n                         t = p.nextToken();\n                     }\n                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                     //    problems if we maintain invariants\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "p.nextToken = JsonToken.END_ARRAY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-101/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 17:57:53.368000873 +0200\n+++ /tmp/tmpq5q64alh.java\t2022-07-19 17:57:53.372000856 +0200\n@@ -766,11 +766,11 @@\n                     // [databind#631]: Assign current value, to be accessible by custom serializers\n                     p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n-                        p.nextToken();\n+p.nextToken = JsonToken.END_ARRAY;\n                         tokens.copyCurrentStructure(p);\n                         t = p.nextToken();\n                     }\n                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                     //    problems if we maintain invariants\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private static final /*day*/int[] EASTER = this.nextToken;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-101/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 17:57:56.319987484 +0200\n+++ /tmp/tmp4gctd2t3.java\t2022-07-19 17:57:56.319987484 +0200\n@@ -766,11 +766,11 @@\n                     // [databind#631]: Assign current value, to be accessible by custom serializers\n                     p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n-                        p.nextToken();\n+private static final /*day*/int[] EASTER = this.nextToken;\n                         tokens.copyCurrentStructure(p);\n                         t = p.nextToken();\n                     }\n                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                     //    problems if we maintain invariants\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "private static final /*day*/int[] p.nextToken();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-101/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 17:57:59.283974031 +0200\n+++ /tmp/tmp0tma8o9i.java\t2022-07-19 17:57:59.287974014 +0200\n@@ -766,11 +766,11 @@\n                     // [databind#631]: Assign current value, to be accessible by custom serializers\n                     p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n-                        p.nextToken();\n+private static final /*day*/int[] p.nextToken();\n                         tokens.copyCurrentStructure(p);\n                         t = p.nextToken();\n                     }\n                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                     //    problems if we maintain invariants\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "p.nextToken();",
        "fixed_line": "if (t != JsonToken.END_OBJECT) { ctxt.reportWrongTokenException(this, JsonToken.END_OBJECT, \"Attempted to unwrap '%s' value\", handledType().getName()); }"
    },
    "Chart-26": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (this.labelToolTip!= null && hotspot!= null) {",
                "patch_diff": "if (this.labelToolTip!= null && hotspot!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (this.labelToolTip!= null && hotspot.getEntity(this, hotspot, this.labelToolTip, this.labelURL);",
                "patch_diff": "if (this.labelToolTip!= null && hotspot.getEntity(this, hotspot, this.labelToolTip, this.labelURL);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (this.labelToolTip!= null && hotspot!= null) { ChartRenderingInfo owner = new AxisLabelGenerator(this, hotspot, this.labelToolTip, this.labelURL); for (int i = 0; i < this.labelURL; i++) { entities.add(new AxisLabelEntity(this, hotspot, this.labelToolTip, this.labelURL); } }",
                "patch_diff": "if (this.labelToolTip!= null && hotspot!= null) { ChartRenderingInfo owner = new AxisLabelGenerator(this, hotspot, this.labelToolTip, this.labelURL); for (int i = 0; i < this.labelURL; i++) { entities.add(new AxisLabelEntity(this, hotspot, this.labelToolTip, this.labelURL); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (this.labelToolTip!= null && hotspot!= null) { ChartRenderingInfo owner = new AxisLabelGenerator(this, hotspot, this.labelToolTip, this.labelURL); for (int i = 0; i < this.labelURL; i++) { entities.add(new AxisLabelEntity(this, hotspot, this.labelToolTip, this.labelURL)); } }",
                "patch_diff": "if (this.labelToolTip!= null && hotspot!= null) { ChartRenderingInfo owner = new AxisLabelGenerator(this, hotspot, this.labelToolTip, this.labelURL); for (int i = 0; i < this.labelURL; i++) { entities.add(new AxisLabelEntity(this, hotspot, this.labelToolTip, this.labelURL)); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (this.labelToolTip!= null && hotspot!= null) { ChartRenderingInfo owner = new AxisLabelGenerator(this, hotspot, this.labelToolTip, this.labelURL); for (int i = 0; i < this.labelURL; i++) { entities.add(new AxisLabelEntity(this, hotspot, this.labelURL, this.labelURL)); } }",
                "patch_diff": "if (this.labelToolTip!= null && hotspot!= null) { ChartRenderingInfo owner = new AxisLabelGenerator(this, hotspot, this.labelToolTip, this.labelURL); for (int i = 0; i < this.labelURL; i++) { entities.add(new AxisLabelEntity(this, hotspot, this.labelURL, this.labelURL)); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (this.labelToolTip!= null && hotspot!= null) { ChartRenderingInfo owner = new AxisLabelGenerator(this, hotspot, this.labelToolTip, this.labelURL); for (int i = 0; i < this.labelURL; i++) { entities.add(new AxisLabelEntity(this, hotspot, this.labelURL, this.labelURL, this.labelURL)); } }",
                "patch_diff": "if (this.labelToolTip!= null && hotspot!= null) { ChartRenderingInfo owner = new AxisLabelGenerator(this, hotspot, this.labelToolTip, this.labelURL); for (int i = 0; i < this.labelURL; i++) { entities.add(new AxisLabelEntity(this, hotspot, this.labelURL, this.labelURL, this.labelURL)); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (this.labelToolTip!= null && hotspot!= null) { ChartRenderingInfo owner = new AxisLabelGenerator(this, hotspot, this.labelToolTip, this.labelURL); for (int i = 0; i < this.labelURL; i++) { entities.add(new AxisLabelEntity(this, hotspot, this.labelURL, this.labelURL, this.labelURL); } }",
                "patch_diff": "if (this.labelToolTip!= null && hotspot!= null) { ChartRenderingInfo owner = new AxisLabelGenerator(this, hotspot, this.labelToolTip, this.labelURL); for (int i = 0; i < this.labelURL; i++) { entities.add(new AxisLabelEntity(this, hotspot, this.labelURL, this.labelURL, this.labelURL); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (this.labelToolTip!= null && hotspot!= null) { ChartRenderingInfo owner = new AxisLabelGenerator(this, hotspot, this.labelToolTip, this.labelURL); for (int i = 0; i < this.labelURL; i++) { entities.add(new AxisLabelEntity(this, hotspot, this.labelURL, this.labelToolTip, this.labelURL); } }",
                "patch_diff": "if (this.labelToolTip!= null && hotspot!= null) { ChartRenderingInfo owner = new AxisLabelGenerator(this, hotspot, this.labelToolTip, this.labelURL); for (int i = 0; i < this.labelURL; i++) { entities.add(new AxisLabelEntity(this, hotspot, this.labelURL, this.labelToolTip, this.labelURL); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (this.labelToolTip!= null && hotspot!= null) { ChartRenderingInfo owner = new AxisLabelGenerator(this, hotspot, this.labelToolTip, this.labelURL); for (int i = 0; i < this.labelURL; i++) { entities.add(new AxisLabelEntity(this, hotspot, this.labelURL, this.labelURL); } }",
                "patch_diff": "if (this.labelToolTip!= null && hotspot!= null) { ChartRenderingInfo owner = new AxisLabelGenerator(this, hotspot, this.labelToolTip, this.labelURL); for (int i = 0; i < this.labelURL; i++) { entities.add(new AxisLabelEntity(this, hotspot, this.labelURL, this.labelURL); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (this.labelToolTip!= null && hotspot!= null) { ChartRenderingInfo owner = new AxisLabelGenerator(this, hotspot, this.labelToolTip, this.labelURL); for (int i = 0; i < this.labelURL; i++) { entities.add(new AxisLabelEntity(this, hotspot, this.labelURL, this.labelToolTip, this.labelURL)); } }",
                "patch_diff": "if (this.labelToolTip!= null && hotspot!= null) { ChartRenderingInfo owner = new AxisLabelGenerator(this, hotspot, this.labelToolTip, this.labelURL); for (int i = 0; i < this.labelURL; i++) { entities.add(new AxisLabelEntity(this, hotspot, this.labelURL, this.labelToolTip, this.labelURL)); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (owner != null) { EntityCollection entities = owner.getEntityCollection(); if (entities != null) { entities.add(new AxisLabelEntity(this, hotspot, this.labelToolTip, this.labelURL)); } }"
    },
    "Jsoup-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "tq.consume; // value is last",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-5/src/main/java/org/jsoup/parser/Parser.java\t2022-07-19 17:58:05.659945069 +0200\n+++ /tmp/tmp19xojx1_.java\t2022-07-19 17:58:05.975943621 +0200\n@@ -201,11 +201,11 @@\n             tq.consumeWhitespace();\n         }\n         if (key.length() != 0)\n             return Attribute.createFromEncoded(key, value);\n         else {\n-            tq.consume();\n+tq.consume; // value is last\n                 \n             return null;\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "tq.consume; // value is to do this",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-5/src/main/java/org/jsoup/parser/Parser.java\t2022-07-19 17:58:08.419932517 +0200\n+++ /tmp/tmp9mngvu0r.java\t2022-07-19 17:58:08.419932517 +0200\n@@ -201,11 +201,11 @@\n             tq.consumeWhitespace();\n         }\n         if (key.length() != 0)\n             return Attribute.createFromEncoded(key, value);\n         else {\n-            tq.consume();\n+tq.consume; // value is to do this\n                 \n             return null;\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "tq.consume; // value is lower case",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-5/src/main/java/org/jsoup/parser/Parser.java\t2022-07-19 17:58:10.707922108 +0200\n+++ /tmp/tmplhfov95y.java\t2022-07-19 17:58:10.711922090 +0200\n@@ -201,11 +201,11 @@\n             tq.consumeWhitespace();\n         }\n         if (key.length() != 0)\n             return Attribute.createFromEncoded(key, value);\n         else {\n-            tq.consume();\n+tq.consume; // value is lower case\n                 \n             return null;\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "tq.consume; // value is tick",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-5/src/main/java/org/jsoup/parser/Parser.java\t2022-07-19 17:58:12.587913554 +0200\n+++ /tmp/tmpx49thic9.java\t2022-07-19 17:58:12.591913533 +0200\n@@ -201,11 +201,11 @@\n             tq.consumeWhitespace();\n         }\n         if (key.length() != 0)\n             return Attribute.createFromEncoded(key, value);\n         else {\n-            tq.consume();\n+tq.consume; // value is tick\n                 \n             return null;\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "tq.consume; // value is to do value",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-5/src/main/java/org/jsoup/parser/Parser.java\t2022-07-19 17:58:15.019902479 +0200\n+++ /tmp/tmp3nm37o26.java\t2022-07-19 17:58:15.019902479 +0200\n@@ -201,11 +201,11 @@\n             tq.consumeWhitespace();\n         }\n         if (key.length() != 0)\n             return Attribute.createFromEncoded(key, value);\n         else {\n-            tq.consume();\n+tq.consume; // value is to do value\n                 \n             return null;\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "tq.consume; // value is to check",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-5/src/main/java/org/jsoup/parser/Parser.java\t2022-07-19 17:58:17.263892258 +0200\n+++ /tmp/tmpkdpe211q.java\t2022-07-19 17:58:17.299892094 +0200\n@@ -201,11 +201,11 @@\n             tq.consumeWhitespace();\n         }\n         if (key.length() != 0)\n             return Attribute.createFromEncoded(key, value);\n         else {\n-            tq.consume();\n+tq.consume; // value is to check\n                 \n             return null;\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "tq.consume; // root is this class value",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-5/src/main/java/org/jsoup/parser/Parser.java\t2022-07-19 17:58:20.131879188 +0200\n+++ /tmp/tmpsrncbtjx.java\t2022-07-19 17:58:20.131879188 +0200\n@@ -201,11 +201,11 @@\n             tq.consumeWhitespace();\n         }\n         if (key.length() != 0)\n             return Attribute.createFromEncoded(key, value);\n         else {\n-            tq.consume();\n+tq.consume; // root is this class value\n                 \n             return null;\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "tq.consume; // value is tick last",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-5/src/main/java/org/jsoup/parser/Parser.java\t2022-07-19 17:58:22.379868937 +0200\n+++ /tmp/tmpde6k6ic8.java\t2022-07-19 17:58:22.435868682 +0200\n@@ -201,11 +201,11 @@\n             tq.consumeWhitespace();\n         }\n         if (key.length() != 0)\n             return Attribute.createFromEncoded(key, value);\n         else {\n-            tq.consume();\n+tq.consume; // value is tick last\n                 \n             return null;\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "tq.consume(); // value is to check",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-5/src/main/java/org/jsoup/parser/Parser.java\t2022-07-19 17:58:25.351855376 +0200\n+++ /tmp/tmp80yro6ff.java\t2022-07-19 17:58:25.351855376 +0200\n@@ -201,11 +201,11 @@\n             tq.consumeWhitespace();\n         }\n         if (key.length() != 0)\n             return Attribute.createFromEncoded(key, value);\n         else {\n-            tq.consume();\n+tq.consume(); // value is to check\n                 \n             return null;\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "tq.consume; // value is this class value",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-5/src/main/java/org/jsoup/parser/Parser.java\t2022-07-19 17:58:30.067833847 +0200\n+++ /tmp/tmpt6z42jkl.java\t2022-07-19 17:58:30.095833718 +0200\n@@ -201,11 +201,11 @@\n             tq.consumeWhitespace();\n         }\n         if (key.length() != 0)\n             return Attribute.createFromEncoded(key, value);\n         else {\n-            tq.consume();\n+tq.consume; // value is this class value\n                 \n             return null;\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "tq.consume();",
        "fixed_line": "if (value.length() == 0) // no key, no val; unknown char, keep popping so not get stuck tq.advance();"
    },
    "Math-70": {
        "fixes": [
            {
                "k": 1,
                "patch": "return solve(min, max, f;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2022-07-19 17:58:33.047820231 +0200\n+++ /tmp/tmplb5ublx3.java\t2022-07-19 17:58:33.347818847 +0200\n@@ -67,11 +67,11 @@\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+return solve(min, max, f;\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return solve;min > 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2022-07-19 17:58:36.495804468 +0200\n+++ /tmp/tmpxgsqz6zf.java\t2022-07-19 17:58:36.495804468 +0200\n@@ -67,11 +67,11 @@\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+return solve;min > 0;\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return solve(min, max = f;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2022-07-19 17:58:39.271791768 +0200\n+++ /tmp/tmp3vfynhvy.java\t2022-07-19 17:58:39.351791402 +0200\n@@ -67,11 +67,11 @@\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+return solve(min, max = f;\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return solve(min, max, f);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2022-07-19 17:58:42.299777911 +0200\n+++ /tmp/tmpwske6qk7.java\t2022-07-19 17:58:42.299777911 +0200\n@@ -67,11 +67,11 @@\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+return solve(min, max, f);\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return solve;minmin, max);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2022-07-19 17:58:45.555762998 +0200\n+++ /tmp/tmpj2uhj9v3.java\t2022-07-19 17:58:45.559762981 +0200\n@@ -67,11 +67,11 @@\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+return solve;minmin, max);\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return solve(min, max;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2022-07-19 17:58:48.219750793 +0200\n+++ /tmp/tmpt8iju25h.java\t2022-07-19 17:58:48.219750793 +0200\n@@ -67,11 +67,11 @@\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+return solve(min, max;\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return solve(min, max);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2022-07-19 17:58:51.615735222 +0200\n+++ /tmp/tmp32a59pqa.java\t2022-07-19 17:58:51.615735222 +0200\n@@ -67,11 +67,11 @@\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+return solve(min, max);\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return solve(min, initial);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2022-07-19 17:59:01.791688511 +0200\n+++ /tmp/tmptwk5kig6.java\t2022-07-19 17:59:01.791688511 +0200\n@@ -67,11 +67,11 @@\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+return solve(min, initial);\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return solve;min = max;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2022-07-19 17:59:11.359644510 +0200\n+++ /tmp/tmpahk72uju.java\t2022-07-19 17:59:11.359644510 +0200\n@@ -67,11 +67,11 @@\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+return solve;min = max;\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return solve;min);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2022-07-19 17:59:13.903632801 +0200\n+++ /tmp/tmp8wnh5ul7.java\t2022-07-19 17:59:13.903632801 +0200\n@@ -67,11 +67,11 @@\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+return solve;min);\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return solve(min, max);",
        "fixed_line": "return solve(f, min, max);"
    },
    "Math-30": {
        "fixes": [
            {
                "k": 1,
                "patch": "final int n1 = n2prod = n2 * UminX;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-30/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\t2022-07-19 17:59:16.979618629 +0200\n+++ /tmp/tmpw4igcqpb.java\t2022-07-19 17:59:17.255617363 +0200\n@@ -168,11 +168,11 @@\n     private double calculateAsymptoticPValue(final double Umin,\n                                              final int n1,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+final int n1 = n2prod = n2 * UminX;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "final int n1 = n2prod = n2 - n2;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-30/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\t2022-07-19 17:59:20.939600381 +0200\n+++ /tmp/tmp1gmzt39y.java\t2022-07-19 17:59:20.939600381 +0200\n@@ -168,11 +168,11 @@\n     private double calculateAsymptoticPValue(final double Umin,\n                                              final int n1,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+final int n1 = n2prod = n2 - n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "final int n1 = n2prod = n2 * U;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-30/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\t2022-07-19 17:59:24.567583651 +0200\n+++ /tmp/tmpttfg3wqb.java\t2022-07-19 17:59:24.799582579 +0200\n@@ -168,11 +168,11 @@\n     private double calculateAsymptoticPValue(final double Umin,\n                                              final int n1,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+final int n1 = n2prod = n2 * U;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "final int n1 = n2prod = n2 / n2;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-30/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\t2022-07-19 17:59:27.519570030 +0200\n+++ /tmp/tmps3s1kkio.java\t2022-07-19 17:59:27.519570030 +0200\n@@ -168,11 +168,11 @@\n     private double calculateAsymptoticPValue(final double Umin,\n                                              final int n1,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+final int n1 = n2prod = n2 / n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "final int n1 = n2prod = n2dy / n2;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-30/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\t2022-07-19 17:59:29.935558879 +0200\n+++ /tmp/tmp88rybnvt.java\t2022-07-19 17:59:29.935558879 +0200\n@@ -168,11 +168,11 @@\n     private double calculateAsymptoticPValue(final double Umin,\n                                              final int n1,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+final int n1 = n2prod = n2dy / n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "final int n1 = n2prod = n2 - n1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-30/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\t2022-07-19 17:59:31.991549384 +0200\n+++ /tmp/tmpklld4ef8.java\t2022-07-19 17:59:31.991549384 +0200\n@@ -168,11 +168,11 @@\n     private double calculateAsymptoticPValue(final double Umin,\n                                              final int n1,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+final int n1 = n2prod = n2 - n1;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "final int n1 = n2prod = n2 * n2;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-30/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\t2022-07-19 17:59:34.055539847 +0200\n+++ /tmp/tmpxpsixjoy.java\t2022-07-19 17:59:34.055539847 +0200\n@@ -168,11 +168,11 @@\n     private double calculateAsymptoticPValue(final double Umin,\n                                              final int n1,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+final int n1 = n2prod = n2 * n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "final int n2prod = n1 / n2;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-30/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\t2022-07-19 17:59:36.127530272 +0200\n+++ /tmp/tmph63f6jvg.java\t2022-07-19 17:59:36.131530256 +0200\n@@ -168,11 +168,11 @@\n     private double calculateAsymptoticPValue(final double Umin,\n                                              final int n1,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+final int n2prod = n1 / n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "final int n1 = n2prod = n1 / n2;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-30/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\t2022-07-19 17:59:38.259520419 +0200\n+++ /tmp/tmpfnxmlt1e.java\t2022-07-19 17:59:38.259520419 +0200\n@@ -168,11 +168,11 @@\n     private double calculateAsymptoticPValue(final double Umin,\n                                              final int n1,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+final int n1 = n2prod = n1 / n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "final int n1 = UminX * n2;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-30/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\t2022-07-19 17:59:40.403510504 +0200\n+++ /tmp/tmpyrihxri4.java\t2022-07-19 17:59:40.407510483 +0200\n@@ -168,11 +168,11 @@\n     private double calculateAsymptoticPValue(final double Umin,\n                                              final int n1,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+final int n1 = UminX * n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "final int n1n2prod = n1 * n2;",
        "fixed_line": "final double n1n2prod = n1 * n2;"
    },
    "JacksonDatabind-28": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (_tokens.getCurrentToken!= JsonToken.START_OBJECT) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-28/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\t2022-07-19 17:59:42.639500160 +0200\n+++ /tmp/tmpeatjscan.java\t2022-07-19 17:59:42.671500008 +0200\n@@ -92,18 +92,11 @@\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n-            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n-                p.nextToken();\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n-            }\n-            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n+if (_tokens.getCurrentToken!= JsonToken.START_OBJECT) {\n             }\n             throw ctxt.mappingException(ObjectNode.class);\n          }\n     }\n         \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (_tokens.getCurrentToken == JsonToken.START_OBJECT) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-28/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\t2022-07-19 17:59:44.755490367 +0200\n+++ /tmp/tmprcxq4vjt.java\t2022-07-19 17:59:44.759490347 +0200\n@@ -92,18 +92,11 @@\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n-            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n-                p.nextToken();\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n-            }\n-            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n+if (_tokens.getCurrentToken == JsonToken.START_OBJECT) {\n             }\n             throw ctxt.mappingException(ObjectNode.class);\n          }\n     }\n         \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (p.getCurrentToken!= JsonToken.START_OBJECT) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-28/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\t2022-07-19 17:59:46.503482273 +0200\n+++ /tmp/tmpgt78tbgt.java\t2022-07-19 17:59:46.503482273 +0200\n@@ -92,18 +92,11 @@\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n-            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n-                p.nextToken();\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n-            }\n-            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n+if (p.getCurrentToken!= JsonToken.START_OBJECT) {\n             }\n             throw ctxt.mappingException(ObjectNode.class);\n          }\n     }\n         \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (_tokens.getCurrentToken() == JsonToken.START_OBJECT) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-28/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\t2022-07-19 17:59:48.243474219 +0200\n+++ /tmp/tmp1trtz3ki.java\t2022-07-19 17:59:48.243474219 +0200\n@@ -92,18 +92,11 @@\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n-            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n-                p.nextToken();\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n-            }\n-            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n+if (_tokens.getCurrentToken() == JsonToken.START_OBJECT) {\n             }\n             throw ctxt.mappingException(ObjectNode.class);\n          }\n     }\n         \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (p.getCurrentToken() == JsonToken.START_OBJECT) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-28/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\t2022-07-19 17:59:49.927466417 +0200\n+++ /tmp/tmpnzu3hvcq.java\t2022-07-19 17:59:49.927466417 +0200\n@@ -92,18 +92,11 @@\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n-            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n-                p.nextToken();\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n-            }\n-            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n+if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n             }\n             throw ctxt.mappingException(ObjectNode.class);\n          }\n     }\n         \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (p.getCurrentToken == JsonToken.START_OBJECT) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-28/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\t2022-07-19 18:00:25.651300459 +0200\n+++ /tmp/tmptg53lhin.java\t2022-07-19 18:00:25.651300459 +0200\n@@ -92,18 +92,11 @@\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n-            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n-                p.nextToken();\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n-            }\n-            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n+if (p.getCurrentToken == JsonToken.START_OBJECT) {\n             }\n             throw ctxt.mappingException(ObjectNode.class);\n          }\n     }\n         \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (p.getCurrentToken() == JsonToken.START_OBJECT;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-28/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\t2022-07-19 18:00:27.367292462 +0200\n+++ /tmp/tmp2xcayd7k.java\t2022-07-19 18:00:27.367292462 +0200\n@@ -92,18 +92,11 @@\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n-            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n-                p.nextToken();\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n-            }\n-            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n+if (p.getCurrentToken() == JsonToken.START_OBJECT;\n             }\n             throw ctxt.mappingException(ObjectNode.class);\n          }\n     }\n         \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (p.getCurrentToken()!= JsonToken.START_OBJECT) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-28/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\t2022-07-19 18:00:28.967285006 +0200\n+++ /tmp/tmpwi95fqn0.java\t2022-07-19 18:00:28.971284989 +0200\n@@ -92,18 +92,11 @@\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n-            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n-                p.nextToken();\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n-            }\n-            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n+if (p.getCurrentToken()!= JsonToken.START_OBJECT) {\n             }\n             throw ctxt.mappingException(ObjectNode.class);\n          }\n     }\n         \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (_p.getCurrentToken == JsonToken.START_OBJECT) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-28/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\t2022-07-19 18:01:02.551128098 +0200\n+++ /tmp/tmp1r07b46r.java\t2022-07-19 18:01:02.555128077 +0200\n@@ -92,18 +92,11 @@\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n-            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n-                p.nextToken();\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n-            }\n-            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n+if (_p.getCurrentToken == JsonToken.START_OBJECT) {\n             }\n             throw ctxt.mappingException(ObjectNode.class);\n          }\n     }\n         \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (_currToken == JsonToken.START_OBJECT) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-28/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\t2022-07-19 18:01:04.335119742 +0200\n+++ /tmp/tmpl21otl9e.java\t2022-07-19 18:01:04.335119742 +0200\n@@ -92,18 +92,11 @@\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n-            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n-                p.nextToken();\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n-            }\n-            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n+if (_currToken == JsonToken.START_OBJECT) {\n             }\n             throw ctxt.mappingException(ObjectNode.class);\n          }\n     }\n         \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (p.getCurrentToken() == JsonToken.START_OBJECT) { p.nextToken(); return deserializeObject(p, ctxt, ctxt.getNodeFactory()); } // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME), // if caller has advanced to the first token of Object, but for empty Object if (p.getCurrentToken() == JsonToken.FIELD_NAME) { return deserializeObject(p, ctxt, ctxt.getNodeFactory());",
        "fixed_line": "if (p.isExpectedStartObjectToken() || p.hasToken(JsonToken.FIELD_NAME)) { return deserializeObject(p, ctxt, ctxt.getNodeFactory()); } // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME), // if caller has advanced to the first token of Object, but for empty Object if (p.hasToken(JsonToken.END_OBJECT)) { return ctxt.getNodeFactory().objectNode();"
    },
    "Lang-58": {
        "fixes": [
            {
                "k": 1,
                "patch": "&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0, Character.numericnumeric.charAt(0)))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-58/src/java/org/apache/commons/lang/math/NumberUtils.java\t2022-07-19 18:01:06.439109884 +0200\n+++ /tmp/tmpx2lo_eq4.java\t2022-07-19 18:01:06.503109584 +0200\n@@ -449,12 +449,11 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0, Character.numericnumeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0 & Character.numericnumeric.charAt(0.0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-58/src/java/org/apache/commons/lang/math/NumberUtils.java\t2022-07-19 18:01:08.327101036 +0200\n+++ /tmp/tmpepvnn0_6.java\t2022-07-19 18:01:08.327101036 +0200\n@@ -449,12 +449,11 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0 & Character.numericnumeric.charAt(0.0) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0.0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-58/src/java/org/apache/commons/lang/math/NumberUtils.java\t2022-07-19 18:01:09.879093759 +0200\n+++ /tmp/tmpliahcfx_.java\t2022-07-19 18:01:09.883093742 +0200\n@@ -449,12 +449,11 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0.0) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-58/src/java/org/apache/commons/lang/math/NumberUtils.java\t2022-07-19 18:01:11.447086410 +0200\n+++ /tmp/tmpi5bh84iq.java\t2022-07-19 18:01:11.447086410 +0200\n@@ -449,12 +449,11 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0 & Character.numericnumeric.charAt(0)))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-58/src/java/org/apache/commons/lang/math/NumberUtils.java\t2022-07-19 18:01:12.959079319 +0200\n+++ /tmp/tmpp_3x2s9f.java\t2022-07-19 18:01:12.959079319 +0200\n@@ -449,12 +449,11 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0 & Character.numericnumeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "&& isDigits(numeric.substring(1 || (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0 & Character.numericnumeric.charAt(0)))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-58/src/java/org/apache/commons/lang/math/NumberUtils.java\t2022-07-19 18:01:14.491072133 +0200\n+++ /tmp/tmp2q3l0wx2.java\t2022-07-19 18:01:14.495072114 +0200\n@@ -449,12 +449,11 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+&& isDigits(numeric.substring(1 || (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0 & Character.numericnumeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0 & Character.numericnumeric.charAt(0.0 & Character.numericnumeric.charAt(0)))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-58/src/java/org/apache/commons/lang/math/NumberUtils.java\t2022-07-19 18:01:15.951065281 +0200\n+++ /tmp/tmpj8cizdot.java\t2022-07-19 18:01:15.951065281 +0200\n@@ -449,12 +449,11 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0 & Character.numericnumeric.charAt(0.0 & Character.numericnumeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0 & Character.numericnumeric.charAt(0.0 & Character.numericnumeric.charAt(0.0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-58/src/java/org/apache/commons/lang/math/NumberUtils.java\t2022-07-19 18:01:17.455058224 +0200\n+++ /tmp/tmpy6hev8vw.java\t2022-07-19 18:01:17.459058208 +0200\n@@ -449,12 +449,11 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0 & Character.numericnumeric.charAt(0.0 & Character.numericnumeric.charAt(0.0) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "&& isDigits(numeric.substring(1 || (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-58/src/java/org/apache/commons/lang/math/NumberUtils.java\t2022-07-19 18:01:18.975051092 +0200\n+++ /tmp/tmplzzagxik.java\t2022-07-19 18:01:18.975051092 +0200\n@@ -449,12 +449,11 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+&& isDigits(numeric.substring(1 || (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0, Character.numericnumeric.charAt(0.0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-58/src/java/org/apache/commons/lang/math/NumberUtils.java\t2022-07-19 18:01:20.447044180 +0200\n+++ /tmp/tmpuk334n8l.java\t2022-07-19 18:01:20.447044180 +0200\n@@ -449,12 +449,11 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0, Character.numericnumeric.charAt(0.0) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {",
        "fixed_line": "&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {"
    },
    "Gson-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "throw new JsonSyntaxException(\"Expecting number, got: \" + json);",
                "patch_diff": "throw new JsonSyntaxException(\"Expecting number, got: \" + json);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "throw new JsonSyntaxException(\"Expecting number, got: \" + json); }",
                "patch_diff": "throw new JsonSyntaxException(\"Expecting number, got: \" + json); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);",
                "patch_diff": "throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new JsonSyntaxException(\"Expecting number, got: \" + json;",
                "patch_diff": "throw new JsonSyntaxException(\"Expecting number, got: \" + json;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "throw new JsonSyntaxException(in, got: \"Expecting number, got: \" + json); }",
                "patch_diff": "throw new JsonSyntaxException(in, got: \"Expecting number, got: \" + json); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return new LazilyParsedNumber(in, got: \" + json;",
                "patch_diff": "return new LazilyParsedNumber(in, got: \" + json;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return new LazilyParsedNumber(in, got: \" + jsonToken);",
                "patch_diff": "return new LazilyParsedNumber(in, got: \" + jsonToken);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return new LazilyParsedNumber(in, got: \" + json);",
                "patch_diff": "return new LazilyParsedNumber(in, got: \" + json);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken;",
                "patch_diff": "throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken); }",
                "patch_diff": "throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "case STRING:"
    },
    "Lang-45": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (upper == -1 || upper > str.length()) {",
                "patch_diff": "if (upper == -1 || upper > str.length()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// if (upper > 0 || upper > str.length()) {",
                "patch_diff": "// if (upper > 0 || upper > str.length()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (upper == 0 || upper > str.length()) {",
                "patch_diff": "if (upper == 0 || upper > str.length()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// if (upper > 0 && upper > 0) {",
                "patch_diff": "// if (upper > 0 && upper > 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// if (upper > 0 || upper > str.charAt(i++) {",
                "patch_diff": "// if (upper > 0 || upper > str.charAt(i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if (upper > 0 && upper < 0) {",
                "patch_diff": "// if (upper > 0 && upper < 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (upper == -1 || upper > str.length) {",
                "patch_diff": "if (upper == -1 || upper > str.length) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (upper == 0 && upper > 0) {",
                "patch_diff": "if (upper == 0 && upper > 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (upper > 0 && upper < 0) {",
                "patch_diff": "if (upper > 0 && upper < 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if (upper > 0 || upper > str.charAt(length - 1) {",
                "patch_diff": "// if (upper > 0 || upper > str.charAt(length - 1) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (lower > str.length()) { lower = str.length(); }"
    },
    "Closure-77": {
        "fixes": [
            {
                "k": 1,
                "patch": "switch (c) { case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\",
                "patch_diff": "switch (c) { case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "switch (c) { case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\",
                "patch_diff": "switch (c) { case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "switch (c) { case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\",
                "patch_diff": "switch (c) { case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "switch (c) { case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\",
                "patch_diff": "switch (c) { case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "switch (c) { case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\",
                "patch_diff": "switch (c) { case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "switch (c) { case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\",
                "patch_diff": "switch (c) { case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "switch (c) { case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\",
                "patch_diff": "switch (c) { case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "switch (c) { case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\",
                "patch_diff": "switch (c) { case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "switch (c) { case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\",
                "patch_diff": "switch (c) { case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "switch (c) { case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\",
                "patch_diff": "switch (c) { case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\t\"); break; case '\\r': sb.append(\"\\\\t\"); break; case '\\",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "case '\\0': sb.append(\"\\\\0\"); break;"
    },
    "Closure-166": {
        "fixes": [
            {
                "k": 1,
                "patch": "// We can't really modify it was non-empty's do implicit re-parse",
                "patch_diff": "// We can't really modify it was non-empty's do implicit re-parse",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// TODO: can't really modify it was non-empty's do implicit re-parse",
                "patch_diff": "// TODO: can't really modify it was non-empty's do implicit re-parse",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// We can't really modify it was non-literal characters that might be null or EMPTY",
                "patch_diff": "// We can't really modify it was non-literal characters that might be null or EMPTY",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// TODO: can't really modify it was non-literal characters that might be null or EMPTY",
                "patch_diff": "// TODO: can't really modify it was non-literal characters that might be null or EMPTY",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if ( constraintObj.isRecordType()) {",
                "patch_diff": "if ( constraintObj.isRecordType()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// TODO: can't really modify it was non-literal characters that might be valid (e.",
                "patch_diff": "// TODO: can't really modify it was non-literal characters that might be valid (e.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// We can't really modify it was non-literal characters that might be valid (e.",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (e.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// We can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// TODO: can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "patch_diff": "// TODO: can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// TODO: can't really modify it was non-literal characters that might be valid (e if it.",
                "patch_diff": "// TODO: can't really modify it was non-literal characters that might be valid (e if it.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "} else if (constraint.isUnionType()) { for (JSType alt : constraint.toMaybeUnionType().getAlternates()) { if (alt.isRecordType()) { matchRecordTypeConstraint(alt.toObjectType()); } }"
    },
    "Collections-28": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (fromKey, fromInclusive, toKey, toInclusive) { return new RangeEntryMap(fromKey, toKey, toInclusive); } else { return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive); } }",
                "patch_diff": "} else if (fromKey, fromInclusive, toKey, toInclusive) { return new RangeEntryMap(fromKey, toKey, toInclusive); } else { return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (fromKey, fromInclusive, toKey, toInclusive) { return new RangeEntryMap(fromKey, toKey, toInclusive); } else { throw new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive); } }",
                "patch_diff": "} else if (fromKey, fromInclusive, toKey, toInclusive) { return new RangeEntryMap(fromKey, toKey, toInclusive); } else { throw new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (fromKey, fromInclusive, toKey, toInclusive) { return new RangeEntryMap(fromKey, toKey, toInclusive); } else { return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive); }",
                "patch_diff": "} else if (fromKey, fromInclusive, toKey, toInclusive) { return new RangeEntryMap(fromKey, toKey, toInclusive); } else { return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (fromKey, fromInclusive, toKey, toInclusive) { return new RangeEntryMap(fromKey, toKey, toInclusive); } else { throw new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive); }",
                "patch_diff": "} else if (fromKey, fromInclusive, toKey, toInclusive) { return new RangeEntryMap(fromKey, toKey, toInclusive); } else { throw new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (fromKey, fromInclusive, toKey, toInclusive) { return new RangeEntryMap(fromKey, toKey, toInclusive); } else { return new RangeEntryMap(fromKey, toKey, toInclusive); } }",
                "patch_diff": "} else if (fromKey, fromInclusive, toKey, toInclusive) { return new RangeEntryMap(fromKey, toKey, toInclusive); } else { return new RangeEntryMap(fromKey, toKey, toInclusive); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return toInclusiveMap(fromKey, fromInclusive, toKey, toInclusive); }",
                "patch_diff": "return toInclusiveMap(fromKey, fromInclusive, toKey, toInclusive); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (fromKey, fromInclusive, toKey, toInclusive) { return new RangeEntryMap(fromKey, toKey, toInclusive); }",
                "patch_diff": "} else if (fromKey, fromInclusive, toKey, toInclusive) { return new RangeEntryMap(fromKey, toKey, toInclusive); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (fromKey, fromInclusive, toKey, toInclusive) { return new RangeEntryMap(fromKey, toKey, toInclusive); } else { throw new RangeEntryMap(fromKey, toKey, toInclusive); } }",
                "patch_diff": "} else if (fromKey, fromInclusive, toKey, toInclusive) { return new RangeEntryMap(fromKey, toKey, toInclusive); } else { throw new RangeEntryMap(fromKey, toKey, toInclusive); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (fromKey, fromInclusive, toKey, toInclusive) { return new RangeEntryMap(fromKey, toKey, toInclusive); } else { return new RangeEntryMap(fromKey, toKey, toInclusive); }",
                "patch_diff": "} else if (fromKey, fromInclusive, toKey, toInclusive) { return new RangeEntryMap(fromKey, toKey, toInclusive); } else { return new RangeEntryMap(fromKey, toKey, toInclusive); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (fromKey, fromInclusive, toKey, toInclusive) { return new RangeEntryMap(fromKey, toKey, toInclusive); } else { throw new RangeEntryMap(fromKey, toKey, toInclusive); }",
                "patch_diff": "} else if (fromKey, fromInclusive, toKey, toInclusive) { return new RangeEntryMap(fromKey, toKey, toInclusive); } else { throw new RangeEntryMap(fromKey, toKey, toInclusive); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "@Override public void clear() { Iterator<Map.Entry<K, V>> it = AbstractPatriciaTrie.this.entrySet().iterator(); Set<K> currentKeys = keySet(); while (it.hasNext()) { if (currentKeys.contains(it.next().getKey())) { it.remove(); } } }"
    },
    "Closure-55": {
        "fixes": [
            {
                "k": 1,
                "patch": "return NodeUtil.isFunctionExpression( n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2022-07-19 18:01:31.314993123 +0200\n+++ /tmp/tmpfyt5qa2d.java\t2022-07-19 18:01:31.342992988 +0200\n@@ -112,11 +112,11 @@\n         reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n     return (root != null) ? root.removeFirstChild() : null;\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+return NodeUtil.isFunctionExpression( n);\n   }\n \n   /**\n    * Information needed to apply a reduction.\n    */\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return NodeUtil.isFunctionExpression( n, n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2022-07-19 18:02:11.366804336 +0200\n+++ /tmp/tmpz4w8gsq4.java\t2022-07-19 18:02:11.366804336 +0200\n@@ -112,11 +112,11 @@\n         reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n     return (root != null) ? root.removeFirstChild() : null;\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+return NodeUtil.isFunctionExpression( n, n);\n   }\n \n   /**\n    * Information needed to apply a reduction.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return NodeUtil.isFunctionExpressionNode( n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2022-07-19 18:02:14.842787904 +0200\n+++ /tmp/tmpl1np3pcl.java\t2022-07-19 18:02:14.842787904 +0200\n@@ -112,11 +112,11 @@\n         reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n     return (root != null) ? root.removeFirstChild() : null;\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+return NodeUtil.isFunctionExpressionNode( n);\n   }\n \n   /**\n    * Information needed to apply a reduction.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return NodeUtil.isFunctionExpression( n;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2022-07-19 18:02:18.474770734 +0200\n+++ /tmp/tmpyay7ujsl.java\t2022-07-19 18:02:18.474770734 +0200\n@@ -112,11 +112,11 @@\n         reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n     return (root != null) ? root.removeFirstChild() : null;\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+return NodeUtil.isFunctionExpression( n;\n   }\n \n   /**\n    * Information needed to apply a reduction.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return NodeUtil.isFunctionExpressionNode( n;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2022-07-19 18:02:21.722755370 +0200\n+++ /tmp/tmpel7d_x_k.java\t2022-07-19 18:02:21.726755351 +0200\n@@ -112,11 +112,11 @@\n         reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n     return (root != null) ? root.removeFirstChild() : null;\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+return NodeUtil.isFunctionExpressionNode( n;\n   }\n \n   /**\n    * Information needed to apply a reduction.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return NodeUtil.isFunctionExpression(n;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2022-07-19 18:02:25.078739487 +0200\n+++ /tmp/tmp2wd0a3be.java\t2022-07-19 18:02:25.078739487 +0200\n@@ -112,11 +112,11 @@\n         reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n     return (root != null) ? root.removeFirstChild() : null;\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+return NodeUtil.isFunctionExpression(n;\n   }\n \n   /**\n    * Information needed to apply a reduction.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return NodeUtil.isFunctionExpressionNode(n;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2022-07-19 18:02:28.366723925 +0200\n+++ /tmp/tmpjyajx5ml.java\t2022-07-19 18:02:28.366723925 +0200\n@@ -112,11 +112,11 @@\n         reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n     return (root != null) ? root.removeFirstChild() : null;\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+return NodeUtil.isFunctionExpressionNode(n;\n   }\n \n   /**\n    * Information needed to apply a reduction.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return NodeUtil.isFunctionExpression(parent);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2022-07-19 18:02:31.638708429 +0200\n+++ /tmp/tmps1l8a6to.java\t2022-07-19 18:02:31.638708429 +0200\n@@ -112,11 +112,11 @@\n         reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n     return (root != null) ? root.removeFirstChild() : null;\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+return NodeUtil.isFunctionExpression(parent);\n   }\n \n   /**\n    * Information needed to apply a reduction.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return NodeUtil.isFunctionExpressionNode( n, n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2022-07-19 18:02:34.990692549 +0200\n+++ /tmp/tmpnut0imhj.java\t2022-07-19 18:02:34.990692549 +0200\n@@ -112,11 +112,11 @@\n         reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n     return (root != null) ? root.removeFirstChild() : null;\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+return NodeUtil.isFunctionExpressionNode( n, n);\n   }\n \n   /**\n    * Information needed to apply a reduction.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return NodeUtil.isFunctionExpression;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2022-07-19 18:02:38.454676132 +0200\n+++ /tmp/tmpamccler9.java\t2022-07-19 18:02:38.458676113 +0200\n@@ -112,11 +112,11 @@\n         reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n     return (root != null) ? root.removeFirstChild() : null;\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+return NodeUtil.isFunctionExpression;\n   }\n \n   /**\n    * Information needed to apply a reduction.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return NodeUtil.isFunctionExpression(n);",
        "fixed_line": "return NodeUtil.isFunctionExpression(n) && !NodeUtil.isGetOrSetKey(n.getParent());"
    },
    "Jsoup-19": {
        "fixes": [
            {
                "k": 1,
                "patch": "// try to resolve relative urls to abs, and optionally update }",
                "patch_diff": "// try to resolve relative urls to abs, and optionally update }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// try to resolve relative urls to abs, and optionally update",
                "patch_diff": "// try to resolve relative urls to abs, and optionally update",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// try to resolve relative urls to abs, and optionally update the attribute.",
                "patch_diff": "// try to resolve relative urls to abs, and optionally update the attribute.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// try to resolve relative urls to abs, and optionally update the attribute so:",
                "patch_diff": "// try to resolve relative urls to abs, and optionally update the attribute so:",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// try to resolve relative urls to abs, and optionally update.",
                "patch_diff": "// try to resolve relative urls to abs, and optionally update.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// try to resolve relative urls to abs, not resolve relative urls to abs, and optionally update }",
                "patch_diff": "// try to resolve relative urls to abs, not resolve relative urls to abs, and optionally update }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// try to resolve relative urls to abs, and optionally update the attribute (attr.",
                "patch_diff": "// try to resolve relative urls to abs, and optionally update the attribute (attr.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// try to resolve relative urls to abs, not resolve relative urls to abs, and optionally update",
                "patch_diff": "// try to resolve relative urls to abs, not resolve relative urls to abs, and optionally update",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// try to resolve relative urls to abs, and optionally update the attribute so it.",
                "patch_diff": "// try to resolve relative urls to abs, and optionally update the attribute so it.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// try to resolve relative urls to abs, not resolve relative urls to abs, and optionally update it.",
                "patch_diff": "// try to resolve relative urls to abs, not resolve relative urls to abs, and optionally update it.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (value.length() == 0) value = attr.getValue(); // if it could not be made abs, run as-is to allow custom unknown protocols"
    },
    "Math-3": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int len = 0; i < len; i++) { if (len == b.length) { throw new DimensionMismatchException(len + b.length; } }",
                "patch_diff": "for (int len = 0; i < len; i++) { if (len == b.length) { throw new DimensionMismatchException(len + b.length; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int len = 0; i < len; i++) { if (len == b.length) { throw new DimensionMismatchException(len, b.length); } }",
                "patch_diff": "for (int len = 0; i < len; i++) { if (len == b.length) { throw new DimensionMismatchException(len, b.length); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int len = 0; i < len; i++) { if (len == b.length) { throw new DimensionMismatchException(len + b.length); } }",
                "patch_diff": "for (int len = 0; i < len; i++) { if (len == b.length) { throw new DimensionMismatchException(len + b.length); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int len = 0; i < len; i++) { if (len > b.length) { throw new DimensionMismatchException(len + b.length; } }",
                "patch_diff": "for (int len = 0; i < len; i++) { if (len > b.length) { throw new DimensionMismatchException(len + b.length; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int len = 1; i < len; i++) { if (len > b.length) { throw new DimensionMismatchException(len + b.length; } }",
                "patch_diff": "for (int len = 1; i < len; i++) { if (len > b.length) { throw new DimensionMismatchException(len + b.length; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int len = 0; i < len; i++) { if (len > b.length) { throw new DimensionMismatchException(len, b.length); } }",
                "patch_diff": "for (int len = 0; i < len; i++) { if (len > b.length) { throw new DimensionMismatchException(len, b.length); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int len = 1; i < len; i++) { if (len == b.length) { throw new DimensionMismatchException(len + b.length; } }",
                "patch_diff": "for (int len = 1; i < len; i++) { if (len == b.length) { throw new DimensionMismatchException(len + b.length; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int len = 0; i < len; i++) { if (len > b.length) { throw new DimensionMismatchException(len + b.length); } }",
                "patch_diff": "for (int len = 0; i < len; i++) { if (len > b.length) { throw new DimensionMismatchException(len + b.length); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int len = 1; i < len; ++i) { if (len > b.length) { throw new DimensionMismatchException(len + b.length; } }",
                "patch_diff": "for (int len = 1; i < len; ++i) { if (len > b.length) { throw new DimensionMismatchException(len + b.length; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int len = 1; i < len; ++i) { if (len > b.length) { throw new DimensionMismatchException(len + b.length); } }",
                "patch_diff": "for (int len = 1; i < len; ++i) { if (len > b.length) { throw new DimensionMismatchException(len + b.length); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (len == 1) { // Revert to scalar multiplication. return a[0] * b[0]; }"
    },
    "JacksonDatabind-41": {
        "fixes": [
            {
                "k": 1,
                "patch": "return constructType; type, constructType = objType.deprecated Since 2.7(type, contextClass, _fromType, _fromType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-41/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 18:02:45.722641664 +0200\n+++ /tmp/tmp0rmwduma.java\t2022-07-19 18:02:45.894640854 +0200\n@@ -597,19 +597,11 @@\n     /**\n      * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n      */\n     @Deprecated\n     public JavaType constructType(Type type, Class<?> contextClass) {\n-        return constructType(type, constructType(contextClass));\n-    }\n-\n-    /**\n-     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n-     */\n-    @Deprecated\n-    public JavaType constructType(Type type, JavaType contextType) {\n-        return _fromAny(null, type, contextType.getBindings());\n+return constructType; type, constructType = objType.deprecated Since 2.7(type, contextClass, _fromType, _fromType);\n     }\n \n     /*\n     /**********************************************************\n     /* Direct factory methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return constructType; type, constructType = objType.deprecated Since 2.7(type, contextClass, _fromType, _fromType, _fromType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-41/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 18:02:47.734632117 +0200\n+++ /tmp/tmpdch1s3vd.java\t2022-07-19 18:02:47.734632117 +0200\n@@ -597,19 +597,11 @@\n     /**\n      * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n      */\n     @Deprecated\n     public JavaType constructType(Type type, Class<?> contextClass) {\n-        return constructType(type, constructType(contextClass));\n-    }\n-\n-    /**\n-     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n-     */\n-    @Deprecated\n-    public JavaType constructType(Type type, JavaType contextType) {\n-        return _fromAny(null, type, contextType.getBindings());\n+return constructType; type, constructType = objType.deprecated Since 2.7(type, contextClass, _fromType, _fromType, _fromType);\n     }\n \n     /*\n     /**********************************************************\n     /* Direct factory methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return constructType; type, constructType = objType.deprecated Since 2.7(type, contextClass, _fromType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-41/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 18:02:49.318624603 +0200\n+++ /tmp/tmpebvnrj7p.java\t2022-07-19 18:02:49.318624603 +0200\n@@ -597,19 +597,11 @@\n     /**\n      * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n      */\n     @Deprecated\n     public JavaType constructType(Type type, Class<?> contextClass) {\n-        return constructType(type, constructType(contextClass));\n-    }\n-\n-    /**\n-     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n-     */\n-    @Deprecated\n-    public JavaType constructType(Type type, JavaType contextType) {\n-        return _fromAny(null, type, contextType.getBindings());\n+return constructType; type, constructType = objType.deprecated Since 2.7(type, contextClass, _fromType);\n     }\n \n     /*\n     /**********************************************************\n     /* Direct factory methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return constructType; type, constructType = objType.deprecated Since 2.7(type, contextClass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-41/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 18:02:50.854617312 +0200\n+++ /tmp/tmpy5o_oc8k.java\t2022-07-19 18:02:50.854617312 +0200\n@@ -597,19 +597,11 @@\n     /**\n      * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n      */\n     @Deprecated\n     public JavaType constructType(Type type, Class<?> contextClass) {\n-        return constructType(type, constructType(contextClass));\n-    }\n-\n-    /**\n-     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n-     */\n-    @Deprecated\n-    public JavaType constructType(Type type, JavaType contextType) {\n-        return _fromAny(null, type, contextType.getBindings());\n+return constructType; type, constructType = objType.deprecated Since 2.7(type, contextClass) {\n     }\n \n     /*\n     /**********************************************************\n     /* Direct factory methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return constructType; type, constructType = objType.deprecated Since 2.7(type, contextClass;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-41/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 18:02:52.362610153 +0200\n+++ /tmp/tmpaze8l6vy.java\t2022-07-19 18:02:52.362610153 +0200\n@@ -597,19 +597,11 @@\n     /**\n      * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n      */\n     @Deprecated\n     public JavaType constructType(Type type, Class<?> contextClass) {\n-        return constructType(type, constructType(contextClass));\n-    }\n-\n-    /**\n-     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n-     */\n-    @Deprecated\n-    public JavaType constructType(Type type, JavaType contextType) {\n-        return _fromAny(null, type, contextType.getBindings());\n+return constructType; type, constructType = objType.deprecated Since 2.7(type, contextClass;\n     }\n \n     /*\n     /**********************************************************\n     /* Direct factory methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return constructType; type, constructType = objType.deprecated Since 2.7(type, contextClass);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-41/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 18:02:53.930602708 +0200\n+++ /tmp/tmpn23lbcpd.java\t2022-07-19 18:02:53.930602708 +0200\n@@ -597,19 +597,11 @@\n     /**\n      * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n      */\n     @Deprecated\n     public JavaType constructType(Type type, Class<?> contextClass) {\n-        return constructType(type, constructType(contextClass));\n-    }\n-\n-    /**\n-     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n-     */\n-    @Deprecated\n-    public JavaType constructType(Type type, JavaType contextType) {\n-        return _fromAny(null, type, contextType.getBindings());\n+return constructType; type, constructType = objType.deprecated Since 2.7(type, contextClass);\n     }\n \n     /*\n     /**********************************************************\n     /* Direct factory methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return constructType(contextClass, constructType; type!= type, contextClass, _fromType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-41/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 18:02:55.434595566 +0200\n+++ /tmp/tmpnqizv45h.java\t2022-07-19 18:02:55.434595566 +0200\n@@ -597,19 +597,11 @@\n     /**\n      * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n      */\n     @Deprecated\n     public JavaType constructType(Type type, Class<?> contextClass) {\n-        return constructType(type, constructType(contextClass));\n-    }\n-\n-    /**\n-     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n-     */\n-    @Deprecated\n-    public JavaType constructType(Type type, JavaType contextType) {\n-        return _fromAny(null, type, contextType.getBindings());\n+return constructType(contextClass, constructType; type!= type, contextClass, _fromType);\n     }\n \n     /*\n     /**********************************************************\n     /* Direct factory methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return constructType; type, constructType = objType.deprecated Since 2.7(type, contextClass, _fromType, _fromType, _fromType, _fromType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-41/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 18:02:57.046587908 +0200\n+++ /tmp/tmp1z0prwnl.java\t2022-07-19 18:02:57.046587908 +0200\n@@ -597,19 +597,11 @@\n     /**\n      * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n      */\n     @Deprecated\n     public JavaType constructType(Type type, Class<?> contextClass) {\n-        return constructType(type, constructType(contextClass));\n-    }\n-\n-    /**\n-     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n-     */\n-    @Deprecated\n-    public JavaType constructType(Type type, JavaType contextType) {\n-        return _fromAny(null, type, contextType.getBindings());\n+return constructType; type, constructType = objType.deprecated Since 2.7(type, contextClass, _fromType, _fromType, _fromType, _fromType);\n     }\n \n     /*\n     /**********************************************************\n     /* Direct factory methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return constructType(contextClass, constructType = objType.deprecated Since 2.7(type, contextClass, _fromType, _fromType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-41/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 18:02:58.602580514 +0200\n+++ /tmp/tmpmaezvjbd.java\t2022-07-19 18:02:58.602580514 +0200\n@@ -597,19 +597,11 @@\n     /**\n      * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n      */\n     @Deprecated\n     public JavaType constructType(Type type, Class<?> contextClass) {\n-        return constructType(type, constructType(contextClass));\n-    }\n-\n-    /**\n-     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n-     */\n-    @Deprecated\n-    public JavaType constructType(Type type, JavaType contextType) {\n-        return _fromAny(null, type, contextType.getBindings());\n+return constructType(contextClass, constructType = objType.deprecated Since 2.7(type, contextClass, _fromType, _fromType);\n     }\n \n     /*\n     /**********************************************************\n     /* Direct factory methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return constructType(contextClass, constructType; type!= type, contextClass;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-41/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 18:03:00.154573143 +0200\n+++ /tmp/tmpeph6rgh8.java\t2022-07-19 18:03:00.154573143 +0200\n@@ -597,19 +597,11 @@\n     /**\n      * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n      */\n     @Deprecated\n     public JavaType constructType(Type type, Class<?> contextClass) {\n-        return constructType(type, constructType(contextClass));\n-    }\n-\n-    /**\n-     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n-     */\n-    @Deprecated\n-    public JavaType constructType(Type type, JavaType contextType) {\n-        return _fromAny(null, type, contextType.getBindings());\n+return constructType(contextClass, constructType; type!= type, contextClass;\n     }\n \n     /*\n     /**********************************************************\n     /* Direct factory methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return constructType(type, constructType(contextClass)); } /** * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1) */ @Deprecated public JavaType constructType(Type type, JavaType contextType) { return _fromAny(null, type, contextType.getBindings());",
        "fixed_line": "TypeBindings bindings = (contextClass == null) ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings(); return _fromAny(null, type, bindings); } /** * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1) */ @Deprecated public JavaType constructType(Type type, JavaType contextType) { TypeBindings bindings = (contextType == null) ? TypeBindings.emptyBindings() : contextType.getBindings(); return _fromAny(null, type, bindings);"
    },
    "Closure-57": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (target!= null && target.getFirstChild) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-57/src/com/google/javascript/jscomp/ClosureCodingConvention.java\t2022-07-19 18:03:01.802565311 +0200\n+++ /tmp/tmptrrw6voc.java\t2022-07-19 18:03:01.822565216 +0200\n@@ -192,11 +192,11 @@\n       Node callee = node.getFirstChild();\n       if (callee != null && callee.getType() == Token.GETPROP) {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+if (target!= null && target.getFirstChild) {\n             className = target.getString();\n           }\n         }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (target == null && target.get(qualifiedName) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-57/src/com/google/javascript/jscomp/ClosureCodingConvention.java\t2022-07-19 18:03:07.126539999 +0200\n+++ /tmp/tmpjwnlgn33.java\t2022-07-19 18:03:07.126539999 +0200\n@@ -192,11 +192,11 @@\n       Node callee = node.getFirstChild();\n       if (callee != null && callee.getType() == Token.GETPROP) {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+if (target == null && target.get(qualifiedName) {\n             className = target.getString();\n           }\n         }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (target!= null && target.get(qualifiedName) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-57/src/com/google/javascript/jscomp/ClosureCodingConvention.java\t2022-07-19 18:03:10.526523830 +0200\n+++ /tmp/tmp6_2ht6nh.java\t2022-07-19 18:03:10.526523830 +0200\n@@ -192,11 +192,11 @@\n       Node callee = node.getFirstChild();\n       if (callee != null && callee.getType() == Token.GETPROP) {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+if (target!= null && target.get(qualifiedName) {\n             className = target.getString();\n           }\n         }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (target!= null && target.equals(qualifiedName)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-57/src/com/google/javascript/jscomp/ClosureCodingConvention.java\t2022-07-19 18:03:13.962507482 +0200\n+++ /tmp/tmpra50ne7y.java\t2022-07-19 18:03:13.962507482 +0200\n@@ -192,11 +192,11 @@\n       Node callee = node.getFirstChild();\n       if (callee != null && callee.getType() == Token.GETPROP) {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+if (target!= null && target.equals(qualifiedName)) {\n             className = target.getString();\n           }\n         }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (target == null && target.equals(qualifiedName) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-57/src/com/google/javascript/jscomp/ClosureCodingConvention.java\t2022-07-19 18:03:52.978321440 +0200\n+++ /tmp/tmpe05danz7.java\t2022-07-19 18:03:52.978321440 +0200\n@@ -192,11 +192,11 @@\n       Node callee = node.getFirstChild();\n       if (callee != null && callee.getType() == Token.GETPROP) {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+if (target == null && target.equals(qualifiedName) {\n             className = target.getString();\n           }\n         }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (target!= null && target.getString) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-57/src/com/google/javascript/jscomp/ClosureCodingConvention.java\t2022-07-19 18:03:56.414305021 +0200\n+++ /tmp/tmpbf30gezx.java\t2022-07-19 18:03:56.414305021 +0200\n@@ -192,11 +192,11 @@\n       Node callee = node.getFirstChild();\n       if (callee != null && callee.getType() == Token.GETPROP) {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+if (target!= null && target.getString) {\n             className = target.getString();\n           }\n         }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (target!= null && target.equals(qualifiedName) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-57/src/com/google/javascript/jscomp/ClosureCodingConvention.java\t2022-07-19 18:03:59.946288137 +0200\n+++ /tmp/tmptawet2u9.java\t2022-07-19 18:03:59.946288137 +0200\n@@ -192,11 +192,11 @@\n       Node callee = node.getFirstChild();\n       if (callee != null && callee.getType() == Token.GETPROP) {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+if (target!= null && target.equals(qualifiedName) {\n             className = target.getString();\n           }\n         }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (target!= null && names.target) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-57/src/com/google/javascript/jscomp/ClosureCodingConvention.java\t2022-07-19 18:04:03.214272510 +0200\n+++ /tmp/tmpu26dr_js.java\t2022-07-19 18:04:03.214272510 +0200\n@@ -192,11 +192,11 @@\n       Node callee = node.getFirstChild();\n       if (callee != null && callee.getType() == Token.GETPROP) {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+if (target!= null && names.target) {\n             className = target.getString();\n           }\n         }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (target == null && target.equals(qualifiedName)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-57/src/com/google/javascript/jscomp/ClosureCodingConvention.java\t2022-07-19 18:04:06.766255518 +0200\n+++ /tmp/tmp5obf5d_j.java\t2022-07-19 18:04:06.766255518 +0200\n@@ -192,11 +192,11 @@\n       Node callee = node.getFirstChild();\n       if (callee != null && callee.getType() == Token.GETPROP) {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+if (target == null && target.equals(qualifiedName)) {\n             className = target.getString();\n           }\n         }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (target!= null && tail.target) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-57/src/com/google/javascript/jscomp/ClosureCodingConvention.java\t2022-07-19 18:04:43.246080703 +0200\n+++ /tmp/tmp999pkiwg.java\t2022-07-19 18:04:43.246080703 +0200\n@@ -192,11 +192,11 @@\n       Node callee = node.getFirstChild();\n       if (callee != null && callee.getType() == Token.GETPROP) {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+if (target!= null && tail.target) {\n             className = target.getString();\n           }\n         }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (target != null) {",
        "fixed_line": "if (target != null && target.getType() == Token.STRING) {"
    },
    "Closure-125": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (docType!= null && fnType!=fnType) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-125/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 18:04:47.110062153 +0200\n+++ /tmp/tmpe80z9ocl.java\t2022-07-19 18:04:47.138062017 +0200\n@@ -1656,11 +1656,11 @@\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+if (docType!= null && fnType!=fnType) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n         ensureTyped(t, n);\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if ( fnType!= null && fnType!=fnType) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-125/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 18:04:52.110038139 +0200\n+++ /tmp/tmpnz_8a5nz.java\t2022-07-19 18:04:52.110038139 +0200\n@@ -1656,11 +1656,11 @@\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+if ( fnType!= null && fnType!=fnType) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n         ensureTyped(t, n);\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (unmodifiableType!= null && fnType!=fnType) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-125/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 18:05:43.437791041 +0200\n+++ /tmp/tmpf_anwoi2.java\t2022-07-19 18:05:43.437791041 +0200\n@@ -1656,11 +1656,11 @@\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+if (unmodifiableType!= null && fnType!=fnType) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n         ensureTyped(t, n);\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (fnType!= null && fnType!=fnType) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-125/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 18:05:47.125773248 +0200\n+++ /tmp/tmpzclj50vd.java\t2022-07-19 18:05:47.125773248 +0200\n@@ -1656,11 +1656,11 @@\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+if (fnType!= null && fnType!=fnType) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n         ensureTyped(t, n);\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (unmodifiableType!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-125/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 18:06:35.481539485 +0200\n+++ /tmp/tmpcr8qgt_3.java\t2022-07-19 18:06:35.485539465 +0200\n@@ -1656,11 +1656,11 @@\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+if (unmodifiableType!= null) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n         ensureTyped(t, n);\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (docType!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-125/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 18:06:39.197521487 +0200\n+++ /tmp/tmp4rn_fx5l.java\t2022-07-19 18:06:39.197521487 +0200\n@@ -1656,11 +1656,11 @@\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+if (docType!= null) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n         ensureTyped(t, n);\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if ( fnType!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-125/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 18:06:42.801504027 +0200\n+++ /tmp/tmp0tfgn83m.java\t2022-07-19 18:06:42.801504027 +0200\n@@ -1656,11 +1656,11 @@\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+if ( fnType!= null) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n         ensureTyped(t, n);\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (inType!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-125/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 18:07:31.145269412 +0200\n+++ /tmp/tmpassgsqf8.java\t2022-07-19 18:07:31.145269412 +0200\n@@ -1656,11 +1656,11 @@\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+if (inType!= null) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n         ensureTyped(t, n);\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (functionType!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-125/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 18:07:34.729251989 +0200\n+++ /tmp/tmp6u_7179k.java\t2022-07-19 18:07:34.729251989 +0200\n@@ -1656,11 +1656,11 @@\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+if (functionType!= null) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n         ensureTyped(t, n);\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (fnType!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-125/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 18:07:38.261234817 +0200\n+++ /tmp/tmpy5esh_zs.java\t2022-07-19 18:07:38.265234797 +0200\n@@ -1656,11 +1656,11 @@\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+if (fnType!= null) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n         ensureTyped(t, n);\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (fnType != null) {",
        "fixed_line": "if (fnType != null && fnType.hasInstanceType()) {"
    },
    "Lang-48": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if (lhs.getClass()!= rhs.getClass()) {",
                "patch_diff": "// if (lhs.getClass()!= rhs.getClass()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// if (lhsClass.isArray()) {",
                "patch_diff": "// if (lhsClass.isArray()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if (lhs.getClass()!= rhs.getClass) {",
                "patch_diff": "// if (lhs.getClass()!= rhs.getClass) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// if (lhsClass == rhs.getClass() || this.setEquals;",
                "patch_diff": "// if (lhsClass == rhs.getClass() || this.setEquals;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// if (lhs.getClass()!= this.setEquals;",
                "patch_diff": "// if (lhs.getClass()!= this.setEquals;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if (lhs.getClass()!= rhs.length) {",
                "patch_diff": "// if (lhs.getClass()!= rhs.length) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// if (lhsClass == rhs.getClass()) {",
                "patch_diff": "// if (lhsClass == rhs.getClass()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// if (lhs.getClass()!= this.setEquals) {",
                "patch_diff": "// if (lhs.getClass()!= this.setEquals) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// if (lhs, rhs.getClass()!= this.setEquals;",
                "patch_diff": "// if (lhs, rhs.getClass()!= this.setEquals;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if (lhsClass == rhs.getClass) {",
                "patch_diff": "// if (lhsClass == rhs.getClass) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (lhs instanceof java.math.BigDecimal) { isEquals = (((java.math.BigDecimal)lhs).compareTo(rhs) == 0); } else { // The simple case, not an array, just test the element isEquals = lhs.equals(rhs); }"
    },
    "Math-41": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int i = 0; i < paddingWts.length; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-41/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\t2022-07-19 18:08:28.464990320 +0200\n+++ /tmp/tmp653w_4ea.java\t2022-07-19 18:08:28.488990204 +0200\n@@ -515,11 +515,11 @@\n                     accum += weights[i] * (dev * dev);\n                     accum2 += weights[i] * dev;\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+for (int i = 0; i < paddingWts.length; i++) {\n                     sumWts += weights[i];\n                 }\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = 0; i < accum.length; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-41/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\t2022-07-19 18:08:30.912978382 +0200\n+++ /tmp/tmpgn7vxdde.java\t2022-07-19 18:08:30.912978382 +0200\n@@ -515,11 +515,11 @@\n                     accum += weights[i] * (dev * dev);\n                     accum2 += weights[i] * dev;\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+for (int i = 0; i < accum.length; i++) {\n                     sumWts += weights[i];\n                 }\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0; i < accumWts.length; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-41/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\t2022-07-19 18:08:33.028968060 +0200\n+++ /tmp/tmpif4xlccl.java\t2022-07-19 18:08:33.028968060 +0200\n@@ -515,11 +515,11 @@\n                     accum += weights[i] * (dev * dev);\n                     accum2 += weights[i] * dev;\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+for (int i = 0; i < accumWts.length; i++) {\n                     sumWts += weights[i];\n                 }\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = 0; i < paddingWts; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-41/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\t2022-07-19 18:08:35.096957971 +0200\n+++ /tmp/tmpussslkwd.java\t2022-07-19 18:08:35.096957971 +0200\n@@ -515,11 +515,11 @@\n                     accum += weights[i] * (dev * dev);\n                     accum2 += weights[i] * dev;\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+for (int i = 0; i < paddingWts; i++) {\n                     sumWts += weights[i];\n                 }\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = 0; i < totalAnchor.length; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-41/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\t2022-07-19 18:08:37.160947899 +0200\n+++ /tmp/tmpqrbey0v4.java\t2022-07-19 18:08:37.164947880 +0200\n@@ -515,11 +515,11 @@\n                     accum += weights[i] * (dev * dev);\n                     accum2 += weights[i] * dev;\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+for (int i = 0; i < totalAnchor.length; i++) {\n                     sumWts += weights[i];\n                 }\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = 0; i <Prefix.length; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-41/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\t2022-07-19 18:08:39.276937574 +0200\n+++ /tmp/tmpe_401ae1.java\t2022-07-19 18:08:39.280937555 +0200\n@@ -515,11 +515,11 @@\n                     accum += weights[i] * (dev * dev);\n                     accum2 += weights[i] * dev;\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+for (int i = 0; i <Prefix.length; i++) {\n                     sumWts += weights[i];\n                 }\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = 0; i < name.length; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-41/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\t2022-07-19 18:08:41.336927520 +0200\n+++ /tmp/tmpby9h8mbl.java\t2022-07-19 18:08:41.336927520 +0200\n@@ -515,11 +515,11 @@\n                     accum += weights[i] * (dev * dev);\n                     accum2 += weights[i] * dev;\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+for (int i = 0; i < name.length; i++) {\n                     sumWts += weights[i];\n                 }\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = 0; i < lhsWts; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-41/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\t2022-07-19 18:08:43.368917602 +0200\n+++ /tmp/tmps7vaacgw.java\t2022-07-19 18:08:43.372917583 +0200\n@@ -515,11 +515,11 @@\n                     accum += weights[i] * (dev * dev);\n                     accum2 += weights[i] * dev;\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+for (int i = 0; i < lhsWts; i++) {\n                     sumWts += weights[i];\n                 }\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int i = 0; i < accumWts; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-41/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\t2022-07-19 18:08:45.444907469 +0200\n+++ /tmp/tmpd2m5ui34.java\t2022-07-19 18:08:45.448907450 +0200\n@@ -515,11 +515,11 @@\n                     accum += weights[i] * (dev * dev);\n                     accum2 += weights[i] * dev;\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+for (int i = 0; i < accumWts; i++) {\n                     sumWts += weights[i];\n                 }\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = 0; i < weights.length; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-41/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\t2022-07-19 18:08:47.480897530 +0200\n+++ /tmp/tmp24omnveo.java\t2022-07-19 18:08:47.480897530 +0200\n@@ -515,11 +515,11 @@\n                     accum += weights[i] * (dev * dev);\n                     accum2 += weights[i] * dev;\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+for (int i = 0; i < weights.length; i++) {\n                     sumWts += weights[i];\n                 }\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "for (int i = 0; i < weights.length; i++) {",
        "fixed_line": "for (int i = begin; i < begin + length; i++) {"
    },
    "Closure-118": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) {",
                "patch_diff": "for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) { String name = child.getString(); if (child.getType() == Token.NAME) { child = child.getString(); } } }",
                "patch_diff": "for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) { String name = child.getString(); if (child.getType() == Token.NAME) { child = child.getString(); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) { String name = child.getString(); if (child.getType() == Token.STRING) { child = child.getString(); } } }",
                "patch_diff": "for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) { String name = child.getString(); if (child.getType() == Token.STRING) { child = child.getString(); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (Node child = n.getFirstChild(); child!= null; child = child.getString; child = child.getNext()) {",
                "patch_diff": "for (Node child = n.getFirstChild(); child!= null; child = child.getString; child = child.getNext()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) { if (child.getType() == Token.NAME) { child = child.getString(); } } }",
                "patch_diff": "for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) { if (child.getType() == Token.NAME) { child = child.getString(); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) { if (child.getType() == Token.STRING) { child = child.getString(); } } }",
                "patch_diff": "for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) { if (child.getType() == Token.STRING) { child = child.getString(); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) { if (child.getType() == Token.NAME) { Node child = child.getString(); if (child.getType() == Token.STRING) { child = child.getString(); } } }",
                "patch_diff": "for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) { if (child.getType() == Token.NAME) { Node child = child.getString(); if (child.getType() == Token.STRING) { child = child.getString(); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) { String name = child.getString(); if (child.getType() == Token.NAME) { String name = child.getString(); if (child.getString() == null) { child = child.getString(); } } }",
                "patch_diff": "for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) { String name = child.getString(); if (child.getType() == Token.NAME) { String name = child.getString(); if (child.getString() == null) { child = child.getString(); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) { String name = child.getString(); if (child.getType() == Token.NAME) { String name = child.getString(); if (child.getString()!= null) { child = child.getString(); } } }",
                "patch_diff": "for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) { String name = child.getString(); if (child.getType() == Token.NAME) { String name = child.getString(); if (child.getString()!= null) { child = child.getString(); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) { String name = child.getString(); if (child.getType() == Token.NAME) { String name = child.getString(); if (child.getType() == Token.STRING) { child = child.getString(); } } }",
                "patch_diff": "for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) { String name = child.getString(); if (child.getType() == Token.NAME) { String name = child.getString(); if (child.getType() == Token.STRING) { child = child.getString(); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (child.isQuotedString()) { continue; }"
    },
    "Jsoup-35": {
        "fixes": [
            {
                "k": 1,
                "patch": "// for (int i = 0; i < childNodes.length; i++) {",
                "patch_diff": "// for (int i = 0; i < childNodes.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// can't really modify it was non-literal characters that might be valid (empty be valid)",
                "patch_diff": "// can't really modify it was non-literal characters that might be valid (empty be valid)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// for (int i = 0; i < childNodes.length; i++) { if (furthestBlock.appendChild(firstNode.getBaseUri()); } }",
                "patch_diff": "// for (int i = 0; i < childNodes.length; i++) { if (furthestBlock.appendChild(firstNode.getBaseUri()); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// // can't really modify it was non-literal characters that might be valid (empty be valid)",
                "patch_diff": "// // can't really modify it was non-literal characters that might be valid (empty be valid)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// can't really modify it was non-empty's do implicit re-parse",
                "patch_diff": "// can't really modify it was non-empty's do implicit re-parse",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// can't really modify it was non-literal characters that might be valid (eurthestBlock.",
                "patch_diff": "// can't really modify it was non-literal characters that might be valid (eurthestBlock.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// // can't really modify it was non-literal characters that might be valid (eurthestBlock.",
                "patch_diff": "// // can't really modify it was non-literal characters that might be valid (eurthestBlock.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "patch_diff": "// can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// for (int i = 0; i < childNodes.length; i++) { if (furthestBlock.appendChild(new Node(lastNode.getFirstChild())); } }",
                "patch_diff": "// for (int i = 0; i < childNodes.length; i++) { if (furthestBlock.appendChild(new Node(lastNode.getFirstChild())); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// for (int i = 0; i < childNodes.length; i++) { if (furthestBlock.getType() == Token.NAME) {",
                "patch_diff": "// for (int i = 0; i < childNodes.length; i++) { if (furthestBlock.getType() == Token.NAME) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "adopter.attributes().addAll(formatEl.attributes());"
    },
    "Mockito-33": {
        "fixes": [
            {
                "k": 1,
                "patch": "return m1.equals(m2.equals(m2.equals(m1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-33/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 18:09:09.400790450 +0200\n+++ /tmp/tmppb4ovdlq.java\t2022-07-19 18:09:09.428790308 +0200\n@@ -94,11 +94,11 @@\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n         \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+return m1.equals(m2.equals(m2.equals(m1);\n     }\n     \n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return m1.equals(m2.equals(m2.equals(m2);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-33/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 18:09:13.068772519 +0200\n+++ /tmp/tmpg17xmsty.java\t2022-07-19 18:09:13.068772519 +0200\n@@ -94,11 +94,11 @@\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n         \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+return m1.equals(m2.equals(m2.equals(m2);\n     }\n     \n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return m1.equals(m2.equals(m1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-33/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 18:09:14.752764286 +0200\n+++ /tmp/tmpr4ret1n1.java\t2022-07-19 18:09:14.752764286 +0200\n@@ -94,11 +94,11 @@\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n         \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+return m1.equals(m2.equals(m1);\n     }\n     \n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return m1.equals(m2.equals(m3.equals(m1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-33/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 18:09:16.552755484 +0200\n+++ /tmp/tmplubxg021.java\t2022-07-19 18:09:16.552755484 +0200\n@@ -94,11 +94,11 @@\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n         \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+return m1.equals(m2.equals(m3.equals(m1);\n     }\n     \n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return m1.equals(m2.equals(m2.equals(m2.equals(m1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-33/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 18:09:18.408746410 +0200\n+++ /tmp/tmpbgoiakkf.java\t2022-07-19 18:09:18.408746410 +0200\n@@ -94,11 +94,11 @@\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n         \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+return m1.equals(m2.equals(m2.equals(m2.equals(m1);\n     }\n     \n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return m1.equals(m2.equals(m2.equals(m3.equals(m1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-33/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 18:09:20.220737548 +0200\n+++ /tmp/tmpqdy5svkm.java\t2022-07-19 18:09:20.220737548 +0200\n@@ -94,11 +94,11 @@\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n         \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+return m1.equals(m2.equals(m2.equals(m3.equals(m1);\n     }\n     \n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return m1.equals(m2.equals(m1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-33/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 18:09:21.976728960 +0200\n+++ /tmp/tmp7xgmyc8o.java\t2022-07-19 18:09:21.976728960 +0200\n@@ -94,11 +94,11 @@\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n         \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+return m1.equals(m2.equals(m1));\n     }\n     \n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return m1.equals(m2.equals(m2);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-33/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 18:09:41.176635010 +0200\n+++ /tmp/tmp7k1u74td.java\t2022-07-19 18:09:41.184634972 +0200\n@@ -94,11 +94,11 @@\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n         \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+return m1.equals(m2.equals(m2);\n     }\n     \n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return m2.equals(m1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-33/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 18:09:42.964626256 +0200\n+++ /tmp/tmp55v9re8o.java\t2022-07-19 18:09:42.968626237 +0200\n@@ -94,11 +94,11 @@\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n         \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+return m2.equals(m1);\n     }\n     \n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return m1.equals(m2.equals(m2.equals(m1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-33/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 18:10:01.672534620 +0200\n+++ /tmp/tmp07gl2c5n.java\t2022-07-19 18:10:01.684534562 +0200\n@@ -94,11 +94,11 @@\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n         \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+return m1.equals(m2.equals(m2.equals(m1));\n     }\n     \n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return m1.equals(m2);",
        "fixed_line": "if (m1.getName() != null && m1.getName().equals(m2.getName())) { /* Avoid unnecessary cloning */ Class[] params1 = m1.getParameterTypes(); Class[] params2 = m2.getParameterTypes(); if (params1.length == params2.length) { for (int i = 0; i < params1.length; i++) { if (params1[i] != params2[i]) return false; } return true; } } return false;"
    },
    "Jsoup-6": {
        "fixes": [
            {
                "k": 1,
                "patch": "m.appendReplacement(accum, c.appendReplacementAttribute).util.group(0.0, m.group(0));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-6/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 18:10:03.740524486 +0200\n+++ /tmp/tmpteqfqh26.java\t2022-07-19 18:10:03.800524192 +0200\n@@ -65,13 +65,11 @@\n                     charval = full.get(name);\n             }\n \n             if (charval != -1 || charval > 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, c);\n-            } else {\n-                m.appendReplacement(accum, m.group(0));\n+m.appendReplacement(accum, c.appendReplacementAttribute).util.group(0.0, m.group(0));\n             }\n         }\n         m.appendTail(accum);\n         return accum.toString();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "m.appendReplacement(accum, c.appendReplacement raw, m.group(0));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-6/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 18:10:05.688514940 +0200\n+++ /tmp/tmpt2asvjnw.java\t2022-07-19 18:10:05.688514940 +0200\n@@ -65,13 +65,11 @@\n                     charval = full.get(name);\n             }\n \n             if (charval != -1 || charval > 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, c);\n-            } else {\n-                m.appendReplacement(accum, m.group(0));\n+m.appendReplacement(accum, c.appendReplacement raw, m.group(0));\n             }\n         }\n         m.appendTail(accum);\n         return accum.toString();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "m.appendReplacement(accum, c, d.appendReplacement, m.group(0));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-6/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 18:10:07.272507176 +0200\n+++ /tmp/tmpg2vw2wgc.java\t2022-07-19 18:10:07.272507176 +0200\n@@ -65,13 +65,11 @@\n                     charval = full.get(name);\n             }\n \n             if (charval != -1 || charval > 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, c);\n-            } else {\n-                m.appendReplacement(accum, m.group(0));\n+m.appendReplacement(accum, c, d.appendReplacement, m.group(0));\n             }\n         }\n         m.appendTail(accum);\n         return accum.toString();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "m.appendReplacement(accum, c.appendReplacement constraint, m.group(0));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-6/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 18:10:08.868499354 +0200\n+++ /tmp/tmpswl42jhv.java\t2022-07-19 18:10:08.872499332 +0200\n@@ -65,13 +65,11 @@\n                     charval = full.get(name);\n             }\n \n             if (charval != -1 || charval > 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, c);\n-            } else {\n-                m.appendReplacement(accum, m.group(0));\n+m.appendReplacement(accum, c.appendReplacement constraint, m.group(0));\n             }\n         }\n         m.appendTail(accum);\n         return accum.toString();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "m.appendReplacement(accum, c); } else if (c.appendReplacementf) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-6/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 18:10:10.476491469 +0200\n+++ /tmp/tmphd6clq1b.java\t2022-07-19 18:10:10.480491450 +0200\n@@ -65,13 +65,11 @@\n                     charval = full.get(name);\n             }\n \n             if (charval != -1 || charval > 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, c);\n-            } else {\n-                m.appendReplacement(accum, m.group(0));\n+m.appendReplacement(accum, c); } else if (c.appendReplacementf) {\n             }\n         }\n         m.appendTail(accum);\n         return accum.toString();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "m.appendReplacement(accum, c.appendReplacement(c, m.group(0));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-6/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 18:10:12.172483157 +0200\n+++ /tmp/tmpx31dmjd9.java\t2022-07-19 18:10:12.172483157 +0200\n@@ -65,13 +65,11 @@\n                     charval = full.get(name);\n             }\n \n             if (charval != -1 || charval > 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, c);\n-            } else {\n-                m.appendReplacement(accum, m.group(0));\n+m.appendReplacement(accum, c.appendReplacement(c, m.group(0));\n             }\n         }\n         m.appendTail(accum);\n         return accum.toString();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "m.appendReplacement(accum, c.appendReplacementAttribute, m.group(0));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-6/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 18:10:13.716475586 +0200\n+++ /tmp/tmpfvb1s3hs.java\t2022-07-19 18:10:13.716475586 +0200\n@@ -65,13 +65,11 @@\n                     charval = full.get(name);\n             }\n \n             if (charval != -1 || charval > 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, c);\n-            } else {\n-                m.appendReplacement(accum, m.group(0));\n+m.appendReplacement(accum, c.appendReplacementAttribute, m.group(0));\n             }\n         }\n         m.appendTail(accum);\n         return accum.toString();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "m.appendReplacement(accum, c.appendReplacementAttribute, m.group(0.0, m.group(0));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-6/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 18:10:15.420467231 +0200\n+++ /tmp/tmp3v0zjexq.java\t2022-07-19 18:10:15.420467231 +0200\n@@ -65,13 +65,11 @@\n                     charval = full.get(name);\n             }\n \n             if (charval != -1 || charval > 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, c);\n-            } else {\n-                m.appendReplacement(accum, m.group(0));\n+m.appendReplacement(accum, c.appendReplacementAttribute, m.group(0.0, m.group(0));\n             }\n         }\n         m.appendTail(accum);\n         return accum.toString();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "m.appendReplacement(accum, c.appendReplacement {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-6/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 18:10:16.904459953 +0200\n+++ /tmp/tmpo3e5d_oy.java\t2022-07-19 18:10:16.908459934 +0200\n@@ -65,13 +65,11 @@\n                     charval = full.get(name);\n             }\n \n             if (charval != -1 || charval > 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, c);\n-            } else {\n-                m.appendReplacement(accum, m.group(0));\n+m.appendReplacement(accum, c.appendReplacement {\n             }\n         }\n         m.appendTail(accum);\n         return accum.toString();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "m.appendReplacement(accum, c).appendReplacement {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-6/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 18:10:18.472452265 +0200\n+++ /tmp/tmpq6lllcv4.java\t2022-07-19 18:10:18.476452246 +0200\n@@ -65,13 +65,11 @@\n                     charval = full.get(name);\n             }\n \n             if (charval != -1 || charval > 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, c);\n-            } else {\n-                m.appendReplacement(accum, m.group(0));\n+m.appendReplacement(accum, c).appendReplacement {\n             }\n         }\n         m.appendTail(accum);\n         return accum.toString();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "m.appendReplacement(accum, c); } else { m.appendReplacement(accum, m.group(0));",
        "fixed_line": "m.appendReplacement(accum, Matcher.quoteReplacement(c)); } else { m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); // replace with original string"
    },
    "Closure-66": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if (n.isObjectLitKey(t, n, STRING_TYPE);",
                "patch_diff": "// if (n.isObjectLitKey(t, n, STRING_TYPE);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// ObjectLitKey(t, n, STRING_TYPE);",
                "patch_diff": "// ObjectLitKey(t, n, STRING_TYPE);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if (n.isObjectLitKey(n, parent)) {",
                "patch_diff": "// if (n.isObjectLitKey(n, parent)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// if (n.isObjectLitKey(n, n, STRING_TYPE);",
                "patch_diff": "// if (n.isObjectLitKey(n, n, STRING_TYPE);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// if (n.isObjectLitKey(t, n, STRING_TYPE;",
                "patch_diff": "// if (n.isObjectLitKey(t, n, STRING_TYPE;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if (parent, n.getParent())) {",
                "patch_diff": "// if (parent, n.getParent())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// if (parent, n.getParent())) { ensureTyped(t, n, STRING_TYPE); }",
                "patch_diff": "// if (parent, n.getParent())) { ensureTyped(t, n, STRING_TYPE); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// if (n.isObjectLitKey(n, parent) {",
                "patch_diff": "// if (n.isObjectLitKey(n, parent) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// if (n.isObjectLitKey(n, parent) && n.getParent())) {",
                "patch_diff": "// if (n.isObjectLitKey(n, parent) && n.getParent())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if (n.isObjectLitKey(t, n, STRING_TYPE) {",
                "patch_diff": "// if (n.isObjectLitKey(t, n, STRING_TYPE) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "} else { // Object literal keys are not typeable typeable = false;"
    },
    "Math-96": {
        "fixes": [
            {
                "k": 1,
                "patch": "ret = (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-96/src/java/org/apache/commons/math/complex/Complex.java\t2022-07-19 18:10:22.144434252 +0200\n+++ /tmp/tmpquvo5js5.java\t2022-07-19 18:10:22.188434039 +0200\n@@ -253,11 +253,11 @@\n             try {\n                 Complex rhs = (Complex)other;\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+ret = (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits;\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "ret = (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-96/src/java/org/apache/commons/math/complex/Complex.java\t2022-07-19 18:10:24.472422836 +0200\n+++ /tmp/tmpxud277kh.java\t2022-07-19 18:10:24.472422836 +0200\n@@ -253,11 +253,11 @@\n             try {\n                 Complex rhs = (Complex)other;\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+ret = (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits);\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "ret = (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-96/src/java/org/apache/commons/math/complex/Complex.java\t2022-07-19 18:10:26.420413280 +0200\n+++ /tmp/tmp81u623yh.java\t2022-07-19 18:10:26.420413280 +0200\n@@ -253,11 +253,11 @@\n             try {\n                 Complex rhs = (Complex)other;\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+ret = (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits) {\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "ret = (Double.doubleToRawLongBits % Double.doubleToRawLongBits) == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-96/src/java/org/apache/commons/math/complex/Complex.java\t2022-07-19 18:10:28.348403820 +0200\n+++ /tmp/tmpcw5e8cnq.java\t2022-07-19 18:10:28.348403820 +0200\n@@ -253,11 +253,11 @@\n             try {\n                 Complex rhs = (Complex)other;\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+ret = (Double.doubleToRawLongBits % Double.doubleToRawLongBits) == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits);\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "ret = (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-96/src/java/org/apache/commons/math/complex/Complex.java\t2022-07-19 18:10:30.440393557 +0200\n+++ /tmp/tmprsbkmohl.java\t2022-07-19 18:10:30.452393498 +0200\n@@ -253,11 +253,11 @@\n             try {\n                 Complex rhs = (Complex)other;\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+ret = (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits);\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "ret = (Double.doubleToRawLongBits % Double.doubleToRawLongBits) == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-96/src/java/org/apache/commons/math/complex/Complex.java\t2022-07-19 18:10:32.452383685 +0200\n+++ /tmp/tmpor108p66.java\t2022-07-19 18:10:32.452383685 +0200\n@@ -253,11 +253,11 @@\n             try {\n                 Complex rhs = (Complex)other;\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+ret = (Double.doubleToRawLongBits % Double.doubleToRawLongBits) == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits;\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "ret = (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-96/src/java/org/apache/commons/math/complex/Complex.java\t2022-07-19 18:10:34.424374006 +0200\n+++ /tmp/tmpg5xwrveb.java\t2022-07-19 18:10:34.424374006 +0200\n@@ -253,11 +253,11 @@\n             try {\n                 Complex rhs = (Complex)other;\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+ret = (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits) {\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "ret = (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-96/src/java/org/apache/commons/math/complex/Complex.java\t2022-07-19 18:10:36.444364094 +0200\n+++ /tmp/tmpjxevce2r.java\t2022-07-19 18:10:36.444364094 +0200\n@@ -253,11 +253,11 @@\n             try {\n                 Complex rhs = (Complex)other;\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+ret = (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits;\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "ret = (Double.doubleToRawLongBits % Double.doubleToRawLongBits) == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-96/src/java/org/apache/commons/math/complex/Complex.java\t2022-07-19 18:10:38.424354375 +0200\n+++ /tmp/tmppr4s1541.java\t2022-07-19 18:10:38.424354375 +0200\n@@ -253,11 +253,11 @@\n             try {\n                 Complex rhs = (Complex)other;\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+ret = (Double.doubleToRawLongBits % Double.doubleToRawLongBits) == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits) {\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "ret = (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-96/src/java/org/apache/commons/math/complex/Complex.java\t2022-07-19 18:10:40.392344715 +0200\n+++ /tmp/tmpf5yhfmks.java\t2022-07-19 18:10:40.392344715 +0200\n@@ -253,11 +253,11 @@\n             try {\n                 Complex rhs = (Complex)other;\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+ret = (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits;\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));",
        "fixed_line": "ret = (real == rhs.real) && (imaginary == rhs.imaginary);"
    },
    "Closure-129": {
        "fixes": [
            {
                "k": 1,
                "patch": "// ignore }",
                "patch_diff": "// ignore }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// ignore cast out.putBooleanProp(Node.FREE_CALL, true);",
                "patch_diff": "// ignore cast out.putBooleanProp(Node.FREE_CALL, true);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// ignore cast out.putBooleanProp(Node.FREE_CALL, false);",
                "patch_diff": "// ignore cast out.putBooleanProp(Node.FREE_CALL, false);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// ignore cast out.putBooleanProp(Node.FREE_CALL, true); }",
                "patch_diff": "// ignore cast out.putBooleanProp(Node.FREE_CALL, true); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// ignore cast out.putBooleanProp(Node.FREE_CALL, false) {",
                "patch_diff": "// ignore cast out.putBooleanProp(Node.FREE_CALL, false) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// ignore cast out.putBooleanProp(Node.FREE_CALL, false); }",
                "patch_diff": "// ignore cast out.putBooleanProp(Node.FREE_CALL, false); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// ignore cast out.putBooleanProp(Node.FREE_CALL, true;",
                "patch_diff": "// ignore cast out.putBooleanProp(Node.FREE_CALL, true;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// ignore cast out.putBooleanProp(Node.FREE_CALL, false;",
                "patch_diff": "// ignore cast out.putBooleanProp(Node.FREE_CALL, false;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// ignore it.putBooleanProp(Node.FREE_CALL, true);",
                "patch_diff": "// ignore it.putBooleanProp(Node.FREE_CALL, true);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// ignore it.putBooleanProp(Node.FREE_CALL, false);",
                "patch_diff": "// ignore it.putBooleanProp(Node.FREE_CALL, false);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "while (first.isCast()) { first = first.getFirstChild(); }"
    },
    "JacksonDatabind-58": {
        "fixes": [
            {
                "k": 1,
                "patch": "// note: let's do implicit re-parse",
                "patch_diff": "// note: let's do implicit re-parse",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// note: can't really modify it was non-empty's do implicit re-parse",
                "patch_diff": "// note: can't really modify it was non-empty's do implicit re-parse",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// note: can't really modify it was non-literal characters that might be valid (e if it's do implicit re-parse",
                "patch_diff": "// note: can't really modify it was non-literal characters that might be valid (e if it's do implicit re-parse",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// note: can't really modify it was non-literal characters that might be null or EMPTY",
                "patch_diff": "// note: can't really modify it was non-literal characters that might be null or EMPTY",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// note: can't really modify it's do implicit re-parse",
                "patch_diff": "// note: can't really modify it's do implicit re-parse",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// note: can't really modify it was non-literal characters that might be valid (e if it's do implicit re-initialized or EMPTY",
                "patch_diff": "// note: can't really modify it was non-literal characters that might be valid (e if it's do implicit re-initialized or EMPTY",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// note: can't really modify it was non-literal characters that might be valid (e if it.",
                "patch_diff": "// note: can't really modify it was non-literal characters that might be valid (e if it.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// note: let's do implicit re-initialized or EMPTY",
                "patch_diff": "// note: let's do implicit re-initialized or EMPTY",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// note: can't really modify it was non-literal characters that might be valid (e if it's",
                "patch_diff": "// note: can't really modify it was non-literal characters that might be valid (e if it's",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// note: can't really modify it's do implicit re-initialized or EMPTY",
                "patch_diff": "// note: can't really modify it's do implicit re-initialized or EMPTY",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if ((mutator instanceof AnnotatedField) && \"cause\".equals(mutator.getName())) { ; } else { mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS)); }"
    },
    "Math-88": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (coefficients == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 18:10:45.772318303 +0200\n+++ /tmp/tmpvb73zy_v.java\t2022-07-19 18:10:45.864317849 +0200\n@@ -331,16 +331,11 @@\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n-            if (basicRow != null) {\n-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n-                    }\n-                }\n+if (coefficients == null) {\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (isRow!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 18:10:54.164277091 +0200\n+++ /tmp/tmpm0iwe0u9.java\t2022-07-19 18:10:54.164277091 +0200\n@@ -331,16 +331,11 @@\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n-            if (basicRow != null) {\n-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n-                    }\n-                }\n+if (isRow!= null) {\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if ( 20,Row == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 18:10:56.344266385 +0200\n+++ /tmp/tmpai7tzbl8.java\t2022-07-19 18:10:56.344266385 +0200\n@@ -331,16 +331,11 @@\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n-            if (basicRow != null) {\n-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n-                    }\n-                }\n+if ( 20,Row == null) {\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (c == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 18:10:58.516255714 +0200\n+++ /tmp/tmp_lzh4a5f.java\t2022-07-19 18:10:58.516255714 +0200\n@@ -331,16 +331,11 @@\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n-            if (basicRow != null) {\n-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n-                    }\n-                }\n+if (c == null) {\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (isRow == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 18:11:00.736244808 +0200\n+++ /tmp/tmpco7yruvm.java\t2022-07-19 18:11:00.740244789 +0200\n@@ -331,16 +331,11 @@\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n-            if (basicRow != null) {\n-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n-                    }\n-                }\n+if (isRow == null) {\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (checkRow!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 18:11:02.860234374 +0200\n+++ /tmp/tmpir4wuuow.java\t2022-07-19 18:11:02.860234374 +0200\n@@ -331,16 +331,11 @@\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n-            if (basicRow != null) {\n-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n-                    }\n-                }\n+if (checkRow!= null) {\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (basic == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 18:11:04.948224113 +0200\n+++ /tmp/tmp1j8elxjs.java\t2022-07-19 18:11:04.948224113 +0200\n@@ -331,16 +331,11 @@\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n-            if (basicRow != null) {\n-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n-                    }\n-                }\n+if (basic == null) {\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (c!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 18:11:07.224212928 +0200\n+++ /tmp/tmptmodexli.java\t2022-07-19 18:11:07.224212928 +0200\n@@ -331,16 +331,11 @@\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n-            if (basicRow != null) {\n-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n-                    }\n-                }\n+if (c!= null) {\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (checkRow == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 18:11:09.316202647 +0200\n+++ /tmp/tmp00craxj8.java\t2022-07-19 18:11:09.316202647 +0200\n@@ -331,16 +331,11 @@\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n-            if (basicRow != null) {\n-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n-                    }\n-                }\n+if (checkRow == null) {\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (basicRow == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 18:11:11.428192267 +0200\n+++ /tmp/tmpfqzwpob3.java\t2022-07-19 18:11:11.432192247 +0200\n@@ -331,16 +331,11 @@\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n-            if (basicRow != null) {\n-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n-                    }\n-                }\n+if (basicRow == null) {\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (basicRow != null) { for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) { if (tableau.getEntry(basicRow, j) == 1) { coefficients[i] = 0; } }",
        "fixed_line": "Set<Integer> basicRows = new HashSet<Integer>(); for (int i = 0; i < coefficients.length; i++) { basicRow = getBasicRow(getNumObjectiveFunctions() + i); if (basicRows.contains(basicRow)) { // if multiple variables can take a given value // then we choose the first and set the rest equal to 0 coefficients[i] = 0; } else { basicRows.add(basicRow);"
    },
    "Jsoup-26": {
        "fixes": [
            {
                "k": 1,
                "patch": "return clean;",
                "patch_diff": "return clean;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return clean.createShell(dirtyDocument);",
                "patch_diff": "return clean.createShell(dirtyDocument);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return clean.createShell(dirtyDocument;",
                "patch_diff": "return clean.createShell(dirtyDocument;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return clean.createShell(dirtyDocument.baseUri());",
                "patch_diff": "return clean.createShell(dirtyDocument.baseUri());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "{ Validate.notNull(dirtyDocument.createShell(dirtyDocument); return clean; }",
                "patch_diff": "{ Validate.notNull(dirtyDocument.createShell(dirtyDocument); return clean; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "{ Validate.notNull(dirtyDocument); return clean.createShell(dirtyDocument); }",
                "patch_diff": "{ Validate.notNull(dirtyDocument); return clean.createShell(dirtyDocument); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "{ Validate.notNull(dirtyDocument); return clean; }",
                "patch_diff": "{ Validate.notNull(dirtyDocument); return clean; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return clean.createShell(dirtyDocument.class(), clean;",
                "patch_diff": "return clean.createShell(dirtyDocument.class(), clean;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return clean.createShell(dirtyDocument, clean = Document.createShell(dirtyDocument);",
                "patch_diff": "return clean.createShell(dirtyDocument, clean = Document.createShell(dirtyDocument);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return clean.createShell(dirtyDocument, clean = Document.body());",
                "patch_diff": "return clean.createShell(dirtyDocument, clean = Document.body());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (dirtyDocument.body() != null) // frameset documents won't have a body. the clean doc will have empty body."
    },
    "JacksonDatabind-42": {
        "fixes": [
            {
                "k": 1,
                "patch": "// As per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "// As per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// As per [JACKSON-88], URI requires special handling",
                "patch_diff": "// As per [JACKSON-88], URI requires special handling",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// As per [JACKSON-18], URI requires special handling",
                "patch_diff": "// As per [JACKSON-18], URI requires special handling",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// As per [JACKSON-407] -- allow disabling wrapping for */;",
                "patch_diff": "// As per [JACKSON-407] -- allow disabling wrapping for */;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// As per [JACKSON-8], URI requires special handling",
                "patch_diff": "// As per [JACKSON-8], URI requires special handling",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// As per [JACKSON-631], URI requires special handling",
                "patch_diff": "// As per [JACKSON-631], URI requires special handling",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// As per [JACKSON-314], URI requires special handling",
                "patch_diff": "// As per [JACKSON-314], URI requires special handling",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// As per [JACKSON-88], URI requires special handling if (_kind == null) {",
                "patch_diff": "// As per [JACKSON-88], URI requires special handling if (_kind == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// As per [JACKSON-16, URI requires special handling",
                "patch_diff": "// As per [JACKSON-16, URI requires special handling",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// As per [JACKSON-88], URI requires special handling if (_deserializeFromEmptyString) {",
                "patch_diff": "// As per [JACKSON-88], URI requires special handling if (_deserializeFromEmptyString) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (_kind == STD_LOCALE) { return Locale.ROOT; }"
    },
    "Closure-145": {
        "fixes": [
            {
                "k": 1,
                "patch": "// We can't really modify it was non-literal characters that might be valid (n.getType() == Token.FUNCTION || n.getType() == Token.CATCH); }",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (n.getType() == Token.FUNCTION || n.getType() == Token.CATCH); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// We can't really modify it was non-literal characters that might be valid (n.getType() == Token.FUNCTION || n.getType() == Token.CATCH);",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (n.getType() == Token.FUNCTION || n.getType() == Token.CATCH);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// We can't really modify it was non-literal characters that might be valid (n.getType() == Token.FOR && n.getFirstChild().getType() == Token.FUNCTION;",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (n.getType() == Token.FOR && n.getFirstChild().getType() == Token.FUNCTION;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// We can't really modify it was non-literal characters that might be valid (n.getType() == Token.FUNCTION || n.getType() == Token.DO) {",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (n.getType() == Token.FUNCTION || n.getType() == Token.DO) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// We can't really modify it was non-literal characters that might be valid (n.getType() == Token.FUNCTION || n.getType() == Token.DO); }",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (n.getType() == Token.FUNCTION || n.getType() == Token.DO); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// We can't really modify it was non-literal characters that might be valid (n.getType() == Token.FUNCTION || n.getType() == Token.DO;",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (n.getType() == Token.FUNCTION || n.getType() == Token.DO;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// We can't really modify it was non-literal characters that might be valid (n.getType() == Token.FUNCTION || n.getType() == Token.FOR &&",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (n.getType() == Token.FUNCTION || n.getType() == Token.FOR &&",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// We can't really modify it was non-literal characters that might be valid (n.getType() == Token.FUNCTION || n.getType() == Token.CATCH;",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (n.getType() == Token.FUNCTION || n.getType() == Token.CATCH;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// We can't really modify it was non-literal characters that might be valid (n.getType() == Token.DO);",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (n.getType() == Token.DO);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// We can't really modify it was non-literal characters that might be valid (n.getType() == Token.FUNCTION || n.getType() == Token.VAR;",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (n.getType() == Token.FUNCTION || n.getType() == Token.VAR;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (n.getType() == Token.LABEL) { Node labeledStatement = n.getLastChild(); if (labeledStatement.getType() != Token.BLOCK) { return isOneExactlyFunctionOrDo(labeledStatement); } else { // For labels with block children, we need to ensure that a // labeled FUNCTION or DO isn't generated when extraneous BLOCKs // are skipped. if (getNonEmptyChildCount(n, 2) == 1) { return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n)); } else { // Either a empty statement or an block with more than one child, // way it isn't a FUNCTION or DO. return false; } } } else { return (n.getType() == Token.FUNCTION || n.getType() == Token.DO); }"
    },
    "JacksonDatabind-67": {
        "fixes": [
            {
                "k": 1,
                "patch": "return _createEnumKeyDeserializer(ctxt, type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, _factoryConfig);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-67/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 18:11:22.972135506 +0200\n+++ /tmp/tmps_p8hgs0.java\t2022-07-19 18:11:23.068135041 +0200\n@@ -1398,13 +1398,11 @@\n             }\n         }\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n-            }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+return _createEnumKeyDeserializer(ctxt, type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, _factoryConfig);\n         }\n         // and then post-processing\n         if (deser != null) {\n             if (_factoryConfig.hasDeserializerModifiers()) {\n                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return _createEnumKeyDeserializer(enumRes, type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, _factoryConfig);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-67/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 18:11:25.220124459 +0200\n+++ /tmp/tmpa396j7mt.java\t2022-07-19 18:11:25.220124459 +0200\n@@ -1398,13 +1398,11 @@\n             }\n         }\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n-            }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+return _createEnumKeyDeserializer(enumRes, type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, _factoryConfig);\n         }\n         // and then post-processing\n         if (deser != null) {\n             if (_factoryConfig.hasDeserializerModifiers()) {\n                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return _createEnumKeyDeserializer(ctxt, type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, _factoryConfigConfig);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-67/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 18:11:26.904116177 +0200\n+++ /tmp/tmpiri_7148.java\t2022-07-19 18:11:26.908116157 +0200\n@@ -1398,13 +1398,11 @@\n             }\n         }\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n-            }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+return _createEnumKeyDeserializer(ctxt, type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, _factoryConfigConfig);\n         }\n         // and then post-processing\n         if (deser != null) {\n             if (_factoryConfig.hasDeserializerModifiers()) {\n                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return _createEnumKeyDeserializer(ctxt, type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, deser);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-67/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 18:11:28.564108015 +0200\n+++ /tmp/tmpsz6q1k74.java\t2022-07-19 18:11:28.568107993 +0200\n@@ -1398,13 +1398,11 @@\n             }\n         }\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n-            }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+return _createEnumKeyDeserializer(ctxt, type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, deser);\n         }\n         // and then post-processing\n         if (deser != null) {\n             if (_factoryConfig.hasDeserializerModifiers()) {\n                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return _createEnumKeyDeserializer(ctxt, type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-67/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 18:11:30.260099670 +0200\n+++ /tmp/tmpygb9k1q1.java\t2022-07-19 18:11:30.260099670 +0200\n@@ -1398,13 +1398,11 @@\n             }\n         }\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n-            }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+return _createEnumKeyDeserializer(ctxt, type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type,\n         }\n         // and then post-processing\n         if (deser != null) {\n             if (_factoryConfig.hasDeserializerModifiers()) {\n                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return _createEnumKeyDeserializer(enumRes, type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, _factoryConfigConfig);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-67/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 18:11:32.052090856 +0200\n+++ /tmp/tmpwin_btfk.java\t2022-07-19 18:11:32.052090856 +0200\n@@ -1398,13 +1398,11 @@\n             }\n         }\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n-            }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+return _createEnumKeyDeserializer(enumRes, type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, _factoryConfigConfig);\n         }\n         // and then post-processing\n         if (deser != null) {\n             if (_factoryConfig.hasDeserializerModifiers()) {\n                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return _createEnumKeyDeserializer(type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, _factoryConfig);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-67/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 18:11:33.676082868 +0200\n+++ /tmp/tmpcezj6xwd.java\t2022-07-19 18:11:33.680082849 +0200\n@@ -1398,13 +1398,11 @@\n             }\n         }\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n-            }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+return _createEnumKeyDeserializer(type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, _factoryConfig);\n         }\n         // and then post-processing\n         if (deser != null) {\n             if (_factoryConfig.hasDeserializerModifiers()) {\n                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return _createEnumKeyDeserializer(ctxt, type = StdKeyDeserializers.findStringBasedKeyDeserializer(type, deser);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-67/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 18:11:35.424074269 +0200\n+++ /tmp/tmp67vnp29q.java\t2022-07-19 18:11:35.424074269 +0200\n@@ -1398,13 +1398,11 @@\n             }\n         }\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n-            }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+return _createEnumKeyDeserializer(ctxt, type = StdKeyDeserializers.findStringBasedKeyDeserializer(type, deser);\n         }\n         // and then post-processing\n         if (deser != null) {\n             if (_factoryConfig.hasDeserializerModifiers()) {\n                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return _createEnumKeyDeserializer(enumRes, type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-67/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 18:11:37.060066219 +0200\n+++ /tmp/tmptzw8_5n7.java\t2022-07-19 18:11:37.060066219 +0200\n@@ -1398,13 +1398,11 @@\n             }\n         }\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n-            }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+return _createEnumKeyDeserializer(enumRes, type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type,\n         }\n         // and then post-processing\n         if (deser != null) {\n             if (_factoryConfig.hasDeserializerModifiers()) {\n                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return _createEnumKeyDeserializer(type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-67/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 18:11:38.760057854 +0200\n+++ /tmp/tmpxo947rxj.java\t2022-07-19 18:11:38.760057854 +0200\n@@ -1398,13 +1398,11 @@\n             }\n         }\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n-            }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+return _createEnumKeyDeserializer(type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n         }\n         // and then post-processing\n         if (deser != null) {\n             if (_factoryConfig.hasDeserializerModifiers()) {\n                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return _createEnumKeyDeserializer(ctxt, type); } deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);",
        "fixed_line": "deser = _createEnumKeyDeserializer(ctxt, type); } else { deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);"
    },
    "Codec-10": {
        "fixes": [
            {
                "k": 1,
                "patch": "txt = txt.replaceAll(\"millis\", txt +millis; // 1.0 only has 6 of",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-10/src/java/org/apache/commons/codec/language/Caverphone.java\t2022-07-19 18:11:40.704048286 +0200\n+++ /tmp/tmpeygxk2cs.java\t2022-07-19 18:11:40.752048053 +0200\n@@ -71,11 +71,11 @@\n         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+txt = txt.replaceAll(\"millis\", txt +millis; // 1.0 only has 6 of\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n         txt = txt.replaceAll(\"ci\", \"si\");\n         txt = txt.replaceAll(\"ce\", \"se\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "txt = txt.replaceAll(\"millis\", txt; // 1.0 only has 6 of",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-10/src/java/org/apache/commons/codec/language/Caverphone.java\t2022-07-19 18:11:42.556039175 +0200\n+++ /tmp/tmpoa6xuogt.java\t2022-07-19 18:11:42.556039175 +0200\n@@ -71,11 +71,11 @@\n         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+txt = txt.replaceAll(\"millis\", txt; // 1.0 only has 6 of\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n         txt = txt.replaceAll(\"ci\", \"si\");\n         txt = txt.replaceAll(\"ce\", \"se\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "txt = txt.replaceAll(\"millis\", txt; // 1.0 only has 6 1s",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-10/src/java/org/apache/commons/codec/language/Caverphone.java\t2022-07-19 18:11:44.044031852 +0200\n+++ /tmp/tmpgi19xdcx.java\t2022-07-19 18:11:44.044031852 +0200\n@@ -71,11 +71,11 @@\n         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+txt = txt.replaceAll(\"millis\", txt; // 1.0 only has 6 1s\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n         txt = txt.replaceAll(\"ci\", \"si\");\n         txt = txt.replaceAll(\"ce\", \"se\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "txt = txt.replaceAll(\"millis\", txt +millis; // 1.0 only has 6",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-10/src/java/org/apache/commons/codec/language/Caverphone.java\t2022-07-19 18:11:45.516024608 +0200\n+++ /tmp/tmpw1rvj7od.java\t2022-07-19 18:11:45.520024589 +0200\n@@ -71,11 +71,11 @@\n         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+txt = txt.replaceAll(\"millis\", txt +millis; // 1.0 only has 6\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n         txt = txt.replaceAll(\"ci\", \"si\");\n         txt = txt.replaceAll(\"ce\", \"se\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "txt = txt.replaceAll(\"millis\", txt; // 1.0 only has 6-millis",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-10/src/java/org/apache/commons/codec/language/Caverphone.java\t2022-07-19 18:11:47.016017225 +0200\n+++ /tmp/tmp26vtoumi.java\t2022-07-19 18:11:47.016017225 +0200\n@@ -71,11 +71,11 @@\n         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+txt = txt.replaceAll(\"millis\", txt; // 1.0 only has 6-millis\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n         txt = txt.replaceAll(\"ci\", \"si\");\n         txt = txt.replaceAll(\"ce\", \"se\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "txt = txt.replaceAll(\"millis\", txt; // 1.0 only has 6",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-10/src/java/org/apache/commons/codec/language/Caverphone.java\t2022-07-19 18:11:48.528009783 +0200\n+++ /tmp/tmp2f9pjmi3.java\t2022-07-19 18:11:48.528009783 +0200\n@@ -71,11 +71,11 @@\n         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+txt = txt.replaceAll(\"millis\", txt; // 1.0 only has 6\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n         txt = txt.replaceAll(\"ci\", \"si\");\n         txt = txt.replaceAll(\"ce\", \"se\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "txt = txt.replaceAll(\"millis\", txt +millis;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-10/src/java/org/apache/commons/codec/language/Caverphone.java\t2022-07-19 18:11:50.120001947 +0200\n+++ /tmp/tmpwcrhe7gr.java\t2022-07-19 18:11:50.124001929 +0200\n@@ -71,11 +71,11 @@\n         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+txt = txt.replaceAll(\"millis\", txt +millis;\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n         txt = txt.replaceAll(\"ci\", \"si\");\n         txt = txt.replaceAll(\"ce\", \"se\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "txt = txt.replaceAll(\"millis\", txt +millis; // 1.0 only has 6 1s",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-10/src/java/org/apache/commons/codec/language/Caverphone.java\t2022-07-19 18:11:51.627994524 +0200\n+++ /tmp/tmp13h4b82p.java\t2022-07-19 18:11:51.627994524 +0200\n@@ -71,11 +71,11 @@\n         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+txt = txt.replaceAll(\"millis\", txt +millis; // 1.0 only has 6 1s\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n         txt = txt.replaceAll(\"ci\", \"si\");\n         txt = txt.replaceAll(\"ce\", \"se\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "txt = txt.replaceAll(\"millis\", txt; // to indicate to 6",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-10/src/java/org/apache/commons/codec/language/Caverphone.java\t2022-07-19 18:11:53.103987257 +0200\n+++ /tmp/tmpc9pppm9r.java\t2022-07-19 18:11:53.103987257 +0200\n@@ -71,11 +71,11 @@\n         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+txt = txt.replaceAll(\"millis\", txt; // to indicate to 6\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n         txt = txt.replaceAll(\"ci\", \"si\");\n         txt = txt.replaceAll(\"ce\", \"se\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "txt = txt.replaceAll(\"millis\", txt +millis; // 1.0 only has 6-millis",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-10/src/java/org/apache/commons/codec/language/Caverphone.java\t2022-07-19 18:11:54.639979695 +0200\n+++ /tmp/tmp9n9tc9wq.java\t2022-07-19 18:11:54.639979695 +0200\n@@ -71,11 +71,11 @@\n         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+txt = txt.replaceAll(\"millis\", txt +millis; // 1.0 only has 6-millis\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n         txt = txt.replaceAll(\"ci\", \"si\");\n         txt = txt.replaceAll(\"ce\", \"se\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "txt = txt.replaceAll(\"^mb\", \"m2\");",
        "fixed_line": "txt = txt.replaceAll(\"mb$\", \"m2\");"
    },
    "Lang-64": {
        "fixes": [
            {
                "k": 1,
                "patch": "// ignore - should never happen }",
                "patch_diff": "// ignore - should never happen }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// ignore - should never happen but...",
                "patch_diff": "// ignore - should never happen but...",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0; i < other.length; i++) { if (other[i] == null) { return i; } } }",
                "patch_diff": "for (int i = 0; i < other.length; i++) { if (other[i] == null) { return i; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = 0; i < other.length; i++) { if (other[i] == null) { return iValue; } } }",
                "patch_diff": "for (int i = 0; i < other.length; i++) { if (other[i] == null) { return iValue; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// ignore - should never happen",
                "patch_diff": "// ignore - should never happen",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = 0; i < other.length; i++) { if (other[i] == null) { return false; } } }",
                "patch_diff": "for (int i = 0; i < other.length; i++) { if (other[i] == null) { return false; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = 0; i < other.length; i++) { if (other[i] == null) { return iValue; } } else { return 0; } }",
                "patch_diff": "for (int i = 0; i < other.length; i++) { if (other[i] == null) { return iValue; } } else { return 0; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = 0; i < this.type; i++) { if (other[i] == null) { return iValue; } } }",
                "patch_diff": "for (int i = 0; i < this.type; i++) { if (other[i] == null) { return iValue; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int i = 0; i < other.length; i++) { if (other[i] == null) { return iValue; } } else { return iValue; } }",
                "patch_diff": "for (int i = 0; i < other.length; i++) { if (other[i] == null) { return iValue; } } else { return iValue; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = 0; i < this.dataset.length; i++) { if (other[i] == null) { return iValue; } } }",
                "patch_diff": "for (int i = 0; i < this.dataset.length; i++) { if (other[i] == null) { return iValue; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (other == this) { return 0; } if (other.getClass() != this.getClass()) { if (other.getClass().getName().equals(this.getClass().getName())) { return iValue - getValueInOtherClassLoader(other); } throw new ClassCastException( \"Different enum class '\" + ClassUtils.getShortClassName(other.getClass()) + \"'\"); } return iValue - ((ValuedEnum) other).iValue; } /** * <p>Use reflection to return an objects value.</p> * * @param other the object to determine the value for * @return the value */ private int getValueInOtherClassLoader(Object other) { try { Method mth = other.getClass().getMethod(\"getValue\", null); Integer value = (Integer) mth.invoke(other, null); return value.intValue(); } catch (NoSuchMethodException e) { // ignore - should never happen } catch (IllegalAccessException e) { // ignore - should never happen } catch (InvocationTargetException e) { // ignore - should never happen } throw new IllegalStateException(\"This should not happen\"); }"
    },
    "JacksonDatabind-46": {
        "fixes": [
            {
                "k": 1,
                "patch": "sb.append(_referencedType;');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-46/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\t2022-07-19 18:11:58.075962775 +0200\n+++ /tmp/tmpqwrw3gga.java\t2022-07-19 18:11:58.139962463 +0200\n@@ -151,11 +151,11 @@\n     public StringBuilder getGenericSignature(StringBuilder sb)\n     {\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(';');\n+sb.append(_referencedType;');\n         return sb;\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "sb.append(_defaultNewLine;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-46/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\t2022-07-19 18:11:59.911953737 +0200\n+++ /tmp/tmpex_1ev4f.java\t2022-07-19 18:11:59.911953737 +0200\n@@ -151,11 +151,11 @@\n     public StringBuilder getGenericSignature(StringBuilder sb)\n     {\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(';');\n+sb.append(_defaultNewLine;\n         return sb;\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "sb.append(_defaultNewLine;');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-46/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\t2022-07-19 18:12:01.527945779 +0200\n+++ /tmp/tmpmex4f2mt.java\t2022-07-19 18:12:01.527945779 +0200\n@@ -151,11 +151,11 @@\n     public StringBuilder getGenericSignature(StringBuilder sb)\n     {\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(';');\n+sb.append(_defaultNewLine;');\n         return sb;\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "sb.append(_referencedType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-46/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\t2022-07-19 18:12:03.199937544 +0200\n+++ /tmp/tmpm_wxda_s.java\t2022-07-19 18:12:03.199937544 +0200\n@@ -151,11 +151,11 @@\n     public StringBuilder getGenericSignature(StringBuilder sb)\n     {\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(';');\n+sb.append(_referencedType;\n         return sb;\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "sb.append(_ns;');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-46/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\t2022-07-19 18:12:04.947928936 +0200\n+++ /tmp/tmp80irwn_y.java\t2022-07-19 18:12:04.947928936 +0200\n@@ -151,11 +151,11 @@\n     public StringBuilder getGenericSignature(StringBuilder sb)\n     {\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(';');\n+sb.append(_ns;');\n         return sb;\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "sb.append(_ns;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-46/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\t2022-07-19 18:12:06.547921055 +0200\n+++ /tmp/tmp0voxc2xg.java\t2022-07-19 18:12:06.547921055 +0200\n@@ -151,11 +151,11 @@\n     public StringBuilder getGenericSignature(StringBuilder sb)\n     {\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(';');\n+sb.append(_ns;\n         return sb;\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "sb.append(_appendType;');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-46/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\t2022-07-19 18:12:08.103913392 +0200\n+++ /tmp/tmppc4byu9e.java\t2022-07-19 18:12:08.103913392 +0200\n@@ -151,11 +151,11 @@\n     public StringBuilder getGenericSignature(StringBuilder sb)\n     {\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(';');\n+sb.append(_appendType;');\n         return sb;\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "sb.append(_valueType;');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-46/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\t2022-07-19 18:12:09.723905413 +0200\n+++ /tmp/tmp_nvou0hm.java\t2022-07-19 18:12:09.727905391 +0200\n@@ -151,11 +151,11 @@\n     public StringBuilder getGenericSignature(StringBuilder sb)\n     {\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(';');\n+sb.append(_valueType;');\n         return sb;\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "sb.append(_valueType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-46/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\t2022-07-19 18:12:11.303897629 +0200\n+++ /tmp/tmpi3njfdi0.java\t2022-07-19 18:12:11.303897629 +0200\n@@ -151,11 +151,11 @@\n     public StringBuilder getGenericSignature(StringBuilder sb)\n     {\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(';');\n+sb.append(_valueType;\n         return sb;\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "sb.append(_append;');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-46/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\t2022-07-19 18:12:12.859889963 +0200\n+++ /tmp/tmp8biw5bmf.java\t2022-07-19 18:12:12.859889963 +0200\n@@ -151,11 +151,11 @@\n     public StringBuilder getGenericSignature(StringBuilder sb)\n     {\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(';');\n+sb.append(_append;');\n         return sb;\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "sb.append(';');",
        "fixed_line": "sb.append(\">;\");"
    },
    "Closure-168": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (this.t.getScopeDepth() < 2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-168/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 18:12:14.535881703 +0200\n+++ /tmp/tmpvdhvb72y.java\t2022-07-19 18:12:14.563881567 +0200\n@@ -1991,11 +1991,11 @@\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+if (this.t.getScopeDepth() < 2) {\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n         //\n         // 2) Local variables that are assigned more than once.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (t.getScopeDepth() < 2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-168/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 18:12:19.687856320 +0200\n+++ /tmp/tmp2yg4l4te.java\t2022-07-19 18:12:19.687856320 +0200\n@@ -1991,11 +1991,11 @@\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+if (t.getScopeDepth() < 2) {\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n         //\n         // 2) Local variables that are assigned more than once.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 3,
                "patch": "if (t.getScopeDepth() == 2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-168/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 18:13:11.739599593 +0200\n+++ /tmp/tmphc90zqy3.java\t2022-07-19 18:13:11.743599575 +0200\n@@ -1991,11 +1991,11 @@\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+if (t.getScopeDepth() == 2) {\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n         //\n         // 2) Local variables that are assigned more than once.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (t.getScopeDepth()!= 2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-168/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 18:13:59.967361348 +0200\n+++ /tmp/tmp6yct2ay2.java\t2022-07-19 18:13:59.971361326 +0200\n@@ -1991,11 +1991,11 @@\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+if (t.getScopeDepth()!= 2) {\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n         //\n         // 2) Local variables that are assigned more than once.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (t.getScopeDepth == 2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-168/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 18:14:46.495131183 +0200\n+++ /tmp/tmpxvywm7ac.java\t2022-07-19 18:14:46.499131164 +0200\n@@ -1991,11 +1991,11 @@\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+if (t.getScopeDepth == 2) {\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n         //\n         // 2) Local variables that are assigned more than once.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (t.getScopeDepth() <= 2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-168/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 18:14:50.215112769 +0200\n+++ /tmp/tmp7k9dwmhj.java\t2022-07-19 18:14:50.215112769 +0200\n@@ -1991,11 +1991,11 @@\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+if (t.getScopeDepth() <= 2) {\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n         //\n         // 2) Local variables that are assigned more than once.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (t.getScopeDepth!= 2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-168/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 18:15:32.350904069 +0200\n+++ /tmp/tmp83y8mo5v.java\t2022-07-19 18:15:32.354904049 +0200\n@@ -1991,11 +1991,11 @@\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+if (t.getScopeDepth!= 2) {\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n         //\n         // 2) Local variables that are assigned more than once.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (type.getScopeDepth < 2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-168/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 18:15:36.178885098 +0200\n+++ /tmp/tmp4updq6gt.java\t2022-07-19 18:15:36.182885080 +0200\n@@ -1991,11 +1991,11 @@\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+if (type.getScopeDepth < 2) {\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n         //\n         // 2) Local variables that are assigned more than once.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (t.getScopeDepth <= 2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-168/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 18:15:39.914866583 +0200\n+++ /tmp/tmpksa7ervv.java\t2022-07-19 18:15:39.914866583 +0200\n@@ -1991,11 +1991,11 @@\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+if (t.getScopeDepth <= 2) {\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n         //\n         // 2) Local variables that are assigned more than once.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (this.t.getScopeDepth() <= 2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-168/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 18:15:44.030846182 +0200\n+++ /tmp/tmpccpa2ewq.java\t2022-07-19 18:15:44.030846182 +0200\n@@ -1991,11 +1991,11 @@\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+if (this.t.getScopeDepth() <= 2) {\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n         //\n         // 2) Local variables that are assigned more than once.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (t.getScopeDepth() <= 2) {",
        "fixed_line": "if (t.getScopeDepth() <= 1) {"
    },
    "Codec-18": {
        "fixes": [
            {
                "k": 1,
                "patch": "return CharSequenceUtils.regionMatches(true, false, cs2, 0, cs2.length(), cs2.length);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-18/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-19 18:15:48.162825698 +0200\n+++ /tmp/tmpt6iunbhy.java\t2022-07-19 18:15:48.238825320 +0200\n@@ -76,11 +76,11 @@\n             return false;\n         }\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+return CharSequenceUtils.regionMatches(true, false, cs2, 0, cs2.length(), cs2.length);\n     }\n \n     /**\n      * Calls {@link String#getBytes(Charset)}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return CharSequenceUtils.regionMatches(true, false, cs2, 0, cs2.length(), Math.max(theta1.length >>>",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-18/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-19 18:15:50.206815563 +0200\n+++ /tmp/tmpjs49lsa3.java\t2022-07-19 18:15:50.206815563 +0200\n@@ -76,11 +76,11 @@\n             return false;\n         }\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+return CharSequenceUtils.regionMatches(true, false, cs2, 0, cs2.length(), Math.max(theta1.length >>>\n     }\n \n     /**\n      * Calls {@link String#getBytes(Charset)}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return CharSequenceUtils.regionMatches(true, false, cs1, 0, 0, Math.max(max2, m text2.length())) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-18/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-19 18:15:51.734807988 +0200\n+++ /tmp/tmpziqqco3s.java\t2022-07-19 18:15:51.734807988 +0200\n@@ -76,11 +76,11 @@\n             return false;\n         }\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+return CharSequenceUtils.regionMatches(true, false, cs1, 0, 0, Math.max(max2, m text2.length())) {\n     }\n \n     /**\n      * Calls {@link String#getBytes(Charset)}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return CharSequenceUtils.regionMatches(true, false, cs1, 0, cs2.length(), Math.max(theta1.length >>>",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-18/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-19 18:15:53.266800394 +0200\n+++ /tmp/tmp4t2na_zw.java\t2022-07-19 18:15:53.266800394 +0200\n@@ -76,11 +76,11 @@\n             return false;\n         }\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+return CharSequenceUtils.regionMatches(true, false, cs1, 0, cs2.length(), Math.max(theta1.length >>>\n     }\n \n     /**\n      * Calls {@link String#getBytes(Charset)}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return CharSequenceUtils.regionMatches(true, false, cs2, 0, cs2.length(), cs2.length());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-18/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-19 18:15:54.794792816 +0200\n+++ /tmp/tmp375cv_kl.java\t2022-07-19 18:15:54.794792816 +0200\n@@ -76,11 +76,11 @@\n             return false;\n         }\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+return CharSequenceUtils.regionMatches(true, false, cs2, 0, cs2.length(), cs2.length());\n     }\n \n     /**\n      * Calls {@link String#getBytes(Charset)}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return CharSequenceUtils.regionMatches(true, false, cs2, 0, cs2.length(), Math.max(theta1.length >>> 12.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-18/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-19 18:15:56.350785101 +0200\n+++ /tmp/tmp4t0lbkxa.java\t2022-07-19 18:15:56.354785082 +0200\n@@ -76,11 +76,11 @@\n             return false;\n         }\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+return CharSequenceUtils.regionMatches(true, false, cs2, 0, cs2.length(), Math.max(theta1.length >>> 12.length()));\n     }\n \n     /**\n      * Calls {@link String#getBytes(Charset)}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return CharSequenceUtils.regionMatches(true, false, cs2, 0, cs2.length(), cs2.length;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-18/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-19 18:15:58.018776830 +0200\n+++ /tmp/tmpv5cf4jph.java\t2022-07-19 18:15:58.018776830 +0200\n@@ -76,11 +76,11 @@\n             return false;\n         }\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+return CharSequenceUtils.regionMatches(true, false, cs2, 0, cs2.length(), cs2.length;\n     }\n \n     /**\n      * Calls {@link String#getBytes(Charset)}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return CharSequenceUtils.regionMatches(true, false, cs2, 0, cs2.length(), Math.max(theta1.length >>> 162.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-18/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-19 18:15:59.538769294 +0200\n+++ /tmp/tmpnga9eev9.java\t2022-07-19 18:15:59.538769294 +0200\n@@ -76,11 +76,11 @@\n             return false;\n         }\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+return CharSequenceUtils.regionMatches(true, false, cs2, 0, cs2.length(), Math.max(theta1.length >>> 162.length()));\n     }\n \n     /**\n      * Calls {@link String#getBytes(Charset)}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return CharSequenceUtils.regionMatches(true, false, cs2, 0, cs2.length(), Math.max(theta1.length,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-18/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-19 18:16:01.034761875 +0200\n+++ /tmp/tmp2ba7sf9p.java\t2022-07-19 18:16:01.038761857 +0200\n@@ -76,11 +76,11 @@\n             return false;\n         }\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+return CharSequenceUtils.regionMatches(true, false, cs2, 0, cs2.length(), Math.max(theta1.length,\n     }\n \n     /**\n      * Calls {@link String#getBytes(Charset)}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return CharSequenceUtils.regionMatches(true, false, cs1, 0, cs2.length(), cs2.length);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-18/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-19 18:16:02.658753821 +0200\n+++ /tmp/tmp5rqiqgpv.java\t2022-07-19 18:16:02.658753821 +0200\n@@ -76,11 +76,11 @@\n             return false;\n         }\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+return CharSequenceUtils.regionMatches(true, false, cs1, 0, cs2.length(), cs2.length);\n     }\n \n     /**\n      * Calls {@link String#getBytes(Charset)}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));",
        "fixed_line": "return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length());"
    },
    "Closure-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (parent.getJSType() == null && childType.isAssign()) { return;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-11/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 18:16:04.534744520 +0200\n+++ /tmp/tmp2okaynou.java\t2022-07-19 18:16:04.578744296 +0200\n@@ -1309,12 +1309,11 @@\n     Node objNode = n.getFirstChild();\n     JSType childType = getJSType(objNode);\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      return;\n+} else if (parent.getJSType() == null && childType.isAssign()) { return;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n     }\n     ensureTyped(t, n);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (parent.getJSType()!= null && childType.isAssign()) { return;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-11/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 18:16:09.578719504 +0200\n+++ /tmp/tmpvu7lfp2s.java\t2022-07-19 18:16:09.578719504 +0200\n@@ -1309,12 +1309,11 @@\n     Node objNode = n.getFirstChild();\n     JSType childType = getJSType(objNode);\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      return;\n+} else if (parent.getJSType()!= null && childType.isAssign()) { return;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n     }\n     ensureTyped(t, n);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (parent.getJSType() == null && childType.isAssign()) { return; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-11/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 18:16:13.282701130 +0200\n+++ /tmp/tmpxe5jv751.java\t2022-07-19 18:16:13.282701130 +0200\n@@ -1309,12 +1309,11 @@\n     Node objNode = n.getFirstChild();\n     JSType childType = getJSType(objNode);\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      return;\n+} else if (parent.getJSType() == null && childType.isAssign()) { return; }\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n     }\n     ensureTyped(t, n);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (parent.getJSType() == null && childType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-11/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 18:16:16.894683213 +0200\n+++ /tmp/tmp38m_nvxn.java\t2022-07-19 18:16:16.894683213 +0200\n@@ -1309,12 +1309,11 @@\n     Node objNode = n.getFirstChild();\n     JSType childType = getJSType(objNode);\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      return;\n+} else if (parent.getJSType() == null && childType;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n     }\n     ensureTyped(t, n);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (parent.getJSType()!= null && childType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-11/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 18:16:20.506665296 +0200\n+++ /tmp/tmpgs9msl9x.java\t2022-07-19 18:16:20.506665296 +0200\n@@ -1309,12 +1309,11 @@\n     Node objNode = n.getFirstChild();\n     JSType childType = getJSType(objNode);\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      return;\n+} else if (parent.getJSType()!= null && childType;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n     }\n     ensureTyped(t, n);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (parent.getJSType() == null && parent.isAssign()) { return;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-11/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 18:16:24.206646937 +0200\n+++ /tmp/tmp_n_fzbek.java\t2022-07-19 18:16:24.206646937 +0200\n@@ -1309,12 +1309,11 @@\n     Node objNode = n.getFirstChild();\n     JSType childType = getJSType(objNode);\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      return;\n+} else if (parent.getJSType() == null && parent.isAssign()) { return;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n     }\n     ensureTyped(t, n);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 7,
                "patch": "} else if (parent.getJSType()!= null && childType.isAssign()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-11/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 18:17:13.326403106 +0200\n+++ /tmp/tmp895yubzl.java\t2022-07-19 18:17:13.330403088 +0200\n@@ -1309,12 +1309,11 @@\n     Node objNode = n.getFirstChild();\n     JSType childType = getJSType(objNode);\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      return;\n+} else if (parent.getJSType()!= null && childType.isAssign()) {\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n     }\n     ensureTyped(t, n);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (parent.isJSType() == null && childType.isAssign()) { return;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-11/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 18:17:16.974384987 +0200\n+++ /tmp/tmpd9vfy9rr.java\t2022-07-19 18:17:16.974384987 +0200\n@@ -1309,12 +1309,11 @@\n     Node objNode = n.getFirstChild();\n     JSType childType = getJSType(objNode);\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      return;\n+} else if (parent.isJSType() == null && childType.isAssign()) { return;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n     }\n     ensureTyped(t, n);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (parent.getJSType() == null && childType.isAssign()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-11/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 18:17:20.430367821 +0200\n+++ /tmp/tmptw8ycyrs.java\t2022-07-19 18:17:20.434367802 +0200\n@@ -1309,12 +1309,11 @@\n     Node objNode = n.getFirstChild();\n     JSType childType = getJSType(objNode);\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      return;\n+} else if (parent.getJSType() == null && childType.isAssign()) {\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n     }\n     ensureTyped(t, n);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (parent.getJSType() == null && objNode.isAssign()) { return;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-11/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 18:17:24.034349919 +0200\n+++ /tmp/tmpxcn6bb7s.java\t2022-07-19 18:17:24.034349919 +0200\n@@ -1309,12 +1309,11 @@\n     Node objNode = n.getFirstChild();\n     JSType childType = getJSType(objNode);\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      return;\n+} else if (parent.getJSType() == null && objNode.isAssign()) { return;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n     }\n     ensureTyped(t, n);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            }
        ],
        "buggy_line": "} else if (n.getJSType() != null && parent.isAssign()) { return;",
        "fixed_line": ""
    },
    "Math-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-12/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\t2022-07-19 18:18:10.950116759 +0200\n+++ /tmp/tmpef3uy42a.java\t2022-07-19 18:18:11.026116382 +0200\n@@ -24,11 +24,11 @@\n  *\n  * @version $Id$\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator {\n+implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n     /** Serializable version identifier */\n     /** Next gaussian. */\n     private double nextGaussian;\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-12/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\t2022-07-19 18:19:00.909868265 +0200\n+++ /tmp/tmp81zj5ky6.java\t2022-07-19 18:19:00.909868265 +0200\n@@ -24,11 +24,11 @@\n  *\n  * @version $Id$\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator {\n+implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n     /** Serializable version identifier */\n     /** Next gaussian. */\n     private double nextGaussian;\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-12/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\t2022-07-19 18:19:46.049643572 +0200\n+++ /tmp/tmped09li9w.java\t2022-07-19 18:19:46.049643572 +0200\n@@ -24,11 +24,11 @@\n  *\n  * @version $Id$\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator {\n+implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n     /** Serializable version identifier */\n     /** Next gaussian. */\n     private double nextGaussian;\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-12/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\t2022-07-19 18:20:32.705411178 +0200\n+++ /tmp/tmpxurdj4jw.java\t2022-07-19 18:20:32.709411159 +0200\n@@ -24,11 +24,11 @@\n  *\n  * @version $Id$\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator {\n+implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number\n     /** Serializable version identifier */\n     /** Next gaussian. */\n     private double nextGaussian;\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-12/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\t2022-07-19 18:21:19.261179138 +0200\n+++ /tmp/tmptd3lnfc5.java\t2022-07-19 18:21:19.261179138 +0200\n@@ -24,11 +24,11 @@\n  *\n  * @version $Id$\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator {\n+implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnot real number\n     /** Serializable version identifier */\n     /** Next gaussian. */\n     private double nextGaussian;\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-12/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\t2022-07-19 18:22:06.748942319 +0200\n+++ /tmp/tmpb0a0kq52.java\t2022-07-19 18:22:06.748942319 +0200\n@@ -24,11 +24,11 @@\n  *\n  * @version $Id$\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator {\n+implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number\n     /** Serializable version identifier */\n     /** Next gaussian. */\n     private double nextGaussian;\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-12/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\t2022-07-19 18:22:52.628713401 +0200\n+++ /tmp/tmpt_uu3i37.java\t2022-07-19 18:22:52.628713401 +0200\n@@ -24,11 +24,11 @@\n  *\n  * @version $Id$\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator {\n+implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnot real number\n     /** Serializable version identifier */\n     /** Next gaussian. */\n     private double nextGaussian;\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-12/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\t2022-07-19 18:23:38.372485055 +0200\n+++ /tmp/tmpxmrwas9h.java\t2022-07-19 18:23:38.372485055 +0200\n@@ -24,11 +24,11 @@\n  *\n  * @version $Id$\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator {\n+implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnot real number\n     /** Serializable version identifier */\n     /** Next gaussian. */\n     private double nextGaussian;\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-12/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\t2022-07-19 18:24:26.140246505 +0200\n+++ /tmp/tmpm3xyrljy.java\t2022-07-19 18:24:26.140246505 +0200\n@@ -24,11 +24,11 @@\n  *\n  * @version $Id$\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator {\n+implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnot real number\n     /** Serializable version identifier */\n     /** Next gaussian. */\n     private double nextGaussian;\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-12/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\t2022-07-19 18:25:13.368010556 +0200\n+++ /tmp/tmpk4rb_92u.java\t2022-07-19 18:25:13.368010556 +0200\n@@ -24,11 +24,11 @@\n  *\n  * @version $Id$\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator {\n+implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnotnot real number\n     /** Serializable version identifier */\n     /** Next gaussian. */\n     private double nextGaussian;\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "implements RandomGenerator {",
        "fixed_line": "import java.io.Serializable; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.apache.commons.math3.util.FastMath; /** Base class for random number generators that generates bits streams. * * @version $Id$ * @since 2.0 */ public abstract class BitsStreamGenerator implements RandomGenerator, Serializable { /** Serializable version identifier */ private static final long serialVersionUID = 20130104L;"
    },
    "Jsoup-48": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (name.isEmpty()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-48/src/main/java/org/jsoup/helper/HttpConnection.java\t2022-07-19 18:25:59.127781863 +0200\n+++ /tmp/tmpn_kub_pw.java\t2022-07-19 18:25:59.179781601 +0200\n@@ -768,11 +768,11 @@\n                         // name not blank, value not null\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n+if (name.isEmpty()) {\n                         header(name, values.get(0));\n                 }\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (cfg.values.length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-48/src/main/java/org/jsoup/helper/HttpConnection.java\t2022-07-19 18:26:01.019772403 +0200\n+++ /tmp/tmps5vsp3e4.java\t2022-07-19 18:26:01.023772384 +0200\n@@ -768,11 +768,11 @@\n                         // name not blank, value not null\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n+if (cfg.values.length) {\n                         header(name, values.get(0));\n                 }\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (this.values.length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-48/src/main/java/org/jsoup/helper/HttpConnection.java\t2022-07-19 18:26:02.527764867 +0200\n+++ /tmp/tmpbtwn2xge.java\t2022-07-19 18:26:02.531764845 +0200\n@@ -768,11 +768,11 @@\n                         // name not blank, value not null\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n+if (this.values.length) {\n                         header(name, values.get(0));\n                 }\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (cfg.values.length == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-48/src/main/java/org/jsoup/helper/HttpConnection.java\t2022-07-19 18:26:04.019757407 +0200\n+++ /tmp/tmpz5pgmocj.java\t2022-07-19 18:26:04.019757407 +0200\n@@ -768,11 +768,11 @@\n                         // name not blank, value not null\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n+if (cfg.values.length == 0) {\n                         header(name, values.get(0));\n                 }\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (this.values.length == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-48/src/main/java/org/jsoup/helper/HttpConnection.java\t2022-07-19 18:26:05.523749889 +0200\n+++ /tmp/tmpoc_9egy3.java\t2022-07-19 18:26:05.523749889 +0200\n@@ -768,11 +768,11 @@\n                         // name not blank, value not null\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n+if (this.values.length == 0) {\n                         header(name, values.get(0));\n                 }\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (path.isEmpty()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-48/src/main/java/org/jsoup/helper/HttpConnection.java\t2022-07-19 18:26:07.071742153 +0200\n+++ /tmp/tmp6hkc2oa4.java\t2022-07-19 18:26:07.071742153 +0200\n@@ -768,11 +768,11 @@\n                         // name not blank, value not null\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n+if (path.isEmpty()) {\n                         header(name, values.get(0));\n                 }\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (values.isEmpty()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-48/src/main/java/org/jsoup/helper/HttpConnection.java\t2022-07-19 18:26:08.539734813 +0200\n+++ /tmp/tmp_ii2rahz.java\t2022-07-19 18:26:08.539734813 +0200\n@@ -768,11 +768,11 @@\n                         // name not blank, value not null\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n+if (values.isEmpty()) {\n                         header(name, values.get(0));\n                 }\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (header.isEmpty()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-48/src/main/java/org/jsoup/helper/HttpConnection.java\t2022-07-19 18:26:09.963727694 +0200\n+++ /tmp/tmpbcklqjcu.java\t2022-07-19 18:26:09.967727675 +0200\n@@ -768,11 +768,11 @@\n                         // name not blank, value not null\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n+if (header.isEmpty()) {\n                         header(name, values.get(0));\n                 }\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (values.length == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-48/src/main/java/org/jsoup/helper/HttpConnection.java\t2022-07-19 18:26:11.607719476 +0200\n+++ /tmp/tmpx3a141vl.java\t2022-07-19 18:26:11.607719476 +0200\n@@ -768,11 +768,11 @@\n                         // name not blank, value not null\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n+if (values.length == 0) {\n                         header(name, values.get(0));\n                 }\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (values.isEmpty())",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-48/src/main/java/org/jsoup/helper/HttpConnection.java\t2022-07-19 18:26:13.179711619 +0200\n+++ /tmp/tmphk6qps37.java\t2022-07-19 18:26:13.179711619 +0200\n@@ -768,11 +768,11 @@\n                         // name not blank, value not null\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n+if (values.isEmpty())\n                         header(name, values.get(0));\n                 }\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (!values.isEmpty())",
        "fixed_line": "if (values.size() == 1) header(name, values.get(0)); else if (values.size() > 1) { StringBuilder accum = new StringBuilder(); for (int i = 0; i < values.size(); i++) { final String val = values.get(i); if (i != 0) accum.append(\", \"); accum.append(val); } header(name, accum.toString()); }"
    },
    "Closure-86": {
        "fixes": [
            {
                "k": 1,
                "patch": "return false; // can't really modify it was non-literal characters that might be valid (empty be // need to check",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-86/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 18:26:17.415690441 +0200\n+++ /tmp/tmp24ohes55.java\t2022-07-19 18:26:17.499690020 +0200\n@@ -2460,11 +2460,11 @@\n             || locals.apply(value);\n       case Token.NEW:\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return false; // can't really modify it was non-literal characters that might be valid (empty be // need to check\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 2,
                "patch": "return false; // can't really modify it was non-literal characters that might be valid (empty be valid)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-86/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 18:26:49.875528151 +0200\n+++ /tmp/tmpqfplylve.java\t2022-07-19 18:26:49.875528151 +0200\n@@ -2460,11 +2460,11 @@\n             || locals.apply(value);\n       case Token.NEW:\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return false; // can't really modify it was non-literal characters that might be valid (empty be valid)\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 3,
                "patch": "return false; // can't really modify it was non-literal characters that might be valid (e if it was -->",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-86/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 18:27:20.143376792 +0200\n+++ /tmp/tmpnohyzt0i.java\t2022-07-19 18:27:20.147376769 +0200\n@@ -2460,11 +2460,11 @@\n             || locals.apply(value);\n       case Token.NEW:\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return false; // can't really modify it was non-literal characters that might be valid (e if it was -->\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 4,
                "patch": "return false; // can't really modify it was non-literal characters that might be valid (empty be",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-86/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 18:27:53.991207494 +0200\n+++ /tmp/tmpxh2mj9x9.java\t2022-07-19 18:27:53.995207476 +0200\n@@ -2460,11 +2460,11 @@\n             || locals.apply(value);\n       case Token.NEW:\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return false; // can't really modify it was non-literal characters that might be valid (empty be\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 5,
                "patch": "return false; // can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-86/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 18:28:24.683040927 +0200\n+++ /tmp/tmpf5iogko6.java\t2022-07-19 18:28:24.687040901 +0200\n@@ -2460,11 +2460,11 @@\n             || locals.apply(value);\n       case Token.NEW:\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return false; // can't really modify it was non-literal characters that might be valid (toJsonNode)\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 6,
                "patch": "return false; // can't really modify it was non-literal characters that might be Token.REGEXPMD -",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-86/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 18:28:53.218872129 +0200\n+++ /tmp/tmprbxb59ac.java\t2022-07-19 18:28:53.218872129 +0200\n@@ -2460,11 +2460,11 @@\n             || locals.apply(value);\n       case Token.NEW:\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return false; // can't really modify it was non-literal characters that might be Token.REGEXPMD -\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 7,
                "patch": "return false; // can't really modify it was non-literal characters that might be null or EMPTY",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-86/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 18:29:21.166707939 +0200\n+++ /tmp/tmp6cq239lc.java\t2022-07-19 18:29:21.170707918 +0200\n@@ -2460,11 +2460,11 @@\n             || locals.apply(value);\n       case Token.NEW:\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return false; // can't really modify it was non-literal characters that might be null or EMPTY\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 8,
                "patch": "return false; // can't really modify it was non-literal characters that were // need to check",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-86/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 18:29:48.914545967 +0200\n+++ /tmp/tmp30x080xu.java\t2022-07-19 18:29:48.918545944 +0200\n@@ -2460,11 +2460,11 @@\n             || locals.apply(value);\n       case Token.NEW:\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return false; // can't really modify it was non-literal characters that were // need to check\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 9,
                "patch": "return false; // can't really modify it was non-literal characters that might be Token.REGEXPMD",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-86/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 18:30:17.050382737 +0200\n+++ /tmp/tmp8yfsm8mz.java\t2022-07-19 18:30:17.050382737 +0200\n@@ -2460,11 +2460,11 @@\n             || locals.apply(value);\n       case Token.NEW:\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return false; // can't really modify it was non-literal characters that might be Token.REGEXPMD\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 10,
                "patch": "return false; // can't really modify it was non-literal characters that might be valid (empty be Token.REGEXPMD -",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-86/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 18:30:45.202220373 +0200\n+++ /tmp/tmph6a_yuwr.java\t2022-07-19 18:30:45.202220373 +0200\n@@ -2460,11 +2460,11 @@\n             || locals.apply(value);\n       case Token.NEW:\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return false; // can't really modify it was non-literal characters that might be valid (empty be Token.REGEXPMD -\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            }
        ],
        "buggy_line": "return true;",
        "fixed_line": "return false;"
    },
    "JacksonDatabind-100": {
        "fixes": [
            {
                "k": 1,
                "patch": "byte[] data = node.binaryValue; if (ob == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-100/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\t2022-07-19 18:31:13.262059444 +0200\n+++ /tmp/tmp6z223lx1.java\t2022-07-19 18:31:13.290059283 +0200\n@@ -358,19 +358,11 @@\n         // Multiple possibilities...\n         JsonNode n = currentNode();\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            byte[] data = n.binaryValue();\n-            if (data != null) {\n-                return data;\n-            }\n-            if (n.isPojo()) {\n-                Object ob = ((POJONode) n).getPojo();\n-                if (ob instanceof byte[]) {\n-                    return (byte[]) ob;\n-                }\n+byte[] data = node.binaryValue; if (ob == null) {\n             }\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "byte[] data = node.binaryValue; if (ob!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-100/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\t2022-07-19 18:31:15.370047390 +0200\n+++ /tmp/tmp145pguam.java\t2022-07-19 18:31:15.370047390 +0200\n@@ -358,19 +358,11 @@\n         // Multiple possibilities...\n         JsonNode n = currentNode();\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            byte[] data = n.binaryValue();\n-            if (data != null) {\n-                return data;\n-            }\n-            if (n.isPojo()) {\n-                Object ob = ((POJONode) n).getPojo();\n-                if (ob instanceof byte[]) {\n-                    return (byte[]) ob;\n-                }\n+byte[] data = node.binaryValue; if (ob!= null) {\n             }\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "byte[] data = node.binaryValue; if (ob instanceof byte[]) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-100/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\t2022-07-19 18:31:17.146037240 +0200\n+++ /tmp/tmpeekea9i7.java\t2022-07-19 18:31:17.146037240 +0200\n@@ -358,19 +358,11 @@\n         // Multiple possibilities...\n         JsonNode n = currentNode();\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            byte[] data = n.binaryValue();\n-            if (data != null) {\n-                return data;\n-            }\n-            if (n.isPojo()) {\n-                Object ob = ((POJONode) n).getPojo();\n-                if (ob instanceof byte[]) {\n-                    return (byte[]) ob;\n-                }\n+byte[] data = node.binaryValue; if (ob instanceof byte[]) {\n             }\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "byte[] data = node.binaryValue; data!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-100/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\t2022-07-19 18:31:18.910027157 +0200\n+++ /tmp/tmpbr6rw9qw.java\t2022-07-19 18:31:18.910027157 +0200\n@@ -358,19 +358,11 @@\n         // Multiple possibilities...\n         JsonNode n = currentNode();\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            byte[] data = n.binaryValue();\n-            if (data != null) {\n-                return data;\n-            }\n-            if (n.isPojo()) {\n-                Object ob = ((POJONode) n).getPojo();\n-                if (ob instanceof byte[]) {\n-                    return (byte[]) ob;\n-                }\n+byte[] data = node.binaryValue; data!= null) {\n             }\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "byte[] data = node.binaryValue; if (rhs == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-100/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\t2022-07-19 18:31:20.562017721 +0200\n+++ /tmp/tmpthemygqj.java\t2022-07-19 18:31:20.562017721 +0200\n@@ -358,19 +358,11 @@\n         // Multiple possibilities...\n         JsonNode n = currentNode();\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            byte[] data = n.binaryValue();\n-            if (data != null) {\n-                return data;\n-            }\n-            if (n.isPojo()) {\n-                Object ob = ((POJONode) n).getPojo();\n-                if (ob instanceof byte[]) {\n-                    return (byte[]) ob;\n-                }\n+byte[] data = node.binaryValue; if (rhs == null) {\n             }\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "byte[] data = n.binaryValue; if (ob instanceof byte[]) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-100/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\t2022-07-19 18:31:22.302007783 +0200\n+++ /tmp/tmpm0t2jo57.java\t2022-07-19 18:31:22.302007783 +0200\n@@ -358,19 +358,11 @@\n         // Multiple possibilities...\n         JsonNode n = currentNode();\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            byte[] data = n.binaryValue();\n-            if (data != null) {\n-                return data;\n-            }\n-            if (n.isPojo()) {\n-                Object ob = ((POJONode) n).getPojo();\n-                if (ob instanceof byte[]) {\n-                    return (byte[]) ob;\n-                }\n+byte[] data = n.binaryValue; if (ob instanceof byte[]) {\n             }\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "byte[] data = node.binaryValue; data == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-100/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\t2022-07-19 18:31:24.089997576 +0200\n+++ /tmp/tmpdfxn1tbd.java\t2022-07-19 18:31:24.089997576 +0200\n@@ -358,19 +358,11 @@\n         // Multiple possibilities...\n         JsonNode n = currentNode();\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            byte[] data = n.binaryValue();\n-            if (data != null) {\n-                return data;\n-            }\n-            if (n.isPojo()) {\n-                Object ob = ((POJONode) n).getPojo();\n-                if (ob instanceof byte[]) {\n-                    return (byte[]) ob;\n-                }\n+byte[] data = node.binaryValue; data == null) {\n             }\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "byte[] data = n.binaryValue; if (ob == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-100/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\t2022-07-19 18:31:25.781987919 +0200\n+++ /tmp/tmpqttd3jiw.java\t2022-07-19 18:31:25.781987919 +0200\n@@ -358,19 +358,11 @@\n         // Multiple possibilities...\n         JsonNode n = currentNode();\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            byte[] data = n.binaryValue();\n-            if (data != null) {\n-                return data;\n-            }\n-            if (n.isPojo()) {\n-                Object ob = ((POJONode) n).getPojo();\n-                if (ob instanceof byte[]) {\n-                    return (byte[]) ob;\n-                }\n+byte[] data = n.binaryValue; if (ob == null) {\n             }\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "byte[] data = n.binaryValue; data!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-100/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\t2022-07-19 18:31:27.497978129 +0200\n+++ /tmp/tmp7opauhn1.java\t2022-07-19 18:31:27.497978129 +0200\n@@ -358,19 +358,11 @@\n         // Multiple possibilities...\n         JsonNode n = currentNode();\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            byte[] data = n.binaryValue();\n-            if (data != null) {\n-                return data;\n-            }\n-            if (n.isPojo()) {\n-                Object ob = ((POJONode) n).getPojo();\n-                if (ob instanceof byte[]) {\n-                    return (byte[]) ob;\n-                }\n+byte[] data = n.binaryValue; data!= null) {\n             }\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "byte[] data = n.binaryValue; if (ob!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-100/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\t2022-07-19 18:31:29.205968386 +0200\n+++ /tmp/tmpl067xa9t.java\t2022-07-19 18:31:29.205968386 +0200\n@@ -358,19 +358,11 @@\n         // Multiple possibilities...\n         JsonNode n = currentNode();\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            byte[] data = n.binaryValue();\n-            if (data != null) {\n-                return data;\n-            }\n-            if (n.isPojo()) {\n-                Object ob = ((POJONode) n).getPojo();\n-                if (ob instanceof byte[]) {\n-                    return (byte[]) ob;\n-                }\n+byte[] data = n.binaryValue; if (ob!= null) {\n             }\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "byte[] data = n.binaryValue(); if (data != null) { return data; } if (n.isPojo()) { Object ob = ((POJONode) n).getPojo(); if (ob instanceof byte[]) { return (byte[]) ob; }",
        "fixed_line": "if (n instanceof TextNode) { return ((TextNode) n).getBinaryValue(b64variant); } return n.binaryValue();"
    },
    "JacksonDatabind-39": {
        "fixes": [
            {
                "k": 1,
                "patch": "// 29-Jan-2013, tatu: Simple skipping;",
                "patch_diff": "// 29-Jan-2013, tatu: Simple skipping;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// 29-Jan-2010, tatu: Simple skipping;",
                "patch_diff": "// 29-Jan-2010, tatu: Simple skipping;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// 29-Jan-2012, tatu: Simple skipping;",
                "patch_diff": "// 29-Jan-2012, tatu: Simple skipping;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// 29-Jan-2015, tatu: Simple skipping;",
                "patch_diff": "// 29-Jan-2015, tatu: Simple skipping;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// 29-Jan-2011, tatu: Simple skipping;",
                "patch_diff": "// 29-Jan-2011, tatu: Simple skipping;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// 29-Jan-2016, tatu: Simple skipping;",
                "patch_diff": "// 29-Jan-2016, tatu: Simple skipping;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// 29-Jan-2013, tatu: Simple skipping, but FIELD_NAME_FOR_EMPTY;",
                "patch_diff": "// 29-Jan-2013, tatu: Simple skipping, but FIELD_NAME_FOR_EMPTY;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// 29-Jan-2013, tatu: Simple skipping for all other",
                "patch_diff": "// 29-Jan-2013, tatu: Simple skipping for all other",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// 29-Jan-2012, tatu: Simple skipping, but FIELD_NAME_FOR_EMPTY;",
                "patch_diff": "// 29-Jan-2012, tatu: Simple skipping, but FIELD_NAME_FOR_EMPTY;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// 29-Jan-2013, tatu: Simple skipping for all",
                "patch_diff": "// 29-Jan-2013, tatu: Simple skipping for all",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (p.hasToken(JsonToken.FIELD_NAME)) { while (true) { JsonToken t = p.nextToken(); if ((t == null) || (t == JsonToken.END_OBJECT)) { break; } p.skipChildren(); } } else { p.skipChildren(); }"
    },
    "Cli-24": {
        "fixes": [
            {
                "k": 1,
                "patch": "throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"- no room for the description\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-24/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 18:31:33.021946631 +0200\n+++ /tmp/tmp0gsj5kn7.java\t2022-07-19 18:31:33.093946226 +0200\n@@ -820,12 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n-                                            \"- no room for the description\");\n+throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"- no room for the description\");\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "throw new IllegalStateException(\"Total width is less than the width of the argument argument and indent \" + \"- no room for the description\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-24/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 18:31:35.829930635 +0200\n+++ /tmp/tmpv09hb0tg.java\t2022-07-19 18:31:35.829930635 +0200\n@@ -820,12 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n-                                            \"- no room for the description\");\n+throw new IllegalStateException(\"Total width is less than the width of the argument argument and indent \" + \"- no room for the description\");\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "throw new IllegalStateException(\"Total width is less than the width of the argumentVars indent \" + \"- no room for the description\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-24/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 18:31:38.217917037 +0200\n+++ /tmp/tmptyhfa2t8.java\t2022-07-19 18:31:38.217917037 +0200\n@@ -820,12 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n-                                            \"- no room for the description\");\n+throw new IllegalStateException(\"Total width is less than the width of the argumentVars indent \" + \"- no room for the description\");\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"-cause room for the description\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-24/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 18:31:40.617903376 +0200\n+++ /tmp/tmpsxthxq6d.java\t2022-07-19 18:31:40.621903353 +0200\n@@ -820,12 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n-                                            \"- no room for the description\");\n+throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"-cause room for the description\");\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"- deserializer for the description\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-24/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 18:31:43.137889039 +0200\n+++ /tmp/tmp3sxbpqh5.java\t2022-07-19 18:31:43.141889016 +0200\n@@ -820,12 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n-                                            \"- no room for the description\");\n+throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"- deserializer for the description\");\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"-reed\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-24/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 18:31:45.657874707 +0200\n+++ /tmp/tmprzmq_oqa.java\t2022-07-19 18:31:45.657874707 +0200\n@@ -820,12 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n-                                            \"- no room for the description\");\n+throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"-reed\");\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"-p\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-24/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 18:31:48.185860338 +0200\n+++ /tmp/tmphqldb9lp.java\t2022-07-19 18:31:48.189860315 +0200\n@@ -820,12 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n-                                            \"- no room for the description\");\n+throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"-p\");\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"- no room for the number\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-24/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 18:31:50.797845497 +0200\n+++ /tmp/tmp_b70r66g.java\t2022-07-19 18:31:50.801845474 +0200\n@@ -820,12 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n-                                            \"- no room for the description\");\n+throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"- no room for the number\");\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"-X\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-24/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 18:31:53.373830867 +0200\n+++ /tmp/tmpx1x6tjtg.java\t2022-07-19 18:31:53.373830867 +0200\n@@ -820,12 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n-                                            \"- no room for the description\");\n+throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"-X\");\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"-VIVI for the description\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-24/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 18:31:55.853816789 +0200\n+++ /tmp/tmp52fvu17i.java\t2022-07-19 18:31:55.853816789 +0200\n@@ -820,12 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n-                                            \"- no room for the description\");\n+throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"-VIVI for the description\");\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"- no room for the description\");",
        "fixed_line": "nextLineTabStop = width - 1;"
    },
    "JxPath-22": {
        "fixes": [
            {
                "k": 1,
                "patch": "return aNode = node.getValueParentNode.getParentNode(); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-22/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-19 18:31:58.697800655 +0200\n+++ /tmp/tmp9sm8m3_6.java\t2022-07-19 18:31:58.745800381 +0200\n@@ -684,18 +684,11 @@\n             Node aNode = node;\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                     if (attr != null) {\n-                        return attr.getValue();\n-                    }\n-                }\n-                aNode = aNode.getParentNode();\n-            }\n-            return null;\n-        }\n-        return uri;\n+return aNode = node.getValueParentNode.getParentNode(); }\n     }\n \n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return aNode = node.getValueParentNode; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-22/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-19 18:32:00.785788811 +0200\n+++ /tmp/tmppcoi8olc.java\t2022-07-19 18:32:00.785788811 +0200\n@@ -684,18 +684,11 @@\n             Node aNode = node;\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                     if (attr != null) {\n-                        return attr.getValue();\n-                    }\n-                }\n-                aNode = aNode.getParentNode();\n-            }\n-            return null;\n-        }\n-        return uri;\n+return aNode = node.getValueParentNode; }\n     }\n \n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return aNode = node.getValueParentNode.getParentNode; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-22/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-19 18:32:02.417779558 +0200\n+++ /tmp/tmpbnfbdu29.java\t2022-07-19 18:32:02.417779558 +0200\n@@ -684,18 +684,11 @@\n             Node aNode = node;\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                     if (attr != null) {\n-                        return attr.getValue();\n-                    }\n-                }\n-                aNode = aNode.getParentNode();\n-            }\n-            return null;\n-        }\n-        return uri;\n+return aNode = node.getValueParentNode.getParentNode; }\n     }\n \n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return aNode = aNode.getParentNode; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-22/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-19 18:32:04.081770126 +0200\n+++ /tmp/tmpgfuq2ubl.java\t2022-07-19 18:32:04.081770126 +0200\n@@ -684,18 +684,11 @@\n             Node aNode = node;\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                     if (attr != null) {\n-                        return attr.getValue();\n-                    }\n-                }\n-                aNode = aNode.getParentNode();\n-            }\n-            return null;\n-        }\n-        return uri;\n+return aNode = aNode.getParentNode; }\n     }\n \n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return aNode = node.getParentNode; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-22/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-19 18:32:05.757760629 +0200\n+++ /tmp/tmpvsqy9viu.java\t2022-07-19 18:32:05.785760470 +0200\n@@ -684,18 +684,11 @@\n             Node aNode = node;\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                     if (attr != null) {\n-                        return attr.getValue();\n-                    }\n-                }\n-                aNode = aNode.getParentNode();\n-            }\n-            return null;\n-        }\n-        return uri;\n+return aNode = node.getParentNode; }\n     }\n \n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return aNode = aNode.getParentNode(); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-22/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-19 18:32:07.425751181 +0200\n+++ /tmp/tmpk2jtmog5.java\t2022-07-19 18:32:07.429751158 +0200\n@@ -684,18 +684,11 @@\n             Node aNode = node;\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                     if (attr != null) {\n-                        return attr.getValue();\n-                    }\n-                }\n-                aNode = aNode.getParentNode();\n-            }\n-            return null;\n-        }\n-        return uri;\n+return aNode = aNode.getParentNode(); }\n     }\n \n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return aNode = node.getParentNode(); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-22/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-19 18:32:09.017742164 +0200\n+++ /tmp/tmpjefqe5oe.java\t2022-07-19 18:32:09.017742164 +0200\n@@ -684,18 +684,11 @@\n             Node aNode = node;\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                     if (attr != null) {\n-                        return attr.getValue();\n-                    }\n-                }\n-                aNode = aNode.getParentNode();\n-            }\n-            return null;\n-        }\n-        return uri;\n+return aNode = node.getParentNode(); }\n     }\n \n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return aNode = node.getParentNode.getParentNode(); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-22/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-19 18:32:10.601733196 +0200\n+++ /tmp/tmp6q77rxm7.java\t2022-07-19 18:32:10.601733196 +0200\n@@ -684,18 +684,11 @@\n             Node aNode = node;\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                     if (attr != null) {\n-                        return attr.getValue();\n-                    }\n-                }\n-                aNode = aNode.getParentNode();\n-            }\n-            return null;\n-        }\n-        return uri;\n+return aNode = node.getParentNode.getParentNode(); }\n     }\n \n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return aNode = node.getValueParentNode(); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-22/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-19 18:32:12.181724254 +0200\n+++ /tmp/tmp26pg8238.java\t2022-07-19 18:32:12.181724254 +0200\n@@ -684,18 +684,11 @@\n             Node aNode = node;\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                     if (attr != null) {\n-                        return attr.getValue();\n-                    }\n-                }\n-                aNode = aNode.getParentNode();\n-            }\n-            return null;\n-        }\n-        return uri;\n+return aNode = node.getValueParentNode(); }\n     }\n \n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return aNode = aNode.getValueParentNode; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JxPath-22/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-19 18:32:13.785715178 +0200\n+++ /tmp/tmpd411_1ud.java\t2022-07-19 18:32:13.785715178 +0200\n@@ -684,18 +684,11 @@\n             Node aNode = node;\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                     if (attr != null) {\n-                        return attr.getValue();\n-                    }\n-                }\n-                aNode = aNode.getParentNode();\n-            }\n-            return null;\n-        }\n-        return uri;\n+return aNode = aNode.getValueParentNode; }\n     }\n \n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return attr.getValue(); } } aNode = aNode.getParentNode(); } return null; } return uri;",
        "fixed_line": "uri = attr.getValue(); break; } } aNode = aNode.getParentNode(); } } return \"\".equals(uri) ? null : uri;"
    },
    "Closure-172": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (qName!= null && qName.endsWith(\".prototype) {",
                "patch_diff": "if (qName!= null && qName.endsWith(\".prototype) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (qName == null || qName.endsWith(\".prototype) {",
                "patch_diff": "if (qName == null || qName.endsWith(\".prototype) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (qName == null || qName.endsWith(\".prototype\")) {",
                "patch_diff": "if (qName == null || qName.endsWith(\".prototype\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (qName!= null && s.endsWith(\".prototype) {",
                "patch_diff": "if (qName!= null && s.endsWith(\".prototype) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (qName == null && qName.hasType() == null) {",
                "patch_diff": "if (qName == null && qName.hasType() == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (qName!= null && qName.hasType() == null) {",
                "patch_diff": "if (qName!= null && qName.hasType() == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (qName!= null && value.endsWith(\".prototype) {",
                "patch_diff": "if (qName!= null && value.endsWith(\".prototype) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (qName!= null && qName.endsWith(\".prototype\")) {",
                "patch_diff": "if (qName!= null && qName.endsWith(\".prototype\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (qName!= null && qName.hasType) {",
                "patch_diff": "if (qName!= null && qName.hasType) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (qName!= null && isExtern) {",
                "patch_diff": "if (qName!= null && isExtern) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "String className = qName.substring(0, qName.lastIndexOf(\".prototype\")); Var slot = scope.getSlot(className); JSType classType = slot == null ? null : slot.getType(); if (classType != null && (classType.isConstructor() || classType.isInterface())) { return false; }"
    },
    "Chart-9": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (endIndex < 0) { // end period is negative",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-9/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 18:32:17.305695268 +0200\n+++ /tmp/tmpp17efi3v.java\t2022-07-19 18:32:17.333695110 +0200\n@@ -939,11 +939,11 @@\n         int endIndex = getIndex(end);\n         if (endIndex < 0) {             // end period is not in original series\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+if (endIndex < 0) { // end period is negative\n             emptyRange = true;\n         }\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (endIndex < 0) { // end period is not in original series",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-9/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 18:32:29.517626287 +0200\n+++ /tmp/tmp1u_5ronm.java\t2022-07-19 18:32:29.517626287 +0200\n@@ -939,11 +939,11 @@\n         int endIndex = getIndex(end);\n         if (endIndex < 0) {             // end period is not in original series\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+if (endIndex < 0) { // end period is not in original series\n             emptyRange = true;\n         }\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (endIndex < 0) { // end period is first item AFTER end",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-9/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 18:32:37.765579778 +0200\n+++ /tmp/tmp4f9y0hw_.java\t2022-07-19 18:32:37.769579755 +0200\n@@ -939,11 +939,11 @@\n         int endIndex = getIndex(end);\n         if (endIndex < 0) {             // end period is not in original series\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+if (endIndex < 0) { // end period is first item AFTER end\n             emptyRange = true;\n         }\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (endIndex < 0) { // start is not in original series",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-9/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 18:32:47.901522705 +0200\n+++ /tmp/tmpvtz9d2a2.java\t2022-07-19 18:32:47.901522705 +0200\n@@ -939,11 +939,11 @@\n         int endIndex = getIndex(end);\n         if (endIndex < 0) {             // end period is not in original series\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+if (endIndex < 0) { // start is not in original series\n             emptyRange = true;\n         }\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (endIndex < 0) { // end period is a end period",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-9/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 18:32:59.841455596 +0200\n+++ /tmp/tmp45thswe6.java\t2022-07-19 18:32:59.845455573 +0200\n@@ -939,11 +939,11 @@\n         int endIndex = getIndex(end);\n         if (endIndex < 0) {             // end period is not in original series\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+if (endIndex < 0) { // end period is a end period\n             emptyRange = true;\n         }\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (startIndex < 0) { // end period is not in original series",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-9/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 18:33:10.365396549 +0200\n+++ /tmp/tmpqp8dzbn2.java\t2022-07-19 18:33:10.365396549 +0200\n@@ -939,11 +939,11 @@\n         int endIndex = getIndex(end);\n         if (endIndex < 0) {             // end period is not in original series\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+if (startIndex < 0) { // end period is not in original series\n             emptyRange = true;\n         }\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (endIndex < 0) { // end period is last item BEFORE end",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-9/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 18:33:20.965337172 +0200\n+++ /tmp/tmpy2mewq0k.java\t2022-07-19 18:33:20.965337172 +0200\n@@ -939,11 +939,11 @@\n         int endIndex = getIndex(end);\n         if (endIndex < 0) {             // end period is not in original series\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+if (endIndex < 0) { // end period is last item BEFORE end\n             emptyRange = true;\n         }\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (lastIndex < 0) { // end period is negative",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-9/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 18:33:31.357279051 +0200\n+++ /tmp/tmpctgmr476.java\t2022-07-19 18:33:31.357279051 +0200\n@@ -939,11 +939,11 @@\n         int endIndex = getIndex(end);\n         if (endIndex < 0) {             // end period is not in original series\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+if (lastIndex < 0) { // end period is negative\n             emptyRange = true;\n         }\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (lastIndex < 0) { // start is not in original series",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-9/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 18:33:35.137257932 +0200\n+++ /tmp/tmp_ea1o0q0.java\t2022-07-19 18:33:35.137257932 +0200\n@@ -939,11 +939,11 @@\n         int endIndex = getIndex(end);\n         if (endIndex < 0) {             // end period is not in original series\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+if (lastIndex < 0) { // start is not in original series\n             emptyRange = true;\n         }\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (startIndex < 0) { // end period is negative",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-9/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 18:33:37.305245827 +0200\n+++ /tmp/tmp8la6c_ro.java\t2022-07-19 18:33:37.305245827 +0200\n@@ -939,11 +939,11 @@\n         int endIndex = getIndex(end);\n         if (endIndex < 0) {             // end period is not in original series\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+if (startIndex < 0) { // end period is negative\n             emptyRange = true;\n         }\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (endIndex < 0) {",
        "fixed_line": "if ((endIndex < 0) || (endIndex < startIndex)) {"
    },
    "Jsoup-8": {
        "fixes": [
            {
                "k": 1,
                "patch": "new NodeTraversorVisitor(accum, ownerDocument().outputSettings())).traverse( accum);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-8/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 18:33:48.837181490 +0200\n+++ /tmp/tmpkmbo3p5z.java\t2022-07-19 18:33:50.157174134 +0200\n@@ -358,11 +358,11 @@\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n     protected void outerHtml(StringBuilder accum) {\n-        new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n+new NodeTraversorVisitor(accum, ownerDocument().outputSettings())).traverse( accum);\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "new NodeTraversorVisitor(accum, ownerDocument().outputSettings())).traverse( accum;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-8/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 18:33:52.909158800 +0200\n+++ /tmp/tmp7h5k7qdj.java\t2022-07-19 18:33:52.909158800 +0200\n@@ -358,11 +358,11 @@\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n     protected void outerHtml(StringBuilder accum) {\n-        new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n+new NodeTraversorVisitor(accum, ownerDocument().outputSettings())).traverse( accum;\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "new NodeTraversorVisitor(accum, binarySearch().outputSettings())).traverse( accum);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-8/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 18:33:55.933141956 +0200\n+++ /tmp/tmpb39leg5q.java\t2022-07-19 18:33:55.977141711 +0200\n@@ -358,11 +358,11 @@\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n     protected void outerHtml(StringBuilder accum) {\n-        new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n+new NodeTraversorVisitor(accum, binarySearch().outputSettings())).traverse( accum);\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "new NodeTraversorVisitor(accum, binarySearch().outputSettings())).traverse( accum;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-8/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 18:33:58.857125678 +0200\n+++ /tmp/tmp9241lwpy.java\t2022-07-19 18:33:58.861125655 +0200\n@@ -358,11 +358,11 @@\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n     protected void outerHtml(StringBuilder accum) {\n-        new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n+new NodeTraversorVisitor(accum, binarySearch().outputSettings())).traverse( accum;\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "new NodeTraversor(accum, ownerDocument().outputSettings())).traverse( accum);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-8/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 18:34:01.757109539 +0200\n+++ /tmp/tmpxgo5x12r.java\t2022-07-19 18:34:01.857108985 +0200\n@@ -358,11 +358,11 @@\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n     protected void outerHtml(StringBuilder accum) {\n-        new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n+new NodeTraversor(accum, ownerDocument().outputSettings())).traverse( accum);\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "new NodeTraversor(accum,Insert().outputSettings())).traverse( accum);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-8/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 18:34:04.341095165 +0200\n+++ /tmp/tmpvd5b2yb_.java\t2022-07-19 18:34:04.341095165 +0200\n@@ -358,11 +358,11 @@\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n     protected void outerHtml(StringBuilder accum) {\n-        new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n+new NodeTraversor(accum,Insert().outputSettings())).traverse( accum);\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "new NodeTraversor(accum, ownerDocument().outputSettings())).traverse( accum;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-8/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 18:34:06.417083619 +0200\n+++ /tmp/tmphbf4rwp6.java\t2022-07-19 18:34:06.417083619 +0200\n@@ -358,11 +358,11 @@\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n     protected void outerHtml(StringBuilder accum) {\n-        new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n+new NodeTraversor(accum, ownerDocument().outputSettings())).traverse( accum;\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "new NodeTraversor(accum,Insert().outputSettings())).traverse( accum;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-8/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 18:34:09.049068988 +0200\n+++ /tmp/tmp0keqeays.java\t2022-07-19 18:34:09.049068988 +0200\n@@ -358,11 +358,11 @@\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n     protected void outerHtml(StringBuilder accum) {\n-        new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n+new NodeTraversor(accum,Insert().outputSettings())).traverse( accum;\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "new NodeTraversor(accum, binarySearch().outputSettings())).traverse( accum);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-8/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 18:34:12.829047982 +0200\n+++ /tmp/tmprw6hx3sm.java\t2022-07-19 18:34:12.829047982 +0200\n@@ -358,11 +358,11 @@\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n     protected void outerHtml(StringBuilder accum) {\n-        new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n+new NodeTraversor(accum, binarySearch().outputSettings())).traverse( accum);\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "new NodeTraversor(accum, binarySearch().outputSettings())).traverse( accum;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-8/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 18:34:15.597032607 +0200\n+++ /tmp/tmpf1zaqvrl.java\t2022-07-19 18:34:15.597032607 +0200\n@@ -358,11 +358,11 @@\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n     protected void outerHtml(StringBuilder accum) {\n-        new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n+new NodeTraversor(accum, binarySearch().outputSettings())).traverse( accum;\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);",
        "fixed_line": "new NodeTraversor(new OuterHtmlVisitor(accum, getOutputSettings())).traverse(this); } // if this node has no document (or parent), retrieve the default output settings private Document.OutputSettings getOutputSettings() { return ownerDocument() != null ? ownerDocument().outputSettings() : (new Document(\"\")).outputSettings(); }"
    },
    "Csv-4": {
        "fixes": [
            {
                "k": 1,
                "patch": "return new LinkedHashMap<String, Integer>(parent.headerMap, Integer.MAX_VALUE);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-4/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 18:34:18.061018930 +0200\n+++ /tmp/tmp9e133eyn.java\t2022-07-19 18:34:18.377017173 +0200\n@@ -283,11 +283,11 @@\n      * The map keys are column names. The map values are 0-based indices.\n      * </p>\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+return new LinkedHashMap<String, Integer>(parent.headerMap, Integer.MAX_VALUE);\n     }\n \n     /**\n      * Returns the current record number in the input stream.\n      * <p/>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return new LinkedHashMap<String, Integer>(headerMap, Integer.MAX_VALUE);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-4/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 18:34:20.369006117 +0200\n+++ /tmp/tmp0qlzmbxw.java\t2022-07-19 18:34:20.369006117 +0200\n@@ -283,11 +283,11 @@\n      * The map keys are column names. The map values are 0-based indices.\n      * </p>\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+return new LinkedHashMap<String, Integer>(headerMap, Integer.MAX_VALUE);\n     }\n \n     /**\n      * Returns the current record number in the input stream.\n      * <p/>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return new LinkedHashMap<String, Integer>(parent.headerMap);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-4/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 18:34:22.200995950 +0200\n+++ /tmp/tmpmw7cwl18.java\t2022-07-19 18:34:22.200995950 +0200\n@@ -283,11 +283,11 @@\n      * The map keys are column names. The map values are 0-based indices.\n      * </p>\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+return new LinkedHashMap<String, Integer>(parent.headerMap);\n     }\n \n     /**\n      * Returns the current record number in the input stream.\n      * <p/>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return new LinkedHashMap<String, Integer>(parent.headerMap;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-4/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 18:34:24.108985365 +0200\n+++ /tmp/tmps31s_vrm.java\t2022-07-19 18:34:24.112985345 +0200\n@@ -283,11 +283,11 @@\n      * The map keys are column names. The map values are 0-based indices.\n      * </p>\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+return new LinkedHashMap<String, Integer>(parent.headerMap;\n     }\n \n     /**\n      * Returns the current record number in the input stream.\n      * <p/>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return new LinkedHashMap<String, Integer>(this.headerMap, Integer.MAX_VALUE)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-4/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 18:34:25.548977380 +0200\n+++ /tmp/tmp74si46dn.java\t2022-07-19 18:34:25.548977380 +0200\n@@ -283,11 +283,11 @@\n      * The map keys are column names. The map values are 0-based indices.\n      * </p>\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+return new LinkedHashMap<String, Integer>(this.headerMap, Integer.MAX_VALUE)\n     }\n \n     /**\n      * Returns the current record number in the input stream.\n      * <p/>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return new LinkedHashMap<String, Integer>(this.headerMap, Integer.MAX_VALUE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-4/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 18:34:27.084968862 +0200\n+++ /tmp/tmp1qswitri.java\t2022-07-19 18:34:27.084968862 +0200\n@@ -283,11 +283,11 @@\n      * The map keys are column names. The map values are 0-based indices.\n      * </p>\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+return new LinkedHashMap<String, Integer>(this.headerMap, Integer.MAX_VALUE;\n     }\n \n     /**\n      * Returns the current record number in the input stream.\n      * <p/>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return new LinkedHashMap<String, Integer>(this.headerMap, Integer.MAX_VALUE);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-4/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 18:34:28.792959393 +0200\n+++ /tmp/tmpjz2obats.java\t2022-07-19 18:34:28.792959393 +0200\n@@ -283,11 +283,11 @@\n      * The map keys are column names. The map values are 0-based indices.\n      * </p>\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+return new LinkedHashMap<String, Integer>(this.headerMap, Integer.MAX_VALUE);\n     }\n \n     /**\n      * Returns the current record number in the input stream.\n      * <p/>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return new LinkedHashMap<String, Integer>(headerMap);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-4/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 18:34:30.532949749 +0200\n+++ /tmp/tmpvzwdx5ta.java\t2022-07-19 18:34:30.532949749 +0200\n@@ -283,11 +283,11 @@\n      * The map keys are column names. The map values are 0-based indices.\n      * </p>\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+return new LinkedHashMap<String, Integer>(headerMap);\n     }\n \n     /**\n      * Returns the current record number in the input stream.\n      * <p/>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return new LinkedHashMap<String, Integer>(headerMap;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-4/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 18:34:33.660932415 +0200\n+++ /tmp/tmpwxana_j4.java\t2022-07-19 18:34:33.660932415 +0200\n@@ -283,11 +283,11 @@\n      * The map keys are column names. The map values are 0-based indices.\n      * </p>\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+return new LinkedHashMap<String, Integer>(headerMap;\n     }\n \n     /**\n      * Returns the current record number in the input stream.\n      * <p/>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return new LinkedHashMap<String, Integer>(parent.headerMap, Integer.MAX_VALUE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Csv-4/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 18:34:35.296923354 +0200\n+++ /tmp/tmpr597ldi4.java\t2022-07-19 18:34:35.296923354 +0200\n@@ -283,11 +283,11 @@\n      * The map keys are column names. The map values are 0-based indices.\n      * </p>\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+return new LinkedHashMap<String, Integer>(parent.headerMap, Integer.MAX_VALUE;\n     }\n \n     /**\n      * Returns the current record number in the input stream.\n      * <p/>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return new LinkedHashMap<String, Integer>(this.headerMap);",
        "fixed_line": "return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);"
    },
    "Jsoup-1": {
        "fixes": [
            {
                "k": 1,
                "patch": "body.appendChild(new TextNode(\" \", \" + node);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-1/src/main/java/org/jsoup/nodes/Document.java\t2022-07-19 18:34:37.124913231 +0200\n+++ /tmp/tmpncou3xpu.java\t2022-07-19 18:34:37.208912765 +0200\n@@ -120,12 +120,11 @@\n             }\n         }\n \n         for (Node node: toMove) {\n             element.removeChild(node);\n-            body().appendChild(new TextNode(\" \", \"\"));\n-            body().appendChild(node);\n+body.appendChild(new TextNode(\" \", \" + node);\n         }\n     }\n \n     @Override\n     public String outerHtml() {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "body().appendChild(new TextNode(\" \", \" + node);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-1/src/main/java/org/jsoup/nodes/Document.java\t2022-07-19 18:34:39.132902112 +0200\n+++ /tmp/tmp7hrpy4uu.java\t2022-07-19 18:34:39.132902112 +0200\n@@ -120,12 +120,11 @@\n             }\n         }\n \n         for (Node node: toMove) {\n             element.removeChild(node);\n-            body().appendChild(new TextNode(\" \", \"\"));\n-            body().appendChild(node);\n+body().appendChild(new TextNode(\" \", \" + node);\n         }\n     }\n \n     @Override\n     public String outerHtml() {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "body().appendChild(new TextNode(\" \", \" + node;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-1/src/main/java/org/jsoup/nodes/Document.java\t2022-07-19 18:34:40.800892879 +0200\n+++ /tmp/tmp592qzr7i.java\t2022-07-19 18:34:40.800892879 +0200\n@@ -120,12 +120,11 @@\n             }\n         }\n \n         for (Node node: toMove) {\n             element.removeChild(node);\n-            body().appendChild(new TextNode(\" \", \"\"));\n-            body().appendChild(node);\n+body().appendChild(new TextNode(\" \", \" + node;\n         }\n     }\n \n     @Override\n     public String outerHtml() {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "body.appendChild(new TextNode(\" \", \" + node;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-1/src/main/java/org/jsoup/nodes/Document.java\t2022-07-19 18:34:42.212885067 +0200\n+++ /tmp/tmps3xqy52l.java\t2022-07-19 18:34:42.212885067 +0200\n@@ -120,12 +120,11 @@\n             }\n         }\n \n         for (Node node: toMove) {\n             element.removeChild(node);\n-            body().appendChild(new TextNode(\" \", \"\"));\n-            body().appendChild(node);\n+body.appendChild(new TextNode(\" \", \" + node;\n         }\n     }\n \n     @Override\n     public String outerHtml() {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "body.appendChild(new TextNode(\" \", \" + body; node);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-1/src/main/java/org/jsoup/nodes/Document.java\t2022-07-19 18:34:43.840876058 +0200\n+++ /tmp/tmpy4t3rci_.java\t2022-07-19 18:34:43.840876058 +0200\n@@ -120,12 +120,11 @@\n             }\n         }\n \n         for (Node node: toMove) {\n             element.removeChild(node);\n-            body().appendChild(new TextNode(\" \", \"\"));\n-            body().appendChild(node);\n+body.appendChild(new TextNode(\" \", \" + body; node);\n         }\n     }\n \n     @Override\n     public String outerHtml() {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "body().appendChild(new TextNode(\" \", \" + body; node);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-1/src/main/java/org/jsoup/nodes/Document.java\t2022-07-19 18:34:45.552866589 +0200\n+++ /tmp/tmplbmumcit.java\t2022-07-19 18:34:45.552866589 +0200\n@@ -120,12 +120,11 @@\n             }\n         }\n \n         for (Node node: toMove) {\n             element.removeChild(node);\n-            body().appendChild(new TextNode(\" \", \"\"));\n-            body().appendChild(node);\n+body().appendChild(new TextNode(\" \", \" + body; node);\n         }\n     }\n \n     @Override\n     public String outerHtml() {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "body().appendChild(new TextNode(\"2), \"\"));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-1/src/main/java/org/jsoup/nodes/Document.java\t2022-07-19 18:34:47.104858004 +0200\n+++ /tmp/tmpap7ys95l.java\t2022-07-19 18:34:47.104858004 +0200\n@@ -120,12 +120,11 @@\n             }\n         }\n \n         for (Node node: toMove) {\n             element.removeChild(node);\n-            body().appendChild(new TextNode(\" \", \"\"));\n-            body().appendChild(node);\n+body().appendChild(new TextNode(\"2), \"\"));\n         }\n     }\n \n     @Override\n     public String outerHtml() {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "body().appendChild(new TextNode(\"\"));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-1/src/main/java/org/jsoup/nodes/Document.java\t2022-07-19 18:34:48.780848736 +0200\n+++ /tmp/tmp41qd_iaq.java\t2022-07-19 18:34:48.780848736 +0200\n@@ -120,12 +120,11 @@\n             }\n         }\n \n         for (Node node: toMove) {\n             element.removeChild(node);\n-            body().appendChild(new TextNode(\" \", \"\"));\n-            body().appendChild(node);\n+body().appendChild(new TextNode(\"\"));\n         }\n     }\n \n     @Override\n     public String outerHtml() {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "body.appendChild(new TextNode(\"\"));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-1/src/main/java/org/jsoup/nodes/Document.java\t2022-07-19 18:34:50.432839604 +0200\n+++ /tmp/tmpql93ry1t.java\t2022-07-19 18:34:50.432839604 +0200\n@@ -120,12 +120,11 @@\n             }\n         }\n \n         for (Node node: toMove) {\n             element.removeChild(node);\n-            body().appendChild(new TextNode(\" \", \"\"));\n-            body().appendChild(node);\n+body.appendChild(new TextNode(\"\"));\n         }\n     }\n \n     @Override\n     public String outerHtml() {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "body().appendChild(node, new TextNode(\"\"));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-1/src/main/java/org/jsoup/nodes/Document.java\t2022-07-19 18:34:52.188829897 +0200\n+++ /tmp/tmpn0n_p_02.java\t2022-07-19 18:34:52.192829877 +0200\n@@ -120,12 +120,11 @@\n             }\n         }\n \n         for (Node node: toMove) {\n             element.removeChild(node);\n-            body().appendChild(new TextNode(\" \", \"\"));\n-            body().appendChild(node);\n+body().appendChild(node, new TextNode(\"\"));\n         }\n     }\n \n     @Override\n     public String outerHtml() {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "body().appendChild(new TextNode(\" \", \"\")); body().appendChild(node);",
        "fixed_line": "body().prependChild(node); body().prependChild(new TextNode(\" \", \"\"));"
    },
    "Closure-111": {
        "fixes": [
            {
                "k": 1,
                "patch": "return thisType topType.NONE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-111/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\t2022-07-19 18:34:54.008819841 +0200\n+++ /tmp/tmpfols7elg.java\t2022-07-19 18:34:54.084819421 +0200\n@@ -49,11 +49,11 @@\n    */\n   private final Visitor<JSType> restrictToArrayVisitor =\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType;\n+return thisType topType.NONE;\n         }\n \n         @Override\n         public JSType caseObjectType(ObjectType type) {\n           JSType arrayType = getNativeType(ARRAY_TYPE);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return topType.NONE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-111/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\t2022-07-19 18:34:59.200791164 +0200\n+++ /tmp/tmpkc390lmm.java\t2022-07-19 18:34:59.200791164 +0200\n@@ -49,11 +49,11 @@\n    */\n   private final Visitor<JSType> restrictToArrayVisitor =\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType;\n+return topType.NONE;\n         }\n \n         @Override\n         public JSType caseObjectType(ObjectType type) {\n           JSType arrayType = getNativeType(ARRAY_TYPE);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return this.rightType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-111/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\t2022-07-19 18:35:03.052769899 +0200\n+++ /tmp/tmp1nw3_tpk.java\t2022-07-19 18:35:03.052769899 +0200\n@@ -49,11 +49,11 @@\n    */\n   private final Visitor<JSType> restrictToArrayVisitor =\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType;\n+return this.rightType;\n         }\n \n         @Override\n         public JSType caseObjectType(ObjectType type) {\n           JSType arrayType = getNativeType(ARRAY_TYPE);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return this.topType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-111/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\t2022-07-19 18:35:06.848748956 +0200\n+++ /tmp/tmp2x8ftxgr.java\t2022-07-19 18:35:06.848748956 +0200\n@@ -49,11 +49,11 @@\n    */\n   private final Visitor<JSType> restrictToArrayVisitor =\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType;\n+return this.topType;\n         }\n \n         @Override\n         public JSType caseObjectType(ObjectType type) {\n           JSType arrayType = getNativeType(ARRAY_TYPE);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return thisType topType.rightType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-111/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\t2022-07-19 18:35:10.688727779 +0200\n+++ /tmp/tmp8pib63jb.java\t2022-07-19 18:35:10.688727779 +0200\n@@ -49,11 +49,11 @@\n    */\n   private final Visitor<JSType> restrictToArrayVisitor =\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType;\n+return thisType topType.rightType;\n         }\n \n         @Override\n         public JSType caseObjectType(ObjectType type) {\n           JSType arrayType = getNativeType(ARRAY_TYPE);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return topType.rightType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-111/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\t2022-07-19 18:35:14.344707623 +0200\n+++ /tmp/tmpt_h09pmh.java\t2022-07-19 18:35:14.344707623 +0200\n@@ -49,11 +49,11 @@\n    */\n   private final Visitor<JSType> restrictToArrayVisitor =\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType;\n+return topType.rightType;\n         }\n \n         @Override\n         public JSType caseObjectType(ObjectType type) {\n           JSType arrayType = getNativeType(ARRAY_TYPE);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return thisType topType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-111/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\t2022-07-19 18:35:18.116686842 +0200\n+++ /tmp/tmpsbndmurh.java\t2022-07-19 18:35:18.116686842 +0200\n@@ -49,11 +49,11 @@\n    */\n   private final Visitor<JSType> restrictToArrayVisitor =\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType;\n+return thisType topType;\n         }\n \n         @Override\n         public JSType caseObjectType(ObjectType type) {\n           JSType arrayType = getNativeType(ARRAY_TYPE);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return this.bottomType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-111/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\t2022-07-19 18:35:21.988665516 +0200\n+++ /tmp/tmps4yixz3x.java\t2022-07-19 18:35:21.992665493 +0200\n@@ -49,11 +49,11 @@\n    */\n   private final Visitor<JSType> restrictToArrayVisitor =\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType;\n+return this.bottomType;\n         }\n \n         @Override\n         public JSType caseObjectType(ObjectType type) {\n           JSType arrayType = getNativeType(ARRAY_TYPE);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return thisType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-111/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\t2022-07-19 18:35:25.840644313 +0200\n+++ /tmp/tmpdbgin2we.java\t2022-07-19 18:35:25.840644313 +0200\n@@ -49,11 +49,11 @@\n    */\n   private final Visitor<JSType> restrictToArrayVisitor =\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType;\n+return thisType;\n         }\n \n         @Override\n         public JSType caseObjectType(ObjectType type) {\n           JSType arrayType = getNativeType(ARRAY_TYPE);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return topType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-111/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\t2022-07-19 18:35:29.476624306 +0200\n+++ /tmp/tmpn_mtj27_.java\t2022-07-19 18:35:29.476624306 +0200\n@@ -49,11 +49,11 @@\n    */\n   private final Visitor<JSType> restrictToArrayVisitor =\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType;\n+return topType;\n         }\n \n         @Override\n         public JSType caseObjectType(ObjectType type) {\n           JSType arrayType = getNativeType(ARRAY_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return topType;",
        "fixed_line": "return topType.isAllType() ? getNativeType(ARRAY_TYPE) : topType;"
    },
    "JacksonCore-7": {
        "fixes": [
            {
                "k": 1,
                "patch": "int writeValueName = _type == TYPE_OBJECT; return STATUS_OK_AFTER_COLON;",
                "patch_diff": "int writeValueName = _type == TYPE_OBJECT; return STATUS_OK_AFTER_COLON;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// Most likely, object: if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_",
                "patch_diff": "// Most likely, object: if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// Most likely, object: if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } }",
                "patch_diff": "// Most likely, object: if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// Most likely, object: if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_",
                "patch_diff": "// Most likely, object: if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// Most likely, object: if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } }",
                "patch_diff": "// Most likely, object: if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// Most likely, object: if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; return STATUS_OK_AFTER_COLON; } }",
                "patch_diff": "// Most likely, object: if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; return STATUS_OK_AFTER_COLON; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// Most likely, object: if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } ++_index; return STATUS_OK_AFTER_COLON; }",
                "patch_diff": "// Most likely, object: if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } ++_index; return STATUS_OK_AFTER_COLON; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// Most likely, object: if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } ++_index; return STATUS_OK_AFTER_COLON; }",
                "patch_diff": "// Most likely, object: if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } ++_index; return STATUS_OK_AFTER_COLON; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// Most likely, object: if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; return STATUS_OK_AFTER_COLON; } }",
                "patch_diff": "// Most likely, object: if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; return STATUS_OK_AFTER_COLON; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// Most likely, object: if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } }",
                "patch_diff": "// Most likely, object: if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } else if (_type == TYPE_OBJECT) { return STATUS_OK_AFTER_COLON; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (!_gotName) { return STATUS_EXPECT_NAME; }"
    },
    "Math-85": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (fa * fb > 0.0 ) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2022-07-19 18:36:26.564311295 +0200\n+++ /tmp/tmpe20fcfbb.java\t2022-07-19 18:36:26.588311162 +0200\n@@ -193,11 +193,11 @@\n             fb = function.value(b);\n             numIterations++ ;\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+if (fa * fb > 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n                       numIterations, maximumIterations, initial,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 2,
                "patch": "if (fa * fb > 0.0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2022-07-19 18:36:35.132264486 +0200\n+++ /tmp/tmp85nnexgk.java\t2022-07-19 18:36:35.132264486 +0200\n@@ -193,11 +193,11 @@\n             fb = function.value(b);\n             numIterations++ ;\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+if (fa * fb > 0.0) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n                       numIterations, maximumIterations, initial,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 3,
                "patch": "if (fafa * fb >= 0.0 ) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2022-07-19 18:36:41.740228415 +0200\n+++ /tmp/tmpsjejkudo.java\t2022-07-19 18:36:41.740228415 +0200\n@@ -193,11 +193,11 @@\n             fb = function.value(b);\n             numIterations++ ;\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+if (fafa * fb >= 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n                       numIterations, maximumIterations, initial,\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (fa * fb!= 0.0 ) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2022-07-19 18:36:43.928216479 +0200\n+++ /tmp/tmpywp_m3yo.java\t2022-07-19 18:36:43.928216479 +0200\n@@ -193,11 +193,11 @@\n             fb = function.value(b);\n             numIterations++ ;\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+if (fa * fb!= 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n                       numIterations, maximumIterations, initial,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (fa * fb >= 0.0 ) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2022-07-19 18:36:50.552180354 +0200\n+++ /tmp/tmp_bxb1pa3.java\t2022-07-19 18:36:50.552180354 +0200\n@@ -193,11 +193,11 @@\n             fb = function.value(b);\n             numIterations++ ;\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+if (fa * fb >= 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n                       numIterations, maximumIterations, initial,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (fa * fb >= 0.0){",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2022-07-19 18:36:57.128144516 +0200\n+++ /tmp/tmpq9asgofs.java\t2022-07-19 18:36:57.128144516 +0200\n@@ -193,11 +193,11 @@\n             fb = function.value(b);\n             numIterations++ ;\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+if (fa * fb >= 0.0){\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n                       numIterations, maximumIterations, initial,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (fa * fb >= 0.0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2022-07-19 18:37:04.004107066 +0200\n+++ /tmp/tmpnglqbse3.java\t2022-07-19 18:37:04.008107045 +0200\n@@ -193,11 +193,11 @@\n             fb = function.value(b);\n             numIterations++ ;\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+if (fa * fb >= 0.0) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n                       numIterations, maximumIterations, initial,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (fa * fb == 0.0 ) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2022-07-19 18:37:10.572071321 +0200\n+++ /tmp/tmptstxj_h2.java\t2022-07-19 18:37:10.572071321 +0200\n@@ -193,11 +193,11 @@\n             fb = function.value(b);\n             numIterations++ ;\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+if (fa * fb == 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n                       numIterations, maximumIterations, initial,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (fa / fb!= 0.0 ) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2022-07-19 18:37:17.088035878 +0200\n+++ /tmp/tmp_vl3n4z5.java\t2022-07-19 18:37:17.088035878 +0200\n@@ -193,11 +193,11 @@\n             fb = function.value(b);\n             numIterations++ ;\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+if (fa / fb!= 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n                       numIterations, maximumIterations, initial,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (fa * fb!= 0.0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2022-07-19 18:37:23.608000439 +0200\n+++ /tmp/tmp3qlrudai.java\t2022-07-19 18:37:23.608000439 +0200\n@@ -193,11 +193,11 @@\n             fb = function.value(b);\n             numIterations++ ;\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+if (fa * fb!= 0.0) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n                       numIterations, maximumIterations, initial,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (fa * fb >= 0.0 ) {",
        "fixed_line": "if (fa * fb > 0.0 ) {"
    },
    "Lang-3": {
        "fixes": [
            {
                "k": 1,
                "patch": "// ignore }",
                "patch_diff": "// ignore }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "patch_diff": "// can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if (f.isInfinite() || (f.doubleValue() == 0.0 ||!allZeros) {",
                "patch_diff": "// if (f.isInfinite() || (f.doubleValue() == 0.0 ||!allZeros) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// can't really modify it was non-literal characters that might be valid (empty be",
                "patch_diff": "// can't really modify it was non-literal characters that might be valid (empty be",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// ignore the bad number }",
                "patch_diff": "// ignore the bad number }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// can't really modify it was non-literal characters that might be valid (x.",
                "patch_diff": "// can't really modify it was non-literal characters that might be valid (x.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// can't really modify it was non-literal characters that might be valid (e.",
                "patch_diff": "// can't really modify it was non-literal characters that might be valid (e.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// can't really modify it was non-literal characters that might be valid (empty be // need to check",
                "patch_diff": "// can't really modify it was non-literal characters that might be valid (empty be // need to check",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// can't really modify it was non-literal characters that might be valid (empty be valid)",
                "patch_diff": "// can't really modify it was non-literal characters that might be valid (empty be valid)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if (f.isInfinite() || (f.doubleValue() == 0.0 &&!allZeros) {",
                "patch_diff": "// if (f.isInfinite() || (f.doubleValue() == 0.0 &&!allZeros) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float final Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } } catch (final NumberFormatException nfe) { // NOPMD // ignore the bad number } try { if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double final Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } }"
    },
    "Jsoup-10": {
        "fixes": [
            {
                "k": 1,
                "patch": "// } catch (Exception e) { throw new URL(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); }",
                "patch_diff": "// } catch (Exception e) { throw new URL(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// } catch (Exception e) { throw new URL(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); }",
                "patch_diff": "// } catch (Exception e) { throw new URL(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// } catch (Exception e) { throw new URL(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); }",
                "patch_diff": "// } catch (Exception e) { throw new URL(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// } catch (Exception e) { throw new URL(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URL(e); }",
                "patch_diff": "// } catch (Exception e) { throw new URL(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URL(e); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// } catch (Exception e) { throw new URL(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URL(e); } catch (Exception e) { throw new URLException(e); }",
                "patch_diff": "// } catch (Exception e) { throw new URL(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URL(e); } catch (Exception e) { throw new URLException(e); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// } catch (Exception e) { throw new URL(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e.to",
                "patch_diff": "// } catch (Exception e) { throw new URL(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e.to",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// } catch (Exception e) { throw new URL(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } }",
                "patch_diff": "// } catch (Exception e) { throw new URL(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// } catch (Exception e) { throw new URL(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URL(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); }",
                "patch_diff": "// } catch (Exception e) { throw new URL(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URL(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// } catch (Exception e) { throw new URL(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URL(e); }",
                "patch_diff": "// } catch (Exception e) { throw new URL(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URL(e); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// } catch (Exception e) { throw new URL(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } }",
                "patch_diff": "// } catch (Exception e) { throw new URL(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } catch (Exception e) { throw new URLException(e); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (relUrl.startsWith(\"?\")) relUrl = base.getPath() + relUrl;"
    },
    "Time-24": {
        "fixes": [
            {
                "k": 1,
                "patch": "e.prependMessage(\"Cannot parse \\\"\" + text + '\"'); }",
                "patch_diff": "e.prependMessage(\"Cannot parse \\\"\" + text + '\"'); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "e.prependMessage(\"Cannot parse \\\"\" + text + '\"');",
                "patch_diff": "e.prependMessage(\"Cannot parse \\\"\" + text + '\"');",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "e.prependMessage(\"Cannot parse \\\"\" + text + '\"'); if (millis == null) { throw new IllegalArgumentException(\"Cannot parse \\\"\" + text + '\"'); } }",
                "patch_diff": "e.prependMessage(\"Cannot parse \\\"\" + text + '\"'); if (millis == null) { throw new IllegalArgumentException(\"Cannot parse \\\"\" + text + '\"'); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "e.prependMessage(\"Cannot parse \\\"\" + text + '\"'); if (millis < 0) { throw new IllegalArgumentException(\"Cannot parse \\\"\" + text + '\"'); } }",
                "patch_diff": "e.prependMessage(\"Cannot parse \\\"\" + text + '\"'); if (millis < 0) { throw new IllegalArgumentException(\"Cannot parse \\\"\" + text + '\"'); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "e.prependMessage(\"Cannot parse \\\"\" + text + '\"'); try { millis = savedFields[i].set(millis, resetFields); } catch (IllegalAccessException e) { throw new IllegalArgumentException(\"Cannot parse \\\"\" + text + '\"'); } }",
                "patch_diff": "e.prependMessage(\"Cannot parse \\\"\" + text + '\"'); try { millis = savedFields[i].set(millis, resetFields); } catch (IllegalAccessException e) { throw new IllegalArgumentException(\"Cannot parse \\\"\" + text + '\"'); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "e.prependMessage(\"Cannot parse \\\"\" + text + '\"'); if (millis > 0) { throw new IllegalArgumentException(\"Cannot parse \\\"\" + text + '\"'); } }",
                "patch_diff": "e.prependMessage(\"Cannot parse \\\"\" + text + '\"'); if (millis > 0) { throw new IllegalArgumentException(\"Cannot parse \\\"\" + text + '\"'); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "e.prependMessage(\"Cannot parse \\\"\" + text + '\"'); if (millis == null) {",
                "patch_diff": "e.prependMessage(\"Cannot parse \\\"\" + text + '\"'); if (millis == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "e.prependMessage(\"Cannot parse \\\"\" + text + '\"'); try { millis = savedFields[i].set(millis, resetFields); } catch (IllegalAccessException e) { throw e; } }",
                "patch_diff": "e.prependMessage(\"Cannot parse \\\"\" + text + '\"'); try { millis = savedFields[i].set(millis, resetFields); } catch (IllegalAccessException e) { throw e; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "e.prependMessage(\"Cannot parse \\\"\" + text + '\"'); try { millis = savedFields[i].set(millis, resetFields); } } catch (IllegalAccessException e) { throw new IllegalArgumentException(\"Cannot parse \\\"\" + text + '\"'); } }",
                "patch_diff": "e.prependMessage(\"Cannot parse \\\"\" + text + '\"'); try { millis = savedFields[i].set(millis, resetFields); } } catch (IllegalAccessException e) { throw new IllegalArgumentException(\"Cannot parse \\\"\" + text + '\"'); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "e.prependMessage(\"Cannot parse \\\"\" + text + '\"'); if (millis == null) { throw new IllegalArgumentException(\"Invalid parse \\\"\" + text + '\"'); } }",
                "patch_diff": "e.prependMessage(\"Cannot parse \\\"\" + text + '\"'); if (millis == null) { throw new IllegalArgumentException(\"Invalid parse \\\"\" + text + '\"'); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (resetFields) { for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, i == (count - 1)); } }"
    },
    "Csv-3": {
        "fixes": [
            {
                "k": 1,
                "patch": "// throw new IOException(\"EOF whilst processing escape sequence\"); default: throw new IOException(\"EOF whilst processing escape sequence\"); }",
                "patch_diff": "// throw new IOException(\"EOF whilst processing escape sequence\"); default: throw new IOException(\"EOF whilst processing escape sequence\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// throw new IOException(\"EOF whilst processing escape sequence\"); }",
                "patch_diff": "// throw new IOException(\"EOF whilst processing escape sequence\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0; i < length; i++) { char c = str.charAt(i); if (c == '\\n' || c == '\\r' || c == EOF_CHAR) { break; } }",
                "patch_diff": "for (int i = 0; i < length; i++) { char c = str.charAt(i); if (c == '\\n' || c == '\\r' || c == EOF_CHAR) { break; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = 0; i < length; i++) { char c = str.charAt(i); if (c == '\\n' || c == '\\r' || c == EOF_CHAR) { break; } } }",
                "patch_diff": "for (int i = 0; i < length; i++) { char c = str.charAt(i); if (c == '\\n' || c == '\\r' || c == EOF_CHAR) { break; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = 0; i < length; i++) { char c = str.charAt(i); if (c == '\\'' || c == EOF_CHAR) { break; } } }",
                "patch_diff": "for (int i = 0; i < length; i++) { char c = str.charAt(i); if (c == '\\'' || c == EOF_CHAR) { break; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = 0; i < length; i++) { char c = str.charAt(i); if (c == '\\n' || c == EOF_CHAR) { break; } } }",
                "patch_diff": "for (int i = 0; i < length; i++) { char c = str.charAt(i); if (c == '\\n' || c == EOF_CHAR) { break; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = 0; i < length; i++) { char c = str.charAt(i); if (c == '\\'' || c == EOF_CHAR) { break; } }",
                "patch_diff": "for (int i = 0; i < length; i++) { char c = str.charAt(i); if (c == '\\'' || c == EOF_CHAR) { break; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = 0; i < length; i++) { char c = str.charAt(i); if (c == '\\n' || c == '\\r' || c == EOF_CHAR) { return c; } }",
                "patch_diff": "for (int i = 0; i < length; i++) { char c = str.charAt(i); if (c == '\\n' || c == '\\r' || c == EOF_CHAR) { return c; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int i = 0; i < length; i++) { char c = str.charAt(i); if (c == '\\n' || c == '\\r' || c == EOF_CHAR) { return c; } } }",
                "patch_diff": "for (int i = 0; i < length; i++) { char c = str.charAt(i); if (c == '\\n' || c == '\\r' || c == EOF_CHAR) { return c; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = 0; i < length; i++) { char c = str.charAt(i); if (c == '\\n' || c == EOF_CHAR) { break; } }",
                "patch_diff": "for (int i = 0; i < length; i++) { char c = str.charAt(i); if (c == '\\n' || c == EOF_CHAR) { break; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (isDelimiter(c) || isEscape(c) || isQuoteChar(c) || isCommentStart(c)) { return c; } // indicate unexpected char - available from in.getLastChar() return END_OF_STREAM;"
    },
    "Lang-51": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (str.charAt(1) == 'E' || str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) =='s' || str.charAt(2) =='s'); }",
                "patch_diff": "if (str.charAt(1) == 'E' || str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) =='s' || str.charAt(2) =='s'); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return (str.charAt(1) == 'E' || str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) =='s' || str.charAt(2) =='s'); }",
                "patch_diff": "return (str.charAt(1) == 'E' || str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) =='s' || str.charAt(2) =='s'); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return (str.charAt(1) == 'E' || str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) =='s' || str.charAt(2) =='s');",
                "patch_diff": "return (str.charAt(1) == 'E' || str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) =='s' || str.charAt(2) =='s');",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (str.charAt(1) == 'E' || str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) =='s' || str.charAt(2) =='s');",
                "patch_diff": "if (str.charAt(1) == 'E' || str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) =='s' || str.charAt(2) =='s');",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return (str.charAt(1) == 'E' || str.charAt(1) == 'e' || str.charAt(2) =='s'); }",
                "patch_diff": "return (str.charAt(1) == 'E' || str.charAt(1) == 'e' || str.charAt(2) =='s'); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return (str.charAt(1) == 'E' || str.charAt(1) == 'E' || str.charAt(1) == 'e' || str.charAt(2) =='s'); }",
                "patch_diff": "return (str.charAt(1) == 'E' || str.charAt(1) == 'E' || str.charAt(1) == 'e' || str.charAt(2) =='s'); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (str.charAt(1) == 'E' || str.charAt(1) == 'E' || str.charAt(1) == 'e' || str.charAt(2) =='s'); }",
                "patch_diff": "if (str.charAt(1) == 'E' || str.charAt(1) == 'E' || str.charAt(1) == 'e' || str.charAt(2) =='s'); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (str.charAt(1) == 'E' || str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s'); }",
                "patch_diff": "if (str.charAt(1) == 'E' || str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s'); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) =='s' || str.charAt(2) =='s'); }",
                "patch_diff": "return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) =='s' || str.charAt(2) =='s'); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) =='s' || str.charAt(2) =='s'); }",
                "patch_diff": "if (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) =='s' || str.charAt(2) =='s'); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "return false;"
    },
    "Cli-35": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (longOpt = longOpt.keySet;",
                "patch_diff": "for (longOpt = longOpt.keySet;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (longOpt = longOpt.keySet()) {",
                "patch_diff": "for (longOpt = longOpt.keySet()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (longOpt = longOpt.keySet()) { if (opt.equals(opt)) {",
                "patch_diff": "for (longOpt = longOpt.keySet()) { if (opt.equals(opt)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (longOpt = longOpt.keySet()) { if (opt.getType() == Token.stripLeadingHyph) {",
                "patch_diff": "for (longOpt = longOpt.keySet()) { if (opt.getType() == Token.stripLeadingHyph) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (longOpt = longOpt.keySet()) { if (opt.isAssignableFrom(opt)) {",
                "patch_diff": "for (longOpt = longOpt.keySet()) { if (opt.isAssignableFrom(opt)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (longOpt = longOpt.keySet()) { if (opt.getType() == Token.stripLeading) {",
                "patch_diff": "for (longOpt = longOpt.keySet()) { if (opt.getType() == Token.stripLeading) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// for (longOpt = longOpt.keySet;",
                "patch_diff": "// for (longOpt = longOpt.keySet;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (longOpt = longOpt.keySet()) { if (opt.getType() == Token.ASSIGN) {",
                "patch_diff": "for (longOpt = longOpt.keySet()) { if (opt.getType() == Token.ASSIGN) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (longOpt = longOpt.keySet()) { if (opt.equals(longOpt)) {",
                "patch_diff": "for (longOpt = longOpt.keySet()) { if (opt.equals(longOpt)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (longOpt : longOpt.stripLeadingHyph) { if (opt.equals(opt)) {",
                "patch_diff": "for (longOpt : longOpt.stripLeadingHyph) { if (opt.equals(opt)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if(longOpts.keySet().contains(opt)) { return Collections.singletonList(opt); }"
    },
    "Gson-15": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (Double.isNaN || Double.isInfinite(_value)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-15/gson/src/main/java/com/google/gson/stream/JsonWriter.java\t2022-07-19 18:37:41.795901695 +0200\n+++ /tmp/tmpagf_suam.java\t2022-07-19 18:37:41.871901279 +0200\n@@ -490,11 +490,11 @@\n    *     {@link Double#isInfinite() infinities}.\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n     writeDeferredName();\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+if (Double.isNaN || Double.isInfinite(_value)) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (Double.isNaN(value || Double.isInfinite(value || Double.isInfinite(_value)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-15/gson/src/main/java/com/google/gson/stream/JsonWriter.java\t2022-07-19 18:37:43.895890304 +0200\n+++ /tmp/tmpm3ynfdn3.java\t2022-07-19 18:37:43.895890304 +0200\n@@ -490,11 +490,11 @@\n    *     {@link Double#isInfinite() infinities}.\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n     writeDeferredName();\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+if (Double.isNaN(value || Double.isInfinite(value || Double.isInfinite(_value)) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (Double.isNaN(value || Double.isInfinite(_value)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-15/gson/src/main/java/com/google/gson/stream/JsonWriter.java\t2022-07-19 18:37:45.423882018 +0200\n+++ /tmp/tmp5kv53qpf.java\t2022-07-19 18:37:45.423882018 +0200\n@@ -490,11 +490,11 @@\n    *     {@link Double#isInfinite() infinities}.\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n     writeDeferredName();\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+if (Double.isNaN(value || Double.isInfinite(_value)) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (Double.isNaN || Double.isInfinite(value || Double.isInfinite(_value)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-15/gson/src/main/java/com/google/gson/stream/JsonWriter.java\t2022-07-19 18:37:47.027873323 +0200\n+++ /tmp/tmpe72azvlf.java\t2022-07-19 18:37:47.027873323 +0200\n@@ -490,11 +490,11 @@\n    *     {@link Double#isInfinite() infinities}.\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n     writeDeferredName();\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+if (Double.isNaN || Double.isInfinite(value || Double.isInfinite(_value)) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (Double.isNaN(value || Double.isInfinite(_value) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-15/gson/src/main/java/com/google/gson/stream/JsonWriter.java\t2022-07-19 18:37:48.627864647 +0200\n+++ /tmp/tmptwlctkxa.java\t2022-07-19 18:37:48.627864647 +0200\n@@ -490,11 +490,11 @@\n    *     {@link Double#isInfinite() infinities}.\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n     writeDeferredName();\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+if (Double.isNaN(value || Double.isInfinite(_value) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (Double.isNaN || Double.isInfinite(value)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-15/gson/src/main/java/com/google/gson/stream/JsonWriter.java\t2022-07-19 18:37:50.239855909 +0200\n+++ /tmp/tmpw23dfoao.java\t2022-07-19 18:37:50.239855909 +0200\n@@ -490,11 +490,11 @@\n    *     {@link Double#isInfinite() infinities}.\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n     writeDeferredName();\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+if (Double.isNaN || Double.isInfinite(value)) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (Double.isNaN || Double.isInfinite(value) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-15/gson/src/main/java/com/google/gson/stream/JsonWriter.java\t2022-07-19 18:37:52.063846025 +0200\n+++ /tmp/tmp3r8tc874.java\t2022-07-19 18:37:52.063846025 +0200\n@@ -490,11 +490,11 @@\n    *     {@link Double#isInfinite() infinities}.\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n     writeDeferredName();\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+if (Double.isNaN || Double.isInfinite(value) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (Double.isNaN || Double.isInfinite(_value) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-15/gson/src/main/java/com/google/gson/stream/JsonWriter.java\t2022-07-19 18:37:53.675837290 +0200\n+++ /tmp/tmpqryhu6kk.java\t2022-07-19 18:37:53.675837290 +0200\n@@ -490,11 +490,11 @@\n    *     {@link Double#isInfinite() infinities}.\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n     writeDeferredName();\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+if (Double.isNaN || Double.isInfinite(_value) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (Double.isNaN(value || Double.isInfinite(value || Double.isInfinite(value)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-15/gson/src/main/java/com/google/gson/stream/JsonWriter.java\t2022-07-19 18:37:55.315828405 +0200\n+++ /tmp/tmp5gwoyscg.java\t2022-07-19 18:37:55.315828405 +0200\n@@ -490,11 +490,11 @@\n    *     {@link Double#isInfinite() infinities}.\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n     writeDeferredName();\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+if (Double.isNaN(value || Double.isInfinite(value || Double.isInfinite(value)) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (Double.isNaN(value || Double.isInfinite(_value || Double.isInfinite(_value)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Gson-15/gson/src/main/java/com/google/gson/stream/JsonWriter.java\t2022-07-19 18:37:56.851820083 +0200\n+++ /tmp/tmpqy_9yb7e.java\t2022-07-19 18:37:56.851820083 +0200\n@@ -490,11 +490,11 @@\n    *     {@link Double#isInfinite() infinities}.\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n     writeDeferredName();\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+if (Double.isNaN(value || Double.isInfinite(_value || Double.isInfinite(_value)) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (Double.isNaN(value) || Double.isInfinite(value)) {",
        "fixed_line": "if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) {"
    },
    "JacksonCore-14": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (toRelease!= src) && (toReleaseBuf.length!= _class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-14/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\t2022-07-19 18:37:58.547810896 +0200\n+++ /tmp/tmpsrpmiqk4.java\t2022-07-19 18:37:58.563810809 +0200\n@@ -269,18 +269,8 @@\n         if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n     }\n \n     protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    protected final void _verifyRelease(char[] toRelease, char[] src) {\n-        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    private IllegalArgumentException wrongBuf() {\n-        // sanity check failed; trying to return different, smaller buffer.\n-return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n+if (toRelease!= src) && (toReleaseBuf.length!= _class) {\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (toRelease!= src) && (toReleaseBuf.length!= toReleaseBuf.length)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-14/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\t2022-07-19 18:38:00.407800822 +0200\n+++ /tmp/tmp0leexp_x.java\t2022-07-19 18:38:00.411800801 +0200\n@@ -269,18 +269,8 @@\n         if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n     }\n \n     protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    protected final void _verifyRelease(char[] toRelease, char[] src) {\n-        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    private IllegalArgumentException wrongBuf() {\n-        // sanity check failed; trying to return different, smaller buffer.\n-return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n+if (toRelease!= src) && (toReleaseBuf.length!= toReleaseBuf.length)) {\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (toRelease!= src) && (toReleaseBuf.length!= toReleaseBuf.length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-14/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\t2022-07-19 18:38:01.987792269 +0200\n+++ /tmp/tmphundppmk.java\t2022-07-19 18:38:01.987792269 +0200\n@@ -269,18 +269,8 @@\n         if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n     }\n \n     protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    protected final void _verifyRelease(char[] toRelease, char[] src) {\n-        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    private IllegalArgumentException wrongBuf() {\n-        // sanity check failed; trying to return different, smaller buffer.\n-return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n+if (toRelease!= src) && (toReleaseBuf.length!= toReleaseBuf.length) {\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (toRelease!= src) && (toReleaseBuf.length!= src;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-14/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\t2022-07-19 18:38:03.567783713 +0200\n+++ /tmp/tmp1wijaclq.java\t2022-07-19 18:38:03.567783713 +0200\n@@ -269,18 +269,8 @@\n         if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n     }\n \n     protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    protected final void _verifyRelease(char[] toRelease, char[] src) {\n-        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    private IllegalArgumentException wrongBuf() {\n-        // sanity check failed; trying to return different, smaller buffer.\n-return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n+if (toRelease!= src) && (toReleaseBuf.length!= src;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (toRelease!= src) && (toReleaseBuf.length!= toReleaseBuf.length);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-14/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\t2022-07-19 18:38:05.067775593 +0200\n+++ /tmp/tmpfc8v0g6p.java\t2022-07-19 18:38:05.067775593 +0200\n@@ -269,18 +269,8 @@\n         if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n     }\n \n     protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    protected final void _verifyRelease(char[] toRelease, char[] src) {\n-        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    private IllegalArgumentException wrongBuf() {\n-        // sanity check failed; trying to return different, smaller buffer.\n-return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n+if (toRelease!= src) && (toReleaseBuf.length!= toReleaseBuf.length);\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (toRelease!= src) && (toReleaseBuf.length!= 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-14/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\t2022-07-19 18:38:06.571767455 +0200\n+++ /tmp/tmpfqnxrhl8.java\t2022-07-19 18:38:06.571767455 +0200\n@@ -269,18 +269,8 @@\n         if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n     }\n \n     protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    protected final void _verifyRelease(char[] toRelease, char[] src) {\n-        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    private IllegalArgumentException wrongBuf() {\n-        // sanity check failed; trying to return different, smaller buffer.\n-return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n+if (toRelease!= src) && (toReleaseBuf.length!= 0;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (toRelease!= src) && (toReleaseBuf.length!= toReleaseBuf.length;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-14/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\t2022-07-19 18:38:08.107759142 +0200\n+++ /tmp/tmpsanlwvp7.java\t2022-07-19 18:38:08.107759142 +0200\n@@ -269,18 +269,8 @@\n         if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n     }\n \n     protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    protected final void _verifyRelease(char[] toRelease, char[] src) {\n-        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    private IllegalArgumentException wrongBuf() {\n-        // sanity check failed; trying to return different, smaller buffer.\n-return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n+if (toRelease!= src) && (toReleaseBuf.length!= toReleaseBuf.length;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (toRelease!= src) && (toReleaseBuf.length!= src) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-14/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\t2022-07-19 18:38:09.567751240 +0200\n+++ /tmp/tmp2qbjeq7q.java\t2022-07-19 18:38:09.567751240 +0200\n@@ -269,18 +269,8 @@\n         if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n     }\n \n     protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    protected final void _verifyRelease(char[] toRelease, char[] src) {\n-        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    private IllegalArgumentException wrongBuf() {\n-        // sanity check failed; trying to return different, smaller buffer.\n-return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n+if (toRelease!= src) && (toReleaseBuf.length!= src) {\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (toRelease!= src) && (toReleaseBuf.length < src) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-14/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\t2022-07-19 18:38:11.139742736 +0200\n+++ /tmp/tmpwxje6vur.java\t2022-07-19 18:38:11.139742736 +0200\n@@ -269,18 +269,8 @@\n         if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n     }\n \n     protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    protected final void _verifyRelease(char[] toRelease, char[] src) {\n-        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    private IllegalArgumentException wrongBuf() {\n-        // sanity check failed; trying to return different, smaller buffer.\n-return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n+if (toRelease!= src) && (toReleaseBuf.length < src) {\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (toRelease!= src) && (toRelease.length!= toReleaseBuf.length)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-14/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\t2022-07-19 18:38:12.639734621 +0200\n+++ /tmp/tmp7btt99ks.java\t2022-07-19 18:38:12.643734601 +0200\n@@ -269,18 +269,8 @@\n         if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n     }\n \n     protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    protected final void _verifyRelease(char[] toRelease, char[] src) {\n-        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    private IllegalArgumentException wrongBuf() {\n-        // sanity check failed; trying to return different, smaller buffer.\n-return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n+if (toRelease!= src) && (toRelease.length!= toReleaseBuf.length)) {\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); } } protected final void _verifyRelease(char[] toRelease, char[] src) { // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); } } private IllegalArgumentException wrongBuf() { // sanity check failed; trying to return different, smaller buffer. return new IllegalArgumentException(\"Trying to release buffer not owned by the context\");",
        "fixed_line": "if ((toRelease != src) && (toRelease.length < src.length)) { throw wrongBuf(); } } protected final void _verifyRelease(char[] toRelease, char[] src) { // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer if ((toRelease != src) && (toRelease.length < src.length)) { throw wrongBuf(); } } private IllegalArgumentException wrongBuf() { // sanity check failed; trying to return different, smaller buffer. return new IllegalArgumentException(\"Trying to release buffer smaller than original\");"
    },
    "Math-20": {
        "fixes": [
            {
                "k": 1,
                "patch": "return MIN_CHAR_ARRAY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-20/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\t2022-07-19 18:38:14.363725298 +0200\n+++ /tmp/tmp75maos7a.java\t2022-07-19 18:38:14.419724993 +0200\n@@ -916,11 +916,11 @@\n         /**\n          * @param x Normalized objective variables.\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return\n+return MIN_CHAR_ARRAY;\n                 decode(x);\n         }\n \n         /**\n          * @param x Normalized objective variables.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return MIN_ langized_CHAR_STROKE_OBJECT_ARRAY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-20/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\t2022-07-19 18:38:17.179710070 +0200\n+++ /tmp/tmpqwuoxt5m.java\t2022-07-19 18:38:17.179710070 +0200\n@@ -916,11 +916,11 @@\n         /**\n          * @param x Normalized objective variables.\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return\n+return MIN_ langized_CHAR_STROKE_OBJECT_ARRAY;\n                 decode(x);\n         }\n \n         /**\n          * @param x Normalized objective variables.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return MAX_ langized_CHAR_STROKE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-20/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\t2022-07-19 18:38:19.123699557 +0200\n+++ /tmp/tmpzgbdlp8o.java\t2022-07-19 18:38:19.123699557 +0200\n@@ -916,11 +916,11 @@\n         /**\n          * @param x Normalized objective variables.\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return\n+return MAX_ langized_CHAR_STROKE;\n                 decode(x);\n         }\n \n         /**\n          * @param x Normalized objective variables.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return MIN_ langized_CHAR_STROKE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-20/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\t2022-07-19 18:38:21.147688617 +0200\n+++ /tmp/tmpl8l4mx4s.java\t2022-07-19 18:38:21.147688617 +0200\n@@ -916,11 +916,11 @@\n         /**\n          * @param x Normalized objective variables.\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return\n+return MIN_ langized_CHAR_STROKE;\n                 decode(x);\n         }\n \n         /**\n          * @param x Normalized objective variables.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return MAX_ langized_CHAR_STROKE_OBJECT_ARRAY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-20/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\t2022-07-19 18:38:23.303676966 +0200\n+++ /tmp/tmp1aowzciw.java\t2022-07-19 18:38:23.303676966 +0200\n@@ -916,11 +916,11 @@\n         /**\n          * @param x Normalized objective variables.\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return\n+return MAX_ langized_CHAR_STROKE_OBJECT_ARRAY;\n                 decode(x);\n         }\n \n         /**\n          * @param x Normalized objective variables.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return MIN_ langized_CHAR_ARRAY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-20/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\t2022-07-19 18:38:25.327666026 +0200\n+++ /tmp/tmpaqf_beaw.java\t2022-07-19 18:38:25.327666026 +0200\n@@ -916,11 +916,11 @@\n         /**\n          * @param x Normalized objective variables.\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return\n+return MIN_ langized_CHAR_ARRAY;\n                 decode(x);\n         }\n \n         /**\n          * @param x Normalized objective variables.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return MIN_ langized_CHAR_STROKE_TO_END;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-20/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\t2022-07-19 18:38:27.411654768 +0200\n+++ /tmp/tmpi9wjhy7y.java\t2022-07-19 18:38:27.411654768 +0200\n@@ -916,11 +916,11 @@\n         /**\n          * @param x Normalized objective variables.\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return\n+return MIN_ langized_CHAR_STROKE_TO_END;\n                 decode(x);\n         }\n \n         /**\n          * @param x Normalized objective variables.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return MIN_ langized_CHAR_TO_END;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-20/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\t2022-07-19 18:38:29.527643339 +0200\n+++ /tmp/tmp514zo9s2.java\t2022-07-19 18:38:29.527643339 +0200\n@@ -916,11 +916,11 @@\n         /**\n          * @param x Normalized objective variables.\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return\n+return MIN_ langized_CHAR_TO_END;\n                 decode(x);\n         }\n \n         /**\n          * @param x Normalized objective variables.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return x;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-20/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\t2022-07-19 18:38:31.623632018 +0200\n+++ /tmp/tmpufyu2mur.java\t2022-07-19 18:38:31.623632018 +0200\n@@ -916,11 +916,11 @@\n         /**\n          * @param x Normalized objective variables.\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return\n+return x;\n                 decode(x);\n         }\n \n         /**\n          * @param x Normalized objective variables.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return w;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-20/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\t2022-07-19 18:38:33.879619837 +0200\n+++ /tmp/tmpdno4qezl.java\t2022-07-19 18:38:33.879619837 +0200\n@@ -916,11 +916,11 @@\n         /**\n          * @param x Normalized objective variables.\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return\n+return w;\n                 decode(x);\n         }\n \n         /**\n          * @param x Normalized objective variables.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return",
        "fixed_line": "return boundaries != null && isRepairMode ? decode(repair(x)) :"
    },
    "JacksonDatabind-74": {
        "fixes": [
            {
                "k": 1,
                "patch": "// to contain type id (for class \"+type+\"' that is to contain type id (for class \"+baseTypeName()+\")\"); return result; }",
                "patch_diff": "// to contain type id (for class \"+type+\"' that is to contain type id (for class \"+baseTypeName()+\")\"); return result; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// to contain type id (for class \"+type+\"' that is to contain type id (for class \"+baseTypeName()+\")\"); return result; } // or, something that is to contain type id (for class \"+baseTypeName()+\")\"); }",
                "patch_diff": "// to contain type id (for class \"+type+\"' that is to contain type id (for class \"+baseTypeName()+\")\"); return result; } // or, something that is to contain type id (for class \"+baseTypeName()+\")\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// to contain type id (for class \"+type+\"' that is to contain type id (for class \"+type+\"' that is to contain type id (for class \"+baseTypeName()+\")\"); return result; } // or, something that is to contain type id (for class \"+baseTypeName()+\")\"); }",
                "patch_diff": "// to contain type id (for class \"+type+\"' that is to contain type id (for class \"+type+\"' that is to contain type id (for class \"+baseTypeName()+\")\"); return result; } // or, something that is to contain type id (for class \"+baseTypeName()+\")\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// to contain type id (for class \"+type+\"' that is to contain type id (for class \"+type+\"' that is to contain type id (for class \"+baseTypeName()+\")\"); return result; }",
                "patch_diff": "// to contain type id (for class \"+type+\"' that is to contain type id (for class \"+type+\"' that is to contain type id (for class \"+baseTypeName()+\")\"); return result; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// to contain type id (for class \"+type+\"' that is to contain type id (for class \"+baseTypeName()+\")\"); return result; } // or, something that is to contain type id (for class)",
                "patch_diff": "// to contain type id (for class \"+type+\"' that is to contain type id (for class \"+baseTypeName()+\")\"); return result; } // or, something that is to contain type id (for class)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// to contain type id (for class \"+type+\"' that is to contain type id (for class \"+baseTypeName()+\")\"); return result; } // or, something that is to contain type id (for class \"+baseTypeName()+\")\"); return result; }",
                "patch_diff": "// to contain type id (for class \"+type+\"' that is to contain type id (for class \"+baseTypeName()+\")\"); return result; } // or, something that is to contain type id (for class \"+baseTypeName()+\")\"); return result; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// to contain type id (for class \"+type+\"' that is to contain type id (for class \"+type+\"' that is to contain type id (for class \"+baseTypeName()+\")\"); return result; } // or, something that is to contain type id (for class \"+baseTypeName()+\")\"); return result; }",
                "patch_diff": "// to contain type id (for class \"+type+\"' that is to contain type id (for class \"+type+\"' that is to contain type id (for class \"+baseTypeName()+\")\"); return result; } // or, something that is to contain type id (for class \"+baseTypeName()+\")\"); return result; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// to contain type id (for class \"+type+\"' that is to contain type id (for class \"+type+\"' (for class \"+baseTypeName()+\")\"); return result; }",
                "patch_diff": "// to contain type id (for class \"+type+\"' that is to contain type id (for class \"+type+\"' (for class \"+baseTypeName()+\")\"); return result; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// to contain type id (for class \"+type+\"' that is to contain type id (for class \"+type+\"' that is to contain type id (for class \"+baseTypeName()+\")\"); return result; } // or, something that is to contain type id (for class)",
                "patch_diff": "// to contain type id (for class \"+type+\"' that is to contain type id (for class \"+type+\"' that is to contain type id (for class \"+baseTypeName()+\")\"); return result; } // or, something that is to contain type id (for class)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// to contain type id (for class \"+type+\"' that is to contain type id (for class \"+type+\"' that is to contain type id (for class \"+baseTypeName()+\")\"); return result; } // or, something }",
                "patch_diff": "// to contain type id (for class \"+type+\"' that is to contain type id (for class \"+type+\"' that is to contain type id (for class \"+baseTypeName()+\")\"); return result; } // or, something }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "} else if (p.getCurrentToken() == JsonToken.VALUE_STRING) { if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { String str = p.getText().trim(); if (str.isEmpty()) { return null; } }"
    },
    "JacksonDatabind-71": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (raw == String.class || raw == Object.class || raw.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-71/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\t2022-07-19 18:38:38.887592801 +0200\n+++ /tmp/tmpudmowikz.java\t2022-07-19 18:38:38.999592191 +0200\n@@ -70,11 +70,11 @@\n     public static StdKeyDeserializer forType(Class<?> raw)\n     {\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class) {\n+if (raw == String.class || raw == Object.class || raw.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n         } else if (raw == Integer.class) {\n             kind = TYPE_INT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-71/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\t2022-07-19 18:38:41.123580737 +0200\n+++ /tmp/tmpaadexril.java\t2022-07-19 18:38:41.123580737 +0200\n@@ -70,11 +70,11 @@\n     public static StdKeyDeserializer forType(Class<?> raw)\n     {\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class) {\n+if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n         } else if (raw == Integer.class) {\n             kind = TYPE_INT;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] --raw (raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-71/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\t2022-07-19 18:39:21.099365377 +0200\n+++ /tmp/tmpjeb42yos.java\t2022-07-19 18:39:21.099365377 +0200\n@@ -70,11 +70,11 @@\n     public static StdKeyDeserializer forType(Class<?> raw)\n     {\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class) {\n+if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] --raw (raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n         } else if (raw == Integer.class) {\n             kind = TYPE_INT;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (raw == String.class || raw == Object.class || raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-71/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\t2022-07-19 18:39:58.411164975 +0200\n+++ /tmp/tmpem0y820h.java\t2022-07-19 18:39:58.411164975 +0200\n@@ -70,11 +70,11 @@\n     public static StdKeyDeserializer forType(Class<?> raw)\n     {\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class) {\n+if (raw == String.class || raw == Object.class || raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n         } else if (raw == Integer.class) {\n             kind = TYPE_INT;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (raw == String.class || raw == Object.class || raw.class) { // as per [JACKSON-407] --raw (raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-71/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\t2022-07-19 18:40:35.454966549 +0200\n+++ /tmp/tmpylb8s22x.java\t2022-07-19 18:40:35.454966549 +0200\n@@ -70,11 +70,11 @@\n     public static StdKeyDeserializer forType(Class<?> raw)\n     {\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class) {\n+if (raw == String.class || raw == Object.class || raw.class) { // as per [JACKSON-407] --raw (raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n         } else if (raw == Integer.class) {\n             kind = TYPE_INT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] --raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-71/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\t2022-07-19 18:40:37.218957111 +0200\n+++ /tmp/tmp16qepci3.java\t2022-07-19 18:40:37.218957111 +0200\n@@ -70,11 +70,11 @@\n     public static StdKeyDeserializer forType(Class<?> raw)\n     {\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class) {\n+if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] --raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n         } else if (raw == Integer.class) {\n             kind = TYPE_INT;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-71/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\t2022-07-19 18:41:14.350758732 +0200\n+++ /tmp/tmpryasl5hw.java\t2022-07-19 18:41:14.354758711 +0200\n@@ -70,11 +70,11 @@\n     public static StdKeyDeserializer forType(Class<?> raw)\n     {\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class) {\n+if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class) {\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n         } else if (raw == Integer.class) {\n             kind = TYPE_INT;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (raw == String.class || raw == Object.class || raw.class) { // as per [JACKSON-407] --raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-71/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\t2022-07-19 18:41:51.262561988 +0200\n+++ /tmp/tmpjl1flj6g.java\t2022-07-19 18:41:51.262561988 +0200\n@@ -70,11 +70,11 @@\n     public static StdKeyDeserializer forType(Class<?> raw)\n     {\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class) {\n+if (raw == String.class || raw == Object.class || raw.class) { // as per [JACKSON-407] --raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n         } else if (raw == Integer.class) {\n             kind = TYPE_INT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class; {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-71/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\t2022-07-19 18:41:53.002552727 +0200\n+++ /tmp/tmpfbvk4jjs.java\t2022-07-19 18:41:53.006552702 +0200\n@@ -70,11 +70,11 @@\n     public static StdKeyDeserializer forType(Class<?> raw)\n     {\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class) {\n+if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class; {\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n         } else if (raw == Integer.class) {\n             kind = TYPE_INT;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (raw == String.class || raw == Object.class || raw.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-71/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\t2022-07-19 18:42:29.862356700 +0200\n+++ /tmp/tmp6w8fnm_0.java\t2022-07-19 18:42:29.862356700 +0200\n@@ -70,11 +70,11 @@\n     public static StdKeyDeserializer forType(Class<?> raw)\n     {\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class) {\n+if (raw == String.class || raw == Object.class || raw.class) {\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n         } else if (raw == Integer.class) {\n             kind = TYPE_INT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (raw == String.class || raw == Object.class) {",
        "fixed_line": "if (raw == String.class || raw == Object.class || raw == CharSequence.class) {"
    },
    "Closure-104": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (result == null) { // can be null if the type in result; caller should never be null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-104/src/com/google/javascript/rhino/jstype/UnionType.java\t2022-07-19 18:42:31.802346393 +0200\n+++ /tmp/tmp8lsszjkx.java\t2022-07-19 18:42:31.838346203 +0200\n@@ -286,11 +286,11 @@\n       }\n     } else if (that.isSubtype(this)) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+if (result == null) { // can be null if the type in result; caller should never be null)\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     } else {\n       return getNativeType(JSTypeNative.NO_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (result == null) { // should never be null if the type in result; caller should never be null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-104/src/com/google/javascript/rhino/jstype/UnionType.java\t2022-07-19 18:42:51.502241801 +0200\n+++ /tmp/tmpw3rqvkv6.java\t2022-07-19 18:42:51.502241801 +0200\n@@ -286,11 +286,11 @@\n       }\n     } else if (that.isSubtype(this)) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+if (result == null) { // should never be null if the type in result; caller should never be null)\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     } else {\n       return getNativeType(JSTypeNative.NO_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (result == null) { // should never be null if the type in result; caller should never be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-104/src/com/google/javascript/rhino/jstype/UnionType.java\t2022-07-19 18:43:10.030143530 +0200\n+++ /tmp/tmpz_0xo8dt.java\t2022-07-19 18:43:10.030143530 +0200\n@@ -286,11 +286,11 @@\n       }\n     } else if (that.isSubtype(this)) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+if (result == null) { // should never be null if the type in result; caller should never be null!\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     } else {\n       return getNativeType(JSTypeNative.NO_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (result == null) { // can be null if the type in result; caller should never be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-104/src/com/google/javascript/rhino/jstype/UnionType.java\t2022-07-19 18:43:28.374046324 +0200\n+++ /tmp/tmpu5fjwe21.java\t2022-07-19 18:43:28.378046303 +0200\n@@ -286,11 +286,11 @@\n       }\n     } else if (that.isSubtype(this)) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+if (result == null) { // can be null if the type in result; caller should never be null!\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     } else {\n       return getNativeType(JSTypeNative.NO_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (result == null) { // block == null; return result; caller should never be null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-104/src/com/google/javascript/rhino/jstype/UnionType.java\t2022-07-19 18:43:47.177946769 +0200\n+++ /tmp/tmpwmeq7rpv.java\t2022-07-19 18:43:47.177946769 +0200\n@@ -286,11 +286,11 @@\n       }\n     } else if (that.isSubtype(this)) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+if (result == null) { // block == null; return result; caller should never be null)\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     } else {\n       return getNativeType(JSTypeNative.NO_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (result == null) { // block == null; caller should never be null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-104/src/com/google/javascript/rhino/jstype/UnionType.java\t2022-07-19 18:44:05.489849908 +0200\n+++ /tmp/tmpk2esyazt.java\t2022-07-19 18:44:05.505849824 +0200\n@@ -286,11 +286,11 @@\n       }\n     } else if (that.isSubtype(this)) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+if (result == null) { // block == null; caller should never be null)\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     } else {\n       return getNativeType(JSTypeNative.NO_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (result == null) { // block only override if the type in result; caller should never be null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-104/src/com/google/javascript/rhino/jstype/UnionType.java\t2022-07-19 18:44:24.145751308 +0200\n+++ /tmp/tmp_pc9ivmi.java\t2022-07-19 18:44:24.145751308 +0200\n@@ -286,11 +286,11 @@\n       }\n     } else if (that.isSubtype(this)) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+if (result == null) { // block only override if the type in result; caller should never be null)\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     } else {\n       return getNativeType(JSTypeNative.NO_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (result == null) { // block == null; return result; caller should never be null; caller should never be null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-104/src/com/google/javascript/rhino/jstype/UnionType.java\t2022-07-19 18:44:42.345655195 +0200\n+++ /tmp/tmpgwq2tqxk.java\t2022-07-19 18:44:42.345655195 +0200\n@@ -286,11 +286,11 @@\n       }\n     } else if (that.isSubtype(this)) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+if (result == null) { // block == null; return result; caller should never be null; caller should never be null)\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     } else {\n       return getNativeType(JSTypeNative.NO_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (result == null) { // block only override if the type in result; caller should never be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-104/src/com/google/javascript/rhino/jstype/UnionType.java\t2022-07-19 18:45:00.449559662 +0200\n+++ /tmp/tmpkybacx7g.java\t2022-07-19 18:45:00.461559599 +0200\n@@ -286,11 +286,11 @@\n       }\n     } else if (that.isSubtype(this)) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+if (result == null) { // block only override if the type in result; caller should never be null!\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     } else {\n       return getNativeType(JSTypeNative.NO_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (result == null) { // block == null; can be null if the type in result; caller should never be null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-104/src/com/google/javascript/rhino/jstype/UnionType.java\t2022-07-19 18:45:18.769463061 +0200\n+++ /tmp/tmppmb9j8mt.java\t2022-07-19 18:45:18.769463061 +0200\n@@ -286,11 +286,11 @@\n       }\n     } else if (that.isSubtype(this)) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+if (result == null) { // block == null; can be null if the type in result; caller should never be null)\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     } else {\n       return getNativeType(JSTypeNative.NO_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (result != null) {",
        "fixed_line": "if (!result.isNoType()) {"
    },
    "Lang-1": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (hexLen > 16) { {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-1/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 18:45:37.145366233 +0200\n+++ /tmp/tmp8hc6qla1.java\t2022-07-19 18:45:37.185366023 +0200\n@@ -463,14 +463,11 @@\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n-                return createBigInteger(str);\n-            }\n-            if (hexDigits > 8) { // too many for an int\n+if (hexLen > 16) { {\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (hexhex > 16) { {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-1/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 18:45:38.981356563 +0200\n+++ /tmp/tmpc_vbuvbq.java\t2022-07-19 18:45:38.985356543 +0200\n@@ -463,14 +463,11 @@\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n-                return createBigInteger(str);\n-            }\n-            if (hexDigits > 8) { // too many for an int\n+if (hexhex > 16) { {\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (hexLen > 16) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-1/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 18:45:40.493348600 +0200\n+++ /tmp/tmp939c5j5e.java\t2022-07-19 18:45:40.493348600 +0200\n@@ -463,14 +463,11 @@\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n-                return createBigInteger(str);\n-            }\n-            if (hexDigits > 8) { // too many for an int\n+if (hexLen > 16) {\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (hexDigits > 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-1/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 18:45:42.105340111 +0200\n+++ /tmp/tmpve6vxiu0.java\t2022-07-19 18:45:42.105340111 +0200\n@@ -463,14 +463,11 @@\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n-                return createBigInteger(str);\n-            }\n-            if (hexDigits > 8) { // too many for an int\n+if (hexDigits > 1) {\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (hexDigits > 127) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-1/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 18:45:56.081266529 +0200\n+++ /tmp/tmptepvi1kc.java\t2022-07-19 18:45:56.085266507 +0200\n@@ -463,14 +463,11 @@\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n-                return createBigInteger(str);\n-            }\n-            if (hexDigits > 8) { // too many for an int\n+if (hexDigits > 127) {\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (hexDigits > 31) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-1/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 18:46:09.625195255 +0200\n+++ /tmp/tmpwfdfankd.java\t2022-07-19 18:46:09.629195234 +0200\n@@ -463,14 +463,11 @@\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n-                return createBigInteger(str);\n-            }\n-            if (hexDigits > 8) { // too many for an int\n+if (hexDigits > 31) {\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (hexDigits > 18) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-1/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 18:46:23.081124480 +0200\n+++ /tmp/tmp2t7d02yd.java\t2022-07-19 18:46:23.085124459 +0200\n@@ -463,14 +463,11 @@\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n-                return createBigInteger(str);\n-            }\n-            if (hexDigits > 8) { // too many for an int\n+if (hexDigits > 18) {\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (hexDigits > 16) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-1/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 18:46:36.505053906 +0200\n+++ /tmp/tmprfhl1gl7.java\t2022-07-19 18:46:36.505053906 +0200\n@@ -463,14 +463,11 @@\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n-                return createBigInteger(str);\n-            }\n-            if (hexDigits > 8) { // too many for an int\n+if (hexDigits > 16) {\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (hexDigits < 16) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-1/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 18:46:49.772984185 +0200\n+++ /tmp/tmp78ulyjaa.java\t2022-07-19 18:46:49.772984185 +0200\n@@ -463,14 +463,11 @@\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n-                return createBigInteger(str);\n-            }\n-            if (hexDigits > 8) { // too many for an int\n+if (hexDigits < 16) {\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (hexhex > 16) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-1/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 18:47:03.224913526 +0200\n+++ /tmp/tmp7gg6xf65.java\t2022-07-19 18:47:03.224913526 +0200\n@@ -463,14 +463,11 @@\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n-                return createBigInteger(str);\n-            }\n-            if (hexDigits > 8) { // too many for an int\n+if (hexhex > 16) {\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (hexDigits > 16) { // too many for Long return createBigInteger(str); } if (hexDigits > 8) { // too many for an int",
        "fixed_line": "char firstSigDigit = 0; // strip leading zeroes for(int i = pfxLen; i < str.length(); i++) { firstSigDigit = str.charAt(i); if (firstSigDigit == '0') { // count leading zeroes pfxLen++; } else { break; } } final int hexDigits = str.length() - pfxLen; if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { // too many for Long return createBigInteger(str); } if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { // too many for an int"
    },
    "Math-57": {
        "fixes": [
            {
                "k": 1,
                "patch": "int sum = 1; // we didn't really modify it was copied",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-57/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\t2022-07-19 18:47:05.244902919 +0200\n+++ /tmp/tmpdfdwyl6j.java\t2022-07-19 18:47:05.292902668 +0200\n@@ -170,11 +170,11 @@\n \n         final double[] dx2 = new double[pointSet.size()];\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+int sum = 1; // we didn't really modify it was copied\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                 final double d = p.distanceFrom(nearest.getCenter());\n                 sum += d * d;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int sum = 1; // we didn't really modify it was non-literal characters that might be valid (x0",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-57/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\t2022-07-19 18:47:50.004668044 +0200\n+++ /tmp/tmp5deqabur.java\t2022-07-19 18:47:50.020667961 +0200\n@@ -170,11 +170,11 @@\n \n         final double[] dx2 = new double[pointSet.size()];\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+int sum = 1; // we didn't really modify it was non-literal characters that might be valid (x0\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                 final double d = p.distanceFrom(nearest.getCenter());\n                 sum += d * d;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int sum = 1; // we didn't really modify it was last",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-57/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\t2022-07-19 18:48:32.344446154 +0200\n+++ /tmp/tmpiqhfdl6a.java\t2022-07-19 18:48:32.356446090 +0200\n@@ -170,11 +170,11 @@\n \n         final double[] dx2 = new double[pointSet.size()];\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+int sum = 1; // we didn't really modify it was last\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                 final double d = p.distanceFrom(nearest.getCenter());\n                 sum += d * d;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int sum = 1; // we didn't really gets this.x0",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-57/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\t2022-07-19 18:49:14.504225462 +0200\n+++ /tmp/tmp_3dfocv0.java\t2022-07-19 18:49:14.524225355 +0200\n@@ -170,11 +170,11 @@\n \n         final double[] dx2 = new double[pointSet.size()];\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+int sum = 1; // we didn't really gets this.x0\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                 final double d = p.distanceFrom(nearest.getCenter());\n                 sum += d * d;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int sum = 1; // we didn't really modify it was non-literal characters that were // we didn't really modify it.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-57/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\t2022-07-19 18:49:56.548005608 +0200\n+++ /tmp/tmpi6g8z04j.java\t2022-07-19 18:49:56.568005503 +0200\n@@ -170,11 +170,11 @@\n \n         final double[] dx2 = new double[pointSet.size()];\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+int sum = 1; // we didn't really modify it was non-literal characters that were // we didn't really modify it.\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                 final double d = p.distanceFrom(nearest.getCenter());\n                 sum += d * d;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int sum = 1; // we didn't really modify it.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-57/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\t2022-07-19 18:50:38.735785216 +0200\n+++ /tmp/tmphem31urs.java\t2022-07-19 18:50:38.751785131 +0200\n@@ -170,11 +170,11 @@\n \n         final double[] dx2 = new double[pointSet.size()];\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+int sum = 1; // we didn't really modify it.\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                 final double d = p.distanceFrom(nearest.getCenter());\n                 sum += d * d;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int sum = 1; // we didn't really modify it was non-literal characters that were // we didn't really gets this.x0",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-57/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\t2022-07-19 18:51:20.879565250 +0200\n+++ /tmp/tmpbuej0ofc.java\t2022-07-19 18:51:20.899565146 +0200\n@@ -170,11 +170,11 @@\n \n         final double[] dx2 = new double[pointSet.size()];\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+int sum = 1; // we didn't really modify it was non-literal characters that were // we didn't really gets this.x0\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                 final double d = p.distanceFrom(nearest.getCenter());\n                 sum += d * d;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int sum = 1; // we didn't really modify it was x",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-57/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\t2022-07-19 18:52:03.223344424 +0200\n+++ /tmp/tmpr8_vkrh6.java\t2022-07-19 18:52:03.239344341 +0200\n@@ -170,11 +170,11 @@\n \n         final double[] dx2 = new double[pointSet.size()];\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+int sum = 1; // we didn't really modify it was x\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                 final double d = p.distanceFrom(nearest.getCenter());\n                 sum += d * d;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int sum = 1; // we didn't really modify it's parent",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-57/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\t2022-07-19 18:52:45.635123413 +0200\n+++ /tmp/tmpnkb8iud4.java\t2022-07-19 18:52:45.655123309 +0200\n@@ -170,11 +170,11 @@\n \n         final double[] dx2 = new double[pointSet.size()];\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+int sum = 1; // we didn't really modify it's parent\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                 final double d = p.distanceFrom(nearest.getCenter());\n                 sum += d * d;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int sum = 1; // we didn't really modify it was non-literal characters that were // we didn't really modify it was copied",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-57/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\t2022-07-19 18:53:28.054902516 +0200\n+++ /tmp/tmpuw9yd50x.java\t2022-07-19 18:53:28.070902433 +0200\n@@ -170,11 +170,11 @@\n \n         final double[] dx2 = new double[pointSet.size()];\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+int sum = 1; // we didn't really modify it was non-literal characters that were // we didn't really modify it was copied\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                 final double d = p.distanceFrom(nearest.getCenter());\n                 sum += d * d;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "int sum = 0;",
        "fixed_line": "double sum = 0;"
    },
    "Mockito-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "catch (e.mockito.Pie.junit, e) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-5/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\t2022-07-19 18:54:10.270682825 +0200\n+++ /tmp/tmpbp8i8kja.java\t2022-07-19 18:54:10.306682639 +0200\n@@ -86,11 +86,11 @@\n                     error = null;\n                 }\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+catch (e.mockito.Pie.junit, e) {\n                 error = handleVerifyException(e);\n             }\n         }\n \n         if (error != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "catch (e.mockito.Pie.junit. containsValue.ArgumentsAreDifferent e) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-5/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\t2022-07-19 18:54:22.958616823 +0200\n+++ /tmp/tmpzx4zlfae.java\t2022-07-19 18:54:22.958616823 +0200\n@@ -86,11 +86,11 @@\n                     error = null;\n                 }\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+catch (e.mockito.Pie.junit. containsValue.ArgumentsAreDifferent e) {\n                 error = handleVerifyException(e);\n             }\n         }\n \n         if (error != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "catch (e.mockito.Pie.junit.ArgumentsAreDifferent e) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-5/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\t2022-07-19 18:54:32.130569118 +0200\n+++ /tmp/tmp1rn_h_s5.java\t2022-07-19 18:54:32.130569118 +0200\n@@ -86,11 +86,11 @@\n                     error = null;\n                 }\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+catch (e.mockito.Pie.junit.ArgumentsAreDifferent e) {\n                 error = handleVerifyException(e);\n             }\n         }\n \n         if (error != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "catch (e.mockito.junit.class.junit.CharAreDifferent e) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-5/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\t2022-07-19 18:54:41.214521876 +0200\n+++ /tmp/tmpy0rj1ov8.java\t2022-07-19 18:54:41.214521876 +0200\n@@ -86,11 +86,11 @@\n                     error = null;\n                 }\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+catch (e.mockito.junit.class.junit.CharAreDifferent e) {\n                 error = handleVerifyException(e);\n             }\n         }\n \n         if (error != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "catch (e.mockito.Pie.junit.CharAreDifferent e) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-5/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\t2022-07-19 18:54:49.018481294 +0200\n+++ /tmp/tmp9ruqlrww.java\t2022-07-19 18:54:49.018481294 +0200\n@@ -86,11 +86,11 @@\n                     error = null;\n                 }\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+catch (e.mockito.Pie.junit.CharAreDifferent e) {\n                 error = handleVerifyException(e);\n             }\n         }\n \n         if (error != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "catch (e.mockito.Pie.junit.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-5/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\t2022-07-19 18:54:58.050434333 +0200\n+++ /tmp/tmpvol44ljn.java\t2022-07-19 18:54:58.050434333 +0200\n@@ -86,11 +86,11 @@\n                     error = null;\n                 }\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+catch (e.mockito.Pie.junit.class) {\n                 error = handleVerifyException(e);\n             }\n         }\n \n         if (error != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "catch (e.mockito.verification.junit.ArgumentsAreDifferent e) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-5/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\t2022-07-19 18:55:06.034392829 +0200\n+++ /tmp/tmp_zfp1f50.java\t2022-07-19 18:55:06.038392808 +0200\n@@ -86,11 +86,11 @@\n                     error = null;\n                 }\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+catch (e.mockito.verification.junit.ArgumentsAreDifferent e) {\n                 error = handleVerifyException(e);\n             }\n         }\n \n         if (error != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "catch (e.mockito.junit.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-5/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\t2022-07-19 18:55:15.154345421 +0200\n+++ /tmp/tmp8dp7h5io.java\t2022-07-19 18:55:15.154345421 +0200\n@@ -86,11 +86,11 @@\n                     error = null;\n                 }\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+catch (e.mockito.junit.class) {\n                 error = handleVerifyException(e);\n             }\n         }\n \n         if (error != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "catch (e.mockito.verification.junit.CharAreDifferent e) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-5/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\t2022-07-19 18:55:23.314303005 +0200\n+++ /tmp/tmpp7zrpqh0.java\t2022-07-19 18:55:23.314303005 +0200\n@@ -86,11 +86,11 @@\n                     error = null;\n                 }\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+catch (e.mockito.verification.junit.CharAreDifferent e) {\n                 error = handleVerifyException(e);\n             }\n         }\n \n         if (error != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "catch (e.mockito.junit.class.junit.ArgumentsAreDifferent e) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-5/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\t2022-07-19 18:55:32.646254508 +0200\n+++ /tmp/tmpq0espfd0.java\t2022-07-19 18:55:32.650254487 +0200\n@@ -86,11 +86,11 @@\n                     error = null;\n                 }\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+catch (e.mockito.junit.class.junit.ArgumentsAreDifferent e) {\n                 error = handleVerifyException(e);\n             }\n         }\n \n         if (error != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {",
        "fixed_line": "catch (AssertionError e) {"
    },
    "Lang-17": {
        "fixes": [
            {
                "k": 1,
                "patch": "int len = Character.length - pos]; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-17/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 18:55:40.746212416 +0200\n+++ /tmp/tmpdx98bo_3.java\t2022-07-19 18:55:40.762212335 +0200\n@@ -78,30 +78,11 @@\n         }\n         if (input == null) {\n             return;\n         }\n         int pos = 0;\n-        int len = Character.codePointCount(input, 0, input.length());\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n-                out.write(c);\n-            }\n-            else {\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                    if (pos < len - 2) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n-                    } else {\n-                        pos++;\n-                    }\n-                }\n-                pos--;\n-            }\n-            pos++;\n+int len = Character.length - pos]; }\n         }\n     }\n \n     /**\n      * Helper method to create a merger of this translator with another set of \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int len = Character.length - pos pos;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-17/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 18:55:42.422203705 +0200\n+++ /tmp/tmpi2c_u_p0.java\t2022-07-19 18:55:42.422203705 +0200\n@@ -78,30 +78,11 @@\n         }\n         if (input == null) {\n             return;\n         }\n         int pos = 0;\n-        int len = Character.codePointCount(input, 0, input.length());\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n-                out.write(c);\n-            }\n-            else {\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                    if (pos < len - 2) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n-                    } else {\n-                        pos++;\n-                    }\n-                }\n-                pos--;\n-            }\n-            pos++;\n+int len = Character.length - pos pos;\n         }\n     }\n \n     /**\n      * Helper method to create a merger of this translator with another set of \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int len = Character.length - pos pos pos;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-17/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 18:55:43.878196142 +0200\n+++ /tmp/tmpldxxo2u2.java\t2022-07-19 18:55:43.878196142 +0200\n@@ -78,30 +78,11 @@\n         }\n         if (input == null) {\n             return;\n         }\n         int pos = 0;\n-        int len = Character.codePointCount(input, 0, input.length());\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n-                out.write(c);\n-            }\n-            else {\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                    if (pos < len - 2) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n-                    } else {\n-                        pos++;\n-                    }\n-                }\n-                pos--;\n-            }\n-            pos++;\n+int len = Character.length - pos pos pos;\n         }\n     }\n \n     /**\n      * Helper method to create a merger of this translator with another set of \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int len = Character.length; pos pos pos pos < len;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-17/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 18:55:45.290188805 +0200\n+++ /tmp/tmp5g3vv7jw.java\t2022-07-19 18:55:45.294188784 +0200\n@@ -78,30 +78,11 @@\n         }\n         if (input == null) {\n             return;\n         }\n         int pos = 0;\n-        int len = Character.codePointCount(input, 0, input.length());\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n-                out.write(c);\n-            }\n-            else {\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                    if (pos < len - 2) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n-                    } else {\n-                        pos++;\n-                    }\n-                }\n-                pos--;\n-            }\n-            pos++;\n+int len = Character.length; pos pos pos pos < len;\n         }\n     }\n \n     /**\n      * Helper method to create a merger of this translator with another set of \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int len = Character.length - pos;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-17/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 18:55:46.838180762 +0200\n+++ /tmp/tmpi9a5s_2c.java\t2022-07-19 18:55:46.838180762 +0200\n@@ -78,30 +78,11 @@\n         }\n         if (input == null) {\n             return;\n         }\n         int pos = 0;\n-        int len = Character.codePointCount(input, 0, input.length());\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n-                out.write(c);\n-            }\n-            else {\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                    if (pos < len - 2) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n-                    } else {\n-                        pos++;\n-                    }\n-                }\n-                pos--;\n-            }\n-            pos++;\n+int len = Character.length - pos;\n         }\n     }\n \n     /**\n      * Helper method to create a merger of this translator with another set of \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int len = Character.length; pos pos pos pos pos < len;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-17/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 18:55:48.338172968 +0200\n+++ /tmp/tmpc6v93z5c.java\t2022-07-19 18:55:48.342172947 +0200\n@@ -78,30 +78,11 @@\n         }\n         if (input == null) {\n             return;\n         }\n         int pos = 0;\n-        int len = Character.codePointCount(input, 0, input.length());\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n-                out.write(c);\n-            }\n-            else {\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                    if (pos < len - 2) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n-                    } else {\n-                        pos++;\n-                    }\n-                }\n-                pos--;\n-            }\n-            pos++;\n+int len = Character.length; pos pos pos pos pos < len;\n         }\n     }\n \n     /**\n      * Helper method to create a merger of this translator with another set of \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int len = Character.length; pos pos pos < len;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-17/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 18:55:49.758165590 +0200\n+++ /tmp/tmpnu2fqms3.java\t2022-07-19 18:55:49.758165590 +0200\n@@ -78,30 +78,11 @@\n         }\n         if (input == null) {\n             return;\n         }\n         int pos = 0;\n-        int len = Character.codePointCount(input, 0, input.length());\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n-                out.write(c);\n-            }\n-            else {\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                    if (pos < len - 2) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n-                    } else {\n-                        pos++;\n-                    }\n-                }\n-                pos--;\n-            }\n-            pos++;\n+int len = Character.length; pos pos pos < len;\n         }\n     }\n \n     /**\n      * Helper method to create a merger of this translator with another set of \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int len = Character.length; pos pos pos pos pos pos < len;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-17/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 18:55:51.226157962 +0200\n+++ /tmp/tmp3z4yovu1.java\t2022-07-19 18:55:51.226157962 +0200\n@@ -78,30 +78,11 @@\n         }\n         if (input == null) {\n             return;\n         }\n         int pos = 0;\n-        int len = Character.codePointCount(input, 0, input.length());\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n-                out.write(c);\n-            }\n-            else {\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                    if (pos < len - 2) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n-                    } else {\n-                        pos++;\n-                    }\n-                }\n-                pos--;\n-            }\n-            pos++;\n+int len = Character.length; pos pos pos pos pos pos < len;\n         }\n     }\n \n     /**\n      * Helper method to create a merger of this translator with another set of \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int len = Character.codePointCount, 0, pos;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-17/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 18:55:52.694150336 +0200\n+++ /tmp/tmplics5qg6.java\t2022-07-19 18:55:52.698150315 +0200\n@@ -78,30 +78,11 @@\n         }\n         if (input == null) {\n             return;\n         }\n         int pos = 0;\n-        int len = Character.codePointCount(input, 0, input.length());\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n-                out.write(c);\n-            }\n-            else {\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                    if (pos < len - 2) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n-                    } else {\n-                        pos++;\n-                    }\n-                }\n-                pos--;\n-            }\n-            pos++;\n+int len = Character.codePointCount, 0, pos;\n         }\n     }\n \n     /**\n      * Helper method to create a merger of this translator with another set of \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int len = Character.length; pos pos pos pos pos pos pos < len;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-17/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 18:55:54.130142872 +0200\n+++ /tmp/tmpzw2qmwpe.java\t2022-07-19 18:55:54.130142872 +0200\n@@ -78,30 +78,11 @@\n         }\n         if (input == null) {\n             return;\n         }\n         int pos = 0;\n-        int len = Character.codePointCount(input, 0, input.length());\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n-                out.write(c);\n-            }\n-            else {\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                    if (pos < len - 2) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n-                    } else {\n-                        pos++;\n-                    }\n-                }\n-                pos--;\n-            }\n-            pos++;\n+int len = Character.length; pos pos pos pos pos pos pos < len;\n         }\n     }\n \n     /**\n      * Helper method to create a merger of this translator with another set of \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "int len = Character.codePointCount(input, 0, input.length()); while (pos < len) { int consumed = translate(input, pos, out); if (consumed == 0) { char[] c = Character.toChars(Character.codePointAt(input, pos)); out.write(c); } else { // // contract with translators is that they have to understand codepoints // // and they just took care of a surrogate pair for (int pt = 0; pt < consumed; pt++) { if (pos < len - 2) { pos += Character.charCount(Character.codePointAt(input, pos)); } else { pos++; } } pos--; } pos++;",
        "fixed_line": "int len = input.length(); while (pos < len) { int consumed = translate(input, pos, out); if (consumed == 0) { char[] c = Character.toChars(Character.codePointAt(input, pos)); out.write(c); pos+= c.length; continue;"
    },
    "Closure-40": {
        "fixes": [
            {
                "k": 1,
                "patch": "JsName name = getNameNameNode, false).ns.new ClassDefiningFunctionNode, parent, parent.getParent()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-40/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 18:55:55.842133979 +0200\n+++ /tmp/tmpls6nhk_v.java\t2022-07-19 18:55:55.862133877 +0200\n@@ -630,15 +630,11 @@\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n-          }\n+JsName name = getNameNameNode, false).ns.new ClassDefiningFunctionNode, parent, parent.getParent()));\n         }\n       }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "JsName name = getNameNameNode, false).ns.new ClassDefiningFunctionNode(parent, n, parent, parent.getParent()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-40/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 18:56:00.622109147 +0200\n+++ /tmp/tmprivq7s6z.java\t2022-07-19 18:56:00.626109126 +0200\n@@ -630,15 +630,11 @@\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n-          }\n+JsName name = getNameNameNode, false).ns.new ClassDefiningFunctionNode(parent, n, parent, parent.getParent()));\n         }\n       }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "JsName name = getNameNameNode, false).ns.new ClassDefiningFunctionNode( name, parent, parent.getParent()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-40/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 18:56:03.922092003 +0200\n+++ /tmp/tmp16eqnsp8.java\t2022-07-19 18:56:03.926091982 +0200\n@@ -630,15 +630,11 @@\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n-          }\n+JsName name = getNameNameNode, false).ns.new ClassDefiningFunctionNode( name, parent, parent.getParent()));\n         }\n       }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "JsName name = getNameNameNode, false).ns.new ClassDefiningFunctionNode(ns, n, parent, parent.getParent()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-40/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 18:56:07.422073821 +0200\n+++ /tmp/tmp7bn09xbh.java\t2022-07-19 18:56:07.422073821 +0200\n@@ -630,15 +630,11 @@\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n-          }\n+JsName name = getNameNameNode, false).ns.new ClassDefiningFunctionNode(ns, n, parent, parent.getParent()));\n         }\n       }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "JsName name = getNameNameNode(ns.name, false) - new ClassDefiningFunctionNode, parent, parent.getParent()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-40/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 18:56:10.762056471 +0200\n+++ /tmp/tmp5ctdbi23.java\t2022-07-19 18:56:10.766056450 +0200\n@@ -630,15 +630,11 @@\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n-          }\n+JsName name = getNameNameNode(ns.name, false) - new ClassDefiningFunctionNode, parent, parent.getParent()));\n         }\n       }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "JsName name = getNameNameNode, false).ns.new ClassDefiningFunctionNode(parent, n, parent, parent);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-40/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 18:56:14.210038558 +0200\n+++ /tmp/tmpnv7y3wxs.java\t2022-07-19 18:56:14.214038541 +0200\n@@ -630,15 +630,11 @@\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n-          }\n+JsName name = getNameNameNode, false).ns.new ClassDefiningFunctionNode(parent, n, parent, parent);\n         }\n       }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "JsName name = getNameNameNode(ns.name, false).ns.isFunctionNode, parent, parent.getParent()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-40/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 18:56:17.646020711 +0200\n+++ /tmp/tmp7duqw7fn.java\t2022-07-19 18:56:17.650020694 +0200\n@@ -630,15 +630,11 @@\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n-          }\n+JsName name = getNameNameNode(ns.name, false).ns.isFunctionNode, parent, parent.getParent()));\n         }\n       }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "JsName name = getNameFunctionNode, false).ns.new ClassDefiningFunctionNode(ns, n, parent, parent.getParent()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-40/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 18:56:21.130002617 +0200\n+++ /tmp/tmpt46x4_cz.java\t2022-07-19 18:56:21.130002617 +0200\n@@ -630,15 +630,11 @@\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n-          }\n+JsName name = getNameFunctionNode, false).ns.new ClassDefiningFunctionNode(ns, n, parent, parent.getParent()));\n         }\n       }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "JsName name = getNameFunctionNode, false).ns.new ClassDefiningFunctionNode(parent, n, parent, parent.getParent()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-40/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 18:56:24.749983815 +0200\n+++ /tmp/tmp8xkb0rb9.java\t2022-07-19 18:56:24.749983815 +0200\n@@ -630,15 +630,11 @@\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n-          }\n+JsName name = getNameFunctionNode, false).ns.new ClassDefiningFunctionNode(parent, n, parent, parent.getParent()));\n         }\n       }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "JsName name = getNameFunctionNode, false).ns.new ClassDefiningFunctionNode, parent, parent.getParent()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-40/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 18:56:28.321965264 +0200\n+++ /tmp/tmp6higs8m3.java\t2022-07-19 18:56:28.321965264 +0200\n@@ -630,15 +630,11 @@\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n-          }\n+JsName name = getNameFunctionNode, false).ns.new ClassDefiningFunctionNode, parent, parent.getParent()));\n         }\n       }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "JsName name = getName(ns.name, false); if (name != null) { refNodes.add(new ClassDefiningFunctionNode( name, n, parent, parent.getParent())); }",
        "fixed_line": "JsName name = getName(ns.name, true);"
    },
    "Closure-152": {
        "fixes": [
            {
                "k": 1,
                "patch": "typeOfThis = (ObjectType) typeOfThis; t, scope!= scope;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-152/src/com/google/javascript/rhino/jstype/FunctionType.java\t2022-07-19 18:56:32.049945903 +0200\n+++ /tmp/tmp5fjg2646.java\t2022-07-19 18:56:32.089945696 +0200\n@@ -866,11 +866,11 @@\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+typeOfThis = (ObjectType) typeOfThis; t, scope!= scope;\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n         ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "typeOfThis = (ObjectType) typeOfThis; t, scope = typeOfThis;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-152/src/com/google/javascript/rhino/jstype/FunctionType.java\t2022-07-19 18:56:34.133935081 +0200\n+++ /tmp/tmp9c3ncnwa.java\t2022-07-19 18:56:34.133935081 +0200\n@@ -866,11 +866,11 @@\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+typeOfThis = (ObjectType) typeOfThis; t, scope = typeOfThis;\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n         ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "typeOfThis = (ObjectType) typeOfThis; t, node, scope);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-152/src/com/google/javascript/rhino/jstype/FunctionType.java\t2022-07-19 18:56:35.797926440 +0200\n+++ /tmp/tmpkm4agrwi.java\t2022-07-19 18:56:35.797926440 +0200\n@@ -866,11 +866,11 @@\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+typeOfThis = (ObjectType) typeOfThis; t, node, scope);\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n         ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "typeOfThis = (ObjectType) typeOfThis; t, scope,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-152/src/com/google/javascript/rhino/jstype/FunctionType.java\t2022-07-19 18:56:37.249918899 +0200\n+++ /tmp/tmpktsskex7.java\t2022-07-19 18:56:37.249918899 +0200\n@@ -866,11 +866,11 @@\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+typeOfThis = (ObjectType) typeOfThis; t, scope,\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n         ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "typeOfThis = (ObjectType) typeOfThis; t, scope = scope;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-152/src/com/google/javascript/rhino/jstype/FunctionType.java\t2022-07-19 18:56:38.909910279 +0200\n+++ /tmp/tmppwrc008e.java\t2022-07-19 18:56:38.909910279 +0200\n@@ -866,11 +866,11 @@\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+typeOfThis = (ObjectType) typeOfThis; t, scope = scope;\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n         ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "typeOfThis = (ObjectType) typeOfThis; t, scope) scope;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-152/src/com/google/javascript/rhino/jstype/FunctionType.java\t2022-07-19 18:56:40.445902302 +0200\n+++ /tmp/tmpq6ge6vys.java\t2022-07-19 18:56:40.445902302 +0200\n@@ -866,11 +866,11 @@\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+typeOfThis = (ObjectType) typeOfThis; t, scope) scope;\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n         ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "typeOfThis = (ObjectType) typeOfThis; t, scope, scope);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-152/src/com/google/javascript/rhino/jstype/FunctionType.java\t2022-07-19 18:56:42.113893641 +0200\n+++ /tmp/tmpn0xjeecg.java\t2022-07-19 18:56:42.113893641 +0200\n@@ -866,11 +866,11 @@\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+typeOfThis = (ObjectType) typeOfThis; t, scope, scope);\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n         ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "typeOfThis = (ObjectType) typeOfThis; t, scope);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-152/src/com/google/javascript/rhino/jstype/FunctionType.java\t2022-07-19 18:56:43.705885374 +0200\n+++ /tmp/tmpqcbqtgsz.java\t2022-07-19 18:56:43.705885374 +0200\n@@ -866,11 +866,11 @@\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+typeOfThis = (ObjectType) typeOfThis; t, scope);\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n         ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "typeOfThis = (ObjectType) typeOfThis; t, scope;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-152/src/com/google/javascript/rhino/jstype/FunctionType.java\t2022-07-19 18:56:45.173877751 +0200\n+++ /tmp/tmpep1lo69w.java\t2022-07-19 18:56:45.177877730 +0200\n@@ -866,11 +866,11 @@\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+typeOfThis = (ObjectType) typeOfThis; t, scope;\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n         ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "typeOfThis = (ObjectType) typeOfThis; t, scope!= scope) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-152/src/com/google/javascript/rhino/jstype/FunctionType.java\t2022-07-19 18:56:46.841869089 +0200\n+++ /tmp/tmp_8gv0ds1.java\t2022-07-19 18:56:46.845869070 +0200\n@@ -866,11 +866,11 @@\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+typeOfThis = (ObjectType) typeOfThis; t, scope!= scope) {\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n         ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);",
        "fixed_line": "JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope); if (maybeTypeOfThis instanceof ObjectType) { typeOfThis = (ObjectType) maybeTypeOfThis; }"
    },
    "Cli-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (option.hasArg() && (option.getArgName() == null ||",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-11/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 18:56:48.581860056 +0200\n+++ /tmp/tmpw0sr2q5t.java\t2022-07-19 18:56:48.657859661 +0200\n@@ -627,11 +627,11 @@\n         {\n             buff.append(\"--\").append(option.getLongOpt());\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+if (option.hasArg() && (option.getArgName() == null ||\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n \n         // if the Option is not a required option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (option.hasArg() && (option.getArgName()!= null)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-11/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 18:56:50.333850958 +0200\n+++ /tmp/tmpaigwbf9i.java\t2022-07-19 18:56:50.333850958 +0200\n@@ -627,11 +627,11 @@\n         {\n             buff.append(\"--\").append(option.getLongOpt());\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+if (option.hasArg() && (option.getArgName()!= null)) {\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n \n         // if the Option is not a required option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (option.hasArg() && (option.getArgName() == null)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-11/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 18:56:52.197841280 +0200\n+++ /tmp/tmpfiohpnb3.java\t2022-07-19 18:56:52.201841259 +0200\n@@ -627,11 +627,11 @@\n         {\n             buff.append(\"--\").append(option.getLongOpt());\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+if (option.hasArg() && (option.getArgName() == null)) {\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n \n         // if the Option is not a required option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (option.hasArg() && (option.getArgName()!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-11/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 18:56:53.661833680 +0200\n+++ /tmp/tmpszv6_9ra.java\t2022-07-19 18:56:53.665833658 +0200\n@@ -627,11 +627,11 @@\n         {\n             buff.append(\"--\").append(option.getLongOpt());\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+if (option.hasArg() && (option.getArgName()!= null) {\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n \n         // if the Option is not a required option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (option.hasArg() && (option.getArgName() == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-11/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 18:56:55.101826203 +0200\n+++ /tmp/tmpsxp_j7dl.java\t2022-07-19 18:56:55.101826203 +0200\n@@ -627,11 +627,11 @@\n         {\n             buff.append(\"--\").append(option.getLongOpt());\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+if (option.hasArg() && (option.getArgName() == null) {\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n \n         // if the Option is not a required option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (option.hasArg() || (option.getArgName()!= null)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-11/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 18:56:56.525818810 +0200\n+++ /tmp/tmpv2gtj31y.java\t2022-07-19 18:56:56.529818789 +0200\n@@ -627,11 +627,11 @@\n         {\n             buff.append(\"--\").append(option.getLongOpt());\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+if (option.hasArg() || (option.getArgName()!= null)) {\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n \n         // if the Option is not a required option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (option.hasArg() || (option.getArgName()!= null)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-11/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 18:56:58.009811104 +0200\n+++ /tmp/tmpjkosn_cv.java\t2022-07-19 18:56:58.009811104 +0200\n@@ -627,11 +627,11 @@\n         {\n             buff.append(\"--\").append(option.getLongOpt());\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+if (option.hasArg() || (option.getArgName()!= null)) {\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n \n         // if the Option is not a required option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (option.hasArg() && (option.getArgName()!= null)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-11/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 18:56:59.449803627 +0200\n+++ /tmp/tmpqq884l_7.java\t2022-07-19 18:56:59.453803606 +0200\n@@ -627,11 +627,11 @@\n         {\n             buff.append(\"--\").append(option.getLongOpt());\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+if (option.hasArg() && (option.getArgName()!= null)) {\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n \n         // if the Option is not a required option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (option.hasArg() && (option.getArgName!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-11/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 18:57:01.045795342 +0200\n+++ /tmp/tmp7z3ev_l5.java\t2022-07-19 18:57:01.045795342 +0200\n@@ -627,11 +627,11 @@\n         {\n             buff.append(\"--\").append(option.getLongOpt());\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+if (option.hasArg() && (option.getArgName!= null) {\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n \n         // if the Option is not a required option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (option.hasArg() && (option.getArgName() == null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-11/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 18:57:02.481787887 +0200\n+++ /tmp/tmpgawld2xd.java\t2022-07-19 18:57:02.485787866 +0200\n@@ -627,11 +627,11 @@\n         {\n             buff.append(\"--\").append(option.getLongOpt());\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+if (option.hasArg() && (option.getArgName() == null)\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n \n         // if the Option is not a required option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (option.hasArg() && (option.getArgName() != null))",
        "fixed_line": "if (option.hasArg() && option.hasArgName())"
    },
    "JacksonCore-21": {
        "fixes": [
            {
                "k": 1,
                "patch": "// return _currToken == JsonToken.VALUE_NUMBER_INT || _nextToken == JsonToken.VALUE_NUMBER_FLOAT) {",
                "patch_diff": "// return _currToken == JsonToken.VALUE_NUMBER_INT || _nextToken == JsonToken.VALUE_NUMBER_FLOAT) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// return _currToken == JsonToken.VALUE_NUMBER_INT || _nextToken == JsonToken.START_ARRAY) {",
                "patch_diff": "// return _currToken == JsonToken.VALUE_NUMBER_INT || _nextToken == JsonToken.START_ARRAY) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// return _currToken == JsonToken.VALUE_NUMBER_INT || _nextToken == JsonToken.FIELD_NAME) {",
                "patch_diff": "// return _currToken == JsonToken.VALUE_NUMBER_INT || _nextToken == JsonToken.FIELD_NAME) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// return _currToken == JsonToken.VALUE_STRING && _currToken!= JsonToken.FIELD_NAME) {",
                "patch_diff": "// return _currToken == JsonToken.VALUE_STRING && _currToken!= JsonToken.FIELD_NAME) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// return _currToken == JsonToken.VALUE_NUMBER_INT || _nextToken == JsonToken.FIELD_NAME;",
                "patch_diff": "// return _currToken == JsonToken.VALUE_NUMBER_INT || _nextToken == JsonToken.FIELD_NAME;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// return _currToken == JsonToken.VALUE_NUMBER_INT || _nextToken == JsonToken.START_ARRAY;",
                "patch_diff": "// return _currToken == JsonToken.VALUE_NUMBER_INT || _nextToken == JsonToken.START_ARRAY;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// return _currToken == JsonToken.FIELD_NAME && _nextToken!= JsonToken.END_OBJECT) {",
                "patch_diff": "// return _currToken == JsonToken.FIELD_NAME && _nextToken!= JsonToken.END_OBJECT) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// return _currToken == JsonToken.FIELD_NAME && _nextToken!= JsonToken.END_ARRAY;",
                "patch_diff": "// return _currToken == JsonToken.FIELD_NAME && _nextToken!= JsonToken.END_ARRAY;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// return _currToken == JsonToken.VALUE_NUMBER_INT || _nextToken == JsonToken.VALUE_NUMBER_FLOAT;",
                "patch_diff": "// return _currToken == JsonToken.VALUE_NUMBER_INT || _nextToken == JsonToken.VALUE_NUMBER_FLOAT;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// return _currToken == JsonToken.VALUE_NUMBER_INT || _nextToken == JsonToken.END_ARRAY) {",
                "patch_diff": "// return _currToken == JsonToken.VALUE_NUMBER_INT || _nextToken == JsonToken.END_ARRAY) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (!_includePath) { if (_currToken.isStructEnd()) { if (_headContext.isStartHandled()) { return (_currToken = null); } } else if (_currToken.isScalarValue()) { //else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once // then return null if (!_headContext.isStartHandled() && (_itemFilter == TokenFilter.INCLUDE_ALL)) { return (_currToken = null); } }"
    },
    "Math-25": {
        "fixes": [
            {
                "k": 1,
                "patch": "// return a = 0.5 * (xMax - xMin); }",
                "patch_diff": "// return a = 0.5 * (xMax - xMin); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// return a = 0.5 * (xMax - xMin); } else if (c1 > c2) {",
                "patch_diff": "// return a = 0.5 * (xMax - xMin); } else if (c1 > c2) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// } else if (c1 > c2) {",
                "patch_diff": "// } else if (c1 > c2) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// return a = 0.5 * (xMax - xMin); } else if (c1 > c2); }",
                "patch_diff": "// return a = 0.5 * (xMax - xMin); } else if (c1 > c2); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// return a = 0.5 * (xMax - xMin); } else if (c1!= null) {",
                "patch_diff": "// return a = 0.5 * (xMax - xMin); } else if (c1!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// return a = 0.5 * (xMax - xMin); } else if (c1 > c2); } else if (c1!= null) {",
                "patch_diff": "// return a = 0.5 * (xMax - xMin); } else if (c1 > c2); } else if (c1!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// return a = 0.5 * (xMax - xMin); } else if (c1 > c2); } else if (c1 > c2) {",
                "patch_diff": "// return a = 0.5 * (xMax - xMin); } else if (c1 > c2); } else if (c1 > c2) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// return a = 0.5 * (xMax - xMin); } else if (c1!= c2) {",
                "patch_diff": "// return a = 0.5 * (xMax - xMin); } else if (c1!= c2) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// return a = 0.5 * (xMax - xMin); } else if (c1 > c2); } else if (c1!= c2) {",
                "patch_diff": "// return a = 0.5 * (xMax - xMin); } else if (c1 > c2); } else if (c1!= c2) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// return a = 0.5 * (xMax - xMin); } else if (c1!= null && c2 > xMax) {",
                "patch_diff": "// return a = 0.5 * (xMax - xMin); } else if (c1!= null && c2 > xMax) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (c2 == 0) { // In some ill-conditioned cases (cf. MATH-844), the guesser // procedure cannot produce sensible results. throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR); }"
    },
    "JacksonDatabind-88": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if (cls == null) { // can't really modify it's do implicit re-parse",
                "patch_diff": "// if (cls == null) { // can't really modify it's do implicit re-parse",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// if (cls == null) { // can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "patch_diff": "// if (cls == null) { // can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if (cls == null) { // can't really modify it's do implicit re-initialized or EMPTY",
                "patch_diff": "// if (cls == null) { // can't really modify it's do implicit re-initialized or EMPTY",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// We can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// note: can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "patch_diff": "// note: can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if (cls == null) { // can't really modify it was non-literal characters that might be valid (e if it's",
                "patch_diff": "// if (cls == null) { // can't really modify it was non-literal characters that might be valid (e if it's",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// if (cls == null) { // can't really modify it was non-literal characters that might be null or EMPTY",
                "patch_diff": "// if (cls == null) { // can't really modify it was non-literal characters that might be null or EMPTY",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// if (cls == null) { // can't really modify it was non-literal characters that might be valid (e if it.",
                "patch_diff": "// if (cls == null) { // can't really modify it was non-literal characters that might be valid (e if it.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// note: can't really modify it was non-literal characters that might be valid (e if it.",
                "patch_diff": "// note: can't really modify it was non-literal characters that might be valid (e if it.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// We can't really modify it was non-literal characters that might be valid (e if it.",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (e if it.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) { // Probably cleaner to have a method in `TypeFactory` but can't add in patch throw new IllegalArgumentException(String.format( \"Class %s not subtype of %s\", t.getRawClass().getName(), _baseType)); }"
    },
    "Lang-16": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (str.startsWith(\"0x\") || str.startsWith(\"-1]x\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 18:57:09.565751110 +0200\n+++ /tmp/tmp2iq3ty6f.java\t2022-07-19 18:57:09.625750800 +0200\n@@ -453,11 +453,11 @@\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+if (str.startsWith(\"0x\") || str.startsWith(\"-1]x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (str.startsWith(\"0x\") || str.startsWith(\"-1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 18:57:20.241695691 +0200\n+++ /tmp/tmpxd7is2ks.java\t2022-07-19 18:57:20.241695691 +0200\n@@ -453,11 +453,11 @@\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+if (str.startsWith(\"0x\") || str.startsWith(\"-1) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (str.startsWith(\"0x\") && str.startsWith(\"-0x\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 18:57:21.737687925 +0200\n+++ /tmp/tmplxdxowgm.java\t2022-07-19 18:57:21.741687905 +0200\n@@ -453,11 +453,11 @@\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+if (str.startsWith(\"0x\") && str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (str.startsWith(\"0x\") || str.startsWith(\"-5x\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 18:57:31.841635481 +0200\n+++ /tmp/tmp5r9bhywk.java\t2022-07-19 18:57:31.845635462 +0200\n@@ -453,11 +453,11 @@\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+if (str.startsWith(\"0x\") || str.startsWith(\"-5x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (str.startsWith(\"0x\") || str.startsWith(\"Lexx\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 18:57:41.705584289 +0200\n+++ /tmp/tmpxpsfv7dz.java\t2022-07-19 18:57:41.705584289 +0200\n@@ -453,11 +453,11 @@\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+if (str.startsWith(\"0x\") || str.startsWith(\"Lexx\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 18:57:51.685532497 +0200\n+++ /tmp/tmp6efjerdx.java\t2022-07-19 18:57:51.685532497 +0200\n@@ -453,11 +453,11 @@\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (str.startsWith(\"0x\") || str.startsWith(\"-1; {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 18:58:01.861479694 +0200\n+++ /tmp/tmpdhsjh851.java\t2022-07-19 18:58:01.873479633 +0200\n@@ -453,11 +453,11 @@\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+if (str.startsWith(\"0x\") || str.startsWith(\"-1; {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (str.startsWith(\"0x\") || str.startsWith(\"getx\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 18:58:03.517471103 +0200\n+++ /tmp/tmpdpwvngky.java\t2022-07-19 18:58:03.521471082 +0200\n@@ -453,11 +453,11 @@\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+if (str.startsWith(\"0x\") || str.startsWith(\"getx\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (str.startsWith(\"0x\") || str.startsWith(\">x\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 18:58:13.325420215 +0200\n+++ /tmp/tmpihlj7w6k.java\t2022-07-19 18:58:13.341420132 +0200\n@@ -453,11 +453,11 @@\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+if (str.startsWith(\"0x\") || str.startsWith(\">x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (str.startsWith(\"0x\") || str.startsWith(\"0x\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 18:58:23.361368149 +0200\n+++ /tmp/tmpyfk7m15c.java\t2022-07-19 18:58:23.361368149 +0200\n@@ -453,11 +453,11 @@\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+if (str.startsWith(\"0x\") || str.startsWith(\"0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {",
        "fixed_line": "if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {"
    },
    "Gson-14": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int i = 0; i < upperBounds.length; i++) { if (upperBounds[i] == Type.class) { return new WildcardTypeImpl(lowerBounds, upperBounds); } } return new WildcardTypeImpl(lowerBounds, upperBounds); }",
                "patch_diff": "for (int i = 0; i < upperBounds.length; i++) { if (upperBounds[i] == Type.class) { return new WildcardTypeImpl(lowerBounds, upperBounds); } } return new WildcardTypeImpl(lowerBounds, upperBounds); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "Type[] upperBounds = new WildcardTypeImpl(lowerBounds, upperBounds);",
                "patch_diff": "Type[] upperBounds = new WildcardTypeImpl(lowerBounds, upperBounds);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0; i < upperBounds.length; i++) { if (lowerBounds[i] == Type.class) { return new WildcardTypeImpl(lowerBounds, upperBounds); } } return new WildcardTypeImpl(lowerBounds, upperBounds); }",
                "patch_diff": "for (int i = 0; i < upperBounds.length; i++) { if (lowerBounds[i] == Type.class) { return new WildcardTypeImpl(lowerBounds, upperBounds); } } return new WildcardTypeImpl(lowerBounds, upperBounds); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = 0; i < upperBounds.length; i++) { if (upperBounds[i] == Type.class) { return new WildcardTypeImpl(lowerBounds, upperBounds); } }",
                "patch_diff": "for (int i = 0; i < upperBounds.length; i++) { if (upperBounds[i] == Type.class) { return new WildcardTypeImpl(lowerBounds, upperBounds); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = 0; i < upperBounds.length; i++) { if (upperBounds[i] == Type.class) { return new WildcardTypeImpl(lowerBounds, upperBounds); } } return new WildcardTypeImpl(lowerBounds); }",
                "patch_diff": "for (int i = 0; i < upperBounds.length; i++) { if (upperBounds[i] == Type.class) { return new WildcardTypeImpl(lowerBounds, upperBounds); } } return new WildcardTypeImpl(lowerBounds); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "Type[] upperBounds = new WildcardTypeImpl(lowerBounds, upperBounds); return new WildcardTypeImpl(lowerBounds, upperBounds);",
                "patch_diff": "Type[] upperBounds = new WildcardTypeImpl(lowerBounds, upperBounds); return new WildcardTypeImpl(lowerBounds, upperBounds);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = 0; i < upperBounds.length; i++) { if (upperBounds[i] == Type.class) { return new WildcardTypeImpl(lowerBounds, upperBounds); } } return new WildcardTypeImpl(lowerBounds, upperBounds);",
                "patch_diff": "for (int i = 0; i < upperBounds.length; i++) { if (upperBounds[i] == Type.class) { return new WildcardTypeImpl(lowerBounds, upperBounds); } } return new WildcardTypeImpl(lowerBounds, upperBounds);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = 0; i < upperBounds.length; i++) { if (upperBounds[i] == Type.class) { return new WildcardTypeImpl(lowerBounds, upperBounds); } return new WildcardTypeImpl(lowerBounds, upperBounds); } }",
                "patch_diff": "for (int i = 0; i < upperBounds.length; i++) { if (upperBounds[i] == Type.class) { return new WildcardTypeImpl(lowerBounds, upperBounds); } return new WildcardTypeImpl(lowerBounds, upperBounds); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "Type[] upperBounds = new WildcardTypeImpl(lowerBounds); return new WildcardTypeImpl(lowerBounds, upperBounds);",
                "patch_diff": "Type[] upperBounds = new WildcardTypeImpl(lowerBounds); return new WildcardTypeImpl(lowerBounds, upperBounds);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = 0; i < upperBounds.length; i++) { if (lowerBounds[i] == Type.class) { return new WildcardTypeImpl(lowerBounds, upperBounds); } }",
                "patch_diff": "for (int i = 0; i < upperBounds.length; i++) { if (lowerBounds[i] == Type.class) { return new WildcardTypeImpl(lowerBounds, upperBounds); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (bound instanceof WildcardType) { upperBounds = ((WildcardType) bound).getUpperBounds(); } else { upperBounds = new Type[] { bound }; } return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY); } /** * Returns a type that represents an unknown supertype of {@code bound}. For * example, if {@code bound} is {@code String.class}, this returns {@code ? * super String}. */ public static WildcardType supertypeOf(Type bound) { Type[] lowerBounds; if (bound instanceof WildcardType) { lowerBounds = ((WildcardType) bound).getLowerBounds(); } else { lowerBounds = new Type[] { bound }; }"
    },
    "Chart-7": {
        "fixes": [
            {
                "k": 1,
                "patch": "long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() - this.minMiddleIndex).getPeriod().getEnd() {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-7/source/org/jfree/data/time/TimePeriodValues.java\t2022-07-19 18:58:35.497305191 +0200\n+++ /tmp/tmpffblkgff.java\t2022-07-19 18:58:35.553304902 +0200\n@@ -295,13 +295,11 @@\n         else {\n             this.minMiddleIndex = index;\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() - this.minMiddleIndex).getPeriod().getEnd() {\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n                 this.maxMiddleIndex = index;           \n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() {this.minMiddleIndex).getPeriod().getEnd()",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-7/source/org/jfree/data/time/TimePeriodValues.java\t2022-07-19 18:58:37.957292432 +0200\n+++ /tmp/tmpit669obv.java\t2022-07-19 18:58:37.957292432 +0200\n@@ -295,13 +295,11 @@\n         else {\n             this.minMiddleIndex = index;\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() {this.minMiddleIndex).getPeriod().getEnd()\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n                 this.maxMiddleIndex = index;           \n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() - this.minMiddleIndex).getPeriod().getEnd()",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-7/source/org/jfree/data/time/TimePeriodValues.java\t2022-07-19 18:58:39.629283760 +0200\n+++ /tmp/tmp6bmziycb.java\t2022-07-19 18:58:39.629283760 +0200\n@@ -295,13 +295,11 @@\n         else {\n             this.minMiddleIndex = index;\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() - this.minMiddleIndex).getPeriod().getEnd()\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n                 this.maxMiddleIndex = index;           \n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() {this.minMiddleIndex = getDataItem(this.minMiddleIndex).getPeriod().getEnd()",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-7/source/org/jfree/data/time/TimePeriodValues.java\t2022-07-19 18:58:41.373274714 +0200\n+++ /tmp/tmpdp64mr59.java\t2022-07-19 18:58:41.385274652 +0200\n@@ -295,13 +295,11 @@\n         else {\n             this.minMiddleIndex = index;\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() {this.minMiddleIndex = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n                 this.maxMiddleIndex = index;           \n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() + this.minMiddleIndex).getPeriod().getEnd()",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-7/source/org/jfree/data/time/TimePeriodValues.java\t2022-07-19 18:58:43.129265605 +0200\n+++ /tmp/tmpit08_t75.java\t2022-07-19 18:58:43.129265605 +0200\n@@ -295,13 +295,11 @@\n         else {\n             this.minMiddleIndex = index;\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() + this.minMiddleIndex).getPeriod().getEnd()\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n                 this.maxMiddleIndex = index;           \n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() - this.minMiddleIndex + 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-7/source/org/jfree/data/time/TimePeriodValues.java\t2022-07-19 18:58:44.677257577 +0200\n+++ /tmp/tmp5awv84st.java\t2022-07-19 18:58:44.677257577 +0200\n@@ -295,13 +295,11 @@\n         else {\n             this.minMiddleIndex = index;\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() - this.minMiddleIndex + 1;\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n                 this.maxMiddleIndex = index;           \n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() { this.minMiddleIndex).getPeriod().getEnd()",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-7/source/org/jfree/data/time/TimePeriodValues.java\t2022-07-19 18:58:46.573247743 +0200\n+++ /tmp/tmpiw6frjl5.java\t2022-07-19 18:58:46.573247743 +0200\n@@ -295,13 +295,11 @@\n         else {\n             this.minMiddleIndex = index;\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() { this.minMiddleIndex).getPeriod().getEnd()\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n                 this.maxMiddleIndex = index;           \n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() { this.minMiddleIndex = getDataItem(this.minMiddleIndex).getPeriod().getEnd()",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-7/source/org/jfree/data/time/TimePeriodValues.java\t2022-07-19 18:58:48.297238802 +0200\n+++ /tmp/tmp2odeizx3.java\t2022-07-19 18:58:48.301238781 +0200\n@@ -295,13 +295,11 @@\n         else {\n             this.minMiddleIndex = index;\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() { this.minMiddleIndex = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n                 this.maxMiddleIndex = index;           \n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() - this.minMiddleIndex;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-7/source/org/jfree/data/time/TimePeriodValues.java\t2022-07-19 18:58:49.853230731 +0200\n+++ /tmp/tmp2ekb0m8o.java\t2022-07-19 18:58:49.857230709 +0200\n@@ -295,13 +295,11 @@\n         else {\n             this.minMiddleIndex = index;\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() - this.minMiddleIndex;\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n                 this.maxMiddleIndex = index;           \n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() + this.minMiddleIndex).getPeriod().getEnd() {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-7/source/org/jfree/data/time/TimePeriodValues.java\t2022-07-19 18:58:51.693221188 +0200\n+++ /tmp/tmpru5p9o6t.java\t2022-07-19 18:58:51.693221188 +0200\n@@ -295,13 +295,11 @@\n         else {\n             this.minMiddleIndex = index;\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() + this.minMiddleIndex).getPeriod().getEnd() {\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n                 this.maxMiddleIndex = index;           \n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()",
        "fixed_line": "long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()"
    },
    "Lang-43": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int i = start; i < len; ++i) { char c = pattern.charAt(i; ++i; ++i)",
                "patch_diff": "for (int i = start; i < len; ++i) { char c = pattern.charAt(i; ++i; ++i)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = start; i < len; ++i) { char c = pattern.charAt(i;i; ++i; ++i)",
                "patch_diff": "for (int i = start; i < len; ++i) { char c = pattern.charAt(i;i; ++i; ++i)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = start; i < len; ++i) { char c = pattern.charAt(i);i; ++i; ++i)",
                "patch_diff": "for (int i = start; i < len; ++i) { char c = pattern.charAt(i);i; ++i; ++i)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = start; i < len; ++i) { char c = pattern.charAt(i;i; ++i)",
                "patch_diff": "for (int i = start; i < len; ++i) { char c = pattern.charAt(i;i; ++i)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = start; i < len; ++i) { char c = pattern.charAt(i);i; ++i)",
                "patch_diff": "for (int i = start; i < len; ++i) { char c = pattern.charAt(i);i; ++i)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = start; i < len; i++) {",
                "patch_diff": "for (int i = start; i < len; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = start; i < len; i++) { char c = pattern.charAt(i); if (c == 'D' || c == 'J' || c == 'E') {",
                "patch_diff": "for (int i = start; i < len; i++) { char c = pattern.charAt(i); if (c == 'D' || c == 'J' || c == 'E') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = start; i < len; ++i) { char c = pattern.charAt(i;i++) {",
                "patch_diff": "for (int i = start; i < len; ++i) { char c = pattern.charAt(i;i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int i = start; i < len; ++i) { char c = pattern.charAt(i); if (c == 'D' || c == 'J' || c == 'E') {",
                "patch_diff": "for (int i = start; i < len; ++i) { char c = pattern.charAt(i); if (c == 'D' || c == 'J' || c == 'E') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = start; i < len; i++) { char c = pattern.charAt(i); if (c == 'D' || c == 'E') {",
                "patch_diff": "for (int i = start; i < len; i++) { char c = pattern.charAt(i); if (c == 'D' || c == 'E') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "next(pos);"
    },
    "Closure-112": {
        "fixes": [
            {
                "k": 1,
                "patch": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n, fnType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-112/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 18:58:55.585201003 +0200\n+++ /tmp/tmpn__d2h1a.java\t2022-07-19 18:58:55.641200714 +0200\n@@ -1187,12 +1187,11 @@\n     if (keys.isEmpty()) {\n       return false;\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = \n-        inferTemplateTypesFromParameters(fnType, n);\n+Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n, fnType);\n \n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n     TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, templateTypeName, n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-112/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 18:59:01.585169885 +0200\n+++ /tmp/tmp1s15364e.java\t2022-07-19 18:59:01.589169864 +0200\n@@ -1187,12 +1187,11 @@\n     if (keys.isEmpty()) {\n       return false;\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = \n-        inferTemplateTypesFromParameters(fnType, n);\n+Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, templateTypeName, n);\n \n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n     TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnNode, n, fnType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-112/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 18:59:05.189151195 +0200\n+++ /tmp/tmpfy85_64u.java\t2022-07-19 18:59:05.189151195 +0200\n@@ -1187,12 +1187,11 @@\n     if (keys.isEmpty()) {\n       return false;\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = \n-        inferTemplateTypesFromParameters(fnType, n);\n+Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnNode, n, fnType);\n \n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n     TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters( fnType, templateTypeName, n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-112/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 18:59:09.069131074 +0200\n+++ /tmp/tmpto40k0sl.java\t2022-07-19 18:59:09.069131074 +0200\n@@ -1187,12 +1187,11 @@\n     if (keys.isEmpty()) {\n       return false;\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = \n-        inferTemplateTypesFromParameters(fnType, n);\n+Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters( fnType, templateTypeName, n);\n \n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n     TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-112/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 18:59:12.857111429 +0200\n+++ /tmp/tmpgs3h8sql.java\t2022-07-19 18:59:12.861111410 +0200\n@@ -1187,12 +1187,11 @@\n     if (keys.isEmpty()) {\n       return false;\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = \n-        inferTemplateTypesFromParameters(fnType, n);\n+Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n);\n \n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n     TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters( fnType, n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-112/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 19:00:07.532827961 +0200\n+++ /tmp/tmpaydyq84x.java\t2022-07-19 19:00:07.532827961 +0200\n@@ -1187,12 +1187,11 @@\n     if (keys.isEmpty()) {\n       return false;\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = \n-        inferTemplateTypesFromParameters(fnType, n);\n+Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters( fnType, n);\n \n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n     TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters( fnType, n, fnType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-112/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 19:00:58.028566259 +0200\n+++ /tmp/tmpl2zwffu7.java\t2022-07-19 19:00:58.028566259 +0200\n@@ -1187,12 +1187,11 @@\n     if (keys.isEmpty()) {\n       return false;\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = \n-        inferTemplateTypesFromParameters(fnType, n);\n+Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters( fnType, n, fnType);\n \n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n     TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters( fnType, templateTypeName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-112/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 19:01:01.652547481 +0200\n+++ /tmp/tmpvg7l7md8.java\t2022-07-19 19:01:01.652547481 +0200\n@@ -1187,12 +1187,11 @@\n     if (keys.isEmpty()) {\n       return false;\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = \n-        inferTemplateTypesFromParameters(fnType, n);\n+Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters( fnType, templateTypeName);\n \n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n     TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, templateTypeName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-112/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 19:01:05.484527625 +0200\n+++ /tmp/tmp5uoq0sd8.java\t2022-07-19 19:01:05.484527625 +0200\n@@ -1187,12 +1187,11 @@\n     if (keys.isEmpty()) {\n       return false;\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = \n-        inferTemplateTypesFromParameters(fnType, n);\n+Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, templateTypeName);\n \n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n     TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnNode, n, templateType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-112/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 19:01:09.296507872 +0200\n+++ /tmp/tmpaxc009gd.java\t2022-07-19 19:01:09.296507872 +0200\n@@ -1187,12 +1187,11 @@\n     if (keys.isEmpty()) {\n       return false;\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = \n-        inferTemplateTypesFromParameters(fnType, n);\n+Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnNode, n, templateType);\n \n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n     TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n);",
        "fixed_line": "Map<TemplateType, JSType> inferred = Maps.filterKeys( inferTemplateTypesFromParameters(fnType, n), new Predicate<TemplateType>() { @Override public boolean apply(TemplateType key) { return keys.contains(key); }} );"
    },
    "Csv-6": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getValue().intValue(); for (int i = 0; i < col; i++) {",
                "patch_diff": "for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getValue().intValue(); for (int i = 0; i < col; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (final Entry<String, Integer> entry : mapping.entrySet()) { for (final Entry<String, Integer> entry : mapping.getValue().intValue(); map.put(entry.getKey(), entry.getValue().intValue()); } }",
                "patch_diff": "for (final Entry<String, Integer> entry : mapping.entrySet()) { for (final Entry<String, Integer> entry : mapping.getValue().intValue(); map.put(entry.getKey(), entry.getValue().intValue()); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getValue().intValue(); map.put(entry.getKey(), entry.getValue().intValue()); }",
                "patch_diff": "for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getValue().intValue(); map.put(entry.getKey(), entry.getValue().intValue()); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getKey().intValue(); for (int i = 0; i < col; i++) {",
                "patch_diff": "for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getKey().intValue(); for (int i = 0; i < col; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getKey(); for (int i = 0; i < col; i++) {",
                "patch_diff": "for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getKey(); for (int i = 0; i < col; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getKey().intValue(); map.put(entry.getKey(), entry.getValue().intValue()); }",
                "patch_diff": "for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getKey().intValue(); map.put(entry.getKey(), entry.getValue().intValue()); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (final Entry<String, Integer> entry : mapping.entrySet()) { for (final Entry<String, Integer> entry : mapping.getValue().intValue(); map.put(entry.getKey(), entry.getValue().intValue(); } }",
                "patch_diff": "for (final Entry<String, Integer> entry : mapping.entrySet()) { for (final Entry<String, Integer> entry : mapping.getValue().intValue(); map.put(entry.getKey(), entry.getValue().intValue(); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (final Entry<String, Integer> col = entry.getValue().intValue(); map.put(entry.getKey(), values[col]); }",
                "patch_diff": "for (final Entry<String, Integer> col = entry.getValue().intValue(); map.put(entry.getKey(), values[col]); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getValue().intValue(); for (int i = 0; i < col; i++) { entry.getValue().intValue(); map.put(entry.getKey(), values[col]); } }",
                "patch_diff": "for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getValue().intValue(); for (int i = 0; i < col; i++) { entry.getValue().intValue(); map.put(entry.getKey(), values[col]); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (final Entry<String, Integer> col = entry.getValue().intValue(); map.put(entry.getKey(), entry.getValue().intValue()); }",
                "patch_diff": "for (final Entry<String, Integer> col = entry.getValue().intValue(); map.put(entry.getKey(), entry.getValue().intValue()); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (col < values.length) { map.put(entry.getKey(), values[col]); }"
    },
    "Jsoup-46": {
        "fixes": [
            {
                "k": 1,
                "patch": "accum.append(AND_CHAR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-46/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 19:01:15.384476331 +0200\n+++ /tmp/tmpucyrexys.java\t2022-07-19 19:01:15.464475916 +0200\n@@ -113,11 +113,11 @@\n                         break;\n                     case 0xA0:\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+accum.append(AND_CHAR;\n                         break;\n                     case '<':\n                         if (!inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "accum.append(versionMode;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-46/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 19:01:17.356466112 +0200\n+++ /tmp/tmp5tlh_mz0.java\t2022-07-19 19:01:17.356466112 +0200\n@@ -113,11 +113,11 @@\n                         break;\n                     case 0xA0:\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+accum.append(versionMode;\n                         break;\n                     case '<':\n                         if (!inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "accum.append(versionMode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-46/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 19:01:19.264456227 +0200\n+++ /tmp/tmpcc52n6ye.java\t2022-07-19 19:01:19.264456227 +0200\n@@ -113,11 +113,11 @@\n                         break;\n                     case 0xA0:\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+accum.append(versionMode);\n                         break;\n                     case '<':\n                         if (!inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "accum.append(path;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-46/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 19:01:21.036447046 +0200\n+++ /tmp/tmptdvnr_cx.java\t2022-07-19 19:01:21.036447046 +0200\n@@ -113,11 +113,11 @@\n                         break;\n                     case 0xA0:\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+accum.append(path;\n                         break;\n                     case '<':\n                         if (!inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "accum.append(enclosing;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-46/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 19:01:22.832437740 +0200\n+++ /tmp/tmpmsr8p_70.java\t2022-07-19 19:01:22.832437740 +0200\n@@ -113,11 +113,11 @@\n                         break;\n                     case 0xA0:\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+accum.append(enclosing;\n                         break;\n                     case '<':\n                         if (!inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "accum.append(escapeMode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-46/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 19:01:24.428429472 +0200\n+++ /tmp/tmpd7upkeq_.java\t2022-07-19 19:01:24.432429450 +0200\n@@ -113,11 +113,11 @@\n                         break;\n                     case 0xA0:\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+accum.append(escapeMode);\n                         break;\n                     case '<':\n                         if (!inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "accum.append(escapeMode;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-46/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 19:01:28.424408770 +0200\n+++ /tmp/tmphq57d6dz.java\t2022-07-19 19:01:28.424408770 +0200\n@@ -113,11 +113,11 @@\n                         break;\n                     case 0xA0:\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+accum.append(escapeMode;\n                         break;\n                     case '<':\n                         if (!inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "accum.append(tt;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-46/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 19:01:29.956400833 +0200\n+++ /tmp/tmp0h6xz_nd.java\t2022-07-19 19:01:29.956400833 +0200\n@@ -113,11 +113,11 @@\n                         break;\n                     case 0xA0:\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+accum.append(tt;\n                         break;\n                     case '<':\n                         if (!inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "accum.append(AND;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-46/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 19:01:31.644392089 +0200\n+++ /tmp/tmpb51t4smt.java\t2022-07-19 19:01:31.644392089 +0200\n@@ -113,11 +113,11 @@\n                         break;\n                     case 0xA0:\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+accum.append(AND;\n                         break;\n                     case '<':\n                         if (!inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "accum.append(AND);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-46/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 19:01:33.536382287 +0200\n+++ /tmp/tmpsjzvi429.java\t2022-07-19 19:01:33.536382287 +0200\n@@ -113,11 +113,11 @@\n                         break;\n                     case 0xA0:\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+accum.append(AND);\n                         break;\n                     case '<':\n                         if (!inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "accum.append(c);",
        "fixed_line": "accum.append(\"&#xa0;\");"
    },
    "JacksonDatabind-9": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (value instanceof Date instanceof Date;DateKey) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-9/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\t2022-07-19 19:01:35.736370888 +0200\n+++ /tmp/tmp10bymfk5.java\t2022-07-19 19:01:35.856370266 +0200\n@@ -23,11 +23,11 @@\n \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         String str;\n         \n-        if (value instanceof Date) {\n+if (value instanceof Date instanceof Date;DateKey) {\n             provider.defaultSerializeDateKey((Date) value, jgen);\n             return;\n         } else {\n             str = value.toString();\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (value instanceof Date;DateKey) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-9/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\t2022-07-19 19:01:37.836360008 +0200\n+++ /tmp/tmphzrni1q7.java\t2022-07-19 19:01:37.836360008 +0200\n@@ -23,11 +23,11 @@\n \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         String str;\n         \n-        if (value instanceof Date) {\n+if (value instanceof Date;DateKey) {\n             provider.defaultSerializeDateKey((Date) value, jgen);\n             return;\n         } else {\n             str = value.toString();\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (_value instanceof Date;DateKey) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-9/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\t2022-07-19 19:01:39.400351908 +0200\n+++ /tmp/tmpwg11co9_.java\t2022-07-19 19:01:39.400351908 +0200\n@@ -23,11 +23,11 @@\n \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         String str;\n         \n-        if (value instanceof Date) {\n+if (_value instanceof Date;DateKey) {\n             provider.defaultSerializeDateKey((Date) value, jgen);\n             return;\n         } else {\n             str = value.toString();\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (_value instanceof Date instanceof Date) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-9/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\t2022-07-19 19:01:41.248342335 +0200\n+++ /tmp/tmp32to6_jq.java\t2022-07-19 19:01:41.252342314 +0200\n@@ -23,11 +23,11 @@\n \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         String str;\n         \n-        if (value instanceof Date) {\n+if (_value instanceof Date instanceof Date) {\n             provider.defaultSerializeDateKey((Date) value, jgen);\n             return;\n         } else {\n             str = value.toString();\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (_value instanceof Date instanceof Date;DateKey) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-9/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\t2022-07-19 19:01:43.228332077 +0200\n+++ /tmp/tmp4y2m__00.java\t2022-07-19 19:01:43.228332077 +0200\n@@ -23,11 +23,11 @@\n \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         String str;\n         \n-        if (value instanceof Date) {\n+if (_value instanceof Date instanceof Date;DateKey) {\n             provider.defaultSerializeDateKey((Date) value, jgen);\n             return;\n         } else {\n             str = value.toString();\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (value instanceof Date instanceof Date)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-9/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\t2022-07-19 19:01:44.828323787 +0200\n+++ /tmp/tmp8hvadkir.java\t2022-07-19 19:01:44.828323787 +0200\n@@ -23,11 +23,11 @@\n \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         String str;\n         \n-        if (value instanceof Date) {\n+if (value instanceof Date instanceof Date)) {\n             provider.defaultSerializeDateKey((Date) value, jgen);\n             return;\n         } else {\n             str = value.toString();\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (value instanceof Date instanceof Date) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-9/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\t2022-07-19 19:01:46.560314817 +0200\n+++ /tmp/tmpyt0poir0.java\t2022-07-19 19:01:46.560314817 +0200\n@@ -23,11 +23,11 @@\n \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         String str;\n         \n-        if (value instanceof Date) {\n+if (value instanceof Date instanceof Date) {\n             provider.defaultSerializeDateKey((Date) value, jgen);\n             return;\n         } else {\n             str = value.toString();\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (_value instanceof Date) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-9/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\t2022-07-19 19:01:48.328305656 +0200\n+++ /tmp/tmpjrw927fj.java\t2022-07-19 19:01:48.332305638 +0200\n@@ -23,11 +23,11 @@\n \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         String str;\n         \n-        if (value instanceof Date) {\n+if (_value instanceof Date) {\n             provider.defaultSerializeDateKey((Date) value, jgen);\n             return;\n         } else {\n             str = value.toString();\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (value instanceof Date; {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-9/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\t2022-07-19 19:01:50.232295796 +0200\n+++ /tmp/tmprhgqfwlg.java\t2022-07-19 19:01:50.232295796 +0200\n@@ -23,11 +23,11 @@\n \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         String str;\n         \n-        if (value instanceof Date) {\n+if (value instanceof Date; {\n             provider.defaultSerializeDateKey((Date) value, jgen);\n             return;\n         } else {\n             str = value.toString();\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (value instanceof Date)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-9/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\t2022-07-19 19:01:52.044286408 +0200\n+++ /tmp/tmphkwzaz47.java\t2022-07-19 19:01:52.044286408 +0200\n@@ -23,11 +23,11 @@\n \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         String str;\n         \n-        if (value instanceof Date) {\n+if (value instanceof Date)) {\n             provider.defaultSerializeDateKey((Date) value, jgen);\n             return;\n         } else {\n             str = value.toString();\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (value instanceof Date) {",
        "fixed_line": "Class<?> cls = value.getClass(); if (cls == String.class) { str = (String) value; } else if (Date.class.isAssignableFrom(cls)) { provider.defaultSerializeDateKey((Date) value, jgen); return; } else if (cls == Class.class) { str = ((Class<?>) value).getName();"
    },
    "Math-55": {
        "fixes": [
            {
                "k": 1,
                "patch": "return new Vector3D(v1 * v2Constants.MILLIS_PER_HOUR; v1.x - v2.x * v1.x, v2.y - v1.y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-55/src/main/java/org/apache/commons/math/geometry/Vector3D.java\t2022-07-19 19:01:54.024276153 +0200\n+++ /tmp/tmp_qhlqu2c.java\t2022-07-19 19:01:54.096275779 +0200\n@@ -468,11 +468,11 @@\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n \n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n+return new Vector3D(v1 * v2Constants.MILLIS_PER_HOUR; v1.x - v2.x * v1.x, v2.y - v1.y;\n \n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return new Vector3D(v1 * v2Constants.MILLIS_PER_HOUR; v1.x - v2.x * v1.x, v2.y);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-55/src/main/java/org/apache/commons/math/geometry/Vector3D.java\t2022-07-19 19:01:57.000260737 +0200\n+++ /tmp/tmpu7hgekw_.java\t2022-07-19 19:01:57.000260737 +0200\n@@ -468,11 +468,11 @@\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n \n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n+return new Vector3D(v1 * v2Constants.MILLIS_PER_HOUR; v1.x - v2.x * v1.x, v2.y);\n \n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return new Vector3D(v1 * v2Constants.MILLIS_PER_HOUR; v1.x - v2.x * v1.x, v2.y - v1.y * v2.y);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-55/src/main/java/org/apache/commons/math/geometry/Vector3D.java\t2022-07-19 19:01:59.128249713 +0200\n+++ /tmp/tmphtupnxqb.java\t2022-07-19 19:01:59.128249713 +0200\n@@ -468,11 +468,11 @@\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n \n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n+return new Vector3D(v1 * v2Constants.MILLIS_PER_HOUR; v1.x - v2.x * v1.x, v2.y - v1.y * v2.y);\n \n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return new Vector3D(v1 * v2Constants.MILLIS_PER_HOUR; v1.x - v2.x * v1.x, v2.y - v1.y * v2.y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-55/src/main/java/org/apache/commons/math/geometry/Vector3D.java\t2022-07-19 19:02:01.368238110 +0200\n+++ /tmp/tmp2gypda9a.java\t2022-07-19 19:02:01.372238091 +0200\n@@ -468,11 +468,11 @@\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n \n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n+return new Vector3D(v1 * v2Constants.MILLIS_PER_HOUR; v1.x - v2.x * v1.x, v2.y - v1.y * v2.y;\n \n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return new Vector3D(v1 * v1 - v1.x, v2.y * v1.y - v2.y * v1.y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-55/src/main/java/org/apache/commons/math/geometry/Vector3D.java\t2022-07-19 19:02:03.628226405 +0200\n+++ /tmp/tmp4t3ihp27.java\t2022-07-19 19:02:03.628226405 +0200\n@@ -468,11 +468,11 @@\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n \n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n+return new Vector3D(v1 * v1 - v1.x, v2.y * v1.y - v2.y * v1.y;\n \n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return new Vector3D(v1 * v1.x - v2.x, v2.y * v1.y - v2.y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-55/src/main/java/org/apache/commons/math/geometry/Vector3D.java\t2022-07-19 19:02:05.932214470 +0200\n+++ /tmp/tmpkdiyavak.java\t2022-07-19 19:02:05.932214470 +0200\n@@ -468,11 +468,11 @@\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n \n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n+return new Vector3D(v1 * v1.x - v2.x, v2.y * v1.y - v2.y;\n \n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return new Vector3D(v1 * v1.x - v2.x, v2.y * v1.y - v2.y * v1.y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-55/src/main/java/org/apache/commons/math/geometry/Vector3D.java\t2022-07-19 19:02:08.144203014 +0200\n+++ /tmp/tmp2ghlzpgb.java\t2022-07-19 19:02:08.144203014 +0200\n@@ -468,11 +468,11 @@\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n \n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n+return new Vector3D(v1 * v1.x - v2.x, v2.y * v1.y - v2.y * v1.y;\n \n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return new Vector3D(v1 * v1.x - v2.x, v2.y * v1.y - v2.y * v1.y);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-55/src/main/java/org/apache/commons/math/geometry/Vector3D.java\t2022-07-19 19:02:10.500190809 +0200\n+++ /tmp/tmptyb539jb.java\t2022-07-19 19:02:10.504190791 +0200\n@@ -468,11 +468,11 @@\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n \n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n+return new Vector3D(v1 * v1.x - v2.x, v2.y * v1.y - v2.y * v1.y);\n \n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return new Vector3D(v1 * v1 - v1.x, v2.y * v1.y - v2.y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-55/src/main/java/org/apache/commons/math/geometry/Vector3D.java\t2022-07-19 19:02:12.892178420 +0200\n+++ /tmp/tmpd5off8eu.java\t2022-07-19 19:02:12.892178420 +0200\n@@ -468,11 +468,11 @@\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n \n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n+return new Vector3D(v1 * v1 - v1.x, v2.y * v1.y - v2.y;\n \n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return new Vector3D(v1 * v1 - v1.x, v2.y * v1.y - v2.y * v1.y);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-55/src/main/java/org/apache/commons/math/geometry/Vector3D.java\t2022-07-19 19:02:14.996167524 +0200\n+++ /tmp/tmpn8vtvku8.java\t2022-07-19 19:02:14.996167524 +0200\n@@ -468,11 +468,11 @@\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n \n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n+return new Vector3D(v1 * v1 - v1.x, v2.y * v1.y - v2.y * v1.y);\n \n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);",
        "fixed_line": "final double n1 = v1.getNormSq(); final double n2 = v2.getNormSq(); if ((n1 * n2) < MathUtils.SAFE_MIN) { return ZERO; } // rescale both vectors without losing precision, // to ensure their norm are the same order of magnitude final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4; final double x1 = FastMath.scalb(v1.x, -deltaExp); final double y1 = FastMath.scalb(v1.y, -deltaExp); final double z1 = FastMath.scalb(v1.z, -deltaExp); final double x2 = FastMath.scalb(v2.x, deltaExp); final double y2 = FastMath.scalb(v2.y, deltaExp); final double z2 = FastMath.scalb(v2.z, deltaExp); // we reduce cancellation errors by preconditioning, // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute // v3 without loss of precision. See Kahan lecture // \"Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces\" // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf // compute rho as an 8 bits approximation of v1.v2 / v2.v2 final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp); final double rho = FastMath.rint(256 * ratio) / 256; final double x3 = x1 - rho * x2; final double y3 = y1 - rho * y2; final double z3 = z1 - rho * z2; // compute cross product from v3 and v2 instead of v1 and v2 return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);"
    },
    "Jsoup-39": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (docData.length() > 0 && docData.charAt(0) == '\\n') {",
                "patch_diff": "if (docData.length() > 0 && docData.charAt(0) == '\\n') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (docData.length() > 0 && docData.charAt(0) == '-' ) {",
                "patch_diff": "if (docData.length() > 0 && docData.charAt(0) == '-' ) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (docData.length() > 0 && docData.charAt(0) == '\\'') {",
                "patch_diff": "if (docData.length() > 0 && docData.charAt(0) == '\\'') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (docData.length() > 0 && docData.charAt(0) == '/') {",
                "patch_diff": "if (docData.length() > 0 && docData.charAt(0) == '/') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (docData.charAt(0) == 0 && docInfo.charAt(0) == '\\n') {",
                "patch_diff": "if (docData.charAt(0) == 0 && docInfo.charAt(0) == '\\n') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (docData.charAt(0) == 0 && docData.charAt(0) == '\\n') {",
                "patch_diff": "if (docData.charAt(0) == 0 && docData.charAt(0) == '\\n') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (docData.length() > 0 && docData.charAt(0) == '>') {",
                "patch_diff": "if (docData.length() > 0 && docData.charAt(0) == '>') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (docData.length() > 0 && docData.charAt(0) == '\\r') {",
                "patch_diff": "if (docData.length() > 0 && docData.charAt(0) == '\\r') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (docData.charAt(0) == 0 && docInfo.charAt(0) == '\\r') {",
                "patch_diff": "if (docData.charAt(0) == 0 && docInfo.charAt(0) == '\\r') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (docData.length() > 0 && docData.charAt(0) == '\\r'') {",
                "patch_diff": "if (docData.length() > 0 && docData.charAt(0) == '\\r'') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "doc = null;"
    },
    "Mockito-8": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (typeualActualType instanceof actualTypeParameters;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-8/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\t2022-07-19 19:02:19.412144656 +0200\n+++ /tmp/tmp17u8zq9i.java\t2022-07-19 19:02:19.496144216 +0200\n@@ -74,11 +74,11 @@\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             if (actualTypeArgument instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else {\n+} else if (typeualActualType instanceof actualTypeParameters;\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (wantedualActualType instanceof actualTypeParameters;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-8/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\t2022-07-19 19:02:33.368072374 +0200\n+++ /tmp/tmplibcsjf7.java\t2022-07-19 19:02:33.368072374 +0200\n@@ -74,11 +74,11 @@\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             if (actualTypeArgument instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else {\n+} else if (wantedualActualType instanceof actualTypeParameters;\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (typeualActualType instanceof actualTypeParameters.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-8/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\t2022-07-19 19:02:41.580029846 +0200\n+++ /tmp/tmp8bmaxr93.java\t2022-07-19 19:02:41.596029763 +0200\n@@ -74,11 +74,11 @@\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             if (actualTypeArgument instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else {\n+} else if (typeualActualType instanceof actualTypeParameters.class) {\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (wantedualActualType instanceof actualTypeParameters.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-8/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\t2022-07-19 19:02:49.843987049 +0200\n+++ /tmp/tmpmjw17onl.java\t2022-07-19 19:02:49.843987049 +0200\n@@ -74,11 +74,11 @@\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             if (actualTypeArgument instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else {\n+} else if (wantedualActualType instanceof actualTypeParameters.class) {\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (typeualActualType instanceof actualTypeParameters) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-8/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\t2022-07-19 19:02:58.203943758 +0200\n+++ /tmp/tmpcc1233cc.java\t2022-07-19 19:02:58.203943758 +0200\n@@ -74,11 +74,11 @@\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             if (actualTypeArgument instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else {\n+} else if (typeualActualType instanceof actualTypeParameters) {\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (wantedualActualType instanceof actualTypeParameters) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-8/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\t2022-07-19 19:03:07.767894234 +0200\n+++ /tmp/tmpdz4t73c_.java\t2022-07-19 19:03:07.767894234 +0200\n@@ -74,11 +74,11 @@\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             if (actualTypeArgument instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else {\n+} else if (wantedualActualType instanceof actualTypeParameters) {\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (actualType instanceof actualTypeParameters.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-8/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\t2022-07-19 19:03:17.031846267 +0200\n+++ /tmp/tmp29ubq_5h.java\t2022-07-19 19:03:17.031846267 +0200\n@@ -74,11 +74,11 @@\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             if (actualTypeArgument instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else {\n+} else if (actualType instanceof actualTypeParameters.class) {\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (actualType instanceof actualTypeParameters) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-8/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\t2022-07-19 19:03:25.223803854 +0200\n+++ /tmp/tmphyqkz8oq.java\t2022-07-19 19:03:25.223803854 +0200\n@@ -74,11 +74,11 @@\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             if (actualTypeArgument instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else {\n+} else if (actualType instanceof actualTypeParameters) {\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (actualType instanceof actualTypeParameters;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-8/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\t2022-07-19 19:03:34.667754958 +0200\n+++ /tmp/tmp9i9rc0h_.java\t2022-07-19 19:03:34.667754958 +0200\n@@ -74,11 +74,11 @@\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             if (actualTypeArgument instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else {\n+} else if (actualType instanceof actualTypeParameters;\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (typeualActualType instanceof actualTypeArgument;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-8/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\t2022-07-19 19:03:42.959712030 +0200\n+++ /tmp/tmpqounu679.java\t2022-07-19 19:03:42.959712030 +0200\n@@ -74,11 +74,11 @@\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             if (actualTypeArgument instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else {\n+} else if (typeualActualType instanceof actualTypeArgument;\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "} else {",
        "fixed_line": "} else if (typeParameter != actualTypeArgument) {"
    },
    "Jsoup-2": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if (tag.isData()) { String data = tq.chompTo(\"</\" + tagName); if (tag.equals(titleTag)) { break; } } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag?) dataNode = tq.chompTo(\">\"); } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag.chompTo(\">\"); } else if (tag.equals(titleTag)) {",
                "patch_diff": "// if (tag.isData()) { String data = tq.chompTo(\"</\" + tagName); if (tag.equals(titleTag)) { break; } } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag?) dataNode = tq.chompTo(\">\"); } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag.chompTo(\">\"); } else if (tag.equals(titleTag)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// if (tag.isData()) { String data = tq.chompTo(\"</\" + tagName); } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag?) dataNode = tq.chompTo(\">\"); } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag.chompTo(\">\"); } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (",
                "patch_diff": "// if (tag.isData()) { String data = tq.chompTo(\"</\" + tagName); } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag?) dataNode = tq.chompTo(\">\"); } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag.chompTo(\">\"); } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if (tag.isData()) { String data = tq.chompTo(\"</\" + tagName); if (tag.equals(titleTag)) { break; } } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag?) dataNode = tq.chompTo(\">\"); } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag.",
                "patch_diff": "// if (tag.isData()) { String data = tq.chompTo(\"</\" + tagName); if (tag.equals(titleTag)) { break; } } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag?) dataNode = tq.chompTo(\">\"); } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// if (tag.isData()) { String data = tq.chompTo(\"</\" + tagName); if (tag.equals(titleTag)) { break; } } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag?) dataNode = tq.chompTo(\">\"); } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag, but not contain inside tags (so not a data tag.chompTo(\">\");",
                "patch_diff": "// if (tag.isData()) { String data = tq.chompTo(\"</\" + tagName); if (tag.equals(titleTag)) { break; } } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag?) dataNode = tq.chompTo(\">\"); } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag, but not contain inside tags (so not a data tag.chompTo(\">\");",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// if (tag.isData()) { String data = tq.chompTo(\"</\" + tagName); if (tag.equals(titleTag)) { break; } } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag?) dataNode = tq.chompTo(\">\"); } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag",
                "patch_diff": "// if (tag.isData()) { String data = tq.chompTo(\"</\" + tagName); if (tag.equals(titleTag)) { break; } } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag?) dataNode = tq.chompTo(\">\"); } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if (tag.isData()) { String data = tq.chompTo(\"</\" + tagName); if (tag.equals(titleTag)) { break; } } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag?) dataNode = tq.chompTo(\">\"); } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag, but not contain inside tags (so not a data tag.",
                "patch_diff": "// if (tag.isData()) { String data = tq.chompTo(\"</\" + tagName); if (tag.equals(titleTag)) { break; } } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag?) dataNode = tq.chompTo(\">\"); } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag, but not contain inside tags (so not a data tag.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// if (tag.isData()) { String data = tq.chompTo(\"</\" + tagName); } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag?) dataNode = tq.chompTo(\">\"); } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag?) dataNode = tq.chompTo(\">\"); } else if (tag.equals(titleTag)) {",
                "patch_diff": "// if (tag.isData()) { String data = tq.chompTo(\"</\" + tagName); } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag?) dataNode = tq.chompTo(\">\"); } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag?) dataNode = tq.chompTo(\">\"); } else if (tag.equals(titleTag)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// if (tag.isData()) { String data = tq.chompTo(\"</\" + tagName); if (tag.equals(titleTag)) { break; } } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag?) dataNode = tq.chompTo(\">\"); } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag, but not contain inside tags (so not a data tag, but not contain inside tags",
                "patch_diff": "// if (tag.isData()) { String data = tq.chompTo(\"</\" + tagName); if (tag.equals(titleTag)) { break; } } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag?) dataNode = tq.chompTo(\">\"); } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag, but not contain inside tags (so not a data tag, but not contain inside tags",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// if (tag.isData()) { String data = tq.chompTo(\"</\" + tagName); if (tag.equals(titleTag)) { break; } } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag?) dataNode = tq.chompTo(\">\"); } else if (tag.equals(titleTag)) {",
                "patch_diff": "// if (tag.isData()) { String data = tq.chompTo(\"</\" + tagName); if (tag.equals(titleTag)) { break; } } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag?) dataNode = tq.chompTo(\">\"); } else if (tag.equals(titleTag)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if (tag.isData()) { String data = tq.chompTo(\"</\" + tagName); if (tag.equals(titleTag)) { break; } } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag?) dataNode = tq.chompTo(\">\"); } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag, but not contain inside tags (so not a data tag",
                "patch_diff": "// if (tag.isData()) { String data = tq.chompTo(\"</\" + tagName); if (tag.equals(titleTag)) { break; } } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag?) dataNode = tq.chompTo(\">\"); } else if (tag.equals(titleTag)) { // want to show as text, but not contain inside tags (so not a data tag, but not contain inside tags (so not a data tag",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "popStackToClose(tag);"
    },
    "Time-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "years = FieldUtils.safeAdd(years, months % 12; if (months % 12!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-5/src/main/java/org/joda/time/Period.java\t2022-07-19 19:03:53.723656306 +0200\n+++ /tmp/tmp3cj1j_sm.java\t2022-07-19 19:03:53.791655951 +0200\n@@ -1623,17 +1623,11 @@\n         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+years = FieldUtils.safeAdd(years, months % 12; if (months % 12!= 0) {\n             }\n         }\n         return result;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "years = FieldUtils.safeAdd(years, months / 12; if (months % 12!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-5/src/main/java/org/joda/time/Period.java\t2022-07-19 19:03:55.591646635 +0200\n+++ /tmp/tmpuh9b6_13.java\t2022-07-19 19:03:55.595646614 +0200\n@@ -1623,17 +1623,11 @@\n         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+years = FieldUtils.safeAdd(years, months / 12; if (months % 12!= 0) {\n             }\n         }\n         return result;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "years = FieldUtils.safeAdd(years, months % 12; if (months % 12 == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-5/src/main/java/org/joda/time/Period.java\t2022-07-19 19:03:57.219638205 +0200\n+++ /tmp/tmpvon1wfn2.java\t2022-07-19 19:03:57.219638205 +0200\n@@ -1623,17 +1623,11 @@\n         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+years = FieldUtils.safeAdd(years, months % 12; if (months % 12 == 0) {\n             }\n         }\n         return result;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "years = FieldUtils.safeAdd(years, months / 12; if (months % 12 == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-5/src/main/java/org/joda/time/Period.java\t2022-07-19 19:03:58.667630709 +0200\n+++ /tmp/tmp_sne8awa.java\t2022-07-19 19:03:58.667630709 +0200\n@@ -1623,17 +1623,11 @@\n         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+years = FieldUtils.safeAdd(years, months / 12; if (months % 12 == 0) {\n             }\n         }\n         return result;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "years = FieldUtils.safeAdd(years, months % 12; if (years % 12!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-5/src/main/java/org/joda/time/Period.java\t2022-07-19 19:04:00.183622863 +0200\n+++ /tmp/tmpjdsnley1.java\t2022-07-19 19:04:00.183622863 +0200\n@@ -1623,17 +1623,11 @@\n         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+years = FieldUtils.safeAdd(years, months % 12; if (years % 12!= 0) {\n             }\n         }\n         return result;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "years = FieldUtils.safeAdd(years, months / 12; if (years % 12!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-5/src/main/java/org/joda/time/Period.java\t2022-07-19 19:04:01.771614642 +0200\n+++ /tmp/tmpgw9uoksa.java\t2022-07-19 19:04:01.775614621 +0200\n@@ -1623,17 +1623,11 @@\n         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+years = FieldUtils.safeAdd(years, months / 12; if (years % 12!= 0) {\n             }\n         }\n         return result;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "years = FieldUtils.safeAdd(years, months % 12; if (years % 12 == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-5/src/main/java/org/joda/time/Period.java\t2022-07-19 19:04:03.499605695 +0200\n+++ /tmp/tmpcpw99d_q.java\t2022-07-19 19:04:03.499605695 +0200\n@@ -1623,17 +1623,11 @@\n         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+years = FieldUtils.safeAdd(years, months % 12; if (years % 12 == 0) {\n             }\n         }\n         return result;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "years = FieldUtils.safeAdd(years, months / 12; if (years % 12 == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-5/src/main/java/org/joda/time/Period.java\t2022-07-19 19:04:05.099597415 +0200\n+++ /tmp/tmp2gx57asp.java\t2022-07-19 19:04:05.099597415 +0200\n@@ -1623,17 +1623,11 @@\n         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+years = FieldUtils.safeAdd(years, months / 12; if (years % 12 == 0) {\n             }\n         }\n         return result;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "years = FieldUtils.safeAdd(years, months * 12; if (months % 12!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-5/src/main/java/org/joda/time/Period.java\t2022-07-19 19:04:06.615589567 +0200\n+++ /tmp/tmp793bea5u.java\t2022-07-19 19:04:06.619589544 +0200\n@@ -1623,17 +1623,11 @@\n         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+years = FieldUtils.safeAdd(years, months * 12; if (months % 12!= 0) {\n             }\n         }\n         return result;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "years = FieldUtils.safeAdd(years, months / 12;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-5/src/main/java/org/joda/time/Period.java\t2022-07-19 19:04:08.211581305 +0200\n+++ /tmp/tmpnqg5lrct.java\t2022-07-19 19:04:08.211581305 +0200\n@@ -1623,17 +1623,11 @@\n         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+years = FieldUtils.safeAdd(years, months / 12;\n             }\n         }\n         return result;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "years = FieldUtils.safeAdd(years, months / 12); months = months % 12; if (years != 0) { result = result.withYears(years); } if (months != 0) { result = result.withMonths(months);",
        "fixed_line": "long totalMonths = years * 12L + months; if (type.isSupported(DurationFieldType.YEARS_TYPE)) { int normalizedYears = FieldUtils.safeToInt(totalMonths / 12); result = result.withYears(normalizedYears); totalMonths = totalMonths - (normalizedYears * 12); } if (type.isSupported(DurationFieldType.MONTHS_TYPE)) { int normalizedMonths = FieldUtils.safeToInt(totalMonths); result = result.withMonths(normalizedMonths); totalMonths = totalMonths - normalizedMonths; } if (totalMonths != 0) { throw new UnsupportedOperationException(\"Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: \" + toString());"
    },
    "Cli-28": {
        "fixes": [
            {
                "k": 1,
                "patch": "break.addValue(value;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-28/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 19:04:09.835572906 +0200\n+++ /tmp/tmpryym2uic.java\t2022-07-19 19:04:09.867572737 +0200\n@@ -285,11 +285,11 @@\n                         || \"true\".equalsIgnoreCase(value)\n                         || \"1\".equalsIgnoreCase(value)))\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+break.addValue(value;\n                 }\n \n                 cmd.addOption(opt);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "break.addValue(value);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-28/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 19:04:11.779562835 +0200\n+++ /tmp/tmp2gdi5337.java\t2022-07-19 19:04:11.779562835 +0200\n@@ -285,11 +285,11 @@\n                         || \"true\".equalsIgnoreCase(value)\n                         || \"1\".equalsIgnoreCase(value)))\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+break.addValue(value);\n                 }\n \n                 cmd.addOption(opt);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "break.isOption;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-28/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 19:04:13.527553788 +0200\n+++ /tmp/tmpo9tu3zvy.java\t2022-07-19 19:04:13.527553788 +0200\n@@ -285,11 +285,11 @@\n                         || \"true\".equalsIgnoreCase(value)\n                         || \"1\".equalsIgnoreCase(value)))\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+break.isOption;\n                 }\n \n                 cmd.addOption(opt);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "break.addOption(value;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-28/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 19:04:15.203545111 +0200\n+++ /tmp/tmpebsti99m.java\t2022-07-19 19:04:15.203545111 +0200\n@@ -285,11 +285,11 @@\n                         || \"true\".equalsIgnoreCase(value)\n                         || \"1\".equalsIgnoreCase(value)))\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+break.addOption(value;\n                 }\n \n                 cmd.addOption(opt);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "break.isOption(value;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-28/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 19:04:16.751537099 +0200\n+++ /tmp/tmpb5hmtqir.java\t2022-07-19 19:04:16.751537099 +0200\n@@ -285,11 +285,11 @@\n                         || \"true\".equalsIgnoreCase(value)\n                         || \"1\".equalsIgnoreCase(value)))\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+break.isOption(value;\n                 }\n \n                 cmd.addOption(opt);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "break.addOption;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-28/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 19:04:18.447528320 +0200\n+++ /tmp/tmpk01in121.java\t2022-07-19 19:04:18.451528299 +0200\n@@ -285,11 +285,11 @@\n                         || \"true\".equalsIgnoreCase(value)\n                         || \"1\".equalsIgnoreCase(value)))\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+break.addOption;\n                 }\n \n                 cmd.addOption(opt);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "break.add(value;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-28/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 19:04:20.079519872 +0200\n+++ /tmp/tmp32zcd4ek.java\t2022-07-19 19:04:20.079519872 +0200\n@@ -285,11 +285,11 @@\n                         || \"true\".equalsIgnoreCase(value)\n                         || \"1\".equalsIgnoreCase(value)))\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+break.add(value;\n                 }\n \n                 cmd.addOption(opt);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "break.addOption(value);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-28/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 19:04:21.599512004 +0200\n+++ /tmp/tmpt15mtbhd.java\t2022-07-19 19:04:21.599512004 +0200\n@@ -285,11 +285,11 @@\n                         || \"true\".equalsIgnoreCase(value)\n                         || \"1\".equalsIgnoreCase(value)))\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+break.addOption(value);\n                 }\n \n                 cmd.addOption(opt);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "break.add;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-28/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 19:04:23.359502894 +0200\n+++ /tmp/tmpe2b6tdzv.java\t2022-07-19 19:04:23.359502894 +0200\n@@ -285,11 +285,11 @@\n                         || \"true\".equalsIgnoreCase(value)\n                         || \"1\".equalsIgnoreCase(value)))\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+break.add;\n                 }\n \n                 cmd.addOption(opt);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "break.add(value);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-28/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 19:04:25.047494157 +0200\n+++ /tmp/tmp5h3ta7y0.java\t2022-07-19 19:04:25.051494136 +0200\n@@ -285,11 +285,11 @@\n                         || \"true\".equalsIgnoreCase(value)\n                         || \"1\".equalsIgnoreCase(value)))\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+break.add(value);\n                 }\n \n                 cmd.addOption(opt);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "break;",
        "fixed_line": "continue;"
    },
    "JacksonDatabind-84": {
        "fixes": [
            {
                "k": 1,
                "patch": "throw new IllegalStateException(\"Trying to re-set self for \"+_referencedType+\", new = _referencedType;",
                "patch_diff": "throw new IllegalStateException(\"Trying to re-set self for \"+_referencedType+\", new = _referencedType;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "throw new IllegalStateException(\"Trying to re-set self reference: \"+_referencedType+\", new = _referencedType;",
                "patch_diff": "throw new IllegalStateException(\"Trying to re-set self reference: \"+_referencedType+\", new = _referencedType;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "throw new IllegalStateException(\"Trying to re-set self reference: \"+_referencedType+\", new = _referencedType; }",
                "patch_diff": "throw new IllegalStateException(\"Trying to re-set self reference: \"+_referencedType+\", new = _referencedType; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new IllegalStateException(\"Trying to re-set self for \"+_referencedType+\", new = _referencedType; }",
                "patch_diff": "throw new IllegalStateException(\"Trying to re-set self for \"+_referencedType+\", new = _referencedType; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "throw new IllegalStateException(\"Trying to re-set self-set selfType+\", new = _referencedType;",
                "patch_diff": "throw new IllegalStateException(\"Trying to re-set self-set selfType+\", new = _referencedType;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = _referencedType; i < len; ++i) { if (referencedType == null) { sb.append(\"Trying to re-set self reference\"); } sb.append(\"Trying to re-set self reference\"); } sb = _referencedType; } }",
                "patch_diff": "for (int i = _referencedType; i < len; ++i) { if (referencedType == null) { sb.append(\"Trying to re-set self reference\"); } sb.append(\"Trying to re-set self reference\"); } sb = _referencedType; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "throw new IllegalStateException(\"Trying to re-set self for \"+_referencedType+\", new = \"+ref); }",
                "patch_diff": "throw new IllegalStateException(\"Trying to re-set self for \"+_referencedType+\", new = \"+ref); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = _referencedType; i < len; ++i) { if (referencedType == null) { sb.append(\"Trying to re-set self reference\"); } sb.append(\"Trying to re-set self reference\"); } }",
                "patch_diff": "for (int i = _referencedType; i < len; ++i) { if (referencedType == null) { sb.append(\"Trying to re-set self reference\"); } sb.append(\"Trying to re-set self reference\"); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int i = _referencedType; i < len; ++i) { if (referencedType == null) { sb.append(\"Trying to re-set self reference\"); } sb.append(\"Trying to re-set self\"); } sb = _referencedType; } }",
                "patch_diff": "for (int i = _referencedType; i < len; ++i) { if (referencedType == null) { sb.append(\"Trying to re-set self reference\"); } sb.append(\"Trying to re-set self\"); } sb = _referencedType; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "throw new IllegalStateException(\"Trying to re-set self reference; old value = _referencedType;",
                "patch_diff": "throw new IllegalStateException(\"Trying to re-set self reference; old value = _referencedType;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "@Override public JavaType getSuperClass() { if (_referencedType != null) { return _referencedType.getSuperClass(); } return super.getSuperClass(); }"
    },
    "Closure-130": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (name.globalSets == 1 && name.localSets == 0 && // no property-inExterns) // no property-inExterns",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-130/src/com/google/javascript/jscomp/CollapseProperties.java\t2022-07-19 19:04:29.159472874 +0200\n+++ /tmp/tmprizognzv.java\t2022-07-19 19:04:29.239472459 +0200\n@@ -167,11 +167,11 @@\n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+if (name.globalSets == 1 && name.localSets == 0 && // no property-inExterns) // no property-inExterns\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (name.globalSets == 1 && name.localSets == 0 && // no property-inExterns)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-130/src/com/google/javascript/jscomp/CollapseProperties.java\t2022-07-19 19:05:17.879220723 +0200\n+++ /tmp/tmp1urvm9x7.java\t2022-07-19 19:05:17.879220723 +0200\n@@ -167,11 +167,11 @@\n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+if (name.globalSets == 1 && name.localSets == 0 && // no property-inExterns)\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (name.globalSets == 1 && name.localSets == 0 && // no property name.aliasingGets > 0) // empty String meaning \"use default name.aliasingGets",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-130/src/com/google/javascript/jscomp/CollapseProperties.java\t2022-07-19 19:06:03.150986460 +0200\n+++ /tmp/tmp9zeuk9gl.java\t2022-07-19 19:06:03.154986439 +0200\n@@ -167,11 +167,11 @@\n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+if (name.globalSets == 1 && name.localSets == 0 && // no property name.aliasingGets > 0) // empty String meaning \"use default name.aliasingGets\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (name.globalSets == 1 && name.localSets == 0 && // name.aliasingGets > 0) // empty String meaning \"use default name.aliasingGets",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-130/src/com/google/javascript/jscomp/CollapseProperties.java\t2022-07-19 19:06:47.790755502 +0200\n+++ /tmp/tmpj3y54vi3.java\t2022-07-19 19:06:47.790755502 +0200\n@@ -167,11 +167,11 @@\n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+if (name.globalSets == 1 && name.localSets == 0 && // name.aliasingGets > 0) // empty String meaning \"use default name.aliasingGets\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (name.globalSets == 1 && name.localSets == 0 && // no property-inExterns) // no property-inExterns)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-130/src/com/google/javascript/jscomp/CollapseProperties.java\t2022-07-19 19:07:32.738522989 +0200\n+++ /tmp/tmpy0vg4fml.java\t2022-07-19 19:07:32.738522989 +0200\n@@ -167,11 +167,11 @@\n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+if (name.globalSets == 1 && name.localSets == 0 && // no property-inExterns) // no property-inExterns)\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (name.globalSets == 1 && name.localSets == 0 && // no property-name.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-130/src/com/google/javascript/jscomp/CollapseProperties.java\t2022-07-19 19:08:17.622290835 +0200\n+++ /tmp/tmp3ye9kthl.java\t2022-07-19 19:08:17.622290835 +0200\n@@ -167,11 +167,11 @@\n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+if (name.globalSets == 1 && name.localSets == 0 && // no property-name.\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (name.globalSets == 1 && name.localSets == 0 && // no property-inExterns",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-130/src/com/google/javascript/jscomp/CollapseProperties.java\t2022-07-19 19:09:01.646063157 +0200\n+++ /tmp/tmpzhvo59nb.java\t2022-07-19 19:09:01.646063157 +0200\n@@ -167,11 +167,11 @@\n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+if (name.globalSets == 1 && name.localSets == 0 && // no property-inExterns\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (name.globalSets == 1 && name.localSets == 0 && // sign/user default name.aliasingGets > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-130/src/com/google/javascript/jscomp/CollapseProperties.java\t2022-07-19 19:09:45.529836227 +0200\n+++ /tmp/tmpz3nccw8e.java\t2022-07-19 19:09:45.529836227 +0200\n@@ -167,11 +167,11 @@\n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+if (name.globalSets == 1 && name.localSets == 0 && // sign/user default name.aliasingGets > 0) {\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (name.globalSets == 1 && name.localSets == 0 && // no property-inExterns) // no property-inExterns) // no property-inExterns",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-130/src/com/google/javascript/jscomp/CollapseProperties.java\t2022-07-19 19:10:29.269610065 +0200\n+++ /tmp/tmpny55m33q.java\t2022-07-19 19:10:29.269610065 +0200\n@@ -167,11 +167,11 @@\n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+if (name.globalSets == 1 && name.localSets == 0 && // no property-inExterns) // no property-inExterns) // no property-inExterns\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (name.globalSets == 1 && name.localSets == 0 && // sign/user default name.aliasingGets > 0) // empty String meaning \"use default name.aliasingGets",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-130/src/com/google/javascript/jscomp/CollapseProperties.java\t2022-07-19 19:11:13.629380719 +0200\n+++ /tmp/tmp9zkxzbfm.java\t2022-07-19 19:11:13.629380719 +0200\n@@ -167,11 +167,11 @@\n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+if (name.globalSets == 1 && name.localSets == 0 && // sign/user default name.aliasingGets > 0) // empty String meaning \"use default name.aliasingGets\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (name.globalSets == 1 && name.localSets == 0 &&",
        "fixed_line": "if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 &&"
    },
    "Math-40": {
        "fixes": [
            {
                "k": 1,
                "patch": "targetY = -REQUI || this.yB; } else if (targetY > targetY) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2022-07-19 19:11:57.909151806 +0200\n+++ /tmp/tmpy9oa7609.java\t2022-07-19 19:11:57.929151702 +0200\n@@ -230,14 +230,11 @@\n \n             // target for the next evaluation point\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+targetY = -REQUI || this.yB; } else if (targetY > targetY) {\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "targetY = -REQUI || this.yB; } else if (targetYY > targetY) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2022-07-19 19:12:00.609137848 +0200\n+++ /tmp/tmp6vzfv14n.java\t2022-07-19 19:12:00.609137848 +0200\n@@ -230,14 +230,11 @@\n \n             // target for the next evaluation point\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+targetY = -REQUI || this.yB; } else if (targetYY > targetY) {\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "targetY = -REQUI || this.yB; } else if (targetY == targetY) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2022-07-19 19:12:02.781126620 +0200\n+++ /tmp/tmpbsavjes4.java\t2022-07-19 19:12:02.781126620 +0200\n@@ -230,14 +230,11 @@\n \n             // target for the next evaluation point\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+targetY = -REQUI || this.yB; } else if (targetY == targetY) {\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "targetY = -RE true; } else if (targetY > targetY) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2022-07-19 19:12:04.825116053 +0200\n+++ /tmp/tmpz4dq55g8.java\t2022-07-19 19:12:04.829116034 +0200\n@@ -230,14 +230,11 @@\n \n             // target for the next evaluation point\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+targetY = -RE true; } else if (targetY > targetY) {\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "targetY = -REQUI || this.yB; } else if (targetYY > targetYY) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2022-07-19 19:12:06.849105591 +0200\n+++ /tmp/tmpataj04a4.java\t2022-07-19 19:12:06.853105570 +0200\n@@ -230,14 +230,11 @@\n \n             // target for the next evaluation point\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+targetY = -REQUI || this.yB; } else if (targetYY > targetYY) {\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "targetY = -RE true; } else if (targetYY > targetY) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2022-07-19 19:12:08.953094713 +0200\n+++ /tmp/tmpigw7gmkd.java\t2022-07-19 19:12:08.953094713 +0200\n@@ -230,14 +230,11 @@\n \n             // target for the next evaluation point\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+targetY = -RE true; } else if (targetYY > targetY) {\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "targetY = -RE true; } else if (targetY == targetY) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2022-07-19 19:12:10.941084438 +0200\n+++ /tmp/tmpj44z6yop.java\t2022-07-19 19:12:10.941084438 +0200\n@@ -230,14 +230,11 @@\n \n             // target for the next evaluation point\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+targetY = -RE true; } else if (targetY == targetY) {\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "targetY = -REASON * 2, targetY) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2022-07-19 19:12:12.957074016 +0200\n+++ /tmp/tmp4defy4a3.java\t2022-07-19 19:12:12.957074016 +0200\n@@ -230,14 +230,11 @@\n \n             // target for the next evaluation point\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+targetY = -REASON * 2, targetY) {\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "targetY = -REyB; } else if (targetYY > targetY) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2022-07-19 19:12:15.025063326 +0200\n+++ /tmp/tmpuld0de5c.java\t2022-07-19 19:12:15.025063326 +0200\n@@ -230,14 +230,11 @@\n \n             // target for the next evaluation point\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+targetY = -REyB; } else if (targetYY > targetY) {\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "targetY = -RE true; } else if (targetY == targetYY) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2022-07-19 19:12:17.109052554 +0200\n+++ /tmp/tmpxte8g70d.java\t2022-07-19 19:12:17.113052532 +0200\n@@ -230,14 +230,11 @@\n \n             // target for the next evaluation point\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+targetY = -RE true; } else if (targetY == targetYY) {\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "targetY = -REDUCTION_FACTOR * yB; } else if (agingB >= MAXIMAL_AGING) { // we keep updating the low bracket, try to compensate this targetY = -REDUCTION_FACTOR * yA;",
        "fixed_line": "final int p = agingA - MAXIMAL_AGING; final double weightA = (1 << p) - 1; final double weightB = p + 1; targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB); } else if (agingB >= MAXIMAL_AGING) { // we keep updating the low bracket, try to compensate this final int p = agingB - MAXIMAL_AGING; final double weightA = p + 1; final double weightB = (1 << p) - 1; targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB);"
    },
    "Lang-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "int gap = 'z' + 1; start =''; }",
                "patch_diff": "int gap = 'z' + 1; start =''; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "char[] buffer = 'z' + 1; start =''; }",
                "patch_diff": "char[] buffer = 'z' + 1; start =''; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "char[] buf = 'z' + 1; start =''; }",
                "patch_diff": "char[] buf = 'z' + 1; start =''; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (end < start) { end = 'z' + 1; } else { end =''; } } char[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count];",
                "patch_diff": "} else if (end < start) { end = 'z' + 1; } else { end =''; } } char[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count];",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (end < start) { end = 'z' + 1; } else { end =''; } } char[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count];",
                "patch_diff": "} else if (end < start) { end = 'z' + 1; } else { end =''; } } char[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count];",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (end < start) { end = 'z' + 1; } else { end =''; } } char[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count];",
                "patch_diff": "} else if (end < start) { end = 'z' + 1; } else { end =''; } } char[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count];",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (end < start) { end = 'z' + 1; } else { end =''; } } char[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int start =''; }",
                "patch_diff": "} else if (end < start) { end = 'z' + 1; } else { end =''; } } char[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int start =''; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (end < start) { end = 'z' + 1; } else { end =''; } } char[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int start =''; }",
                "patch_diff": "} else if (end < start) { end = 'z' + 1; } else { end =''; } } char[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int start =''; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (end < start) { end = 'z' + 1; } else { end =''; } } char[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count];",
                "patch_diff": "} else if (end < start) { end = 'z' + 1; } else { end =''; } } char[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count];",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (end < start) { end = 'z' + 1; } else { end =''; } } char[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int start =''; }",
                "patch_diff": "} else if (end < start) { end = 'z' + 1; } else { end =''; } } char[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int[] buffer = new char[count]; int start =''; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "} else { if (end <= start) { throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\"); }"
    },
    "Cli-17": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (stopAtNonOption) {",
                "patch_diff": "if (stopAtNonOption) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (stopAtNonOption) {",
                "patch_diff": "} else if (stopAtNonOption) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "else if (stopAtNonOption) {",
                "patch_diff": "else if (stopAtNonOption) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "tokens.add(token.substring(i));",
                "patch_diff": "tokens.add(token.substring(i));",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "tokens.add(tokenPropertyAtNonOption) {",
                "patch_diff": "tokens.add(tokenPropertyAtNonOption) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (tokAtNonOption) {",
                "patch_diff": "if (tokAtNonOption) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "tokens.add(token; if (stopAtNonOption) {",
                "patch_diff": "tokens.add(token; if (stopAtNonOption) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "tokens.add(token.substring(i + 1, tokens.length - 1) {",
                "patch_diff": "tokens.add(token.substring(i + 1, tokens.length - 1) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (tokentokenIncompleteOption) {",
                "patch_diff": "if (tokentokenIncompleteOption) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "tokens.add(token.substring(i + 1));",
                "patch_diff": "tokens.add(token.substring(i + 1));",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "break;"
    },
    "Time-8": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (hoursOffset < 1 || minutesOffset > 59) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-8/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 19:12:23.337020360 +0200\n+++ /tmp/tmp1vxe11h6.java\t2022-07-19 19:12:23.361020235 +0200\n@@ -274,18 +274,11 @@\n             return DateTimeZone.UTC;\n         }\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < 0 || minutesOffset > 59) {\n-            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n-        }\n-        int offset = 0;\n-        try {\n-            int hoursInMinutes = hoursOffset * 60;\n-            if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+if (hoursOffset < 1 || minutesOffset > 59) {\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (minutesOffset < 1 || minutesOffset > 59) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-8/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 19:12:26.177005677 +0200\n+++ /tmp/tmpj5bv2v6u.java\t2022-07-19 19:12:26.177005677 +0200\n@@ -274,18 +274,11 @@\n             return DateTimeZone.UTC;\n         }\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < 0 || minutesOffset > 59) {\n-            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n-        }\n-        int offset = 0;\n-        try {\n-            int hoursInMinutes = hoursOffset * 60;\n-            if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+if (minutesOffset < 1 || minutesOffset > 59) {\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (hoursOffset < 5 || minutesOffset > 59) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-8/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 19:12:28.708992591 +0200\n+++ /tmp/tmp4mteo7j3.java\t2022-07-19 19:12:28.712992570 +0200\n@@ -274,18 +274,11 @@\n             return DateTimeZone.UTC;\n         }\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < 0 || minutesOffset > 59) {\n-            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n-        }\n-        int offset = 0;\n-        try {\n-            int hoursInMinutes = hoursOffset * 60;\n-            if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+if (hoursOffset < 5 || minutesOffset > 59) {\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (minutesOffset < 4 || minutesOffset > 59) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-8/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 19:12:31.280979294 +0200\n+++ /tmp/tmpf9ndt1w2.java\t2022-07-19 19:12:31.280979294 +0200\n@@ -274,18 +274,11 @@\n             return DateTimeZone.UTC;\n         }\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < 0 || minutesOffset > 59) {\n-            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n-        }\n-        int offset = 0;\n-        try {\n-            int hoursInMinutes = hoursOffset * 60;\n-            if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+if (minutesOffset < 4 || minutesOffset > 59) {\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (offset < 0 || minutesOffset > 59) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-8/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 19:12:33.780966371 +0200\n+++ /tmp/tmpr90scpdb.java\t2022-07-19 19:12:33.784966352 +0200\n@@ -274,18 +274,11 @@\n             return DateTimeZone.UTC;\n         }\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < 0 || minutesOffset > 59) {\n-            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n-        }\n-        int offset = 0;\n-        try {\n-            int hoursInMinutes = hoursOffset * 60;\n-            if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+if (offset < 0 || minutesOffset > 59) {\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (hoursOffset < 0 || minutesOffset > 59) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-8/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 19:12:36.324953222 +0200\n+++ /tmp/tmp74ldy1wx.java\t2022-07-19 19:12:36.324953222 +0200\n@@ -274,18 +274,11 @@\n             return DateTimeZone.UTC;\n         }\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < 0 || minutesOffset > 59) {\n-            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n-        }\n-        int offset = 0;\n-        try {\n-            int hoursInMinutes = hoursOffset * 60;\n-            if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+if (hoursOffset < 0 || minutesOffset > 59) {\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (hoursOffset < 2 || minutesOffset > 59) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-8/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 19:12:38.852940155 +0200\n+++ /tmp/tmp5ays48j_.java\t2022-07-19 19:12:38.856940134 +0200\n@@ -274,18 +274,11 @@\n             return DateTimeZone.UTC;\n         }\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < 0 || minutesOffset > 59) {\n-            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n-        }\n-        int offset = 0;\n-        try {\n-            int hoursInMinutes = hoursOffset * 60;\n-            if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+if (hoursOffset < 2 || minutesOffset > 59) {\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (millis < 0 || minutesOffset > 59) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-8/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 19:12:41.376927106 +0200\n+++ /tmp/tmpg0f6jndi.java\t2022-07-19 19:12:41.376927106 +0200\n@@ -274,18 +274,11 @@\n             return DateTimeZone.UTC;\n         }\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < 0 || minutesOffset > 59) {\n-            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n-        }\n-        int offset = 0;\n-        try {\n-            int hoursInMinutes = hoursOffset * 60;\n-            if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+if (millis < 0 || minutesOffset > 59) {\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (minutesOffset < 5 || minutesOffset > 59) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-8/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 19:12:43.968913708 +0200\n+++ /tmp/tmpayngxlww.java\t2022-07-19 19:12:43.968913708 +0200\n@@ -274,18 +274,11 @@\n             return DateTimeZone.UTC;\n         }\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < 0 || minutesOffset > 59) {\n-            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n-        }\n-        int offset = 0;\n-        try {\n-            int hoursInMinutes = hoursOffset * 60;\n-            if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+if (minutesOffset < 5 || minutesOffset > 59) {\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (minutesOffset < 0 || minutesOffset > 59) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-8/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 19:12:46.528900475 +0200\n+++ /tmp/tmpr1jkt3ct.java\t2022-07-19 19:12:46.532900456 +0200\n@@ -274,18 +274,11 @@\n             return DateTimeZone.UTC;\n         }\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < 0 || minutesOffset > 59) {\n-            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n-        }\n-        int offset = 0;\n-        try {\n-            int hoursInMinutes = hoursOffset * 60;\n-            if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+if (minutesOffset < 0 || minutesOffset > 59) {\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset); } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset;",
        "fixed_line": "if (minutesOffset < -59 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset); } if (hoursOffset > 0 && minutesOffset < 0) { throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset); } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - Math.abs(minutesOffset);"
    },
    "Time-14": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if (valueToAdd == 0) {",
                "patch_diff": "// if (valueToAdd == 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// if (valueToAdd == 0) { instant = partial.getFieldType(i).setField(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).set(iChronology); } }",
                "patch_diff": "// if (valueToAdd == 0) { instant = partial.getFieldType(i).setField(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).set(iChronology); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if (valueToAdd == 0) { instant = partial.getFieldType(i).set(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).set(iChronology); } }",
                "patch_diff": "// if (valueToAdd == 0) { instant = partial.getFieldType(i).set(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).set(iChronology); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// if (valueToAdd == 0) { instant = partial.getFieldType(i).set(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).set(iChronology).set(instant, values[i]); } }",
                "patch_diff": "// if (valueToAdd == 0) { instant = partial.getFieldType(i).set(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).set(iChronology).set(instant, values[i]); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// if (valueToAdd == 0) { instant = partial.getFieldType(i).setField(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).set(iChronology).set(instant, values[i]); } }",
                "patch_diff": "// if (valueToAdd == 0) { instant = partial.getFieldType(i).setField(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).set(iChronology).set(instant, values[i]); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if (valueToAdd == 0) { instant = partial.getFieldType(i).set(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); } }",
                "patch_diff": "// if (valueToAdd == 0) { instant = partial.getFieldType(i).set(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// if (valueToAdd == 0) { instant = partial.getFieldType(i).setField(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); } }",
                "patch_diff": "// if (valueToAdd == 0) { instant = partial.getFieldType(i).setField(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// if (valueToAdd == 0) { instant = partial.getFieldType(i).set(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).set(iChronology).set(instant, valueToAdd); } }",
                "patch_diff": "// if (valueToAdd == 0) { instant = partial.getFieldType(i).set(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).set(iChronology).set(instant, valueToAdd); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// if (valueToAdd == 0) { instant = partial.getFieldType(i).setField(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).set(iChronology); } if (valueToAdd == 0) {",
                "patch_diff": "// if (valueToAdd == 0) { instant = partial.getFieldType(i).setField(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).set(iChronology); } if (valueToAdd == 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if (valueToAdd == 0) { instant = partial.getFieldType(i).setField(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).set(iChronology).set(instant, valueToAdd); } }",
                "patch_diff": "// if (valueToAdd == 0) { instant = partial.getFieldType(i).setField(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); } if (valueToAdd == 0) { instant = partial.getFieldType(i).set(iChronology).set(instant, valueToAdd); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) { // month is largest field and being added to, such as month-day int curMonth0 = partial.getValue(0) - 1; int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1; return set(partial, 0, values, newMonth); }"
    },
    "Lang-27": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (expPos < decPos + 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-27/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 19:12:51.760873432 +0200\n+++ /tmp/tmpah_1dyxq.java\t2022-07-19 19:12:51.796873247 +0200\n@@ -474,11 +474,11 @@\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+if (expPos < decPos + 1) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (expPos < decPos) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-27/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 19:13:02.124819861 +0200\n+++ /tmp/tmp5rwuq9f9.java\t2022-07-19 19:13:02.124819861 +0200\n@@ -474,11 +474,11 @@\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+if (expPos < decPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (decPos < decPos + 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-27/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 19:13:11.756770073 +0200\n+++ /tmp/tmpq7rb1qgc.java\t2022-07-19 19:13:11.760770054 +0200\n@@ -474,11 +474,11 @@\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+if (decPos < decPos + 1) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (expPos < expPos) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-27/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 19:13:21.212721198 +0200\n+++ /tmp/tmptlx83r8m.java\t2022-07-19 19:13:21.212721198 +0200\n@@ -474,11 +474,11 @@\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+if (expPos < expPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (expPos < minPos) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-27/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 19:13:30.572672819 +0200\n+++ /tmp/tmpkq2nrf7g.java\t2022-07-19 19:13:30.576672798 +0200\n@@ -474,11 +474,11 @@\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+if (expPos < minPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (expPos < -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-27/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 19:13:32.212664342 +0200\n+++ /tmp/tmplicyat5c.java\t2022-07-19 19:13:32.212664342 +0200\n@@ -474,11 +474,11 @@\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+if (expPos < -1) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (decPos < decPos) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-27/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 19:13:41.704615280 +0200\n+++ /tmp/tmpisg53juv.java\t2022-07-19 19:13:41.704615280 +0200\n@@ -474,11 +474,11 @@\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+if (decPos < decPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (expPos < 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-27/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 19:13:51.104566697 +0200\n+++ /tmp/tmphia91g0d.java\t2022-07-19 19:13:51.104566697 +0200\n@@ -474,11 +474,11 @@\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+if (expPos < 0) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (expPos < 5) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-27/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 19:14:00.376518773 +0200\n+++ /tmp/tmpw8mrh983.java\t2022-07-19 19:14:00.376518773 +0200\n@@ -474,11 +474,11 @@\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+if (expPos < 5) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (expPos < 2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-27/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 19:14:09.796470086 +0200\n+++ /tmp/tmp60ol1ecv.java\t2022-07-19 19:14:09.796470086 +0200\n@@ -474,11 +474,11 @@\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+if (expPos < 2) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (expPos < decPos) {",
        "fixed_line": "if (expPos < decPos || expPos > str.length()) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { if (expPos > str.length()) { throw new NumberFormatException(str + \" is not a valid number.\"); }"
    },
    "Closure-132": {
        "fixes": [
            {
                "k": 1,
                "patch": "!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are immutable, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 19:14:19.948417618 +0200\n+++ /tmp/tmp_4n80ldx.java\t2022-07-19 19:14:20.004417328 +0200\n@@ -777,11 +777,11 @@\n           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n               // if LHS has side effects, don't proceed [since the optimization\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are immutable, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are immutable, don't",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 19:14:24.596393596 +0200\n+++ /tmp/tmp45focnpl.java\t2022-07-19 19:14:24.600393575 +0200\n@@ -777,11 +777,11 @@\n           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n               // if LHS has side effects, don't proceed [since the optimization\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are immutable, don't\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are immutable, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 19:14:28.400373936 +0200\n+++ /tmp/tmpcuo05la2.java\t2022-07-19 19:14:28.400373936 +0200\n@@ -777,11 +777,11 @@\n           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n               // if LHS has side effects, don't proceed [since the optimization\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are immutable, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are immutable, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 19:14:31.744356653 +0200\n+++ /tmp/tmpfosky50v.java\t2022-07-19 19:14:31.744356653 +0200\n@@ -777,11 +777,11 @@\n           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n               // if LHS has side effects, don't proceed [since the optimization\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are immutable, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 19:14:35.208338749 +0200\n+++ /tmp/tmpakc3l0y2.java\t2022-07-19 19:14:35.208338749 +0200\n@@ -777,11 +777,11 @@\n           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n               // if LHS has side effects, don't proceed [since the optimization\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 19:14:38.728320558 +0200\n+++ /tmp/tmpors_24ci.java\t2022-07-19 19:14:38.728320558 +0200\n@@ -777,11 +777,11 @@\n           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n               // if LHS has side effects, don't proceed [since the optimization\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don'",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 19:14:42.196302635 +0200\n+++ /tmp/tmp69q9ggxm.java\t2022-07-19 19:14:42.196302635 +0200\n@@ -777,11 +777,11 @@\n           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n               // if LHS has side effects, don't proceed [since the optimization\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don'\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are immutable, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are immutable, don't proceed",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 19:14:45.768284172 +0200\n+++ /tmp/tmpqa50a_q4.java\t2022-07-19 19:14:45.768284172 +0200\n@@ -777,11 +777,11 @@\n           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n               // if LHS has side effects, don't proceed [since the optimization\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are immutable, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are immutable, don't proceed\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are immutable, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 19:14:49.332265753 +0200\n+++ /tmp/tmpiwpoq_jy.java\t2022-07-19 19:14:49.336265734 +0200\n@@ -777,11 +777,11 @@\n           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n               // if LHS has side effects, don't proceed [since the optimization\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are immutable, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are immutable, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 19:14:52.772247976 +0200\n+++ /tmp/tmpcwlriara.java\t2022-07-19 19:14:52.776247954 +0200\n@@ -777,11 +777,11 @@\n           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n               // if LHS has side effects, don't proceed [since the optimization\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are immutable, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "!mayEffectMutableState(lhs)) {",
        "fixed_line": "!mayEffectMutableState(lhs) && (!mayHaveSideEffects(cond) || (thenOp.isAssign() && thenOp.getFirstChild().isName()))) {"
    },
    "Math-97": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-97/src/java/org/apache/commons/math/analysis/BrentSolver.java\t2022-07-19 19:14:57.176225219 +0200\n+++ /tmp/tmpiw0dracl.java\t2022-07-19 19:14:57.192225135 +0200\n@@ -133,18 +133,11 @@\n         double yMin = f.value(min);\n         double yMax = f.value(max);\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-97/src/java/org/apache/commons/math/analysis/BrentSolver.java\t2022-07-19 19:14:59.540212998 +0200\n+++ /tmp/tmp552kp5co.java\t2022-07-19 19:14:59.540212998 +0200\n@@ -133,18 +133,11 @@\n         double yMin = f.value(min);\n         double yMax = f.value(max);\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); }\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-97/src/java/org/apache/commons/math/analysis/BrentSolver.java\t2022-07-19 19:15:01.592202393 +0200\n+++ /tmp/tmpitsnnd4e.java\t2022-07-19 19:15:01.592202393 +0200\n@@ -133,18 +133,11 @@\n         double yMin = f.value(min);\n         double yMax = f.value(max);\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); }\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-97/src/java/org/apache/commons/math/analysis/BrentSolver.java\t2022-07-19 19:15:03.592192058 +0200\n+++ /tmp/tmpccuysglu.java\t2022-07-19 19:15:03.592192058 +0200\n@@ -133,18 +133,11 @@\n         double yMin = f.value(min);\n         double yMax = f.value(max);\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); }\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-97/src/java/org/apache/commons/math/analysis/BrentSolver.java\t2022-07-19 19:15:05.604181658 +0200\n+++ /tmp/tmpbckt2_z4.java\t2022-07-19 19:15:05.604181658 +0200\n@@ -133,18 +133,11 @@\n         double yMin = f.value(min);\n         double yMax = f.value(max);\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); }\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-97/src/java/org/apache/commons/math/analysis/BrentSolver.java\t2022-07-19 19:15:07.700170828 +0200\n+++ /tmp/tmpohaad6km.java\t2022-07-19 19:15:07.700170828 +0200\n@@ -133,18 +133,11 @@\n         double yMin = f.value(min);\n         double yMax = f.value(max);\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); }\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-97/src/java/org/apache/commons/math/analysis/BrentSolver.java\t2022-07-19 19:15:09.796159995 +0200\n+++ /tmp/tmppzk88st2.java\t2022-07-19 19:15:09.796159995 +0200\n@@ -133,18 +133,11 @@\n         double yMin = f.value(min);\n         double yMax = f.value(max);\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); }\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-97/src/java/org/apache/commons/math/analysis/BrentSolver.java\t2022-07-19 19:15:11.828149494 +0200\n+++ /tmp/tmpey70rxqx.java\t2022-07-19 19:15:11.828149494 +0200\n@@ -133,18 +133,11 @@\n         double yMin = f.value(min);\n         double yMax = f.value(max);\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); }\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-97/src/java/org/apache/commons/math/analysis/BrentSolver.java\t2022-07-19 19:15:13.752139550 +0200\n+++ /tmp/tmpxjehjak7.java\t2022-07-19 19:15:13.752139550 +0200\n@@ -133,18 +133,11 @@\n         double yMin = f.value(min);\n         double yMax = f.value(max);\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); }\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else if (yMin + \"]\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-97/src/java/org/apache/commons/math/analysis/BrentSolver.java\t2022-07-19 19:15:15.744129255 +0200\n+++ /tmp/tmpmgwrx293.java\t2022-07-19 19:15:15.744129255 +0200\n@@ -133,18 +133,11 @@\n         double yMin = f.value(min);\n         double yMax = f.value(max);\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else if (yMin + \"]\"); }\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (sign >= 0) { // check if either value is close to a zero // neither value is close to zero and min and max do not bracket root. throw new IllegalArgumentException (\"Function values at endpoints do not have different signs.\" + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else {",
        "fixed_line": "if (sign > 0) { // check if either value is close to a zero if (Math.abs(yMin) <= functionValueAccuracy) { setResult(min, 0); ret = min; } else if (Math.abs(yMax) <= functionValueAccuracy) { setResult(max, 0); ret = max; } else { // neither value is close to zero and min and max do not bracket root. throw new IllegalArgumentException (\"Function values at endpoints do not have different signs.\" + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } } else if (sign < 0){ // solve using only the first endpoint as initial guess ret = solve(min, yMin, max, yMax, min, yMin); } else { // either min or max is a root if (yMin == 0.0) { ret = min; } else { ret = max; }"
    },
    "Closure-82": {
        "fixes": [
            {
                "k": 1,
                "patch": "return isNoType() || isNoObjectType || isNo visibleType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-82/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 19:15:17.872118259 +0200\n+++ /tmp/tmpcineizro.java\t2022-07-19 19:15:17.892118154 +0200\n@@ -158,11 +158,11 @@\n   public boolean isNoObjectType() {\n     return false;\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n+return isNoType() || isNoObjectType || isNo visibleType;\n   }\n \n   public boolean isNumberObjectType() {\n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return isNoType && isNoObjectType || isNo visibleType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-82/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 19:15:21.124101452 +0200\n+++ /tmp/tmpirkif29s.java\t2022-07-19 19:15:21.124101452 +0200\n@@ -158,11 +158,11 @@\n   public boolean isNoObjectType() {\n     return false;\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n+return isNoType && isNoObjectType || isNo visibleType;\n   }\n \n   public boolean isNumberObjectType() {\n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return isNoType() && isNoObjectType || isNo visibleType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-82/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 19:15:23.616088573 +0200\n+++ /tmp/tmp90mqddk2.java\t2022-07-19 19:15:23.616088573 +0200\n@@ -158,11 +158,11 @@\n   public boolean isNoObjectType() {\n     return false;\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n+return isNoType() && isNoObjectType || isNo visibleType;\n   }\n \n   public boolean isNumberObjectType() {\n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return isNoType() || isNoObjectType) && isNoToType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-82/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 19:15:26.140075530 +0200\n+++ /tmp/tmps03spftp.java\t2022-07-19 19:15:26.140075530 +0200\n@@ -158,11 +158,11 @@\n   public boolean isNoObjectType() {\n     return false;\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n+return isNoType() || isNoObjectType) && isNoToType;\n   }\n \n   public boolean isNumberObjectType() {\n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return isNoType() || isNoObjectType() || isNoType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-82/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 19:15:28.608062774 +0200\n+++ /tmp/tmpawche6ag.java\t2022-07-19 19:15:28.608062774 +0200\n@@ -158,11 +158,11 @@\n   public boolean isNoObjectType() {\n     return false;\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n+return isNoType() || isNoObjectType() || isNoType;\n   }\n \n   public boolean isNumberObjectType() {\n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return isNoType() || isNoObjectType || isNoType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-82/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 19:15:31.344048636 +0200\n+++ /tmp/tmps0ck9dmz.java\t2022-07-19 19:15:31.344048636 +0200\n@@ -158,11 +158,11 @@\n   public boolean isNoObjectType() {\n     return false;\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n+return isNoType() || isNoObjectType || isNoType;\n   }\n \n   public boolean isNumberObjectType() {\n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return isNoType() || isNoObjectType) && isNoToType();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-82/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 19:15:34.008034867 +0200\n+++ /tmp/tmpu3dzpuxm.java\t2022-07-19 19:15:34.008034867 +0200\n@@ -158,11 +158,11 @@\n   public boolean isNoObjectType() {\n     return false;\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n+return isNoType() || isNoObjectType) && isNoToType();\n   }\n \n   public boolean isNumberObjectType() {\n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return isNoType() || isNoObjectType() || isNo visibleType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-82/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 19:15:36.600021473 +0200\n+++ /tmp/tmpm960fbpg.java\t2022-07-19 19:15:36.600021473 +0200\n@@ -158,11 +158,11 @@\n   public boolean isNoObjectType() {\n     return false;\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n+return isNoType() || isNoObjectType() || isNo visibleType;\n   }\n \n   public boolean isNumberObjectType() {\n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return isNoType() || isNoObjectType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-82/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 19:15:39.060008761 +0200\n+++ /tmp/tmphxrgrbir.java\t2022-07-19 19:15:39.060008761 +0200\n@@ -158,11 +158,11 @@\n   public boolean isNoObjectType() {\n     return false;\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n+return isNoType() || isNoObjectType;\n   }\n \n   public boolean isNumberObjectType() {\n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return isNoType() && isNoObjectType || isNoType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-82/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 19:15:41.715995035 +0200\n+++ /tmp/tmp6qse_99r.java\t2022-07-19 19:15:41.719995014 +0200\n@@ -158,11 +158,11 @@\n   public boolean isNoObjectType() {\n     return false;\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n+return isNoType() && isNoObjectType || isNoType;\n   }\n \n   public boolean isNumberObjectType() {\n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return isNoType() || isNoObjectType() || isNoResolvedType();",
        "fixed_line": "return isNoType() || isNoObjectType() || isNoResolvedType() || (registry.getNativeFunctionType( JSTypeNative.LEAST_FUNCTION_TYPE) == this);"
    },
    "Time-16": {
        "fixes": [
            {
                "k": 1,
                "patch": "instantLocal, chrono, iLocale, iPivotYear = chrono.iPivotYear, iPivotYear);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-16/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 19:15:44.647979881 +0200\n+++ /tmp/tmpdotx7_ny.java\t2022-07-19 19:15:44.703979593 +0200\n@@ -704,11 +704,11 @@\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+instantLocal, chrono, iLocale, iPivotYear = chrono.iPivotYear, iPivotYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n             int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "instantLocal, chrono, iLocale, iPivotYear, iPivotYear, iPivotYear);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-16/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 19:15:46.575969920 +0200\n+++ /tmp/tmp89awtb4i.java\t2022-07-19 19:15:46.575969920 +0200\n@@ -704,11 +704,11 @@\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+instantLocal, chrono, iLocale, iPivotYear, iPivotYear, iPivotYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n             int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "instantLocal, chrono, iLocale, iPivotYear, iPivotYear);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-16/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 19:15:48.239961318 +0200\n+++ /tmp/tmpocttwn7c.java\t2022-07-19 19:15:48.243961300 +0200\n@@ -704,11 +704,11 @@\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+instantLocal, chrono, iLocale, iPivotYear, iPivotYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n             int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "instantLocal, chrono, iLocale, iPivotYear = chrono.iPivotYear);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-16/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 19:15:50.063951894 +0200\n+++ /tmp/tmp4h6lz5_t.java\t2022-07-19 19:15:50.063951894 +0200\n@@ -704,11 +704,11 @@\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+instantLocal, chrono, iLocale, iPivotYear = chrono.iPivotYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n             int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "instantLocal, chrono, iLocale, iPivotYear = chrono.iPivotYear;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-16/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 19:15:51.751943171 +0200\n+++ /tmp/tmphhkb90nh.java\t2022-07-19 19:15:51.755943149 +0200\n@@ -704,11 +704,11 @@\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+instantLocal, chrono, iLocale, iPivotYear = chrono.iPivotYear;\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n             int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "instantLocal, chrono, iLocale, iPivotYear) - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-16/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 19:15:53.319935068 +0200\n+++ /tmp/tmp3hepua0f.java\t2022-07-19 19:15:53.319935068 +0200\n@@ -704,11 +704,11 @@\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+instantLocal, chrono, iLocale, iPivotYear) - 1;\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n             int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "instantLocal, chrono, iLocale, iPivotYear = chrono.iPivotYear, iPivotYear, iPivotYear);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-16/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 19:15:54.999926385 +0200\n+++ /tmp/tmp_7b7dt__.java\t2022-07-19 19:15:54.999926385 +0200\n@@ -704,11 +704,11 @@\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+instantLocal, chrono, iLocale, iPivotYear = chrono.iPivotYear, iPivotYear, iPivotYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n             int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "instantLocal, chrono, iLocale, iPivotYear, iPivotYear, iPivotYear, iPivotYear);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-16/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 19:15:56.615918034 +0200\n+++ /tmp/tmpo_3fou8w.java\t2022-07-19 19:15:56.615918034 +0200\n@@ -704,11 +704,11 @@\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+instantLocal, chrono, iLocale, iPivotYear, iPivotYear, iPivotYear, iPivotYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n             int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "instantLocal, chrono, iLocale, iPivotYear = chrono;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-16/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 19:15:58.335909147 +0200\n+++ /tmp/tmpfv2fgg9n.java\t2022-07-19 19:15:58.335909147 +0200\n@@ -704,11 +704,11 @@\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+instantLocal, chrono, iLocale, iPivotYear = chrono;\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n             int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "instantLocal, chrono, iLocale, iPivotYear, iPivotYear, iPivotYear, iPivotYear, iPivotYear);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-16/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 19:15:59.935900879 +0200\n+++ /tmp/tmp44rfp961.java\t2022-07-19 19:15:59.935900879 +0200\n@@ -704,11 +704,11 @@\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+instantLocal, chrono, iLocale, iPivotYear, iPivotYear, iPivotYear, iPivotYear, iPivotYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n             int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);",
        "fixed_line": "instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));"
    },
    "Jsoup-20": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if (doc == null) { // can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "// if (doc == null) { // can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// if (doc == null) { // can't really modify it's do implicit re-parse",
                "patch_diff": "// if (doc == null) { // can't really modify it's do implicit re-parse",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if (doc == null) { // can't really modify it was non-literal characters that might be valid (empty be",
                "patch_diff": "// if (doc == null) { // can't really modify it was non-literal characters that might be valid (empty be",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// if (doc == null) { // can't really modify it was non-literal characters that might be valid (empty be // need to check",
                "patch_diff": "// if (doc == null) { // can't really modify it was non-literal characters that might be valid (empty be // need to check",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// if (doc == null) { // can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "patch_diff": "// if (doc == null) { // can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if (doc == null) { // can't really modify it was non-empty's do implicit re-parse",
                "patch_diff": "// if (doc == null) { // can't really modify it was non-empty's do implicit re-parse",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// if (doc == null) { // can't really modify it was non-literal characters that might be valid (empty be valid)",
                "patch_diff": "// if (doc == null) { // can't really modify it was non-literal characters that might be valid (empty be valid)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// if (doc == null) { // can't really modify it was non-literal characters that might be null or EMPTY",
                "patch_diff": "// if (doc == null) { // can't really modify it was non-literal characters that might be null or EMPTY",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// if (doc == null) { // can't really modify it was non-literal characters that might be valid (empty be // if it's do implicit re-parse",
                "patch_diff": "// if (doc == null) { // can't really modify it was non-literal characters that might be valid (empty be // if it's do implicit re-parse",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if (doc == null) {",
                "patch_diff": "// if (doc == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (docData.charAt(0) == 65279) docData = docData.substring(1);"
    },
    "Lang-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (count < 0) {",
                "patch_diff": "} else if (count < 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (count < 0 && start > 0) {",
                "patch_diff": "} else if (count < 0 && start > 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (count < 1) {",
                "patch_diff": "} else if (count < 1) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (count < 0 || start > end) {",
                "patch_diff": "} else if (count < 0 || start > end) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (count < 0 &&!numbers) {",
                "patch_diff": "} else if (count < 0 &&!numbers) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (start == 0 && end == 0) {",
                "patch_diff": "} else if (start == 0 && end == 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (count < 0 || start > 2) {",
                "patch_diff": "} else if (count < 0 || start > 2) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (end < 0 || start > end) {",
                "patch_diff": "} else if (end < 0 || start > end) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (count < 0 &&!count > 0) {",
                "patch_diff": "} else if (count < 0 &&!count > 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (count < 0) { if (count == 0) {",
                "patch_diff": "} else if (count < 0) { if (count == 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (chars != null && chars.length == 0) { throw new IllegalArgumentException(\"The chars array must not be empty\"); } if (start == 0 && end == 0) { if (chars != null) { end = chars.length; } else { if (!letters && !numbers) { end = Integer.MAX_VALUE; } else { end = 'z' + 1; start = ' '; } }"
    },
    "Jsoup-24": {
        "fixes": [
            {
                "k": 1,
                "patch": "r.advance = r;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-24/src/main/java/org/jsoup/parser/TokeniserState.java\t2022-07-19 19:16:05.187873735 +0200\n+++ /tmp/tmp7_4rhrfn.java\t2022-07-19 19:16:05.215873594 +0200\n@@ -553,11 +553,11 @@\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+r.advance = r;\n                 return;\n             }\n \n             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                 char c = r.consume();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "r.advance = r.advance;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-24/src/main/java/org/jsoup/parser/TokeniserState.java\t2022-07-19 19:16:07.195863361 +0200\n+++ /tmp/tmp0s634flj.java\t2022-07-19 19:16:07.195863361 +0200\n@@ -553,11 +553,11 @@\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+r.advance = r.advance;\n                 return;\n             }\n \n             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                 char c = r.consume();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "r.advance = r.advance = r;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-24/src/main/java/org/jsoup/parser/TokeniserState.java\t2022-07-19 19:16:08.967854202 +0200\n+++ /tmp/tmpfo0f6x54.java\t2022-07-19 19:16:08.971854183 +0200\n@@ -553,11 +553,11 @@\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+r.advance = r.advance = r;\n                 return;\n             }\n \n             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                 char c = r.consume();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "r.advance = r.advance();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-24/src/main/java/org/jsoup/parser/TokeniserState.java\t2022-07-19 19:16:10.627845626 +0200\n+++ /tmp/tmp0p__i16r.java\t2022-07-19 19:16:10.627845626 +0200\n@@ -553,11 +553,11 @@\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+r.advance = r.advance();\n                 return;\n             }\n \n             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                 char c = r.consume();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "r.advance = r.advanceIs;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-24/src/main/java/org/jsoup/parser/TokeniserState.java\t2022-07-19 19:16:12.383836551 +0200\n+++ /tmp/tmpkhsrmeu3.java\t2022-07-19 19:16:12.383836551 +0200\n@@ -553,11 +553,11 @@\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+r.advance = r.advanceIs;\n                 return;\n             }\n \n             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                 char c = r.consume();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "r.advance = r.advanceInstant;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-24/src/main/java/org/jsoup/parser/TokeniserState.java\t2022-07-19 19:16:14.095827705 +0200\n+++ /tmp/tmpgivbz_db.java\t2022-07-19 19:16:14.099827683 +0200\n@@ -553,11 +553,11 @@\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+r.advance = r.advanceInstant;\n                 return;\n             }\n \n             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                 char c = r.consume();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "r.advance = r.advance value;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-24/src/main/java/org/jsoup/parser/TokeniserState.java\t2022-07-19 19:16:15.831818731 +0200\n+++ /tmp/tmprije8axr.java\t2022-07-19 19:16:15.831818731 +0200\n@@ -553,11 +553,11 @@\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+r.advance = r.advance value;\n                 return;\n             }\n \n             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                 char c = r.consume();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "r.advance = t;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-24/src/main/java/org/jsoup/parser/TokeniserState.java\t2022-07-19 19:16:17.363810817 +0200\n+++ /tmp/tmpy6e3m9qf.java\t2022-07-19 19:16:17.363810817 +0200\n@@ -553,11 +553,11 @@\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+r.advance = t;\n                 return;\n             }\n \n             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                 char c = r.consume();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "r.advance = r.advanceCount;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-24/src/main/java/org/jsoup/parser/TokeniserState.java\t2022-07-19 19:16:19.095801866 +0200\n+++ /tmp/tmp6kgml946.java\t2022-07-19 19:16:19.095801866 +0200\n@@ -553,11 +553,11 @@\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+r.advance = r.advanceCount;\n                 return;\n             }\n \n             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                 char c = r.consume();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "r.advance;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-24/src/main/java/org/jsoup/parser/TokeniserState.java\t2022-07-19 19:16:20.823792935 +0200\n+++ /tmp/tmp80nh97t0.java\t2022-07-19 19:16:20.823792935 +0200\n@@ -553,11 +553,11 @@\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+r.advance;\n                 return;\n             }\n \n             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                 char c = r.consume();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "r.advance();",
        "fixed_line": ""
    },
    "Cli-4": {
        "fixes": [
            {
                "k": 1,
                "patch": "StringBuffer buff = new StringBuffer(iterables;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-4/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 19:16:22.475784400 +0200\n+++ /tmp/tmphblr6h5z.java\t2022-07-19 19:16:22.511784214 +0200\n@@ -293,11 +293,11 @@\n         // if there are required options that have not been\n         // processsed\n         if (requiredOptions.size() > 0)\n         {\n             Iterator iter = requiredOptions.iterator();\n-            StringBuffer buff = new StringBuffer();\n+StringBuffer buff = new StringBuffer(iterables;\n \n \n             // loop through the required options\n             while (iter.hasNext())\n             {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "StringBuffer buff = new StringBuffer(iterables);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-4/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 19:16:24.179775594 +0200\n+++ /tmp/tmpvkdejtbb.java\t2022-07-19 19:16:24.183775573 +0200\n@@ -293,11 +293,11 @@\n         // if there are required options that have not been\n         // processsed\n         if (requiredOptions.size() > 0)\n         {\n             Iterator iter = requiredOptions.iterator();\n-            StringBuffer buff = new StringBuffer();\n+StringBuffer buff = new StringBuffer(iterables);\n \n \n             // loop through the required options\n             while (iter.hasNext())\n             {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "StringBuffer buff = new StringBuffer(iterators;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-4/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 19:16:25.939766500 +0200\n+++ /tmp/tmp1g58nw4d.java\t2022-07-19 19:16:25.939766500 +0200\n@@ -293,11 +293,11 @@\n         // if there are required options that have not been\n         // processsed\n         if (requiredOptions.size() > 0)\n         {\n             Iterator iter = requiredOptions.iterator();\n-            StringBuffer buff = new StringBuffer();\n+StringBuffer buff = new StringBuffer(iterators;\n \n \n             // loop through the required options\n             while (iter.hasNext())\n             {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "StringBuffer buff = new StringBuffer(iterators);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-4/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 19:16:27.483758520 +0200\n+++ /tmp/tmpo6dqcwqd.java\t2022-07-19 19:16:27.483758520 +0200\n@@ -293,11 +293,11 @@\n         // if there are required options that have not been\n         // processsed\n         if (requiredOptions.size() > 0)\n         {\n             Iterator iter = requiredOptions.iterator();\n-            StringBuffer buff = new StringBuffer();\n+StringBuffer buff = new StringBuffer(iterators);\n \n \n             // loop through the required options\n             while (iter.hasNext())\n             {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "StringBuffer buff = requiredOptions;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-4/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 19:16:29.111750106 +0200\n+++ /tmp/tmp9_692wev.java\t2022-07-19 19:16:29.111750106 +0200\n@@ -293,11 +293,11 @@\n         // if there are required options that have not been\n         // processsed\n         if (requiredOptions.size() > 0)\n         {\n             Iterator iter = requiredOptions.iterator();\n-            StringBuffer buff = new StringBuffer();\n+StringBuffer buff = requiredOptions;\n \n \n             // loop through the required options\n             while (iter.hasNext())\n             {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "StringBuffer buff = new StringBuffer(ake;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-4/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 19:16:30.651742148 +0200\n+++ /tmp/tmptrnncwaf.java\t2022-07-19 19:16:30.651742148 +0200\n@@ -293,11 +293,11 @@\n         // if there are required options that have not been\n         // processsed\n         if (requiredOptions.size() > 0)\n         {\n             Iterator iter = requiredOptions.iterator();\n-            StringBuffer buff = new StringBuffer();\n+StringBuffer buff = new StringBuffer(ake;\n \n \n             // loop through the required options\n             while (iter.hasNext())\n             {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "StringBuffer buff = new StringBuffer(16;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-4/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 19:16:32.195734170 +0200\n+++ /tmp/tmpn7tfnmaz.java\t2022-07-19 19:16:32.195734170 +0200\n@@ -293,11 +293,11 @@\n         // if there are required options that have not been\n         // processsed\n         if (requiredOptions.size() > 0)\n         {\n             Iterator iter = requiredOptions.iterator();\n-            StringBuffer buff = new StringBuffer();\n+StringBuffer buff = new StringBuffer(16;\n \n \n             // loop through the required options\n             while (iter.hasNext())\n             {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "StringBuffer buff = new StringBuffer(128;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-4/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 19:16:33.591726957 +0200\n+++ /tmp/tmp6d_w6tv5.java\t2022-07-19 19:16:33.591726957 +0200\n@@ -293,11 +293,11 @@\n         // if there are required options that have not been\n         // processsed\n         if (requiredOptions.size() > 0)\n         {\n             Iterator iter = requiredOptions.iterator();\n-            StringBuffer buff = new StringBuffer();\n+StringBuffer buff = new StringBuffer(128;\n \n \n             // loop through the required options\n             while (iter.hasNext())\n             {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "StringBuffer buff = new StringBuffer(4;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-4/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 19:16:35.043719454 +0200\n+++ /tmp/tmphgrprpjr.java\t2022-07-19 19:16:35.043719454 +0200\n@@ -293,11 +293,11 @@\n         // if there are required options that have not been\n         // processsed\n         if (requiredOptions.size() > 0)\n         {\n             Iterator iter = requiredOptions.iterator();\n-            StringBuffer buff = new StringBuffer();\n+StringBuffer buff = new StringBuffer(4;\n \n \n             // loop through the required options\n             while (iter.hasNext())\n             {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "StringBuffer buff = new StringBuffer[128];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-4/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 19:16:36.471712074 +0200\n+++ /tmp/tmph76dda9s.java\t2022-07-19 19:16:36.471712074 +0200\n@@ -293,11 +293,11 @@\n         // if there are required options that have not been\n         // processsed\n         if (requiredOptions.size() > 0)\n         {\n             Iterator iter = requiredOptions.iterator();\n-            StringBuffer buff = new StringBuffer();\n+StringBuffer buff = new StringBuffer[128];\n \n \n             // loop through the required options\n             while (iter.hasNext())\n             {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "StringBuffer buff = new StringBuffer();",
        "fixed_line": "StringBuffer buff = new StringBuffer(\"Missing required option\"); buff.append(requiredOptions.size() == 1 ? \"\" : \"s\"); buff.append(\": \");"
    },
    "JxPath-14": {
        "fixes": [
            {
                "k": 1,
                "patch": "double v = InfoSetUtil.doubleValue(v);",
                "patch_diff": "double v = InfoSetUtil.doubleValue(v);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "double v = InfoSetUtil.doubleValue(v) {",
                "patch_diff": "double v = InfoSetUtil.doubleValue(v) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "double v = InfoSetUtil.doubleValue(v;",
                "patch_diff": "double v = InfoSetUtil.doubleValue(v;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "double v = InfoSetUtil.doubleValue(v).computeValue(context;",
                "patch_diff": "double v = InfoSetUtil.doubleValue(v).computeValue(context;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "double v = InfoSetUtil.doubleValue(v).computeValue(v;",
                "patch_diff": "double v = InfoSetUtil.doubleValue(v).computeValue(v;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "double ac = v;",
                "patch_diff": "double ac = v;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "double v = InfoSetUtil.doubleValue(v).computeValue(context) {",
                "patch_diff": "double v = InfoSetUtil.doubleValue(v).computeValue(context) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "double v = InfoSetUtil.doubleValue(v).computeValue(v) {",
                "patch_diff": "double v = InfoSetUtil.doubleValue(v).computeValue(v) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "double v = InfoSetUtil.doubleValue(v + Long.doubleValue(v));",
                "patch_diff": "double v = InfoSetUtil.doubleValue(v + Long.doubleValue(v));",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "double v = InfoSetUtil.doubleValue(v).computeValue(v);",
                "patch_diff": "double v = InfoSetUtil.doubleValue(v).computeValue(v);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (Double.isNaN(v) || Double.isInfinite(v)) { return new Double(v); } return new Double(Math.floor(v)); } protected Object functionCeiling(EvalContext context) { assertArgCount(1); double v = InfoSetUtil.doubleValue(getArg1().computeValue(context)); if (Double.isNaN(v) || Double.isInfinite(v)) { return new Double(v); } return new Double(Math.ceil(v)); } protected Object functionRound(EvalContext context) { assertArgCount(1); double v = InfoSetUtil.doubleValue(getArg1().computeValue(context)); if (Double.isNaN(v) || Double.isInfinite(v)) { return new Double(v); }"
    },
    "Closure-131": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (lengthlength == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-131/src/com/google/javascript/rhino/TokenStream.java\t2022-07-19 19:16:39.899694361 +0200\n+++ /tmp/tmp4bxv8ayo.java\t2022-07-19 19:16:39.947694112 +0200\n@@ -194,11 +194,11 @@\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+if (lengthlength == 0) {\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n       }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (iters.length <= 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-131/src/com/google/javascript/rhino/TokenStream.java\t2022-07-19 19:16:44.579670176 +0200\n+++ /tmp/tmpvw65mn0s.java\t2022-07-19 19:16:44.579670176 +0200\n@@ -194,11 +194,11 @@\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+if (iters.length <= 1) {\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n       }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (!i.isJavaIdentifierPart) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-131/src/com/google/javascript/rhino/TokenStream.java\t2022-07-19 19:16:48.003652483 +0200\n+++ /tmp/tmplat_1wtx.java\t2022-07-19 19:16:48.003652483 +0200\n@@ -194,11 +194,11 @@\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+if (!i.isJavaIdentifierPart) {\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n       }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (lengthlengthlength == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-131/src/com/google/javascript/rhino/TokenStream.java\t2022-07-19 19:16:51.507634377 +0200\n+++ /tmp/tmpkp8yf919.java\t2022-07-19 19:16:51.507634377 +0200\n@@ -194,11 +194,11 @@\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+if (lengthlengthlength == 0) {\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n       }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (lengthlength == 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-131/src/com/google/javascript/rhino/TokenStream.java\t2022-07-19 19:16:54.915616764 +0200\n+++ /tmp/tmpb34cydcj.java\t2022-07-19 19:16:54.915616764 +0200\n@@ -194,11 +194,11 @@\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+if (lengthlength == 1) {\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n       }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (!Character.isJavaIdentifierPart) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-131/src/com/google/javascript/rhino/TokenStream.java\t2022-07-19 19:16:58.307599237 +0200\n+++ /tmp/tmpgoerzte7.java\t2022-07-19 19:16:58.307599237 +0200\n@@ -194,11 +194,11 @@\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+if (!Character.isJavaIdentifierPart) {\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n       }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (i.isJavaIdentifierPart) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-131/src/com/google/javascript/rhino/TokenStream.java\t2022-07-19 19:17:01.587582289 +0200\n+++ /tmp/tmpmjgx5zoh.java\t2022-07-19 19:17:01.591582268 +0200\n@@ -194,11 +194,11 @@\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+if (i.isJavaIdentifierPart) {\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n       }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (lengthlengthlength == 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-131/src/com/google/javascript/rhino/TokenStream.java\t2022-07-19 19:17:04.971564803 +0200\n+++ /tmp/tmpw6i95d5o.java\t2022-07-19 19:17:04.971564803 +0200\n@@ -194,11 +194,11 @@\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+if (lengthlengthlength == 1) {\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n       }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (lengthlength == 0 || length == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-131/src/com/google/javascript/rhino/TokenStream.java\t2022-07-19 19:17:08.319547502 +0200\n+++ /tmp/tmprjjradny.java\t2022-07-19 19:17:08.319547502 +0200\n@@ -194,11 +194,11 @@\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+if (lengthlength == 0 || length == 0) {\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n       }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (lengthlength == 0 || length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-131/src/com/google/javascript/rhino/TokenStream.java\t2022-07-19 19:17:11.663530223 +0200\n+++ /tmp/tmptjncmj2c.java\t2022-07-19 19:17:11.663530223 +0200\n@@ -194,11 +194,11 @@\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+if (lengthlength == 0 || length) {\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n       }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (",
        "fixed_line": "Character.isIdentifierIgnorable(s.charAt(0)) || !Character.isJavaIdentifierStart(s.charAt(0))) { return false; } for (int i = 1; i < length; i++) { if (Character.isIdentifierIgnorable(s.charAt(i)) ||"
    },
    "Time-18": {
        "fixes": [
            {
                "k": 1,
                "patch": "instant = iGregorianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);",
                "patch_diff": "instant = iGregorianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "instant = iGregorianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); }",
                "patch_diff": "instant = iGregorianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (instant = iGregorianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);",
                "patch_diff": "if (instant = iGregorianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (instant = iGregorianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); }",
                "patch_diff": "if (instant = iGregorianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (instant = hourOfDay.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); }",
                "patch_diff": "if (instant = hourOfDay.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if (year, monthOfYear. dayOfMonth, hourOfDay = iGregorianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); }",
                "patch_diff": "// if (year, monthOfYear. dayOfMonth, hourOfDay = iGregorianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// if (year, monthOfYear, dayOfMonth, hourOfDay = iGregorianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); }",
                "patch_diff": "// if (year, monthOfYear, dayOfMonth, hourOfDay = iGregorianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (instant = hourOfDay.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);",
                "patch_diff": "if (instant = hourOfDay.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (instant = iJulianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);",
                "patch_diff": "if (instant = iJulianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (instant = iJulianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); }",
                "patch_diff": "if (instant = iJulianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "try { instant = iGregorianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); } catch (IllegalFieldValueException ex) { if (monthOfYear != 2 || dayOfMonth != 29) { throw ex; } instant = iGregorianChronology.getDateTimeMillis (year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); if (instant >= iCutoverMillis) { throw ex; } }"
    },
    "Mockito-34": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (k instanceof CapturesArguments && k)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-34/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 19:17:17.119502027 +0200\n+++ /tmp/tmp9ud37bj2.java\t2022-07-19 19:17:17.131501966 +0200\n@@ -101,11 +101,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+if (k instanceof CapturesArguments && k)) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (k instanceof CapturesArguments && k) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-34/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 19:17:19.979487251 +0200\n+++ /tmp/tmpougyfv79.java\t2022-07-19 19:17:19.983487230 +0200\n@@ -101,11 +101,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+if (k instanceof CapturesArguments && k) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (k instanceof CapturesArguments && k == m) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-34/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 19:17:22.271475408 +0200\n+++ /tmp/tmp_7tvt8dq.java\t2022-07-19 19:17:22.271475408 +0200\n@@ -101,11 +101,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+if (k instanceof CapturesArguments && k == m) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (k instanceof CapturesArguments && k < m) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-34/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 19:17:24.483463976 +0200\n+++ /tmp/tmpy0mh44wk.java\t2022-07-19 19:17:24.483463976 +0200\n@@ -101,11 +101,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+if (k instanceof CapturesArguments && k < m) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (k instanceof CapturesArguments && k <= m) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-34/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 19:17:26.743452299 +0200\n+++ /tmp/tmp88n4xz0h.java\t2022-07-19 19:17:26.743452299 +0200\n@@ -101,11 +101,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+if (k instanceof CapturesArguments && k <= m) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (k instanceof CapturesArguments && k instanceof CapturesArguments) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-34/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 19:17:29.051440372 +0200\n+++ /tmp/tmpd3rcqecm.java\t2022-07-19 19:17:29.055440354 +0200\n@@ -101,11 +101,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+if (k instanceof CapturesArguments && k instanceof CapturesArguments) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (k >= m) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-34/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 19:17:31.331428590 +0200\n+++ /tmp/tmp4c17j09u.java\t2022-07-19 19:17:31.331428590 +0200\n@@ -101,11 +101,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+if (k >= m) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (k == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-34/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 19:17:33.619416768 +0200\n+++ /tmp/tmpu9sbdczh.java\t2022-07-19 19:17:33.623416750 +0200\n@@ -101,11 +101,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+if (k == 0) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (k < 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-34/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 19:17:50.623328907 +0200\n+++ /tmp/tmpi8_0yy5c.java\t2022-07-19 19:17:50.627328884 +0200\n@@ -101,11 +101,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+if (k < 0) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (k instanceof CapturesArguments) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-34/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 19:18:07.455241932 +0200\n+++ /tmp/tmpnan7xx_x.java\t2022-07-19 19:18:07.455241932 +0200\n@@ -101,11 +101,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+if (k instanceof CapturesArguments) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (m instanceof CapturesArguments) {",
        "fixed_line": "if (m instanceof CapturesArguments && i.getArguments().length > k) {"
    },
    "Lang-61": {
        "fixes": [
            {
                "k": 1,
                "patch": "int len = thisBuf.length - strLen;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-61/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 19:18:09.879229408 +0200\n+++ /tmp/tmpax0apywa.java\t2022-07-19 19:18:09.903229286 +0200\n@@ -1771,11 +1771,11 @@\n         }\n         if (strLen > size) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = thisBuf.length - strLen;\n+int len = thisBuf.length - strLen;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n                     continue outer;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int len = startIndex + thisBuf.length - thisBuf.length;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-61/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 19:18:19.739178462 +0200\n+++ /tmp/tmpyij230vi.java\t2022-07-19 19:18:19.739178462 +0200\n@@ -1771,11 +1771,11 @@\n         }\n         if (strLen > size) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = thisBuf.length - strLen;\n+int len = startIndex + thisBuf.length - thisBuf.length;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n                     continue outer;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int len = startIndex + thisBuf.length - strLen;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-61/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 19:18:29.143129871 +0200\n+++ /tmp/tmp1mpec4ao.java\t2022-07-19 19:18:29.143129871 +0200\n@@ -1771,11 +1771,11 @@\n         }\n         if (strLen > size) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = thisBuf.length - strLen;\n+int len = startIndex + thisBuf.length - strLen;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n                     continue outer;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int len = thisBuf.length - thisBuf.length;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-61/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 19:18:38.483081610 +0200\n+++ /tmp/tmpuic7uhnl.java\t2022-07-19 19:18:38.483081610 +0200\n@@ -1771,11 +1771,11 @@\n         }\n         if (strLen > size) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = thisBuf.length - strLen;\n+int len = thisBuf.length - thisBuf.length;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n                     continue outer;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int len = buffer.length - strLen;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-61/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 19:18:47.803033456 +0200\n+++ /tmp/tmphlpg5b_m.java\t2022-07-19 19:18:47.803033456 +0200\n@@ -1771,11 +1771,11 @@\n         }\n         if (strLen > size) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = thisBuf.length - strLen;\n+int len = buffer.length - strLen;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n                     continue outer;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int len = strLen - thisBuf.length;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-61/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 19:18:57.014985860 +0200\n+++ /tmp/tmp2wa53oen.java\t2022-07-19 19:18:57.018985839 +0200\n@@ -1771,11 +1771,11 @@\n         }\n         if (strLen > size) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = thisBuf.length - strLen;\n+int len = strLen - thisBuf.length;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n                     continue outer;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int len = i - strLen;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-61/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 19:19:06.150938655 +0200\n+++ /tmp/tmpqyjbjm54.java\t2022-07-19 19:19:06.150938655 +0200\n@@ -1771,11 +1771,11 @@\n         }\n         if (strLen > size) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = thisBuf.length - strLen;\n+int len = i - strLen;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n                     continue outer;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int len = thisBuf.length - startIndex;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-61/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 19:19:07.922929500 +0200\n+++ /tmp/tmp11bqx5yq.java\t2022-07-19 19:19:07.922929500 +0200\n@@ -1771,11 +1771,11 @@\n         }\n         if (strLen > size) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = thisBuf.length - strLen;\n+int len = thisBuf.length - startIndex;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n                     continue outer;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int len = startIndex - thisBuf.length;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-61/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 19:19:17.182881655 +0200\n+++ /tmp/tmpgmj9om3p.java\t2022-07-19 19:19:17.182881655 +0200\n@@ -1771,11 +1771,11 @@\n         }\n         if (strLen > size) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = thisBuf.length - strLen;\n+int len = startIndex - thisBuf.length;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n                     continue outer;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int len = buffer.length - thisBuf.length;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-61/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 19:19:26.598833005 +0200\n+++ /tmp/tmp6jk9lkhi.java\t2022-07-19 19:19:26.602832984 +0200\n@@ -1771,11 +1771,11 @@\n         }\n         if (strLen > size) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = thisBuf.length - strLen;\n+int len = buffer.length - thisBuf.length;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n                     continue outer;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "int len = thisBuf.length - strLen;",
        "fixed_line": "int len = size - strLen + 1;"
    },
    "Mockito-20": {
        "fixes": [
            {
                "k": 1,
                "patch": "mockInstance = classInstantiator.instantiateiate(mockedInstance : classInstantiator.MockAccess; mockAccess = classInstantiator.getClass().getSimpleName(),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-20/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\t2022-07-19 19:19:36.062784106 +0200\n+++ /tmp/tmp0onz9hgx.java\t2022-07-19 19:19:36.106783880 +0200\n@@ -29,22 +29,11 @@\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+mockInstance = classInstantiator.instantiateiate(mockedInstance : classInstantiator.MockAccess; mockAccess = classInstantiator.getClass().getSimpleName(),\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n             ),cce);\n         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "mockInstance = classInstantiator.instantiate(mockedInstance : classInstantiator.MockAccess; mockAccess = classInstantiator.getClass().getSimpleName(),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-20/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\t2022-07-19 19:19:49.118716650 +0200\n+++ /tmp/tmpvfz0mhok.java\t2022-07-19 19:19:49.118716650 +0200\n@@ -29,22 +29,11 @@\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+mockInstance = classInstantiator.instantiate(mockedInstance : classInstantiator.MockAccess; mockAccess = classInstantiator.getClass().getSimpleName(),\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n             ),cce);\n         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "mockInstance = classInstantiator.instantiateiate(class : classInstantiator.MockAccess = classInstantiator.getClass().getSimpleName(),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-20/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\t2022-07-19 19:19:56.750677218 +0200\n+++ /tmp/tmp_h7qgapr.java\t2022-07-19 19:19:56.750677218 +0200\n@@ -29,22 +29,11 @@\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+mockInstance = classInstantiator.instantiateiate(class : classInstantiator.MockAccess = classInstantiator.getClass().getSimpleName(),\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n             ),cce);\n         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "mockInstance = classInstantiator.instantiateiate(class : classInstantiator.MockAccess; mockAccess = classInstantiator.getClass().getSimpleName(),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-20/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\t2022-07-19 19:20:04.414637622 +0200\n+++ /tmp/tmpky4aurrk.java\t2022-07-19 19:20:04.486637249 +0200\n@@ -29,22 +29,11 @@\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+mockInstance = classInstantiator.instantiateiate(class : classInstantiator.MockAccess; mockAccess = classInstantiator.getClass().getSimpleName(),\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n             ),cce);\n         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "mockInstance = classInstantiator.instantiate; mockAccess = classInstantiator.MockAccess;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-20/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\t2022-07-19 19:20:12.182597485 +0200\n+++ /tmp/tmp4yefcv1i.java\t2022-07-19 19:20:12.186597467 +0200\n@@ -29,22 +29,11 @@\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+mockInstance = classInstantiator.instantiate; mockAccess = classInstantiator.MockAccess;\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n             ),cce);\n         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "mockInstance = classInstantiator.instantiateiate; mockAccess = classInstantiator.MockAccess;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-20/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\t2022-07-19 19:20:19.910557559 +0200\n+++ /tmp/tmpf049snw5.java\t2022-07-19 19:20:19.910557559 +0200\n@@ -29,22 +29,11 @@\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+mockInstance = classInstantiator.instantiateiate; mockAccess = classInstantiator.MockAccess;\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n             ),cce);\n         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "mockInstance = classInstantiator.instantiate(class : classInstantiator.MockAccess; mockAccess = classInstantiator.getClass().getSimpleName(),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-20/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\t2022-07-19 19:20:27.626517695 +0200\n+++ /tmp/tmpv3nh4iuy.java\t2022-07-19 19:20:27.626517695 +0200\n@@ -29,22 +29,11 @@\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+mockInstance = classInstantiator.instantiate(class : classInstantiator.MockAccess; mockAccess = classInstantiator.getClass().getSimpleName(),\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n             ),cce);\n         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "mockInstance = classInstantiator.instantiate(mockedProxyType).getMockAccess = classInstantiator.getClass().getSimpleName(),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-20/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\t2022-07-19 19:20:35.362477727 +0200\n+++ /tmp/tmpzdxidfai.java\t2022-07-19 19:20:35.362477727 +0200\n@@ -29,22 +29,11 @@\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+mockInstance = classInstantiator.instantiate(mockedProxyType).getMockAccess = classInstantiator.getClass().getSimpleName(),\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n             ),cce);\n         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "mockInstance = classInstantiator.instantiate(class : classInstantiator.MockAccess = classInstantiator.getClass().getSimpleName(),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-20/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\t2022-07-19 19:20:43.106437718 +0200\n+++ /tmp/tmpk8kih03e.java\t2022-07-19 19:20:43.106437718 +0200\n@@ -29,22 +29,11 @@\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+mockInstance = classInstantiator.instantiate(class : classInstantiator.MockAccess = classInstantiator.getClass().getSimpleName(),\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n             ),cce);\n         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "mockInstance = classInstantiator.instantiateiate(mockedProxyType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-20/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\t2022-07-19 19:20:50.814397894 +0200\n+++ /tmp/tmpmkeva6c7.java\t2022-07-19 19:20:50.814397894 +0200\n@@ -29,22 +29,11 @@\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+mockInstance = classInstantiator.instantiateiate(mockedProxyType);\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n             ),cce);\n         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "mockInstance = classInstantiator.instantiate(mockedProxyType); MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance; mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings)); return ensureMockIsAssignableToMockedType(settings, mockInstance); } catch (ClassCastException cce) { throw new MockitoException(join( \"ClassCastException occurred while creating the mockito mock :\", \" class to mock : \" + describeClass(mockedProxyType), \" created class : \" + describeClass(settings.getTypeToMock()), \" proxy instance class : \" + describeClass(mockInstance), \" instance creation by : \" + classInstantiator.getClass().getSimpleName(),",
        "fixed_line": "Instantiator instantiator = new InstantiatorProvider().getInstantiator(settings); T mockInstance = null; try { mockInstance = instantiator.newInstance(mockedProxyType); MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance; mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings)); return ensureMockIsAssignableToMockedType(settings, mockInstance); } catch (ClassCastException cce) { throw new MockitoException(join( \"ClassCastException occurred while creating the mockito mock :\", \" class to mock : \" + describeClass(mockedProxyType), \" created class : \" + describeClass(settings.getTypeToMock()), \" proxy instance class : \" + describeClass(mockInstance), \" instance creation by : \" + instantiator.getClass().getSimpleName(),"
    },
    "JacksonDatabind-1": {
        "fixes": [
            {
                "k": 1,
                "patch": "// can NOT suppress entries in tabular output jgen.writeNull(); // can NOT suppress entries in tabular output",
                "patch_diff": "// can NOT suppress entries in tabular output jgen.writeNull(); // can NOT suppress entries in tabular output",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// can NOT suppress entries in tabular output jgen.writeNull(); }",
                "patch_diff": "// can NOT suppress entries in tabular output jgen.writeNull(); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// can NOT suppress entries in tabular output",
                "patch_diff": "// can NOT suppress entries in tabular output",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// can NOT suppress entries in tabular output jgen.writeNull();",
                "patch_diff": "// can NOT suppress entries in tabular output jgen.writeNull();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// can NOT suppress entries in tabular output jgen.writeNull(); } else { // can NOT suppress entries in tabular output",
                "patch_diff": "// can NOT suppress entries in tabular output jgen.writeNull(); } else { // can NOT suppress entries in tabular output",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// can NOT suppress entries in tabular output jgen = _nullSerializer; if (ser == null) { // can NOT suppress entries in tabular output",
                "patch_diff": "// can NOT suppress entries in tabular output jgen = _nullSerializer; if (ser == null) { // can NOT suppress entries in tabular output",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// can NOT suppress entries in tabular output jgen.writeNull(); } else if (ser == null) { // can NOT suppress entries in tabular output",
                "patch_diff": "// can NOT suppress entries in tabular output jgen.writeNull(); } else if (ser == null) { // can NOT suppress entries in tabular output",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// can NOT suppress entries in tabular output jgen, prov);",
                "patch_diff": "// can NOT suppress entries in tabular output jgen, prov);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// can NOT suppress entries in tabular output jgen = _nullSerializer.serialize(value, jgen, prov);",
                "patch_diff": "// can NOT suppress entries in tabular output jgen = _nullSerializer.serialize(value, jgen, prov);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// can NOT suppress entries in tabular output jgen = _nullSerializer;",
                "patch_diff": "// can NOT suppress entries in tabular output jgen = _nullSerializer;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "return;"
    },
    "Closure-61": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (parent.hasRegExpGlobalReferences() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property nameNode.",
                "patch_diff": "if (parent.hasRegExpGlobalReferences() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property nameNode.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (parent.hasRegExpGlobalReferences() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property-nameNode.",
                "patch_diff": "if (parent.hasRegExpGlobalReferences() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property-nameNode.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (parent.hasRegExpGlobalReferences() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP && // Make sure that we're not handling object literals being // assigned to check whether a prototype, as per RFC 46 property nameNode.",
                "patch_diff": "if (parent.hasRegExpGlobalReferences() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP && // Make sure that we're not handling object literals being // assigned to check whether a prototype, as per RFC 46 property nameNode.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (parent.hasRegExpGlobalReferences() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP && parent.getFirstChild().getType() == Token.REGEXP && parent.getFirstChild().getString().equals(nameNode.getFirstChild().getString())) {",
                "patch_diff": "if (parent.hasRegExpGlobalReferences() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP && parent.getFirstChild().getType() == Token.REGEXP && parent.getFirstChild().getString().equals(nameNode.getFirstChild().getString())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (parent.hasRegExpGlobalReferences() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP && parent.getFirstChild().getString().equals(nameNode.getFirstChild())) {",
                "patch_diff": "if (parent.hasRegExpGlobalReferences() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP && parent.getFirstChild().getString().equals(nameNode.getFirstChild())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (parent.hasRegExpGlobalReferences() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP && parent.getFirstChild().getString().equals(nameNode.getFirstChild().getString())) {",
                "patch_diff": "if (parent.hasRegExpGlobalReferences() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP && parent.getFirstChild().getString().equals(nameNode.getFirstChild().getString())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (parent.hasRegExpGlobalReferences() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP && parent.getFirstChild().getType() == Token.REGEXP;",
                "patch_diff": "if (parent.hasRegExpGlobalReferences() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP && parent.getFirstChild().getType() == Token.REGEXP;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (parent.hasRegExpGlobalReferences() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP && parent.getFirstChild().getType() == Token.REGEXP && parent.getFirstChild().getType() == Token.REGEXP;",
                "patch_diff": "if (parent.hasRegExpGlobalReferences() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP && parent.getFirstChild().getType() == Token.REGEXP && parent.getFirstChild().getType() == Token.REGEXP;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (parent.hasRegExpGlobalReferences() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP && parent.getFirstChild().getType() == Token.REGEXP && parent.getFirstChild().getString().equals(nameNode.getFirstChild())) {",
                "patch_diff": "if (parent.hasRegExpGlobalReferences() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP && parent.getFirstChild().getType() == Token.REGEXP && parent.getFirstChild().getString().equals(nameNode.getFirstChild())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (parent.hasRegExpGlobalReferences() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP && parent.getFirstChild().getType() == Token.REGEXP && parent.getFirstChild().getString().equals(nameNode.getFirstChild().getType() == Token.REGEXP;",
                "patch_diff": "if (parent.hasRegExpGlobalReferences() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP && parent.getFirstChild().getType() == Token.REGEXP && parent.getFirstChild().getString().equals(nameNode.getFirstChild().getType() == Token.REGEXP;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (nameNode.getFirstChild().getType() == Token.NAME) { String namespaceName = nameNode.getFirstChild().getString(); if (namespaceName.equals(\"Math\")) { return false; } }"
    },
    "Gson-6": {
        "fixes": [
            {
                "k": 1,
                "patch": "TypeAdapter or TypeAdapter = typeAdapter; }",
                "patch_diff": "TypeAdapter or TypeAdapter = typeAdapter; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "TypeAdapter or TypeAdapter typeAdapter = typeAdapter; }",
                "patch_diff": "TypeAdapter or TypeAdapter typeAdapter = typeAdapter; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "TypeAdapter or TypeAdapter = typeAdapter.nullSafe; }",
                "patch_diff": "TypeAdapter or TypeAdapter = typeAdapter.nullSafe; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "TypeAdapter or TypeAdapter typeAdapter = typeAdapter.nullSafe; }",
                "patch_diff": "TypeAdapter or TypeAdapter typeAdapter = typeAdapter.nullSafe; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "TypeAdapter or TypeAdapter or TypeAdapter typeAdapter = typeAdapter; }",
                "patch_diff": "TypeAdapter or TypeAdapter or TypeAdapter typeAdapter = typeAdapter; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "TypeAdapter or TypeAdapter typeAdapter = new TypeAdapter(typeAdapter; }",
                "patch_diff": "TypeAdapter or TypeAdapter typeAdapter = new TypeAdapter(typeAdapter; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "TypeAdapter or TypeAdapter or TypeAdapter typeAdapter = typeAdapter.nullSafe; }",
                "patch_diff": "TypeAdapter or TypeAdapter or TypeAdapter typeAdapter = typeAdapter.nullSafe; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "TypeAdapter or TypeAdapter or TypeAdapter = typeAdapter.nullSafe; }",
                "patch_diff": "TypeAdapter or TypeAdapter or TypeAdapter = typeAdapter.nullSafe; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "TypeAdapter typeAdapter = new TypeAdapter(typeAdapter; }",
                "patch_diff": "TypeAdapter typeAdapter = new TypeAdapter(typeAdapter; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "TypeAdapter or TypeAdapter or TypeAdapter = typeAdapter; }",
                "patch_diff": "TypeAdapter or TypeAdapter or TypeAdapter = typeAdapter; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (typeAdapter != null) { typeAdapter = typeAdapter.nullSafe(); }"
    },
    "Math-73": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (yInitial * y, initial, max, yInitial);",
                "patch_diff": "if (yInitial * y, initial, max, yInitial);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (yInitial * yInitial, initial, max, yInitial);",
                "patch_diff": "if (yInitial * yInitial, initial, max, yInitial);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (yInitial * y, initial, max, yInitial); }",
                "patch_diff": "if (yInitial * y, initial, max, yInitial); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (yInitial * y, initial, max, yInitial);",
                "patch_diff": "} else if (yInitial * y, initial, max, yInitial);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (yInitial * yInitial, initial, yInitial);",
                "patch_diff": "if (yInitial * yInitial, initial, yInitial);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (yInitial * yInitial, initial, max, yInitial); }",
                "patch_diff": "if (yInitial * yInitial, initial, max, yInitial); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (yInitial * yMax, initial, max, yInitial);",
                "patch_diff": "if (yInitial * yMax, initial, max, yInitial);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (yInitial * yMax, initial, max, yInitial); }",
                "patch_diff": "if (yInitial * yMax, initial, max, yInitial); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (yInitial * yInitial, initial, yInitial); }",
                "patch_diff": "if (yInitial * yInitial, initial, yInitial); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (yInitial * yLow, initial, max, yInitial); }",
                "patch_diff": "if (yInitial * yLow, initial, max, yInitial); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (yMin * yMax > 0) { throw MathRuntimeException.createIllegalArgumentException( NON_BRACKETING_MESSAGE, min, max, yMin, yMax); }"
    },
    "JacksonDatabind-106": {
        "fixes": [
            {
                "k": 1,
                "patch": "int getIntValue = (NumericNode) currentNumericNode;",
                "patch_diff": "int getIntValue = (NumericNode) currentNumericNode;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (NumericNode node = (NumericNode) currentNumericNode;",
                "patch_diff": "for (NumericNode node = (NumericNode) currentNumericNode;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// int getIntValue = (NumericNode) currentNumericNode;",
                "patch_diff": "// int getIntValue = (NumericNode) currentNumericNode;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (intintValue = 0; currentNumericNode) currentNumericNode;",
                "patch_diff": "for (intintValue = 0; currentNumericNode) currentNumericNode;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = 0; i < currentNumericNode; i++) { if (node.longValue() == null) { currentNumericNode = (NumericNode) currentNumericNode; } }",
                "patch_diff": "for (int i = 0; i < currentNumericNode; i++) { if (node.longValue() == null) { currentNumericNode = (NumericNode) currentNumericNode; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = 0; i < currentNumericNode; i++) { if (node.longValue() == null) { return node.longValue(); } }",
                "patch_diff": "for (int i = 0; i < currentNumericNode; i++) { if (node.longValue() == null) { return node.longValue(); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = 0; i < currentNumericNode; i++) { if (node.longValue() == null) { currentNumericNode = (NumericNode) currentNumericNode.longValue(); } }",
                "patch_diff": "for (int i = 0; i < currentNumericNode; i++) { if (node.longValue() == null) { currentNumericNode = (NumericNode) currentNumericNode.longValue(); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int getIntValue = (NumericNode) currentNumericNode.longValue();",
                "patch_diff": "int getIntValue = (NumericNode) currentNumericNode.longValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int i = 0; i < currentNumericNode; i++) { if (node.longValue() == null) { return node.intValue(); } }",
                "patch_diff": "for (int i = 0; i < currentNumericNode; i++) { if (node.longValue() == null) { return node.intValue(); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = 0; i < currentNumericNode; i++) { if (node.longValue() == null) { return node.longValue(); } } }",
                "patch_diff": "for (int i = 0; i < currentNumericNode; i++) { if (node.longValue() == null) { return node.longValue(); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (!node.canConvertToInt()) { reportOverflowInt(); } return node.intValue(); } @Override public long getLongValue() throws IOException { final NumericNode node = (NumericNode) currentNumericNode(); if (!node.canConvertToInt()) { reportOverflowLong(); }"
    },
    "Cli-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "String stripLeadingHyphens(str.startsWith(\"--\")) { return str.substring(2, str.length()); }",
                "patch_diff": "String stripLeadingHyphens(str.startsWith(\"--\")) { return str.substring(2, str.length()); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "String stripLeadingHyphens(str.startsWith(\"--\")) {",
                "patch_diff": "String stripLeadingHyphens(str.startsWith(\"--\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "String stripLeadingHyphens(str.startsWith(\"--\")) { return str; }",
                "patch_diff": "String stripLeadingHyphens(str.startsWith(\"--\")) { return str; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return str.startsWith(\"--\")) { return str.substring(2, str.length()); }",
                "patch_diff": "return str.startsWith(\"--\")) { return str.substring(2, str.length()); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "String str = str.startsWith(\"--\")) { return str.substring(2, str.length()); }",
                "patch_diff": "String str = str.startsWith(\"--\")) { return str.substring(2, str.length()); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "String stripLeadingHyphens = str.startsWith(\"--\")) { return str.substring(2, str.length()); }",
                "patch_diff": "String stripLeadingHyphens = str.startsWith(\"--\")) { return str.substring(2, str.length()); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "String stripLeadingHyphens.startsWith(\"--\")) { return str.substring(2, str.length()); }",
                "patch_diff": "String stripLeadingHyphens.startsWith(\"--\")) { return str.substring(2, str.length()); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "String stripLeadingHyphens = str.startsWith(\"--\")) {",
                "patch_diff": "String stripLeadingHyphens = str.startsWith(\"--\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (str.startsWith(\"--\")) { return str.substring(2, str.length()); }",
                "patch_diff": "if (str.startsWith(\"--\")) { return str.substring(2, str.length()); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (str.startsWith(\"--\")) { return str.substring(2, str.length()); }",
                "patch_diff": "} else if (str.startsWith(\"--\")) { return str.substring(2, str.length()); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (str == null) { return null; }"
    },
    "Mockito-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if (wanted == null || generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; if (actual instanceof Type) {",
                "patch_diff": "// if (wanted == null || generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; if (actual instanceof Type) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// if (wanted == null || generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic).getActualTypeArguments()[0]; }",
                "patch_diff": "// if (wanted == null || generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic).getActualTypeArguments()[0]; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if (wanted == null || generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic; }",
                "patch_diff": "// if (wanted == null || generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// if (wanted == null || generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; if (actualType instanceof Type) {",
                "patch_diff": "// if (wanted == null || generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; if (actualType instanceof Type) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// if (wanted == null || generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; if (actualType instanceof ParameterizedType) {",
                "patch_diff": "// if (wanted == null || generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; if (actualType instanceof ParameterizedType) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if (actual == null || generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; if (actual instanceof Type) {",
                "patch_diff": "// if (actual == null || generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; if (actual instanceof Type) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// if (wanted == null || generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic).getActualTypeArguments()[0]; } else if (wanted instanceof Type) {",
                "patch_diff": "// if (wanted == null || generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic).getActualTypeArguments()[0]; } else if (wanted instanceof Type) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// if (actual == null || generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; if (actualType instanceof Type) {",
                "patch_diff": "// if (actual == null || generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; if (actualType instanceof Type) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// if (actual == null || generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic; }",
                "patch_diff": "// if (actual == null || generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// } else if (wanted instanceof ParameterizedType && generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic).getActualTypeArguments()[0]; } else if (wanted instanceof Type) {",
                "patch_diff": "// } else if (wanted instanceof ParameterizedType && generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic).getActualTypeArguments()[0]; } else if (wanted instanceof Type) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (actual instanceof Class) { return (Class) actual; } else if (actual instanceof ParameterizedType) { //in case of nested generics we don't go deep return (Class) ((ParameterizedType) actual).getRawType(); }"
    },
    "Closure-18": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (options.instance && options.closurePass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-18/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 19:21:11.654290224 +0200\n+++ /tmp/tmp4s0bwom5.java\t2022-07-19 19:21:11.718289899 +0200\n@@ -1283,11 +1283,11 @@\n \n       hoistExterns(externsRoot);\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+if (options.instance && options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n             getTypeRegistry().forwardDeclareType(provide);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (options.removeRequire && options.closurePass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-18/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 19:21:16.854263361 +0200\n+++ /tmp/tmpaed7z0t8.java\t2022-07-19 19:21:16.854263361 +0200\n@@ -1283,11 +1283,11 @@\n \n       hoistExterns(externsRoot);\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+if (options.removeRequire && options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n             getTypeRegistry().forwardDeclareType(provide);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (options.remove /* declared iff there'sRoot.closurePass && options.closurePass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-18/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 19:21:20.838242778 +0200\n+++ /tmp/tmp8ng33zxu.java\t2022-07-19 19:21:20.838242778 +0200\n@@ -1283,11 +1283,11 @@\n \n       hoistExterns(externsRoot);\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+if (options.remove /* declared iff there'sRoot.closurePass && options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n             getTypeRegistry().forwardDeclareType(provide);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (options.remove /* declared iff there'sRoot || options.closurePass && options.closurePass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-18/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 19:21:24.330224735 +0200\n+++ /tmp/tmpvbrj2gkr.java\t2022-07-19 19:21:24.334224717 +0200\n@@ -1283,11 +1283,11 @@\n \n       hoistExterns(externsRoot);\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+if (options.remove /* declared iff there'sRoot || options.closurePass && options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n             getTypeRegistry().forwardDeclareType(provide);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (options. version || options.closurePass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-18/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 19:21:27.910206242 +0200\n+++ /tmp/tmpe96zbj3l.java\t2022-07-19 19:21:27.910206242 +0200\n@@ -1283,11 +1283,11 @@\n \n       hoistExterns(externsRoot);\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+if (options. version || options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n             getTypeRegistry().forwardDeclareType(provide);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (options.remove /* declared iff there'sRoot || options.closurePass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-18/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 19:21:31.834185969 +0200\n+++ /tmp/tmpwfm7vlct.java\t2022-07-19 19:21:31.838185946 +0200\n@@ -1283,11 +1283,11 @@\n \n       hoistExterns(externsRoot);\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+if (options.remove /* declared iff there'sRoot || options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n             getTypeRegistry().forwardDeclareType(provide);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (options.PopOptions && options.closurePass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-18/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 19:21:35.514166956 +0200\n+++ /tmp/tmpwvemkbdl.java\t2022-07-19 19:21:35.514166956 +0200\n@@ -1283,11 +1283,11 @@\n \n       hoistExterns(externsRoot);\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+if (options.PopOptions && options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n             getTypeRegistry().forwardDeclareType(provide);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (options.okOptions || options.closurePass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-18/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 19:21:39.818144721 +0200\n+++ /tmp/tmpds0k957u.java\t2022-07-19 19:21:39.822144700 +0200\n@@ -1283,11 +1283,11 @@\n \n       hoistExterns(externsRoot);\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+if (options.okOptions || options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n             getTypeRegistry().forwardDeclareType(provide);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (options.PopOptions || options.closurePass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-18/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 19:21:45.338116203 +0200\n+++ /tmp/tmpvgiu7d8f.java\t2022-07-19 19:21:45.342116182 +0200\n@@ -1283,11 +1283,11 @@\n \n       hoistExterns(externsRoot);\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+if (options.PopOptions || options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n             getTypeRegistry().forwardDeclareType(provide);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (options.OutlineOptions || options.closurePass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-18/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 19:21:50.414089979 +0200\n+++ /tmp/tmpjgd2ot5t.java\t2022-07-19 19:21:50.418089956 +0200\n@@ -1283,11 +1283,11 @@\n \n       hoistExterns(externsRoot);\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+if (options.OutlineOptions || options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n             getTypeRegistry().forwardDeclareType(provide);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (options.dependencyOptions.needsManagement() && options.closurePass) {",
        "fixed_line": "if (options.dependencyOptions.needsManagement()) {"
    },
    "Closure-102": {
        "fixes": [
            {
                "k": 1,
                "patch": "removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-102/src/com/google/javascript/jscomp/Normalize.java\t2022-07-19 19:21:55.970061272 +0200\n+++ /tmp/tmpdac8drsw.java\t2022-07-19 19:21:56.262059768 +0200\n@@ -89,11 +89,11 @@\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n+removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n \n   @Override\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-102/src/com/google/javascript/jscomp/Normalize.java\t2022-07-19 19:22:00.214039350 +0200\n+++ /tmp/tmpp4s6u7il.java\t2022-07-19 19:22:00.214039350 +0200\n@@ -89,11 +89,11 @@\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n+removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n \n   @Override\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-102/src/com/google/javascript/jscomp/Normalize.java\t2022-07-19 19:22:02.770026145 +0200\n+++ /tmp/tmpf_y1agg9.java\t2022-07-19 19:22:02.818025895 +0200\n@@ -89,11 +89,11 @@\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n+removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n \n   @Override\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-102/src/com/google/javascript/jscomp/Normalize.java\t2022-07-19 19:22:05.458012258 +0200\n+++ /tmp/tmpdo1c3wl7.java\t2022-07-19 19:22:05.462012237 +0200\n@@ -89,11 +89,11 @@\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n+removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n \n   @Override\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-102/src/com/google/javascript/jscomp/Normalize.java\t2022-07-19 19:22:08.021999012 +0200\n+++ /tmp/tmpyg9_lgvu.java\t2022-07-19 19:22:08.073998742 +0200\n@@ -89,11 +89,11 @@\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n+removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n \n   @Override\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-102/src/com/google/javascript/jscomp/Normalize.java\t2022-07-19 19:22:10.821984546 +0200\n+++ /tmp/tmpb3c99by7.java\t2022-07-19 19:22:10.821984546 +0200\n@@ -89,11 +89,11 @@\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n+removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n \n   @Override\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-102/src/com/google/javascript/jscomp/Normalize.java\t2022-07-19 19:22:13.493970742 +0200\n+++ /tmp/tmpxchs75gl.java\t2022-07-19 19:22:13.533970536 +0200\n@@ -89,11 +89,11 @@\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n+removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n \n   @Override\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-102/src/com/google/javascript/jscomp/Normalize.java\t2022-07-19 19:22:16.237956566 +0200\n+++ /tmp/tmps2ewiy3t.java\t2022-07-19 19:22:16.241956545 +0200\n@@ -89,11 +89,11 @@\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n+removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n \n   @Override\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-102/src/com/google/javascript/jscomp/Normalize.java\t2022-07-19 19:22:18.773943464 +0200\n+++ /tmp/tmpcsoh17i1.java\t2022-07-19 19:22:18.801943320 +0200\n@@ -89,11 +89,11 @@\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n+removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n \n   @Override\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-102/src/com/google/javascript/jscomp/Normalize.java\t2022-07-19 19:22:21.397929909 +0200\n+++ /tmp/tmptusv1hve.java\t2022-07-19 19:22:21.397929909 +0200\n@@ -89,11 +89,11 @@\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n+removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n \n   @Override\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "removeDuplicateDeclarations(root);",
        "fixed_line": "removeDuplicateDeclarations(root);"
    },
    "Lang-55": {
        "fixes": [
            {
                "k": 1,
                "patch": "this.runningState!= STATE_RUNNING && this.runningState!= STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); }",
                "patch_diff": "this.runningState!= STATE_RUNNING && this.runningState!= STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if(this.runningState!= STATE_RUNNING && this.runningState!= STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); }",
                "patch_diff": "if(this.runningState!= STATE_RUNNING && this.runningState!= STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "this.runningState!= STATE_RUNNING && this.runningState!= STATE_SUSPENDED; }",
                "patch_diff": "this.runningState!= STATE_RUNNING && this.runningState!= STATE_SUSPENDED; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "this.runningState!= STATE_RUNNING && this.runningState!= STATE_SUSPENDED;",
                "patch_diff": "this.runningState!= STATE_RUNNING && this.runningState!= STATE_SUSPENDED;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "this.runningState!= STATE_RUNNING && this.runningState!= STATE_SUSPENDED) {",
                "patch_diff": "this.runningState!= STATE_RUNNING && this.runningState!= STATE_SUSPENDED) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "this.runningState!= STATE_RUNNING && this.runningState!= STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); }",
                "patch_diff": "this.runningState!= STATE_RUNNING && this.runningState!= STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "this.runningState!= STATE_RUNNING && this.runningState!= STATE_SUSPENDED; }",
                "patch_diff": "this.runningState!= STATE_RUNNING && this.runningState!= STATE_SUSPENDED; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "this.runningState!= STATE_RUNNING && this.runningState!= STATE_UNSTARTED) { throw new IllegalStateException(\"Stopwatch is not running. \"); }",
                "patch_diff": "this.runningState!= STATE_RUNNING && this.runningState!= STATE_UNSTARTED) { throw new IllegalStateException(\"Stopwatch is not running. \"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "this.runningState!= STATE_RUNNING && this.runningState!= STATE_SUSPENDED) {",
                "patch_diff": "this.runningState!= STATE_RUNNING && this.runningState!= STATE_SUSPENDED) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if(this.runningState!= STATE_RUNNING && this.runningState!= STATE_SUSPENDED) {",
                "patch_diff": "if(this.runningState!= STATE_RUNNING && this.runningState!= STATE_SUSPENDED) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if(this.runningState == STATE_RUNNING) { stopTime = System.currentTimeMillis(); }"
    },
    "JacksonCore-20": {
        "fixes": [
            {
                "k": 1,
                "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", LEAPPROTOTYPE_INTERFACES;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-20/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\t2022-07-19 19:22:26.325904448 +0200\n+++ /tmp/tmpgrue4xza.java\t2022-07-19 19:22:26.673902652 +0200\n@@ -1325,11 +1325,11 @@\n      *\n      * @since 2.8\n      */\n     public void writeEmbeddedObject(Object object) throws IOException {\n         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n-        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n+throw new JsonGenerationException(\"No native support for writing embedded objects\", LEAPPROTOTYPE_INTERFACES;\n                 this);\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", LEAPPROTOTYPE_MEMBERS;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-20/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\t2022-07-19 19:22:28.805891637 +0200\n+++ /tmp/tmpsruti0c5.java\t2022-07-19 19:22:28.805891637 +0200\n@@ -1325,11 +1325,11 @@\n      *\n      * @since 2.8\n      */\n     public void writeEmbeddedObject(Object object) throws IOException {\n         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n-        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n+throw new JsonGenerationException(\"No native support for writing embedded objects\", LEAPPROTOTYPE_MEMBERS;\n                 this);\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", LEAPPROTOTYPE_EMPTY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-20/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\t2022-07-19 19:22:30.697881863 +0200\n+++ /tmp/tmp602zef_m.java\t2022-07-19 19:22:30.697881863 +0200\n@@ -1325,11 +1325,11 @@\n      *\n      * @since 2.8\n      */\n     public void writeEmbeddedObject(Object object) throws IOException {\n         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n-        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n+throw new JsonGenerationException(\"No native support for writing embedded objects\", LEAPPROTOTYPE_EMPTY;\n                 this);\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", LEAPPROTOTYPE_NON_OBJECT;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-20/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\t2022-07-19 19:22:32.941870271 +0200\n+++ /tmp/tmp_osoam1q.java\t2022-07-19 19:22:32.945870250 +0200\n@@ -1325,11 +1325,11 @@\n      *\n      * @since 2.8\n      */\n     public void writeEmbeddedObject(Object object) throws IOException {\n         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n-        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n+throw new JsonGenerationException(\"No native support for writing embedded objects\", LEAPPROTOTYPE_NON_OBJECT;\n                 this);\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-20/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\t2022-07-19 19:22:35.021859524 +0200\n+++ /tmp/tmpxz_w5_mw.java\t2022-07-19 19:22:35.025859504 +0200\n@@ -1325,11 +1325,11 @@\n      *\n      * @since 2.8\n      */\n     public void writeEmbeddedObject(Object object) throws IOException {\n         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n-        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n+throw new JsonGenerationException(\"No native support for writing embedded objects\", 1);\n                 this);\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", // object (tatu:",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-20/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\t2022-07-19 19:22:37.689845740 +0200\n+++ /tmp/tmp067zk_66.java\t2022-07-19 19:22:37.693845721 +0200\n@@ -1325,11 +1325,11 @@\n      *\n      * @since 2.8\n      */\n     public void writeEmbeddedObject(Object object) throws IOException {\n         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n-        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n+throw new JsonGenerationException(\"No native support for writing embedded objects\", // object (tatu:\n                 this);\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", FIX;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-20/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\t2022-07-19 19:22:49.649783954 +0200\n+++ /tmp/tmpj8qqzp21.java\t2022-07-19 19:22:49.665783871 +0200\n@@ -1325,11 +1325,11 @@\n      *\n      * @since 2.8\n      */\n     public void writeEmbeddedObject(Object object) throws IOException {\n         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n-        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n+throw new JsonGenerationException(\"No native support for writing embedded objects\", FIX;\n                 this);\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", member;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-20/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\t2022-07-19 19:22:52.345770026 +0200\n+++ /tmp/tmpl1dyb8po.java\t2022-07-19 19:22:52.345770026 +0200\n@@ -1325,11 +1325,11 @@\n      *\n      * @since 2.8\n      */\n     public void writeEmbeddedObject(Object object) throws IOException {\n         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n-        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n+throw new JsonGenerationException(\"No native support for writing embedded objects\", member;\n                 this);\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", last;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-20/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\t2022-07-19 19:22:54.753757586 +0200\n+++ /tmp/tmpfc072q9s.java\t2022-07-19 19:22:54.773757482 +0200\n@@ -1325,11 +1325,11 @@\n      *\n      * @since 2.8\n      */\n     public void writeEmbeddedObject(Object object) throws IOException {\n         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n-        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n+throw new JsonGenerationException(\"No native support for writing embedded objects\", last;\n                 this);\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", LEAPPROTOTYPE_WITH;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-20/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\t2022-07-19 19:22:57.513743328 +0200\n+++ /tmp/tmp5greqwwn.java\t2022-07-19 19:22:57.513743328 +0200\n@@ -1325,11 +1325,11 @@\n      *\n      * @since 2.8\n      */\n     public void writeEmbeddedObject(Object object) throws IOException {\n         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n-        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n+throw new JsonGenerationException(\"No native support for writing embedded objects\", LEAPPROTOTYPE_WITH;\n                 this);\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "throw new JsonGenerationException(\"No native support for writing embedded objects\",",
        "fixed_line": "if (object == null) { writeNull(); return; } if (object instanceof byte[]) { writeBinary((byte[]) object); return; } throw new JsonGenerationException(\"No native support for writing embedded objects of type \" +object.getClass().getName(),"
    },
    "JacksonCore-6": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int i = 0; i < len; ++i) { char c = str.charAt(i;i; ++i; ++i)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-6/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 19:23:00.217729359 +0200\n+++ /tmp/tmp6pr2355f.java\t2022-07-19 19:23:00.489727956 +0200\n@@ -188,12 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         // [core#176]: no leading zeroes allowed\n-        for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i);\n+for (int i = 0; i < len; ++i) { char c = str.charAt(i;i; ++i; ++i)\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = 0; i < len; ++i) { char c = str.charAt(i);i; ++i; ++i)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-6/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 19:23:03.201713943 +0200\n+++ /tmp/tmpumbtdr5e.java\t2022-07-19 19:23:03.201713943 +0200\n@@ -188,12 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         // [core#176]: no leading zeroes allowed\n-        for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i);\n+for (int i = 0; i < len; ++i) { char c = str.charAt(i);i; ++i; ++i)\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0; i < len; ++i) { char c = str.charAt(i;i; ++i)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-6/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 19:23:05.345702867 +0200\n+++ /tmp/tmpt76rwf3w.java\t2022-07-19 19:23:05.345702867 +0200\n@@ -188,12 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         // [core#176]: no leading zeroes allowed\n-        for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i);\n+for (int i = 0; i < len; ++i) { char c = str.charAt(i;i; ++i)\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = 0; i < len; ++i) { char c = str.charAt(i;i;i; ++i)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-6/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 19:23:08.321687494 +0200\n+++ /tmp/tmpts7j7_le.java\t2022-07-19 19:23:08.321687494 +0200\n@@ -188,12 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         // [core#176]: no leading zeroes allowed\n-        for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i);\n+for (int i = 0; i < len; ++i) { char c = str.charAt(i;i;i; ++i)\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = 0; i < len; ++i) { char c = str.charAt(i;i);i; ++i)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-6/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 19:23:10.389676809 +0200\n+++ /tmp/tmp44pu1znb.java\t2022-07-19 19:23:10.393676790 +0200\n@@ -188,12 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         // [core#176]: no leading zeroes allowed\n-        for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i);\n+for (int i = 0; i < len; ++i) { char c = str.charAt(i;i);i; ++i)\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = 0; i < len; ++i) { char c = str.charAt(i;i;i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-6/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 19:23:13.273661911 +0200\n+++ /tmp/tmp23fh8we3.java\t2022-07-19 19:23:13.273661911 +0200\n@@ -188,12 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         // [core#176]: no leading zeroes allowed\n-        for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i);\n+for (int i = 0; i < len; ++i) { char c = str.charAt(i;i;i++) {\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = 0; i < len; ++i) { char c = str.charAt(i;i; ++i; ++i; ++i)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-6/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 19:23:16.093647342 +0200\n+++ /tmp/tmpszjodvnf.java\t2022-07-19 19:23:16.097647321 +0200\n@@ -188,12 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         // [core#176]: no leading zeroes allowed\n-        for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i);\n+for (int i = 0; i < len; ++i) { char c = str.charAt(i;i; ++i; ++i; ++i)\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = 0; i < len; ++i) { char c = str.charAt(i);i; ++i)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-6/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 19:23:18.773633497 +0200\n+++ /tmp/tmpmthdugrx.java\t2022-07-19 19:23:18.773633497 +0200\n@@ -188,12 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         // [core#176]: no leading zeroes allowed\n-        for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i);\n+for (int i = 0; i < len; ++i) { char c = str.charAt(i);i; ++i)\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int i = 0; i < len; ++i) { char c = str.charAt(i;i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-6/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 19:23:20.433624922 +0200\n+++ /tmp/tmpxc2vec_j.java\t2022-07-19 19:23:20.433624922 +0200\n@@ -188,12 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         // [core#176]: no leading zeroes allowed\n-        for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i);\n+for (int i = 0; i < len; ++i) { char c = str.charAt(i;i++) {\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = 0; i < len; ++i) { char c = str.charAt(i);i;i; ++i)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-6/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 19:23:22.057616531 +0200\n+++ /tmp/tmpdvyovcci.java\t2022-07-19 19:23:22.057616531 +0200\n@@ -188,12 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         // [core#176]: no leading zeroes allowed\n-        for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i);\n+for (int i = 0; i < len; ++i) { char c = str.charAt(i);i;i; ++i)\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "for (int i = 0; i < len; ++i) { char c = str.charAt(i);",
        "fixed_line": "char c = str.charAt(0); if (c <= '0') { return (len == 1 && c == '0') ? 0 : -1; } if (c > '9') { return -1; } for (int i = 1; i < len; ++i) { c = str.charAt(i);"
    },
    "Mockito-1": {
        "fixes": [
            {
                "k": 1,
                "patch": "throw new UnsupportedOperationException(textVarargarg;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-1/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 19:23:23.881607107 +0200\n+++ /tmp/tmpy7fqkgxf.java\t2022-07-19 19:23:23.933606846 +0200\n@@ -118,11 +118,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+throw new UnsupportedOperationException(textVarargarg;\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n                 Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "throw new UnsupportedOperationException(textVararg;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-1/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 19:23:36.901539849 +0200\n+++ /tmp/tmpg6ad1ah2.java\t2022-07-19 19:23:36.901539849 +0200\n@@ -118,11 +118,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+throw new UnsupportedOperationException(textVararg;\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n                 Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "throw new UnsupportedOperationException(matcherss) isVararg;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-1/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 19:23:44.917498438 +0200\n+++ /tmp/tmp5auf9emy.java\t2022-07-19 19:23:44.917498438 +0200\n@@ -118,11 +118,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+throw new UnsupportedOperationException(matcherss) isVararg;\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n                 Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new UnsupportedOperationException(addVarargargarg;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-1/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 19:23:53.113456096 +0200\n+++ /tmp/tmpj4e5prxo.java\t2022-07-19 19:23:53.113456096 +0200\n@@ -118,11 +118,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+throw new UnsupportedOperationException(addVarargargarg;\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n                 Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "throw new UnsupportedOperationException(addVarargarg;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-1/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 19:24:01.401413282 +0200\n+++ /tmp/tmpbr2u3145.java\t2022-07-19 19:24:01.401413282 +0200\n@@ -118,11 +118,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+throw new UnsupportedOperationException(addVarargarg;\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n                 Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "throw new UnsupportedOperationException(textVarargargarg;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-1/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 19:24:09.449371706 +0200\n+++ /tmp/tmp64ncteq5.java\t2022-07-19 19:24:09.449371706 +0200\n@@ -118,11 +118,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+throw new UnsupportedOperationException(textVarargargarg;\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n                 Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "throw new UnsupportedOperationException(\"Vararg\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-1/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 19:24:17.385330710 +0200\n+++ /tmp/tmppv7kqyr8.java\t2022-07-19 19:24:17.385330710 +0200\n@@ -118,11 +118,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+throw new UnsupportedOperationException(\"Vararg\");\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n                 Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "throw new UnsupportedOperationException(addVarargargargarg;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-1/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 19:25:50.548849441 +0200\n+++ /tmp/tmpnbu_vo3k.java\t2022-07-19 19:25:50.560849380 +0200\n@@ -118,11 +118,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+throw new UnsupportedOperationException(addVarargargargarg;\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n                 Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "throw new UnsupportedOperationException(m_MAX_VALUE)\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-1/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 19:25:59.928800987 +0200\n+++ /tmp/tmpc0zfngtr.java\t2022-07-19 19:25:59.928800987 +0200\n@@ -118,11 +118,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+throw new UnsupportedOperationException(m_MAX_VALUE)\");\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n                 Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "throw new UnsupportedOperationException(matcherss;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-1/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 19:26:09.136753422 +0200\n+++ /tmp/tmpshfq7l3g.java\t2022-07-19 19:26:09.136753422 +0200\n@@ -118,11 +118,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+throw new UnsupportedOperationException(matcherss;\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n                 Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "throw new UnsupportedOperationException();",
        "fixed_line": "for (int position = 0; position < indexOfVararg; position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class)); } } for (int position = indexOfVararg; position < matchers.size(); position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]); } }"
    },
    "Closure-69": {
        "fixes": [
            {
                "k": 1,
                "patch": "// } else if (parent, n, CONSTRUCTOR_NOT_CALLABLE) {",
                "patch_diff": "// } else if (parent, n, CONSTRUCTOR_NOT_CALLABLE) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// We can't really modify it was non-literal characters that might be valid (e if it, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString()); }",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (e if it, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString()); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// We can't really modify it was non-empty's do implicit re-parse",
                "patch_diff": "// We can't really modify it was non-empty's do implicit re-parse",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// We can't really modify it's n, CONSTRUCTOR_NOT_CALLABLE, childType.toString()); }",
                "patch_diff": "// We can't really modify it's n, CONSTRUCTOR_NOT_CALLABLE, childType.toString()); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// We can't really modify it was non-literal characters that might be valid (e if it, n, CONSTRUCTOR_NOT_CALLABLE) {",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (e if it, n, CONSTRUCTOR_NOT_CALLABLE) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// We can't really modify it was non-literal characters that might be valid (e if it, n, CONSTRUCTOR_NOT_CALLABLE)",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (e if it, n, CONSTRUCTOR_NOT_CALLABLE)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// We can't really modify it's do implicit re-parse",
                "patch_diff": "// We can't really modify it's do implicit re-parse",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// } else if (n, CONSTRUCTOR_NOT_CALLABLE) {",
                "patch_diff": "// } else if (n, CONSTRUCTOR_NOT_CALLABLE) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// We can't really modify it was non-literal characters that might be valid (e if it, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (e if it, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// We can't really modify it was non-literal characters that might be valid (e if it, n, CONSTRUCTOR_NOT_CALLABLE,",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (e if it, n, CONSTRUCTOR_NOT_CALLABLE,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (functionType.isOrdinaryFunction() && !functionType.getTypeOfThis().isUnknownType() && !functionType.getTypeOfThis().isNativeObjectType() && !(child.getType() == Token.GETELEM || child.getType() == Token.GETPROP)) { report(t, n, EXPECTED_THIS_TYPE, functionType.toString()); }"
    },
    "Closure-170": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (n.isName && n.getString().equals(varName) == n;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-170/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2022-07-19 19:26:22.052686700 +0200\n+++ /tmp/tmpq8o2_eaz.java\t2022-07-19 19:26:23.572678851 +0200\n@@ -477,18 +477,11 @@\n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (n.isName() && n.getString().equals(varName) &&\n-            // We make a special exception when the entire cfgNode is a chain\n-            // of assignments, since in that case the assignment statements\n-            // will happen after the inlining of the right hand side.\n-            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n-            //   and remove this special case.\n-              !(parent.isAssign() &&\n-               (parent.getFirstChild() == n))) {\n+if (n.isName && n.getString().equals(varName) == n;\n               // Don't count lhs of top-level assignment chain\n               numUsesWithinCfgNode++;\n           }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (n.isName && n == parent.getString().equals(varName)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-170/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2022-07-19 19:26:33.348628349 +0200\n+++ /tmp/tmp6nyr4h3z.java\t2022-07-19 19:26:33.380628185 +0200\n@@ -477,18 +477,11 @@\n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (n.isName() && n.getString().equals(varName) &&\n-            // We make a special exception when the entire cfgNode is a chain\n-            // of assignments, since in that case the assignment statements\n-            // will happen after the inlining of the right hand side.\n-            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n-            //   and remove this special case.\n-              !(parent.isAssign() &&\n-               (parent.getFirstChild() == n))) {\n+if (n.isName && n == parent.getString().equals(varName)) {\n               // Don't count lhs of top-level assignment chain\n               numUsesWithinCfgNode++;\n           }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (n.isName) && n.getString().equals(varName) == n;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-170/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2022-07-19 19:26:38.248603038 +0200\n+++ /tmp/tmpwe6jpjir.java\t2022-07-19 19:26:38.316602697 +0200\n@@ -477,18 +477,11 @@\n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (n.isName() && n.getString().equals(varName) &&\n-            // We make a special exception when the entire cfgNode is a chain\n-            // of assignments, since in that case the assignment statements\n-            // will happen after the inlining of the right hand side.\n-            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n-            //   and remove this special case.\n-              !(parent.isAssign() &&\n-               (parent.getFirstChild() == n))) {\n+if (n.isName) && n.getString().equals(varName) == n;\n               // Don't count lhs of top-level assignment chain\n               numUsesWithinCfgNode++;\n           }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (n.isName && n == parent.getString().equals(varName) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-170/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2022-07-19 19:26:43.080578077 +0200\n+++ /tmp/tmp808cuz53.java\t2022-07-19 19:26:43.080578077 +0200\n@@ -477,18 +477,11 @@\n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (n.isName() && n.getString().equals(varName) &&\n-            // We make a special exception when the entire cfgNode is a chain\n-            // of assignments, since in that case the assignment statements\n-            // will happen after the inlining of the right hand side.\n-            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n-            //   and remove this special case.\n-              !(parent.isAssign() &&\n-               (parent.getFirstChild() == n))) {\n+if (n.isName && n == parent.getString().equals(varName) {\n               // Don't count lhs of top-level assignment chain\n               numUsesWithinCfgNode++;\n           }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (n.isName) && n.getString().equals(varName)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-170/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2022-07-19 19:26:47.444555534 +0200\n+++ /tmp/tmpxpm8igbr.java\t2022-07-19 19:26:47.444555534 +0200\n@@ -477,18 +477,11 @@\n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (n.isName() && n.getString().equals(varName) &&\n-            // We make a special exception when the entire cfgNode is a chain\n-            // of assignments, since in that case the assignment statements\n-            // will happen after the inlining of the right hand side.\n-            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n-            //   and remove this special case.\n-              !(parent.isAssign() &&\n-               (parent.getFirstChild() == n))) {\n+if (n.isName) && n.getString().equals(varName)) {\n               // Don't count lhs of top-level assignment chain\n               numUsesWithinCfgNode++;\n           }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (n.isName; n.getString().equals(varName) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-170/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2022-07-19 19:26:51.544534356 +0200\n+++ /tmp/tmpp22w9ydq.java\t2022-07-19 19:26:51.544534356 +0200\n@@ -477,18 +477,11 @@\n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (n.isName() && n.getString().equals(varName) &&\n-            // We make a special exception when the entire cfgNode is a chain\n-            // of assignments, since in that case the assignment statements\n-            // will happen after the inlining of the right hand side.\n-            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n-            //   and remove this special case.\n-              !(parent.isAssign() &&\n-               (parent.getFirstChild() == n))) {\n+if (n.isName; n.getString().equals(varName) {\n               // Don't count lhs of top-level assignment chain\n               numUsesWithinCfgNode++;\n           }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (n.isName; n.getString().equals(varName) == n;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-170/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2022-07-19 19:26:54.840517331 +0200\n+++ /tmp/tmptkw0my8c.java\t2022-07-19 19:26:54.864517205 +0200\n@@ -477,18 +477,11 @@\n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (n.isName() && n.getString().equals(varName) &&\n-            // We make a special exception when the entire cfgNode is a chain\n-            // of assignments, since in that case the assignment statements\n-            // will happen after the inlining of the right hand side.\n-            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n-            //   and remove this special case.\n-              !(parent.isAssign() &&\n-               (parent.getFirstChild() == n))) {\n+if (n.isName; n.getString().equals(varName) == n;\n               // Don't count lhs of top-level assignment chain\n               numUsesWithinCfgNode++;\n           }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (n.isName && n == parent) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-170/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2022-07-19 19:26:58.240499768 +0200\n+++ /tmp/tmpai7mh2dl.java\t2022-07-19 19:26:58.244499747 +0200\n@@ -477,18 +477,11 @@\n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (n.isName() && n.getString().equals(varName) &&\n-            // We make a special exception when the entire cfgNode is a chain\n-            // of assignments, since in that case the assignment statements\n-            // will happen after the inlining of the right hand side.\n-            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n-            //   and remove this special case.\n-              !(parent.isAssign() &&\n-               (parent.getFirstChild() == n))) {\n+if (n.isName && n == parent) {\n               // Don't count lhs of top-level assignment chain\n               numUsesWithinCfgNode++;\n           }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (n.isName) && n.getString().equals(varName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-170/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2022-07-19 19:27:01.992480386 +0200\n+++ /tmp/tmpwjbncgmb.java\t2022-07-19 19:27:01.996480364 +0200\n@@ -477,18 +477,11 @@\n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (n.isName() && n.getString().equals(varName) &&\n-            // We make a special exception when the entire cfgNode is a chain\n-            // of assignments, since in that case the assignment statements\n-            // will happen after the inlining of the right hand side.\n-            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n-            //   and remove this special case.\n-              !(parent.isAssign() &&\n-               (parent.getFirstChild() == n))) {\n+if (n.isName) && n.getString().equals(varName;\n               // Don't count lhs of top-level assignment chain\n               numUsesWithinCfgNode++;\n           }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (n.isName) && n.getString().equals(varName) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-170/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2022-07-19 19:27:05.392462823 +0200\n+++ /tmp/tmporzdazsz.java\t2022-07-19 19:27:05.392462823 +0200\n@@ -477,18 +477,11 @@\n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (n.isName() && n.getString().equals(varName) &&\n-            // We make a special exception when the entire cfgNode is a chain\n-            // of assignments, since in that case the assignment statements\n-            // will happen after the inlining of the right hand side.\n-            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n-            //   and remove this special case.\n-              !(parent.isAssign() &&\n-               (parent.getFirstChild() == n))) {\n+if (n.isName) && n.getString().equals(varName) {\n               // Don't count lhs of top-level assignment chain\n               numUsesWithinCfgNode++;\n           }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (n.isName() && n.getString().equals(varName) && // We make a special exception when the entire cfgNode is a chain // of assignments, since in that case the assignment statements // will happen after the inlining of the right hand side. // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact // and remove this special case. !(parent.isAssign() && (parent.getFirstChild() == n))) {",
        "fixed_line": "if (n.isName() && n.getString().equals(varName)) { // We make a special exception when the entire cfgNode is a chain // of assignments, since in that case the assignment statements // will happen after the inlining of the right hand side. // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact // and remove this special case. if (parent.isAssign() && (parent.getFirstChild() == n) && isAssignChain(parent, cfgNode)) { // Don't count lhs of top-level assignment chain return; } else { numUsesWithinCfgNode++; } } } private boolean isAssignChain(Node child, Node ancestor) { for (Node n = child; n != ancestor; n = n.getParent()) { if (!n.isAssign()) { return false; } } return true; }"
    },
    "Math-75": {
        "fixes": [
            {
                "k": 1,
                "patch": "return getCumPct((Comparable<?> v)v);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-75/src/main/java/org/apache/commons/math/stat/Frequency.java\t2022-07-19 19:27:09.072443814 +0200\n+++ /tmp/tmp3_6nn_nv.java\t2022-07-19 19:27:09.092443708 +0200\n@@ -298,11 +298,11 @@\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+return getCumPct((Comparable<?> v)v);\n     }\n \n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return getCumPct((Comparable<?> v) v);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-75/src/main/java/org/apache/commons/math/stat/Frequency.java\t2022-07-19 19:27:11.792429763 +0200\n+++ /tmp/tmpcj97e6cj.java\t2022-07-19 19:27:11.792429763 +0200\n@@ -298,11 +298,11 @@\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+return getCumPct((Comparable<?> v) v);\n     }\n \n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return getCumPct((Comparable<?> v)v;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-75/src/main/java/org/apache/commons/math/stat/Frequency.java\t2022-07-19 19:27:13.812419328 +0200\n+++ /tmp/tmpsz64eldq.java\t2022-07-19 19:27:13.812419328 +0200\n@@ -298,11 +298,11 @@\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+return getCumPct((Comparable<?> v)v;\n     }\n \n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return getCumPct((Comparable<?> v) v;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-75/src/main/java/org/apache/commons/math/stat/Frequency.java\t2022-07-19 19:27:15.960408233 +0200\n+++ /tmp/tmpz6oz8w5g.java\t2022-07-19 19:27:15.960408233 +0200\n@@ -298,11 +298,11 @@\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+return getCumPct((Comparable<?> v) v;\n     }\n \n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return getCumPct((Comparable<?>)v);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-75/src/main/java/org/apache/commons/math/stat/Frequency.java\t2022-07-19 19:27:18.084397262 +0200\n+++ /tmp/tmpus86ojwl.java\t2022-07-19 19:27:18.084397262 +0200\n@@ -298,11 +298,11 @@\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+return getCumPct((Comparable<?>)v);\n     }\n \n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return getCumPct((Comparable<?> v) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-75/src/main/java/org/apache/commons/math/stat/Frequency.java\t2022-07-19 19:27:26.864351908 +0200\n+++ /tmp/tmpoi0ctxps.java\t2022-07-19 19:27:26.864351908 +0200\n@@ -298,11 +298,11 @@\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+return getCumPct((Comparable<?> v) {\n     }\n \n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return getCumPct((Comparable<?>)v;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-75/src/main/java/org/apache/commons/math/stat/Frequency.java\t2022-07-19 19:27:28.956341100 +0200\n+++ /tmp/tmph3ca5ed3.java\t2022-07-19 19:27:28.956341100 +0200\n@@ -298,11 +298,11 @@\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+return getCumPct((Comparable<?>)v;\n     }\n \n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return getCumPct((Comparable<?>) v);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-75/src/main/java/org/apache/commons/math/stat/Frequency.java\t2022-07-19 19:27:31.088330089 +0200\n+++ /tmp/tmpzhimcaqr.java\t2022-07-19 19:27:31.088330089 +0200\n@@ -298,11 +298,11 @@\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+return getCumPct((Comparable<?>) v);\n     }\n \n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return getCumPct((Comparable<?>) v;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-75/src/main/java/org/apache/commons/math/stat/Frequency.java\t2022-07-19 19:27:37.840295211 +0200\n+++ /tmp/tmpcp0jdaiz.java\t2022-07-19 19:27:37.840295211 +0200\n@@ -298,11 +298,11 @@\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+return getCumPct((Comparable<?>) v;\n     }\n \n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return getCumPct((Comparable<?>) v,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-75/src/main/java/org/apache/commons/math/stat/Frequency.java\t2022-07-19 19:27:39.852284817 +0200\n+++ /tmp/tmpgdpyc9d8.java\t2022-07-19 19:27:39.852284817 +0200\n@@ -298,11 +298,11 @@\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+return getCumPct((Comparable<?>) v,\n     }\n \n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return getCumPct((Comparable<?>) v);",
        "fixed_line": "return getPct((Comparable<?>) v);"
    },
    "Closure-126": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (NodeUtil.hasFinallyBlock = n; tryMinimizeExits(finallyBlock, exitType, labelName); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2022-07-19 19:27:42.144272978 +0200\n+++ /tmp/tmpmxx39sgi.java\t2022-07-19 19:27:42.208272648 +0200\n@@ -136,14 +136,11 @@\n       }\n       /* Don't try to minimize the exits of finally blocks, as this\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+if (NodeUtil.hasFinallyBlock = n; tryMinimizeExits(finallyBlock, exitType, labelName); }\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (NodeUtil.hasFinallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2022-07-19 19:27:47.016247811 +0200\n+++ /tmp/tmprzdb_8zd.java\t2022-07-19 19:27:47.016247811 +0200\n@@ -136,14 +136,11 @@\n       }\n       /* Don't try to minimize the exits of finally blocks, as this\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+if (NodeUtil.hasFinallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); }\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (NodeUtil.hasFinallyBlock = n; tryMinimizeExits(finallyBlock, exitType, labelName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2022-07-19 19:27:50.468229979 +0200\n+++ /tmp/tmpyd02o7g8.java\t2022-07-19 19:27:50.468229979 +0200\n@@ -136,14 +136,11 @@\n       }\n       /* Don't try to minimize the exits of finally blocks, as this\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+if (NodeUtil.hasFinallyBlock = n; tryMinimizeExits(finallyBlock, exitType, labelName;\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (NodeUtil.hasFinallyBlock = n, exitType, labelName); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2022-07-19 19:27:53.956211963 +0200\n+++ /tmp/tmpa2hnezx0.java\t2022-07-19 19:27:53.956211963 +0200\n@@ -136,14 +136,11 @@\n       }\n       /* Don't try to minimize the exits of finally blocks, as this\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+if (NodeUtil.hasFinallyBlock = n, exitType, labelName); }\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (NodeUtil.hasFinallyBlock = n; tryMinimizeExits(finallyBlock, exitType, labelName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2022-07-19 19:27:57.528193512 +0200\n+++ /tmp/tmp3y09ykbw.java\t2022-07-19 19:27:57.528193512 +0200\n@@ -136,14 +136,11 @@\n       }\n       /* Don't try to minimize the exits of finally blocks, as this\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+if (NodeUtil.hasFinallyBlock = n; tryMinimizeExits(finallyBlock, exitType, labelName);\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (n.hasFinallyBlock = n; tryMinimizeExits(finallyBlock, exitType, labelName); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2022-07-19 19:28:00.956175802 +0200\n+++ /tmp/tmp1_k8_mx4.java\t2022-07-19 19:28:00.956175802 +0200\n@@ -136,14 +136,11 @@\n       }\n       /* Don't try to minimize the exits of finally blocks, as this\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+if (n.hasFinallyBlock = n; tryMinimizeExits(finallyBlock, exitType, labelName); }\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (NodeUtil.hasFinallyBlock = n, exitType, labelName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2022-07-19 19:28:04.472157640 +0200\n+++ /tmp/tmp2vs8gch1.java\t2022-07-19 19:28:04.472157640 +0200\n@@ -136,14 +136,11 @@\n       }\n       /* Don't try to minimize the exits of finally blocks, as this\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+if (NodeUtil.hasFinallyBlock = n, exitType, labelName;\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (NodeUtil.hasFinallyBlock = n, exitType, labelName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2022-07-19 19:28:07.952139667 +0200\n+++ /tmp/tmpep83ozqj.java\t2022-07-19 19:28:07.952139667 +0200\n@@ -136,14 +136,11 @@\n       }\n       /* Don't try to minimize the exits of finally blocks, as this\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+if (NodeUtil.hasFinallyBlock = n, exitType, labelName);\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (NodeUtil.hasFinallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2022-07-19 19:28:11.384121938 +0200\n+++ /tmp/tmp20u097qm.java\t2022-07-19 19:28:11.384121938 +0200\n@@ -136,14 +136,11 @@\n       }\n       /* Don't try to minimize the exits of finally blocks, as this\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+if (NodeUtil.hasFinallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName;\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (n.hasFinallyBlock = n, exitType, labelName); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2022-07-19 19:28:15.152102473 +0200\n+++ /tmp/tmpslz2sdbt.java\t2022-07-19 19:28:15.152102473 +0200\n@@ -136,14 +136,11 @@\n       }\n       /* Don't try to minimize the exits of finally blocks, as this\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+if (n.hasFinallyBlock = n, exitType, labelName); }\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); }",
        "fixed_line": ""
    },
    "Closure-159": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (node.getType() == Token.CALL) { Node child = node.getFirstChild();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-159/src/com/google/javascript/jscomp/InlineFunctions.java\t2022-07-19 19:28:18.896083136 +0200\n+++ /tmp/tmpp5topg0k.java\t2022-07-19 19:28:18.968082762 +0200\n@@ -772,14 +772,11 @@\n    */\n   private void findCalledFunctions(\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.CALL) {\n-      Node child = node.getFirstChild();\n-      if (child.getType() == Token.NAME) {\n-        changed.add(child.getString());\n+if (node.getType() == Token.CALL) { Node child = node.getFirstChild();\n       }\n     }\n \n     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n       findCalledFunctions(c, changed);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (node.getType() == Token.CALL) { NodeUtil.getFirstChild();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-159/src/com/google/javascript/jscomp/InlineFunctions.java\t2022-07-19 19:28:22.140066378 +0200\n+++ /tmp/tmpv64q8640.java\t2022-07-19 19:28:22.140066378 +0200\n@@ -772,14 +772,11 @@\n    */\n   private void findCalledFunctions(\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.CALL) {\n-      Node child = node.getFirstChild();\n-      if (child.getType() == Token.NAME) {\n-        changed.add(child.getString());\n+if (node.getType() == Token.CALL) { NodeUtil.getFirstChild();\n       }\n     }\n \n     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n       findCalledFunctions(c, changed);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (node.getType == Token.CALL) { Node child = node.getFirstChild();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-159/src/com/google/javascript/jscomp/InlineFunctions.java\t2022-07-19 19:28:24.756052866 +0200\n+++ /tmp/tmpzhu4va3l.java\t2022-07-19 19:28:24.756052866 +0200\n@@ -772,14 +772,11 @@\n    */\n   private void findCalledFunctions(\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.CALL) {\n-      Node child = node.getFirstChild();\n-      if (child.getType() == Token.NAME) {\n-        changed.add(child.getString());\n+if (node.getType == Token.CALL) { Node child = node.getFirstChild();\n       }\n     }\n \n     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n       findCalledFunctions(c, changed);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (node.getType() == Token.CALL) { Node child = c.getFirstChild();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-159/src/com/google/javascript/jscomp/InlineFunctions.java\t2022-07-19 19:28:27.280039828 +0200\n+++ /tmp/tmpxjt_9gos.java\t2022-07-19 19:28:27.280039828 +0200\n@@ -772,14 +772,11 @@\n    */\n   private void findCalledFunctions(\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.CALL) {\n-      Node child = node.getFirstChild();\n-      if (child.getType() == Token.NAME) {\n-        changed.add(child.getString());\n+if (node.getType() == Token.CALL) { Node child = c.getFirstChild();\n       }\n     }\n \n     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n       findCalledFunctions(c, changed);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (node.getType == Token.CALL) { NodeUtil.getFirstChild();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-159/src/com/google/javascript/jscomp/InlineFunctions.java\t2022-07-19 19:28:29.912026230 +0200\n+++ /tmp/tmpbmvje2uz.java\t2022-07-19 19:28:29.916026211 +0200\n@@ -772,14 +772,11 @@\n    */\n   private void findCalledFunctions(\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.CALL) {\n-      Node child = node.getFirstChild();\n-      if (child.getType() == Token.NAME) {\n-        changed.add(child.getString());\n+if (node.getType == Token.CALL) { NodeUtil.getFirstChild();\n       }\n     }\n \n     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n       findCalledFunctions(c, changed);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (node.getType() == Token.CALL) { Node child = Node.getFirstChild();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-159/src/com/google/javascript/jscomp/InlineFunctions.java\t2022-07-19 19:28:32.412013317 +0200\n+++ /tmp/tmpi0ff0azh.java\t2022-07-19 19:28:32.416013298 +0200\n@@ -772,14 +772,11 @@\n    */\n   private void findCalledFunctions(\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.CALL) {\n-      Node child = node.getFirstChild();\n-      if (child.getType() == Token.NAME) {\n-        changed.add(child.getString());\n+if (node.getType() == Token.CALL) { Node child = Node.getFirstChild();\n       }\n     }\n \n     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n       findCalledFunctions(c, changed);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (node.getType == Token.CALL) { Node child = Node.getFirstChild();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-159/src/com/google/javascript/jscomp/InlineFunctions.java\t2022-07-19 19:28:35.055999660 +0200\n+++ /tmp/tmpexgqkgj9.java\t2022-07-19 19:28:35.055999660 +0200\n@@ -772,14 +772,11 @@\n    */\n   private void findCalledFunctions(\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.CALL) {\n-      Node child = node.getFirstChild();\n-      if (child.getType() == Token.NAME) {\n-        changed.add(child.getString());\n+if (node.getType == Token.CALL) { Node child = Node.getFirstChild();\n       }\n     }\n \n     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n       findCalledFunctions(c, changed);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (node.getType() == Token.CALL) { Node child = child.getFirstChild();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-159/src/com/google/javascript/jscomp/InlineFunctions.java\t2022-07-19 19:28:37.599986518 +0200\n+++ /tmp/tmpha8ipe84.java\t2022-07-19 19:28:37.599986518 +0200\n@@ -772,14 +772,11 @@\n    */\n   private void findCalledFunctions(\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.CALL) {\n-      Node child = node.getFirstChild();\n-      if (child.getType() == Token.NAME) {\n-        changed.add(child.getString());\n+if (node.getType() == Token.CALL) { Node child = child.getFirstChild();\n       }\n     }\n \n     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n       findCalledFunctions(c, changed);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (node.getType == Token.CALL) { Node child = c.getFirstChild();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-159/src/com/google/javascript/jscomp/InlineFunctions.java\t2022-07-19 19:28:40.251972821 +0200\n+++ /tmp/tmp5nevpivz.java\t2022-07-19 19:28:40.255972798 +0200\n@@ -772,14 +772,11 @@\n    */\n   private void findCalledFunctions(\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.CALL) {\n-      Node child = node.getFirstChild();\n-      if (child.getType() == Token.NAME) {\n-        changed.add(child.getString());\n+if (node.getType == Token.CALL) { Node child = c.getFirstChild();\n       }\n     }\n \n     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n       findCalledFunctions(c, changed);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (type == Token.CALL) { NodeUtil.getFirstChild();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-159/src/com/google/javascript/jscomp/InlineFunctions.java\t2022-07-19 19:28:42.699960176 +0200\n+++ /tmp/tmpemjt0fcw.java\t2022-07-19 19:28:42.699960176 +0200\n@@ -772,14 +772,11 @@\n    */\n   private void findCalledFunctions(\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.CALL) {\n-      Node child = node.getFirstChild();\n-      if (child.getType() == Token.NAME) {\n-        changed.add(child.getString());\n+if (type == Token.CALL) { NodeUtil.getFirstChild();\n       }\n     }\n \n     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n       findCalledFunctions(c, changed);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString());",
        "fixed_line": "if (node.getType() == Token.NAME) { if (isCandidateUsage(node)) { changed.add(node.getString());"
    },
    "Compress-1": {
        "fixes": [
            {
                "k": 1,
                "patch": "this.closed = false; }",
                "patch_diff": "this.closed = false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (this.closed!= null) { for (int i = 0; i < this.closed; i++) { this.close(); } } }",
                "patch_diff": "if (this.closed!= null) { for (int i = 0; i < this.closed; i++) { this.close(); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (this.closed == null) { this.closed = true; } else { this.close(); } }",
                "patch_diff": "if (this.closed == null) { this.closed = true; } else { this.close(); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (this.closed!= null) { this.closed = true; } }",
                "patch_diff": "if (this.closed!= null) { this.closed = true; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (this.closed!= null) { this.closed = true; } else { this.close(); } }",
                "patch_diff": "if (this.closed!= null) { this.closed = true; } else { this.close(); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (this.closed!= null) { if (this.closed!= null) { this.closed = true; } } }",
                "patch_diff": "if (this.closed!= null) { if (this.closed!= null) { this.closed = true; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (this.closed!= null) { this.closed = false; } else { this.close(); } }",
                "patch_diff": "if (this.closed!= null) { this.closed = false; } else { this.close(); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (this.closed!= null) { this.closed = false; } }",
                "patch_diff": "if (this.closed!= null) { this.closed = false; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (this.closed!= null) { for (int i = 0; i < this.closed; i++) { super.close(); } } }",
                "patch_diff": "if (this.closed!= null) { for (int i = 0; i < this.closed; i++) { super.close(); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (this.closed!= null) { if (this.closed!= null) { this.closed = false; } } }",
                "patch_diff": "if (this.closed!= null) { if (this.closed!= null) { this.closed = false; } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "this.finish();"
    },
    "Jsoup-34": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (i == sourceIndex) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-34/src/main/java/org/jsoup/parser/CharacterReader.java\t2022-07-19 19:28:47.299936415 +0200\n+++ /tmp/tmp51h_57v5.java\t2022-07-19 19:28:47.371936046 +0200\n@@ -86,11 +86,11 @@\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+if (i == sourceIndex) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (i == source.length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-34/src/main/java/org/jsoup/parser/CharacterReader.java\t2022-07-19 19:28:49.543924822 +0200\n+++ /tmp/tmpjtxikbmv.java\t2022-07-19 19:28:49.543924822 +0200\n@@ -86,11 +86,11 @@\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+if (i == source.length) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (i < length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-34/src/main/java/org/jsoup/parser/CharacterReader.java\t2022-07-19 19:28:51.299915753 +0200\n+++ /tmp/tmp0ytukn64.java\t2022-07-19 19:28:51.299915753 +0200\n@@ -86,11 +86,11 @@\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+if (i < length) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (length < length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-34/src/main/java/org/jsoup/parser/CharacterReader.java\t2022-07-19 19:28:55.235895420 +0200\n+++ /tmp/tmp5kkarslm.java\t2022-07-19 19:28:55.235895420 +0200\n@@ -86,11 +86,11 @@\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+if (length < length) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (i == length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-34/src/main/java/org/jsoup/parser/CharacterReader.java\t2022-07-19 19:28:58.367879244 +0200\n+++ /tmp/tmpmzyknzm8.java\t2022-07-19 19:28:58.367879244 +0200\n@@ -86,11 +86,11 @@\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+if (i == length) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (i > length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-34/src/main/java/org/jsoup/parser/CharacterReader.java\t2022-07-19 19:29:01.375863706 +0200\n+++ /tmp/tmp2ku8zu2s.java\t2022-07-19 19:29:01.375863706 +0200\n@@ -86,11 +86,11 @@\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+if (i > length) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (i == lastChar) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-34/src/main/java/org/jsoup/parser/CharacterReader.java\t2022-07-19 19:29:04.539847362 +0200\n+++ /tmp/tmp_rvl7rhz.java\t2022-07-19 19:29:04.543847340 +0200\n@@ -86,11 +86,11 @@\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+if (i == lastChar) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (i == startPropertyIndex) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-34/src/main/java/org/jsoup/parser/CharacterReader.java\t2022-07-19 19:29:06.231838621 +0200\n+++ /tmp/tmp05y33pz7.java\t2022-07-19 19:29:06.231838621 +0200\n@@ -86,11 +86,11 @@\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+if (i == startPropertyIndex) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (i <= length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-34/src/main/java/org/jsoup/parser/CharacterReader.java\t2022-07-19 19:29:08.043829262 +0200\n+++ /tmp/tmpfxwb05ta.java\t2022-07-19 19:29:08.043829262 +0200\n@@ -86,11 +86,11 @@\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+if (i <= length) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (last < length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-34/src/main/java/org/jsoup/parser/CharacterReader.java\t2022-07-19 19:29:11.291812486 +0200\n+++ /tmp/tmpx1q8efqu.java\t2022-07-19 19:29:11.291812486 +0200\n@@ -86,11 +86,11 @@\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+if (last < length) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (offset < length) {",
        "fixed_line": "if (offset < length && last <= length) {"
    },
    "Lang-22": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (Math.abs(u) < 1 || Math.abs(v) == 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-22/src/main/java/org/apache/commons/lang3/math/Fraction.java\t2022-07-19 19:29:14.503795895 +0200\n+++ /tmp/tmpmm50f35t.java\t2022-07-19 19:29:14.571795544 +0200\n@@ -579,11 +579,11 @@\n      * @return the greatest common divisor, never zero\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+if (Math.abs(u) < 1 || Math.abs(v) == 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (Math.abs(u) <= 1 || Math.abs(v) == 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-22/src/main/java/org/apache/commons/lang3/math/Fraction.java\t2022-07-19 19:29:25.195740664 +0200\n+++ /tmp/tmpibznij7g.java\t2022-07-19 19:29:25.199740645 +0200\n@@ -579,11 +579,11 @@\n      * @return the greatest common divisor, never zero\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+if (Math.abs(u) <= 1 || Math.abs(v) == 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (Math.abs(u) <= 0 && Math.abs(v) <= 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-22/src/main/java/org/apache/commons/lang3/math/Fraction.java\t2022-07-19 19:29:34.935690353 +0200\n+++ /tmp/tmp65wgdw78.java\t2022-07-19 19:29:34.935690353 +0200\n@@ -579,11 +579,11 @@\n      * @return the greatest common divisor, never zero\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+if (Math.abs(u) <= 0 && Math.abs(v) <= 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 4,
                "patch": "if (Math.abs(u) <= 0 || Math.abs(v) <= 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-22/src/main/java/org/apache/commons/lang3/math/Fraction.java\t2022-07-19 19:29:44.327641839 +0200\n+++ /tmp/tmp28b9xfb6.java\t2022-07-19 19:29:44.327641839 +0200\n@@ -579,11 +579,11 @@\n      * @return the greatest common divisor, never zero\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+if (Math.abs(u) <= 0 || Math.abs(v) <= 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (Math.abs(u) < 1 || Math.abs(v) < 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-22/src/main/java/org/apache/commons/lang3/math/Fraction.java\t2022-07-19 19:29:53.815592832 +0200\n+++ /tmp/tmpgr6x6gdj.java\t2022-07-19 19:29:53.815592832 +0200\n@@ -579,11 +579,11 @@\n      * @return the greatest common divisor, never zero\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+if (Math.abs(u) < 1 || Math.abs(v) < 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (Math.abs(u) <= 1 || Math.abs(v) < 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-22/src/main/java/org/apache/commons/lang3/math/Fraction.java\t2022-07-19 19:30:03.411543264 +0200\n+++ /tmp/tmppsyxsjpc.java\t2022-07-19 19:30:03.411543264 +0200\n@@ -579,11 +579,11 @@\n      * @return the greatest common divisor, never zero\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+if (Math.abs(u) <= 1 || Math.abs(v) < 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-22/src/main/java/org/apache/commons/lang3/math/Fraction.java\t2022-07-19 19:30:13.067493388 +0200\n+++ /tmp/tmpl8kr5n1i.java\t2022-07-19 19:30:13.071493367 +0200\n@@ -579,11 +579,11 @@\n      * @return the greatest common divisor, never zero\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (Math.abs(u) < 1 || Math.abs(v) <= 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-22/src/main/java/org/apache/commons/lang3/math/Fraction.java\t2022-07-19 19:30:22.603444131 +0200\n+++ /tmp/tmpagr3ui0g.java\t2022-07-19 19:30:22.603444131 +0200\n@@ -579,11 +579,11 @@\n      * @return the greatest common divisor, never zero\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+if (Math.abs(u) < 1 || Math.abs(v) <= 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (Math.abs(u) < 1 || Math.abs(v - 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-22/src/main/java/org/apache/commons/lang3/math/Fraction.java\t2022-07-19 19:30:32.247394317 +0200\n+++ /tmp/tmpdr9lapyh.java\t2022-07-19 19:30:32.247394317 +0200\n@@ -579,11 +579,11 @@\n      * @return the greatest common divisor, never zero\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+if (Math.abs(u) < 1 || Math.abs(v - 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (Math.abs(u) <= 1 || Math.abs(v - 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Lang-22/src/main/java/org/apache/commons/lang3/math/Fraction.java\t2022-07-19 19:30:33.715386735 +0200\n+++ /tmp/tmpdeclfd6w.java\t2022-07-19 19:30:33.715386735 +0200\n@@ -579,11 +579,11 @@\n      * @return the greatest common divisor, never zero\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+if (Math.abs(u) <= 1 || Math.abs(v - 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {",
        "fixed_line": "if ((u == 0) || (v == 0)) { if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) { throw new ArithmeticException(\"overflow: gcd is 2^31\"); } return Math.abs(u) + Math.abs(v); } //if either operand is abs 1, return 1: if (Math.abs(u) == 1 || Math.abs(v) == 1) {"
    },
    "Time-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-11/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\t2022-07-19 19:30:35.559377209 +0200\n+++ /tmp/tmp2zf_06sh.java\t2022-07-19 19:30:35.583377085 +0200\n@@ -63,14 +63,11 @@\n public class ZoneInfoCompiler {\n     static DateTimeOfYear cStartOfYear;\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n-    static {\n-        cVerbose.set(Boolean.FALSE);\n-    }\n+static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); }\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n      * @return true to log verbosely\n      */\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set):Boolean.FALSE); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-11/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\t2022-07-19 19:30:53.359285265 +0200\n+++ /tmp/tmpt42fqeux.java\t2022-07-19 19:30:53.363285246 +0200\n@@ -63,14 +63,11 @@\n public class ZoneInfoCompiler {\n     static DateTimeOfYear cStartOfYear;\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n-    static {\n-        cVerbose.set(Boolean.FALSE);\n-    }\n+static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set):Boolean.FALSE); }\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n      * @return true to log verbosely\n      */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(0, 0); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-11/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\t2022-07-19 19:30:56.823267372 +0200\n+++ /tmp/tmp6ww_3exi.java\t2022-07-19 19:30:56.823267372 +0200\n@@ -63,14 +63,11 @@\n public class ZoneInfoCompiler {\n     static DateTimeOfYear cStartOfYear;\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n-    static {\n-        cVerbose.set(Boolean.FALSE);\n-    }\n+static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(0, 0); }\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n      * @return true to log verbosely\n      */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(cLenient.FALSE); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-11/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\t2022-07-19 19:31:00.639247663 +0200\n+++ /tmp/tmpy0lw235g.java\t2022-07-19 19:31:00.639247663 +0200\n@@ -63,14 +63,11 @@\n public class ZoneInfoCompiler {\n     static DateTimeOfYear cStartOfYear;\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n-    static {\n-        cVerbose.set(Boolean.FALSE);\n-    }\n+static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(cLenient.FALSE); }\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n      * @return true to log verbosely\n      */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set;Boolean.FALSE); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-11/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\t2022-07-19 19:31:04.367228405 +0200\n+++ /tmp/tmpzl94hpal.java\t2022-07-19 19:31:04.371228386 +0200\n@@ -63,14 +63,11 @@\n public class ZoneInfoCompiler {\n     static DateTimeOfYear cStartOfYear;\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n-    static {\n-        cVerbose.set(Boolean.FALSE);\n-    }\n+static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set;Boolean.FALSE); }\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n      * @return true to log verbosely\n      */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.setTimeBoolean.FALSE); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-11/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\t2022-07-19 19:31:08.055209355 +0200\n+++ /tmp/tmpb1lwttlo.java\t2022-07-19 19:31:08.055209355 +0200\n@@ -63,14 +63,11 @@\n public class ZoneInfoCompiler {\n     static DateTimeOfYear cStartOfYear;\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n-    static {\n-        cVerbose.set(Boolean.FALSE);\n-    }\n+static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.setTimeBoolean.FALSE); }\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n      * @return true to log verbosely\n      */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(cVerbose.FALSE); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-11/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\t2022-07-19 19:31:10.911194603 +0200\n+++ /tmp/tmpal74x089.java\t2022-07-19 19:31:10.911194603 +0200\n@@ -63,14 +63,11 @@\n public class ZoneInfoCompiler {\n     static DateTimeOfYear cStartOfYear;\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n-    static {\n-        cVerbose.set(Boolean.FALSE);\n-    }\n+static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(cVerbose.FALSE); }\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n      * @return true to log verbosely\n      */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-11/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\t2022-07-19 19:31:14.411176526 +0200\n+++ /tmp/tmpfmdgs2fb.java\t2022-07-19 19:31:14.415176505 +0200\n@@ -63,14 +63,11 @@\n public class ZoneInfoCompiler {\n     static DateTimeOfYear cStartOfYear;\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n-    static {\n-        cVerbose.set(Boolean.FALSE);\n-    }\n+static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set; }\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n      * @return true to log verbosely\n      */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(cVerbose; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-11/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\t2022-07-19 19:31:17.707159502 +0200\n+++ /tmp/tmpui8ofh01.java\t2022-07-19 19:31:17.707159502 +0200\n@@ -63,14 +63,11 @@\n public class ZoneInfoCompiler {\n     static DateTimeOfYear cStartOfYear;\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n-    static {\n-        cVerbose.set(Boolean.FALSE);\n-    }\n+static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(cVerbose; }\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n      * @return true to log verbosely\n      */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(cVerbose); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-11/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\t2022-07-19 19:31:20.891143055 +0200\n+++ /tmp/tmpus16ce8m.java\t2022-07-19 19:31:20.895143032 +0200\n@@ -63,14 +63,11 @@\n public class ZoneInfoCompiler {\n     static DateTimeOfYear cStartOfYear;\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n-    static {\n-        cVerbose.set(Boolean.FALSE);\n-    }\n+static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(cVerbose); }\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n      * @return true to log verbosely\n      */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); }",
        "fixed_line": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>() { protected Boolean initialValue() { return Boolean.FALSE; } };"
    },
    "Math-27": {
        "fixes": [
            {
                "k": 1,
                "patch": "return multiply(100 instanceof multiply(100;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-27/src/main/java/org/apache/commons/math3/fraction/Fraction.java\t2022-07-19 19:31:24.499124419 +0200\n+++ /tmp/tmpx2s36auw.java\t2022-07-19 19:31:24.743123158 +0200\n@@ -592,11 +592,11 @@\n      * </p>\n      *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+return multiply(100 instanceof multiply(100;\n     }\n \n     /**\n      * <p>Creates a {@code Fraction} instance with the 2 parts\n      * of a fraction Y/Z.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return multiply(100 instanceof multiply(100);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-27/src/main/java/org/apache/commons/math3/fraction/Fraction.java\t2022-07-19 19:31:30.011095948 +0200\n+++ /tmp/tmpgbcy98hm.java\t2022-07-19 19:31:30.339094253 +0200\n@@ -592,11 +592,11 @@\n      * </p>\n      *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+return multiply(100 instanceof multiply(100);\n     }\n \n     /**\n      * <p>Creates a {@code Fraction} instance with the 2 parts\n      * of a fraction Y/Z.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return multiply(100).doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-27/src/main/java/org/apache/commons/math3/fraction/Fraction.java\t2022-07-19 19:31:33.067080163 +0200\n+++ /tmp/tmp68c8lp7j.java\t2022-07-19 19:31:33.067080163 +0200\n@@ -592,11 +592,11 @@\n      * </p>\n      *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+return multiply(100).doubleValue();\n     }\n \n     /**\n      * <p>Creates a {@code Fraction} instance with the 2 parts\n      * of a fraction Y/Z.</p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "returnnot(100).doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-27/src/main/java/org/apache/commons/math3/fraction/Fraction.java\t2022-07-19 19:32:08.494897168 +0200\n+++ /tmp/tmplomup5ww.java\t2022-07-19 19:32:08.542896919 +0200\n@@ -592,11 +592,11 @@\n      * </p>\n      *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+returnnot(100).doubleValue();\n     }\n \n     /**\n      * <p>Creates a {@code Fraction} instance with the 2 parts\n      * of a fraction Y/Z.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return multiply(100.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-27/src/main/java/org/apache/commons/math3/fraction/Fraction.java\t2022-07-19 19:32:10.954884461 +0200\n+++ /tmp/tmplpgcs6x4.java\t2022-07-19 19:32:10.954884461 +0200\n@@ -592,11 +592,11 @@\n      * </p>\n      *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+return multiply(100.doubleValue();\n     }\n \n     /**\n      * <p>Creates a {@code Fraction} instance with the 2 parts\n      * of a fraction Y/Z.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return neg(100).doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-27/src/main/java/org/apache/commons/math3/fraction/Fraction.java\t2022-07-19 19:32:12.994873922 +0200\n+++ /tmp/tmp59r3w384.java\t2022-07-19 19:32:12.998873904 +0200\n@@ -592,11 +592,11 @@\n      * </p>\n      *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+return neg(100).doubleValue();\n     }\n \n     /**\n      * <p>Creates a {@code Fraction} instance with the 2 parts\n      * of a fraction Y/Z.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return multiply(100;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-27/src/main/java/org/apache/commons/math3/fraction/Fraction.java\t2022-07-19 19:32:15.286862083 +0200\n+++ /tmp/tmptkzceqkg.java\t2022-07-19 19:32:15.286862083 +0200\n@@ -592,11 +592,11 @@\n      * </p>\n      *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+return multiply(100;\n     }\n \n     /**\n      * <p>Creates a {@code Fraction} instance with the 2 parts\n      * of a fraction Y/Z.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return numerator(100).doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-27/src/main/java/org/apache/commons/math3/fraction/Fraction.java\t2022-07-19 19:32:17.370851322 +0200\n+++ /tmp/tmpq2rjf4iy.java\t2022-07-19 19:32:17.370851322 +0200\n@@ -592,11 +592,11 @@\n      * </p>\n      *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+return numerator(100).doubleValue();\n     }\n \n     /**\n      * <p>Creates a {@code Fraction} instance with the 2 parts\n      * of a fraction Y/Z.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return b.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-27/src/main/java/org/apache/commons/math3/fraction/Fraction.java\t2022-07-19 19:32:19.638839606 +0200\n+++ /tmp/tmpng3ocmd9.java\t2022-07-19 19:32:19.642839584 +0200\n@@ -592,11 +592,11 @@\n      * </p>\n      *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+return b.doubleValue();\n     }\n \n     /**\n      * <p>Creates a {@code Fraction} instance with the 2 parts\n      * of a fraction Y/Z.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return multiply(100);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-27/src/main/java/org/apache/commons/math3/fraction/Fraction.java\t2022-07-19 19:32:21.910827869 +0200\n+++ /tmp/tmp1vbrj813.java\t2022-07-19 19:32:21.910827869 +0200\n@@ -592,11 +592,11 @@\n      * </p>\n      *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+return multiply(100);\n     }\n \n     /**\n      * <p>Creates a {@code Fraction} instance with the 2 parts\n      * of a fraction Y/Z.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return multiply(100).doubleValue();",
        "fixed_line": "return 100 * doubleValue();"
    },
    "Jsoup-25": {
        "fixes": [
            {
                "k": 1,
                "patch": "private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"link\"};\", \"title\"};\", \"U\"};\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-25/src/main/java/org/jsoup/parser/Tag.java\t2022-07-19 19:32:24.322815415 +0200\n+++ /tmp/tmp7f5zx91k.java\t2022-07-19 19:32:24.346815288 +0200\n@@ -213,11 +213,11 @@\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"link\"};\", \"title\"};\", \"U\"};\");\n \n     static {\n         // creates\n         for (String tagName : blockTags) {\n             Tag tag = new Tag(tagName);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"U\"};\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-25/src/main/java/org/jsoup/parser/Tag.java\t2022-07-19 19:32:26.314805124 +0200\n+++ /tmp/tmpprbgi5bz.java\t2022-07-19 19:32:26.314805124 +0200\n@@ -213,11 +213,11 @@\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"U\"};\");\n \n     static {\n         // creates\n         for (String tagName : blockTags) {\n             Tag tag = new Tag(tagName);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"title\"};\", \"U\"};\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-25/src/main/java/org/jsoup/parser/Tag.java\t2022-07-19 19:32:27.926796795 +0200\n+++ /tmp/tmpodne45rl.java\t2022-07-19 19:32:27.926796795 +0200\n@@ -213,11 +213,11 @@\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"title\"};\", \"U\"};\");\n \n     static {\n         // creates\n         for (String tagName : blockTags) {\n             Tag tag = new Tag(tagName);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"U\"};\", \"ESCAPE",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-25/src/main/java/org/jsoup/parser/Tag.java\t2022-07-19 19:32:29.398789192 +0200\n+++ /tmp/tmp4an60dn4.java\t2022-07-19 19:32:29.402789174 +0200\n@@ -213,11 +213,11 @@\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"U\"};\", \"ESCAPE\n \n     static {\n         // creates\n         for (String tagName : blockTags) {\n             Tag tag = new Tag(tagName);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"X84};",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-25/src/main/java/org/jsoup/parser/Tag.java\t2022-07-19 19:32:31.090780455 +0200\n+++ /tmp/tmpqybhenqc.java\t2022-07-19 19:32:31.094780434 +0200\n@@ -213,11 +213,11 @@\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"X84};\n \n     static {\n         // creates\n         for (String tagName : blockTags) {\n             Tag tag = new Tag(tagName);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"X84;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-25/src/main/java/org/jsoup/parser/Tag.java\t2022-07-19 19:32:32.626772521 +0200\n+++ /tmp/tmph8nkhwd7.java\t2022-07-19 19:32:32.626772521 +0200\n@@ -213,11 +213,11 @@\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"X84;\n \n     static {\n         // creates\n         for (String tagName : blockTags) {\n             Tag tag = new Tag(tagName);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"link\"};\", \"U\"};\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-25/src/main/java/org/jsoup/parser/Tag.java\t2022-07-19 19:32:34.118764812 +0200\n+++ /tmp/tmp6omiqisp.java\t2022-07-19 19:32:34.122764794 +0200\n@@ -213,11 +213,11 @@\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"link\"};\", \"U\"};\");\n \n     static {\n         // creates\n         for (String tagName : blockTags) {\n             Tag tag = new Tag(tagName);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"link\"};\", \"title\"};\", \"title\"};\", \"U\"};\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-25/src/main/java/org/jsoup/parser/Tag.java\t2022-07-19 19:32:35.754756361 +0200\n+++ /tmp/tmpiic6hwcq.java\t2022-07-19 19:32:35.754756361 +0200\n@@ -213,11 +213,11 @@\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"link\"};\", \"title\"};\", \"title\"};\", \"U\"};\");\n \n     static {\n         // creates\n         for (String tagName : blockTags) {\n             Tag tag = new Tag(tagName);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"title\"};\", \"U\"};\", \"ESCAPE",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-25/src/main/java/org/jsoup/parser/Tag.java\t2022-07-19 19:32:37.234748719 +0200\n+++ /tmp/tmp6idwvgzy.java\t2022-07-19 19:32:37.234748719 +0200\n@@ -213,11 +213,11 @@\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"title\"};\", \"U\"};\", \"ESCAPE\n \n     static {\n         // creates\n         for (String tagName : blockTags) {\n             Tag tag = new Tag(tagName);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"U\"};\", \"Era\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-25/src/main/java/org/jsoup/parser/Tag.java\t2022-07-19 19:32:38.786740702 +0200\n+++ /tmp/tmp18_r2qkg.java\t2022-07-19 19:32:38.790740680 +0200\n@@ -213,11 +213,11 @@\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"U\"};\", \"Era\");\n \n     static {\n         // creates\n         for (String tagName : blockTags) {\n             Tag tag = new Tag(tagName);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};",
        "fixed_line": "private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\", \"textarea\"};"
    },
    "Closure-133": {
        "fixes": [
            {
                "k": 1,
                "patch": "String String null = stream.getRemainingJSDocLine; }",
                "patch_diff": "String String null = stream.getRemainingJSDocLine; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = 0; i < line.getRemainingJSDocLine; i++) { String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name =",
                "patch_diff": "for (int i = 0; i < line.getRemainingJSDocLine; i++) { String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name =",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0; i < line.length; i++) { String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString();",
                "patch_diff": "for (int i = 0; i < line.length; i++) { String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = 0; i < line.length; i++) { String type = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString();",
                "patch_diff": "for (int i = 0; i < line.length; i++) { String type = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = 0; i < line.getRemainingJSDocLine; i++) { String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String type = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name =",
                "patch_diff": "for (int i = 0; i < line.getRemainingJSDocLine; i++) { String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String type = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name =",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = 0; i < line.length; i++) { String name = stream.getString(); String type = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString();",
                "patch_diff": "for (int i = 0; i < line.length; i++) { String name = stream.getString(); String type = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = 0; i < line.getRemainingJSDocLine; i++) { String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String string =",
                "patch_diff": "for (int i = 0; i < line.getRemainingJSDocLine; i++) { String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String string =",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = 0; i < line.getRemainingJSDocLine; i++) { String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); if (source",
                "patch_diff": "for (int i = 0; i < line.getRemainingJSDocLine; i++) { String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); if (source",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int i = 0; i < line.getRemainingJSDocLine; i++) { String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); if (name",
                "patch_diff": "for (int i = 0; i < line.getRemainingJSDocLine; i++) { String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); if (name",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = 0; i < line.getRemainingJSDocLine; i++) { String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); if (c",
                "patch_diff": "for (int i = 0; i < line.getRemainingJSDocLine; i++) { String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); String name = stream.getString(); if (c",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "unreadToken = NO_UNREAD_TOKEN;"
    },
    "Chart-24": {
        "fixes": [
            {
                "k": 1,
                "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound)) * (this.upperBound - v;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-24/source/org/jfree/chart/renderer/GrayPaintScale.java\t2022-07-19 19:32:42.994718967 +0200\n+++ /tmp/tmp80zeg5lm.java\t2022-07-19 19:32:43.042718723 +0200\n@@ -121,11 +121,11 @@\n      * @return A paint for the specified value.\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound)) * (this.upperBound - v;\n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n     \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) / (this.upperBound - this.lowerBound;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-24/source/org/jfree/chart/renderer/GrayPaintScale.java\t2022-07-19 19:32:45.778704588 +0200\n+++ /tmp/tmp3e7yff9a.java\t2022-07-19 19:32:45.778704588 +0200\n@@ -121,11 +121,11 @@\n      * @return A paint for the specified value.\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) / (this.upperBound - this.lowerBound;\n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n     \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound)) * (this.upperBound - this.lowerBound;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-24/source/org/jfree/chart/renderer/GrayPaintScale.java\t2022-07-19 19:32:47.534695515 +0200\n+++ /tmp/tmp9964dtxg.java\t2022-07-19 19:32:47.534695515 +0200\n@@ -121,11 +121,11 @@\n      * @return A paint for the specified value.\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound)) * (this.upperBound - this.lowerBound;\n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n     \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * (this.upperBound - this.lowerBound;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-24/source/org/jfree/chart/renderer/GrayPaintScale.java\t2022-07-19 19:32:49.142687209 +0200\n+++ /tmp/tmpp0ym5fi6.java\t2022-07-19 19:32:49.142687209 +0200\n@@ -121,11 +121,11 @@\n      * @return A paint for the specified value.\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * (this.upperBound - this.lowerBound;\n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n     \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound)) * (this.upperBound - this.upperBound;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-24/source/org/jfree/chart/renderer/GrayPaintScale.java\t2022-07-19 19:32:50.798678658 +0200\n+++ /tmp/tmpmymplv7i.java\t2022-07-19 19:32:50.802678637 +0200\n@@ -121,11 +121,11 @@\n      * @return A paint for the specified value.\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound)) * (this.upperBound - this.upperBound;\n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n     \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound)) / (this.upperBound - this.lowerBound;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-24/source/org/jfree/chart/renderer/GrayPaintScale.java\t2022-07-19 19:32:52.466670043 +0200\n+++ /tmp/tmp_n3houci.java\t2022-07-19 19:32:52.466670043 +0200\n@@ -121,11 +121,11 @@\n      * @return A paint for the specified value.\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound)) / (this.upperBound - this.lowerBound;\n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n     \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) / (this.upperBound - this.lowerBound);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-24/source/org/jfree/chart/renderer/GrayPaintScale.java\t2022-07-19 19:32:54.070661755 +0200\n+++ /tmp/tmpwxeof8ls.java\t2022-07-19 19:32:54.070661755 +0200\n@@ -121,11 +121,11 @@\n      * @return A paint for the specified value.\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) / (this.upperBound - this.lowerBound);\n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n     \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-24/source/org/jfree/chart/renderer/GrayPaintScale.java\t2022-07-19 19:32:55.694653367 +0200\n+++ /tmp/tmpk5h8xc42.java\t2022-07-19 19:32:55.694653367 +0200\n@@ -121,11 +121,11 @@\n      * @return A paint for the specified value.\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound;\n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n     \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-24/source/org/jfree/chart/renderer/GrayPaintScale.java\t2022-07-19 19:32:57.326644940 +0200\n+++ /tmp/tmp41h0malx.java\t2022-07-19 19:32:57.330644918 +0200\n@@ -121,11 +121,11 @@\n      * @return A paint for the specified value.\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound);\n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n     \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * (this.upperBound - v;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-24/source/org/jfree/chart/renderer/GrayPaintScale.java\t2022-07-19 19:32:58.906636779 +0200\n+++ /tmp/tmpyzy8l8en.java\t2022-07-19 19:32:58.906636779 +0200\n@@ -121,11 +121,11 @@\n      * @return A paint for the specified value.\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * (this.upperBound - v;\n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n     \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "int g = (int) ((value - this.lowerBound) / (this.upperBound",
        "fixed_line": "int g = (int) ((v - this.lowerBound) / (this.upperBound"
    },
    "Closure-150": {
        "fixes": [
            {
                "k": 1,
                "patch": "attachLiteralTypes( n.getType() == Token.FUNCTION;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-150/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 19:33:00.734627336 +0200\n+++ /tmp/tmpdatms61z.java\t2022-07-19 19:33:00.754627232 +0200\n@@ -1446,25 +1446,11 @@\n       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+attachLiteralTypes( n.getType() == Token.FUNCTION;\n     }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {\n       // Handle bleeding functions.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "attachLiteralTypes(parent, n.getType = Token.FUNCTION;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-150/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 19:33:02.670617337 +0200\n+++ /tmp/tmpqc7e6r11.java\t2022-07-19 19:33:02.670617337 +0200\n@@ -1446,25 +1446,11 @@\n       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+attachLiteralTypes(parent, n.getType = Token.FUNCTION;\n     }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {\n       // Handle bleeding functions.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "attachLiteralTypes(parent, n.getType() == Token.FUNCTION;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-150/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 19:33:04.166609610 +0200\n+++ /tmp/tmpv90w6agy.java\t2022-07-19 19:33:04.166609610 +0200\n@@ -1446,25 +1446,11 @@\n       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+attachLiteralTypes(parent, n.getType() == Token.FUNCTION;\n     }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {\n       // Handle bleeding functions.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "attachLiteralTypes(scope.getType() == Token.FUNCTION;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-150/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 19:33:05.774601302 +0200\n+++ /tmp/tmptk14244_.java\t2022-07-19 19:33:05.774601302 +0200\n@@ -1446,25 +1446,11 @@\n       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+attachLiteralTypes(scope.getType() == Token.FUNCTION;\n     }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {\n       // Handle bleeding functions.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "attachLiteralTypes(n.getType() == Token.FUNCTION;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-150/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 19:33:07.386592978 +0200\n+++ /tmp/tmp1fr6owdp.java\t2022-07-19 19:33:07.386592978 +0200\n@@ -1446,25 +1446,11 @@\n       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+attachLiteralTypes(n.getType() == Token.FUNCTION;\n     }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {\n       // Handle bleeding functions.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "attachLiteralTypes(parent.getType() == Token.FUNCTION;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-150/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 19:33:08.990584692 +0200\n+++ /tmp/tmp2wgtdqn5.java\t2022-07-19 19:33:08.990584692 +0200\n@@ -1446,25 +1446,11 @@\n       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+attachLiteralTypes(parent.getType() == Token.FUNCTION;\n     }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {\n       // Handle bleeding functions.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "attachLiteralTypes(parent, n.getType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-150/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 19:33:10.578576491 +0200\n+++ /tmp/tmprtdazeyx.java\t2022-07-19 19:33:10.578576491 +0200\n@@ -1446,25 +1446,11 @@\n       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+attachLiteralTypes(parent, n.getType()) {\n     }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {\n       // Handle bleeding functions.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "attachLiteralTypes( n.getType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-150/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 19:33:12.122568515 +0200\n+++ /tmp/tmpt8fbzsuv.java\t2022-07-19 19:33:12.122568515 +0200\n@@ -1446,25 +1446,11 @@\n       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+attachLiteralTypes( n.getType()) {\n     }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {\n       // Handle bleeding functions.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "attachLiteralTypes(parent, n.getType == Token.FUNCTION;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-150/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 19:33:13.662560560 +0200\n+++ /tmp/tmpu8xeq6hd.java\t2022-07-19 19:33:13.662560560 +0200\n@@ -1446,25 +1446,11 @@\n       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+attachLiteralTypes(parent, n.getType == Token.FUNCTION;\n     }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {\n       // Handle bleeding functions.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "attachLiteralTypes( n.getType = Token.FUNCTION;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-150/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 19:33:15.254552338 +0200\n+++ /tmp/tmpwwalbq07.java\t2022-07-19 19:33:15.254552338 +0200\n@@ -1446,25 +1446,11 @@\n       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+attachLiteralTypes( n.getType = Token.FUNCTION;\n     }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {\n       // Handle bleeding functions.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "attachLiteralTypes(n); switch (n.getType()) { case Token.FUNCTION: if (parent.getType() == Token.NAME) { return; } defineDeclaredFunction(n, parent); break; case Token.CATCH: defineCatch(n, parent); break; case Token.VAR: defineVar(n, parent); break; }",
        "fixed_line": "super.visit(t, n, parent);"
    },
    "Closure-81": {
        "fixes": [
            {
                "k": 1,
                "patch": "name = functionNode.getFunctionName();",
                "patch_diff": "name = functionNode.getFunctionName();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "name = functionNode.getFunctionName;",
                "patch_diff": "name = functionNode.getFunctionName;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "name = functionNode.getFunctionName(); Boolean isUnnamedFunction = false;",
                "patch_diff": "name = functionNode.getFunctionName(); Boolean isUnnamedFunction = false;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "Name name = functionNode.getFunctionName();",
                "patch_diff": "Name name = functionNode.getFunctionName();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "Name name = functionNode.getFunctionName(); Boolean isUnnamedFunction = false;",
                "patch_diff": "Name name = functionNode.getFunctionName(); Boolean isUnnamedFunction = false;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "name = functionNode.getFunctionName(); Boolean isUnnamedFunction = true;",
                "patch_diff": "name = functionNode.getFunctionName(); Boolean isUnnamedFunction = true;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "name = name.getFunctionName(); Boolean isUnnamedFunction = false;",
                "patch_diff": "name = name.getFunctionName(); Boolean isUnnamedFunction = false;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "name = Node.newFunctionName(); Boolean isUnnamedFunction = false;",
                "patch_diff": "name = Node.newFunctionName(); Boolean isUnnamedFunction = false;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "name = functionNode.getFunctionName(); Boolean isUnnamedFunction = false; }",
                "patch_diff": "name = functionNode.getFunctionName(); Boolean isUnnamedFunction = false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "name = node.getFunctionName(); Boolean isUnnamedFunction = false;",
                "patch_diff": "name = node.getFunctionName(); Boolean isUnnamedFunction = false;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "int functionType = functionNode.getFunctionType(); if (functionType != FunctionNode.FUNCTION_EXPRESSION) { errorReporter.error( \"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0); }"
    },
    "Chart-20": {
        "fixes": [
            {
                "k": 1,
                "patch": "super(paint, stroke, outlinePaint, alpha, stroke, alpha);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-20/source/org/jfree/chart/plot/ValueMarker.java\t2022-07-19 19:33:18.706534505 +0200\n+++ /tmp/tmpy8n256xp.java\t2022-07-19 19:33:18.730534383 +0200\n@@ -90,11 +90,11 @@\n      * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n      * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+super(paint, stroke, outlinePaint, alpha, stroke, alpha);\n         this.value = value;\n     }\n     \n     /**\n      * Returns the value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "super(paint, stroke, outlinePaint, alpha, alpha, stroke, alpha);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-20/source/org/jfree/chart/plot/ValueMarker.java\t2022-07-19 19:33:21.342520892 +0200\n+++ /tmp/tmpwarat2hm.java\t2022-07-19 19:33:21.346520869 +0200\n@@ -90,11 +90,11 @@\n      * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n      * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+super(paint, stroke, outlinePaint, alpha, alpha, stroke, alpha);\n         this.value = value;\n     }\n     \n     /**\n      * Returns the value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "super(paint, stroke, outlinePaint, paint, stroke, alpha);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-20/source/org/jfree/chart/plot/ValueMarker.java\t2022-07-19 19:33:23.086511884 +0200\n+++ /tmp/tmpcq9h9wmc.java\t2022-07-19 19:33:23.090511863 +0200\n@@ -90,11 +90,11 @@\n      * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n      * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+super(paint, stroke, outlinePaint, paint, stroke, alpha);\n         this.value = value;\n     }\n     \n     /**\n      * Returns the value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "super(paint, stroke, outlinePaint, bar, alpha);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-20/source/org/jfree/chart/plot/ValueMarker.java\t2022-07-19 19:33:24.790503080 +0200\n+++ /tmp/tmp9t48wl3c.java\t2022-07-19 19:33:24.794503062 +0200\n@@ -90,11 +90,11 @@\n      * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n      * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+super(paint, stroke, outlinePaint, bar, alpha);\n         this.value = value;\n     }\n     \n     /**\n      * Returns the value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "super(paint, stroke, outlinePaint, outlineStroke, alpha);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-20/source/org/jfree/chart/plot/ValueMarker.java\t2022-07-19 19:33:26.482494341 +0200\n+++ /tmp/tmpib002s1v.java\t2022-07-19 19:33:26.482494341 +0200\n@@ -90,11 +90,11 @@\n      * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n      * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+super(paint, stroke, outlinePaint, outlineStroke, alpha);\n         this.value = value;\n     }\n     \n     /**\n      * Returns the value.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 6,
                "patch": "super(paint, stroke, outlinePaint, stroke, alpha);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-20/source/org/jfree/chart/plot/ValueMarker.java\t2022-07-19 19:33:36.126444530 +0200\n+++ /tmp/tmpqcih2zuj.java\t2022-07-19 19:33:36.126444530 +0200\n@@ -90,11 +90,11 @@\n      * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n      * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+super(paint, stroke, outlinePaint, stroke, alpha);\n         this.value = value;\n     }\n     \n     /**\n      * Returns the value.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "super(label, stroke, paint, stroke, alpha);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-20/source/org/jfree/chart/plot/ValueMarker.java\t2022-07-19 19:33:43.742405192 +0200\n+++ /tmp/tmpnhzzme63.java\t2022-07-19 19:33:43.746405169 +0200\n@@ -90,11 +90,11 @@\n      * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n      * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+super(label, stroke, paint, stroke, alpha);\n         this.value = value;\n     }\n     \n     /**\n      * Returns the value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "super(paint, stroke, outlinePaint, alpha);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-20/source/org/jfree/chart/plot/ValueMarker.java\t2022-07-19 19:33:45.402396618 +0200\n+++ /tmp/tmpzi130w57.java\t2022-07-19 19:33:45.402396618 +0200\n@@ -90,11 +90,11 @@\n      * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n      * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+super(paint, stroke, outlinePaint, alpha);\n         this.value = value;\n     }\n     \n     /**\n      * Returns the value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "super(paint, stroke, outlinePaint, alpha, alpha, alpha, stroke, alpha);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-20/source/org/jfree/chart/plot/ValueMarker.java\t2022-07-19 19:33:47.158387546 +0200\n+++ /tmp/tmp7je4wt87.java\t2022-07-19 19:33:47.158387546 +0200\n@@ -90,11 +90,11 @@\n      * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n      * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+super(paint, stroke, outlinePaint, alpha, alpha, alpha, stroke, alpha);\n         this.value = value;\n     }\n     \n     /**\n      * Returns the value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "super(paint, stroke, outlinePaint, alpha, paint, stroke, alpha);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-20/source/org/jfree/chart/plot/ValueMarker.java\t2022-07-19 19:33:48.870378706 +0200\n+++ /tmp/tmpg44sbjp1.java\t2022-07-19 19:33:48.870378706 +0200\n@@ -90,11 +90,11 @@\n      * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n      * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+super(paint, stroke, outlinePaint, alpha, paint, stroke, alpha);\n         this.value = value;\n     }\n     \n     /**\n      * Returns the value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "super(paint, stroke, paint, stroke, alpha);",
        "fixed_line": "super(paint, stroke, outlinePaint, outlineStroke, alpha);"
    },
    "Closure-15": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {",
                "patch_diff": "for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// can't really modify it was non-literal characters that might be valid (NodeUtil.constructorCallHasSideEffects(c)) {",
                "patch_diff": "// can't really modify it was non-literal characters that might be valid (NodeUtil.constructorCallHasSideEffects(c)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (c!= null && c.constructorCallHasSideEffects) {",
                "patch_diff": "if (c!= null && c.constructorCallHasSideEffects) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// can't really modify it was non-literal characters that might be valid (NodeUtil.constructorCallHasSideEffects(c) {",
                "patch_diff": "// can't really modify it was non-literal characters that might be valid (NodeUtil.constructorCallHasSideEffects(c) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (NodeUtil.constructorCallHasSideEffects(c) && n.getFirstChild();",
                "patch_diff": "if (NodeUtil.constructorCallHasSideEffects(c) && n.getFirstChild();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return c = n.constructorCallHasSideEffects;",
                "patch_diff": "return c = n.constructorCallHasSideEffects;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// can't really modify it was non-literal characters that might be valid (NodeUtil.constructorCallHasSideEffects(c) && c.getFirstChild();",
                "patch_diff": "// can't really modify it was non-literal characters that might be valid (NodeUtil.constructorCallHasSideEffects(c) && c.getFirstChild();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// can't really modify it was non-literal characters that might be valid (NodeUtil.constructorCallHasSideEffects(c) && n.getFirstChild();",
                "patch_diff": "// can't really modify it was non-literal characters that might be valid (NodeUtil.constructorCallHasSideEffects(c) && n.getFirstChild();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (NodeUtil.constructorCallHasSideEffects(c) && c.getFirstChild();",
                "patch_diff": "if (NodeUtil.constructorCallHasSideEffects(c) && c.getFirstChild();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (Node c = n.constructorCallHasSideEffects; c = n.getNext()) {",
                "patch_diff": "for (Node c = n.constructorCallHasSideEffects; c = n.getNext()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (n.isDelProp()) { return true; }"
    },
    "Closure-19": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if (origType == null? getNativeType(UNKNOWN_TYPE) : origType;",
                "patch_diff": "// if (origType == null? getNativeType(UNKNOWN_TYPE) : origType;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// We can't really modify it was non-literal characters that might be valid (toType == null? getNativeType(UNKNOWN_TYPE) : origType;",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (toType == null? getNativeType(UNKNOWN_TYPE) : origType;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if (origType == null? getNativeType(OBJECT_TYPE) : origType;",
                "patch_diff": "// if (origType == null? getNativeType(OBJECT_TYPE) : origType;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// We can't really modify it was non-literal characters that might be valid (toType == null? getNativeType(OBJECT_TYPE) : origType;",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (toType == null? getNativeType(OBJECT_TYPE) : origType;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// TODO: throw new IllegalArgumentException(\"Node cannot be null? getNativeType(OBJECT_TYPE) : origType;",
                "patch_diff": "// TODO: throw new IllegalArgumentException(\"Node cannot be null? getNativeType(OBJECT_TYPE) : origType;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// We can't really modify it was non-literal characters that might be valid (toType == null? getNativeType(STRING_TYPE) : origType;",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (toType == null? getNativeType(STRING_TYPE) : origType;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// TODO: throw new IllegalArgumentException(\"Node cannot be null? getNativeType(UNKNOWN_TYPE) : origType;",
                "patch_diff": "// TODO: throw new IllegalArgumentException(\"Node cannot be null? getNativeType(UNKNOWN_TYPE) : origType;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// We can't really modify it was non-literal characters that might be valid (toType == null? getNativeType(NO_TYPE) : origType;",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (toType == null? getNativeType(NO_TYPE) : origType;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// We can't really modify it was non-literal characters that might be valid (toType == null? getNativeType(JSType) : origType;",
                "patch_diff": "// We can't really modify it was non-literal characters that might be valid (toType == null? getNativeType(JSType) : origType;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if (origType == null? getNativeType(JSType) : origType;",
                "patch_diff": "// if (origType == null? getNativeType(JSType) : origType;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "case Token.THIS: // \"this\" references aren't currently modeled in the CFG. break;"
    },
    "Jsoup-9": {
        "fixes": [
            {
                "k": 1,
                "patch": "private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|[a-Z]+';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-9/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 19:33:54.274350790 +0200\n+++ /tmp/tmp2upil03w.java\t2022-07-19 19:33:54.298350668 +0200\n@@ -33,11 +33,11 @@\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n-    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n+private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|[a-Z]+';\n \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|[a-Z]+country\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-9/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 19:33:56.014341805 +0200\n+++ /tmp/tmpny3ra5e3.java\t2022-07-19 19:33:56.018341782 +0200\n@@ -33,11 +33,11 @@\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n-    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n+private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|[a-Z]+country\");\n \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+country\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-9/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 19:33:59.162325543 +0200\n+++ /tmp/tmpk29iky6y.java\t2022-07-19 19:33:59.162325543 +0200\n@@ -33,11 +33,11 @@\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n-    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n+private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+country\");\n \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+Child);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-9/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 19:34:01.730312281 +0200\n+++ /tmp/tmpg9_9ylaz.java\t2022-07-19 19:34:01.730312281 +0200\n@@ -33,11 +33,11 @@\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n-    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n+private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+Child);\n \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-9/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 19:34:03.302304161 +0200\n+++ /tmp/tmpw24n9jk9.java\t2022-07-19 19:34:03.302304161 +0200\n@@ -33,11 +33,11 @@\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n-    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n+private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+';\n \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+ensure\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-9/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 19:34:04.850296166 +0200\n+++ /tmp/tmpwojc4cns.java\t2022-07-19 19:34:04.850296166 +0200\n@@ -33,11 +33,11 @@\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n-    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n+private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+ensure\");\n \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+Child\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-9/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 19:34:07.530282323 +0200\n+++ /tmp/tmpp9hm0akg.java\t2022-07-19 19:34:07.530282323 +0200\n@@ -33,11 +33,11 @@\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n-    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n+private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+Child\");\n \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+Static\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-9/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 19:34:10.258268230 +0200\n+++ /tmp/tmpugvbuuab.java\t2022-07-19 19:34:10.258268230 +0200\n@@ -33,11 +33,11 @@\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n-    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n+private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+Static\");\n \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+ determine\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-9/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 19:34:12.826254969 +0200\n+++ /tmp/tmpw81qf3jt.java\t2022-07-19 19:34:12.826254969 +0200\n@@ -33,11 +33,11 @@\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n-    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n+private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+ determine\");\n \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|[a-Z]+Child);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-9/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 19:34:15.566240817 +0200\n+++ /tmp/tmpt3pz7619.java\t2022-07-19 19:34:15.566240817 +0200\n@@ -33,11 +33,11 @@\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n-    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n+private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|[a-Z]+Child);\n \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");",
        "fixed_line": "private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+\\\\d*);?\");"
    },
    "Mockito-13": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode!=getMockAwareVerificationMode) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-13/src/org/mockito/internal/MockHandler.java\t2022-07-19 19:34:17.310231809 +0200\n+++ /tmp/tmpwimr5_kh.java\t2022-07-19 19:34:17.362231541 +0200\n@@ -72,11 +72,11 @@\n \n         //if verificationMode is not null then someone is doing verify()        \n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode!=getMockAwareVerificationMode) {\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n                 // this means there is an invocation on a different mock. Re-adding verification mode \n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode instanceofgetMockAwareVerificationMode) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-13/src/org/mockito/internal/MockHandler.java\t2022-07-19 19:34:19.994217945 +0200\n+++ /tmp/tmpk2gzlunp.java\t2022-07-19 19:34:19.994217945 +0200\n@@ -72,11 +72,11 @@\n \n         //if verificationMode is not null then someone is doing verify()        \n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode instanceofgetMockAwareVerificationMode) {\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n                 // this means there is an invocation on a different mock. Re-adding verification mode \n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode instanceofgetMockMode) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-13/src/org/mockito/internal/MockHandler.java\t2022-07-19 19:34:21.742208916 +0200\n+++ /tmp/tmp0_ost9pk.java\t2022-07-19 19:34:21.742208916 +0200\n@@ -72,11 +72,11 @@\n \n         //if verificationMode is not null then someone is doing verify()        \n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode instanceofgetMockMode) {\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n                 // this means there is an invocation on a different mock. Re-adding verification mode \n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode instanceofgetMockMockMode) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-13/src/org/mockito/internal/MockHandler.java\t2022-07-19 19:34:23.606199288 +0200\n+++ /tmp/tmp269jdpoq.java\t2022-07-19 19:34:23.606199288 +0200\n@@ -72,11 +72,11 @@\n \n         //if verificationMode is not null then someone is doing verify()        \n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode instanceofgetMockMockMode) {\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n                 // this means there is an invocation on a different mock. Re-adding verification mode \n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode == verificationMode.getMock()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-13/src/org/mockito/internal/MockHandler.java\t2022-07-19 19:34:25.614188914 +0200\n+++ /tmp/tmpiax5n77_.java\t2022-07-19 19:34:25.614188914 +0200\n@@ -72,11 +72,11 @@\n \n         //if verificationMode is not null then someone is doing verify()        \n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode == verificationMode.getMock()) {\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n                 // this means there is an invocation on a different mock. Re-adding verification mode \n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode instanceofgetMockAwareVerificationMode)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-13/src/org/mockito/internal/MockHandler.java\t2022-07-19 19:34:27.514179100 +0200\n+++ /tmp/tmp_a7m11h2.java\t2022-07-19 19:34:27.514179100 +0200\n@@ -72,11 +72,11 @@\n \n         //if verificationMode is not null then someone is doing verify()        \n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode instanceofgetMockAwareVerificationMode)) {\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n                 // this means there is an invocation on a different mock. Re-adding verification mode \n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode instanceofgetMock()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-13/src/org/mockito/internal/MockHandler.java\t2022-07-19 19:34:29.386169434 +0200\n+++ /tmp/tmpw0vjfcjq.java\t2022-07-19 19:34:29.386169434 +0200\n@@ -72,11 +72,11 @@\n \n         //if verificationMode is not null then someone is doing verify()        \n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode instanceofgetMock()) {\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n                 // this means there is an invocation on a different mock. Re-adding verification mode \n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-13/src/org/mockito/internal/MockHandler.java\t2022-07-19 19:34:31.270159702 +0200\n+++ /tmp/tmpkifbrprc.java\t2022-07-19 19:34:31.274159680 +0200\n@@ -72,11 +72,11 @@\n \n         //if verificationMode is not null then someone is doing verify()        \n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock()) {\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n                 // this means there is an invocation on a different mock. Re-adding verification mode \n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode instanceofgetMock') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-13/src/org/mockito/internal/MockHandler.java\t2022-07-19 19:34:33.730146996 +0200\n+++ /tmp/tmpy80mo08n.java\t2022-07-19 19:34:33.730146996 +0200\n@@ -72,11 +72,11 @@\n \n         //if verificationMode is not null then someone is doing verify()        \n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode instanceofgetMock') {\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n                 // this means there is an invocation on a different mock. Re-adding verification mode \n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode instanceofgetMockAware) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Mockito-13/src/org/mockito/internal/MockHandler.java\t2022-07-19 19:34:35.590137389 +0200\n+++ /tmp/tmpz5qaz93r.java\t2022-07-19 19:34:35.590137389 +0200\n@@ -72,11 +72,11 @@\n \n         //if verificationMode is not null then someone is doing verify()        \n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode instanceofgetMockAware) {\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n                 // this means there is an invocation on a different mock. Re-adding verification mode \n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {",
        "fixed_line": "if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) { VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher); verificationMode.verify(data); return null; } else { // this means there is an invocation on a different mock. Re-adding verification mode // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138) mockingProgress.verificationStarted(verificationMode);"
    },
    "Cli-14": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (option.validatevalidate(option.validate(option;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-14/src/java/org/apache/commons/cli2/option/GroupImpl.java\t2022-07-19 19:34:37.414127968 +0200\n+++ /tmp/tmpq516g0y7.java\t2022-07-19 19:34:37.478127638 +0200\n@@ -245,13 +245,11 @@\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n \n             // needs validation?\n             boolean validate = option.isRequired() || option instanceof Group;\n-            if (validate) {\n-                option.validate(commandLine);\n-            }\n+if (option.validatevalidate(option.validate(option;\n \n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n                 if (++present > maximum) {\n                     unexpected = option;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (option.validate(option.validate(option;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-14/src/java/org/apache/commons/cli2/option/GroupImpl.java\t2022-07-19 19:34:39.326118093 +0200\n+++ /tmp/tmpk24xtnef.java\t2022-07-19 19:34:39.326118093 +0200\n@@ -245,13 +245,11 @@\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n \n             // needs validation?\n             boolean validate = option.isRequired() || option instanceof Group;\n-            if (validate) {\n-                option.validate(commandLine);\n-            }\n+if (option.validate(option.validate(option;\n \n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n                 if (++present > maximum) {\n                     unexpected = option;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (option.validatevalidate(option;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-14/src/java/org/apache/commons/cli2/option/GroupImpl.java\t2022-07-19 19:34:40.882110056 +0200\n+++ /tmp/tmpu97xi5e4.java\t2022-07-19 19:34:40.886110035 +0200\n@@ -245,13 +245,11 @@\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n \n             // needs validation?\n             boolean validate = option.isRequired() || option instanceof Group;\n-            if (validate) {\n-                option.validate(commandLine);\n-            }\n+if (option.validatevalidate(option;\n \n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n                 if (++present > maximum) {\n                     unexpected = option;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (option.validateLine++commandLine;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-14/src/java/org/apache/commons/cli2/option/GroupImpl.java\t2022-07-19 19:34:42.498101709 +0200\n+++ /tmp/tmpa2dcl6cu.java\t2022-07-19 19:34:42.498101709 +0200\n@@ -245,13 +245,11 @@\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n \n             // needs validation?\n             boolean validate = option.isRequired() || option instanceof Group;\n-            if (validate) {\n-                option.validate(commandLine);\n-            }\n+if (option.validateLine++commandLine;\n \n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n                 if (++present > maximum) {\n                     unexpected = option;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (option.validate;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-14/src/java/org/apache/commons/cli2/option/GroupImpl.java\t2022-07-19 19:34:44.046093711 +0200\n+++ /tmp/tmpt_gshsnm.java\t2022-07-19 19:34:44.046093711 +0200\n@@ -245,13 +245,11 @@\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n \n             // needs validation?\n             boolean validate = option.isRequired() || option instanceof Group;\n-            if (validate) {\n-                option.validate(commandLine);\n-            }\n+if (option.validate;\n \n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n                 if (++present > maximum) {\n                     unexpected = option;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (option.validate(option;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-14/src/java/org/apache/commons/cli2/option/GroupImpl.java\t2022-07-19 19:34:45.730085015 +0200\n+++ /tmp/tmpy34kda4l.java\t2022-07-19 19:34:45.730085015 +0200\n@@ -245,13 +245,11 @@\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n \n             // needs validation?\n             boolean validate = option.isRequired() || option instanceof Group;\n-            if (validate) {\n-                option.validate(commandLine);\n-            }\n+if (option.validate(option;\n \n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n                 if (++present > maximum) {\n                     unexpected = option;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (option.validate) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-14/src/java/org/apache/commons/cli2/option/GroupImpl.java\t2022-07-19 19:34:48.074072908 +0200\n+++ /tmp/tmplphmiejp.java\t2022-07-19 19:34:48.074072908 +0200\n@@ -245,13 +245,11 @@\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n \n             // needs validation?\n             boolean validate = option.isRequired() || option instanceof Group;\n-            if (validate) {\n-                option.validate(commandLine);\n-            }\n+if (option.validate) {\n \n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n                 if (++present > maximum) {\n                     unexpected = option;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (option ==validate) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-14/src/java/org/apache/commons/cli2/option/GroupImpl.java\t2022-07-19 19:34:50.458060595 +0200\n+++ /tmp/tmph_a6b39b.java\t2022-07-19 19:34:50.458060595 +0200\n@@ -245,13 +245,11 @@\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n \n             // needs validation?\n             boolean validate = option.isRequired() || option instanceof Group;\n-            if (validate) {\n-                option.validate(commandLine);\n-            }\n+if (option ==validate) {\n \n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n                 if (++present > maximum) {\n                     unexpected = option;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (option ) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-14/src/java/org/apache/commons/cli2/option/GroupImpl.java\t2022-07-19 19:34:52.638049334 +0200\n+++ /tmp/tmpnzki9tur.java\t2022-07-19 19:34:52.638049334 +0200\n@@ -245,13 +245,11 @@\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n \n             // needs validation?\n             boolean validate = option.isRequired() || option instanceof Group;\n-            if (validate) {\n-                option.validate(commandLine);\n-            }\n+if (option ) {\n \n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n                 if (++present > maximum) {\n                     unexpected = option;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (option.validateLine;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-14/src/java/org/apache/commons/cli2/option/GroupImpl.java\t2022-07-19 19:34:55.426034934 +0200\n+++ /tmp/tmp8qwwb_vo.java\t2022-07-19 19:34:55.426034934 +0200\n@@ -245,13 +245,11 @@\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n \n             // needs validation?\n             boolean validate = option.isRequired() || option instanceof Group;\n-            if (validate) {\n-                option.validate(commandLine);\n-            }\n+if (option.validateLine;\n \n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n                 if (++present > maximum) {\n                     unexpected = option;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (validate) { option.validate(commandLine); }",
        "fixed_line": "validate = true; } if (validate) {"
    },
    "Closure-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if we can't really modify it was non-literal characters that might be valid (e if it.",
                "patch_diff": "// if we can't really modify it was non-literal characters that might be valid (e if it.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// if we can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "patch_diff": "// if we can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if we can't really modify it was non-literal characters that might be valid (e if it was -->",
                "patch_diff": "// if we can't really modify it was non-literal characters that might be valid (e if it was -->",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// if we can't really modify it was non-literal characters that might be valid (empty be",
                "patch_diff": "// if we can't really modify it was non-literal characters that might be valid (empty be",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// if we can't really modify it was non-literal characters that might be null or EMPTY",
                "patch_diff": "// if we can't really modify it was non-literal characters that might be null or EMPTY",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if we can't really modify it was non-literal characters that might be valid (e if it's",
                "patch_diff": "// if we can't really modify it was non-literal characters that might be valid (e if it's",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// if we can't really modify it was non-literal characters that might be valid (empty be valid)",
                "patch_diff": "// if we can't really modify it was non-literal characters that might be valid (empty be valid)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// if we can't really modify it was non-empty's do implicit re-parse",
                "patch_diff": "// if we can't really modify it was non-empty's do implicit re-parse",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// if we can't really modify it was non-literal characters that might be valid (e if it. //",
                "patch_diff": "// if we can't really modify it was non-literal characters that might be valid (e if it. //",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if we can't really modify it was non-literal characters that might be inlined.",
                "patch_diff": "// if we can't really modify it was non-literal characters that might be inlined.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (gramps.isDelProp()) { return false; }"
    },
    "Math-63": {
        "fixes": [
            {
                "k": 1,
                "patch": "return (Double.isNaN || Double.isNaN(x || y == y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-63/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 19:35:00.498008740 +0200\n+++ /tmp/tmpwvgug7vt.java\t2022-07-19 19:35:01.290004643 +0200\n@@ -412,11 +412,11 @@\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+return (Double.isNaN || Double.isNaN(x || y == y;\n     }\n \n     /**\n      * Returns true if both arguments are NaN or neither is NaN and they are\n      * equal as defined by {@link #equals(double,double) this method}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return (Double.isNaN || Double.isNaN(x)) || y == y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-63/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 19:35:04.909985948 +0200\n+++ /tmp/tmpu6tkxwom.java\t2022-07-19 19:35:04.909985948 +0200\n@@ -412,11 +412,11 @@\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+return (Double.isNaN || Double.isNaN(x)) || y == y;\n     }\n \n     /**\n      * Returns true if both arguments are NaN or neither is NaN and they are\n      * equal as defined by {@link #equals(double,double) this method}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return (Double.isNaN || Double.isNaN(x) || y == y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-63/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 19:35:07.925970370 +0200\n+++ /tmp/tmp9ugrx0c9.java\t2022-07-19 19:35:07.925970370 +0200\n@@ -412,11 +412,11 @@\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+return (Double.isNaN || Double.isNaN(x) || y == y;\n     }\n \n     /**\n      * Returns true if both arguments are NaN or neither is NaN and they are\n      * equal as defined by {@link #equals(double,double) this method}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return (Double.isNaN(x) || Double.isNaN || x == y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-63/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 19:35:11.265953119 +0200\n+++ /tmp/tmprj2_gf90.java\t2022-07-19 19:35:11.265953119 +0200\n@@ -412,11 +412,11 @@\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+return (Double.isNaN(x) || Double.isNaN || x == y;\n     }\n \n     /**\n      * Returns true if both arguments are NaN or neither is NaN and they are\n      * equal as defined by {@link #equals(double,double) this method}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return (Double.isNaN || Double.isNaN(x) || x == y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-63/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 19:35:13.905939482 +0200\n+++ /tmp/tmpbct33fv8.java\t2022-07-19 19:35:13.921939399 +0200\n@@ -412,11 +412,11 @@\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+return (Double.isNaN || Double.isNaN(x) || x == y;\n     }\n \n     /**\n      * Returns true if both arguments are NaN or neither is NaN and they are\n      * equal as defined by {@link #equals(double,double) this method}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return (Double.isNaN || Double.isNaN(x)) || x == y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-63/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 19:35:16.709925000 +0200\n+++ /tmp/tmpmcr2m1mj.java\t2022-07-19 19:35:16.709925000 +0200\n@@ -412,11 +412,11 @@\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+return (Double.isNaN || Double.isNaN(x)) || x == y;\n     }\n \n     /**\n      * Returns true if both arguments are NaN or neither is NaN and they are\n      * equal as defined by {@link #equals(double,double) this method}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return (Double.isNaN(x) || Double.isNaN(y || x == y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-63/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 19:35:19.557910289 +0200\n+++ /tmp/tmp_aduu_ku.java\t2022-07-19 19:35:19.561910267 +0200\n@@ -412,11 +412,11 @@\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+return (Double.isNaN(x) || Double.isNaN(y || x == y;\n     }\n \n     /**\n      * Returns true if both arguments are NaN or neither is NaN and they are\n      * equal as defined by {@link #equals(double,double) this method}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return (Double.isNaN || Double.isNaN || x == y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-63/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 19:35:22.333895950 +0200\n+++ /tmp/tmpn5dez5ut.java\t2022-07-19 19:35:22.333895950 +0200\n@@ -412,11 +412,11 @@\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+return (Double.isNaN || Double.isNaN || x == y;\n     }\n \n     /**\n      * Returns true if both arguments are NaN or neither is NaN and they are\n      * equal as defined by {@link #equals(double,double) this method}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return (x.isNaN || Double.isNaN(y || x == y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-63/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 19:35:25.069881818 +0200\n+++ /tmp/tmpnj0erude.java\t2022-07-19 19:35:25.069881818 +0200\n@@ -412,11 +412,11 @@\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+return (x.isNaN || Double.isNaN(y || x == y;\n     }\n \n     /**\n      * Returns true if both arguments are NaN or neither is NaN and they are\n      * equal as defined by {@link #equals(double,double) this method}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return (Double.isNaN(x) || Double.isNaN(y)) || x == y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-63/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 19:35:27.745867998 +0200\n+++ /tmp/tmp5xddrjx4.java\t2022-07-19 19:35:27.745867998 +0200\n@@ -412,11 +412,11 @@\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+return (Double.isNaN(x) || Double.isNaN(y)) || x == y;\n     }\n \n     /**\n      * Returns true if both arguments are NaN or neither is NaN and they are\n      * equal as defined by {@link #equals(double,double) this method}.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return (Double.isNaN(x) && Double.isNaN(y)) || x == y;",
        "fixed_line": "return equals(x, y, 1);"
    },
    "Codec-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "// Note: can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "// Note: can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// Note: we can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "// Note: we can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// Note: can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-notnotnotnotnotnotnotnotnot real number",
                "patch_diff": "// Note: can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-notnotnotnotnotnotnotnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// Note: can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-notnotnotnotnotnotnotnotnotnot real number",
                "patch_diff": "// Note: can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-notnotnotnotnotnotnotnotnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// Note: can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-notnotnotnotnotnotnotnot real number",
                "patch_diff": "// Note: can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-notnotnotnotnotnotnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// Note: can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-notnotnotnotnotnotnotnotnotnotnot real number",
                "patch_diff": "// Note: can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-notnotnotnotnotnotnotnotnotnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// Note: can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "// Note: can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-notnotnotnotnotnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// Note: can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-notnotnotnotnotnotnotnotnotnotnotnot real number",
                "patch_diff": "// Note: can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-notnotnotnotnotnotnotnotnotnotnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// Note: can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-notnotnotnotnotnot real number",
                "patch_diff": "// Note: can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-notnotnotnotnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// Note: can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-notnotnotnotnotnotnotnotnotnotnotnotnot real number",
                "patch_diff": "// Note: can't really modify it was non-literal characters that might be valid (empty be // as per [JACKSON-notnotnotnotnotnotnotnotnotnotnotnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "@Override public long skip(long n) throws IOException { if (n < 0) { throw new IllegalArgumentException(\"Negative skip length\"); } // skip in chunks of 512 bytes final byte[] b = new byte[512]; final int max = (int) Math.min(n, Integer.MAX_VALUE); int total = 0; while (total < max) { int len = max - total; if (len > b.length) { len = b.length; } len = read(b, 0, len); if (len == EOF) { break; } total += len; } return total; } /** * {@inheritDoc} * * @return <code>0</code> if the {@link InputStream} has reached <code>EOF</code>, * <code>1</code> otherwise */ public int available() throws IOException { // Note: the logic is similar to the InflaterInputStream: // as long as we have not reached EOF, indicate that there is more // data available. As we do not know for sure how much data is left, // just return 1 as a safe guess. // use the EOF flag of the underlying codec instance if (baseNCodec.eof) { return 0; } else { return 1; } }"
    },
    "Closure-48": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (valueType == null && rhsValue!= null &&!scope.isFunction() &&!scope.isDeclared(qName, false) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-48/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 19:36:15.045623689 +0200\n+++ /tmp/tmpmzfpwimz.java\t2022-07-19 19:36:15.901619267 +0200\n@@ -1516,15 +1516,11 @@\n             || (info.isConstant() && valueType != null\n                 && !valueType.isUnknownType())\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+if (valueType == null && rhsValue!= null &&!scope.isFunction() &&!scope.isDeclared(qName, false) {\n       }\n \n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (valueType!= null && rhsValue!= null && (info.isFunction() &&!scope.isDeclared(qName, false ||!scope.isDeclared(qName, false) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-48/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 19:36:22.161586934 +0200\n+++ /tmp/tmp10x_mu5m.java\t2022-07-19 19:36:22.161586934 +0200\n@@ -1516,15 +1516,11 @@\n             || (info.isConstant() && valueType != null\n                 && !valueType.isUnknownType())\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+if (valueType!= null && rhsValue!= null && (info.isFunction() &&!scope.isDeclared(qName, false ||!scope.isDeclared(qName, false) {\n       }\n \n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (valueType == null && rhsValue!= null && rhsValue.isFunction() &&!scope.isDeclared(qName, false) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-48/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 19:36:26.929562306 +0200\n+++ /tmp/tmpwa2x5lej.java\t2022-07-19 19:36:26.965562121 +0200\n@@ -1516,15 +1516,11 @@\n             || (info.isConstant() && valueType != null\n                 && !valueType.isUnknownType())\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+if (valueType == null && rhsValue!= null && rhsValue.isFunction() &&!scope.isDeclared(qName, false) {\n       }\n \n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (valueType!= null && rhsValue!= null &&!scope.isFunction() &&!scope.isDeclared(qName, false) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-48/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 19:36:30.453544105 +0200\n+++ /tmp/tmp9555hud2.java\t2022-07-19 19:36:30.453544105 +0200\n@@ -1516,15 +1516,11 @@\n             || (info.isConstant() && valueType != null\n                 && !valueType.isUnknownType())\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+if (valueType!= null && rhsValue!= null &&!scope.isFunction() &&!scope.isDeclared(qName, false) {\n       }\n \n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (valueType!= null && rhsValue!= null && (info.isFunction() &&!scope.isDeclared(qName, false) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-48/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 19:36:34.001525779 +0200\n+++ /tmp/tmpll857v2w.java\t2022-07-19 19:36:34.005525758 +0200\n@@ -1516,15 +1516,11 @@\n             || (info.isConstant() && valueType != null\n                 && !valueType.isUnknownType())\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+if (valueType!= null && rhsValue!= null && (info.isFunction() &&!scope.isDeclared(qName, false) {\n       }\n \n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (valueType!= null && rhsValue!= null && rhsValue.isFunction() &&!scope.isDeclared(qName, false) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-48/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 19:36:37.465507887 +0200\n+++ /tmp/tmpdgkxwa1g.java\t2022-07-19 19:36:37.469507866 +0200\n@@ -1516,15 +1516,11 @@\n             || (info.isConstant() && valueType != null\n                 && !valueType.isUnknownType())\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+if (valueType!= null && rhsValue!= null && rhsValue.isFunction() &&!scope.isDeclared(qName, false) {\n       }\n \n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (valueType && rhsValue!= null && rhsValue.isFunction() &&!scope.isDeclared(qName, false) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-48/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 19:36:40.901490141 +0200\n+++ /tmp/tmpthdkzg4q.java\t2022-07-19 19:36:40.901490141 +0200\n@@ -1516,15 +1516,11 @@\n             || (info.isConstant() && valueType != null\n                 && !valueType.isUnknownType())\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+if (valueType && rhsValue!= null && rhsValue.isFunction() &&!scope.isDeclared(qName, false) {\n       }\n \n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (valueType == null && rhsValue!= null && (info.isFunction() &&!scope.isDeclared(qName, false ||!scope.isDeclared(qName, false) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-48/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 19:36:44.369472228 +0200\n+++ /tmp/tmpxt7q6u6f.java\t2022-07-19 19:36:44.373472207 +0200\n@@ -1516,15 +1516,11 @@\n             || (info.isConstant() && valueType != null\n                 && !valueType.isUnknownType())\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+if (valueType == null && rhsValue!= null && (info.isFunction() &&!scope.isDeclared(qName, false ||!scope.isDeclared(qName, false) {\n       }\n \n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (valueType == null || rhsValue!= null &&!scope.isFunction() &&!scope.isDeclared(qName, false) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-48/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 19:36:47.709454976 +0200\n+++ /tmp/tmpr_njhekc.java\t2022-07-19 19:36:47.713454955 +0200\n@@ -1516,15 +1516,11 @@\n             || (info.isConstant() && valueType != null\n                 && !valueType.isUnknownType())\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+if (valueType == null || rhsValue!= null &&!scope.isFunction() &&!scope.isDeclared(qName, false) {\n       }\n \n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (valueType == null && rhsValue!= null && (info.isFunction() &&!scope.isDeclared(qName, false) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-48/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 19:36:51.173437085 +0200\n+++ /tmp/tmpq34fwuqw.java\t2022-07-19 19:36:51.173437085 +0200\n@@ -1516,15 +1516,11 @@\n             || (info.isConstant() && valueType != null\n                 && !valueType.isUnknownType())\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+if (valueType == null && rhsValue!= null && (info.isFunction() &&!scope.isDeclared(qName, false) {\n       }\n \n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (inferred) { // Determining declaration for #2 inferred = !(rhsValue != null && rhsValue.isFunction() && (info != null || !scope.isDeclared(qName, false)));",
        "fixed_line": "if (inferred && rhsValue != null && rhsValue.isFunction()) { // Determining declaration for #2 if (info != null) { inferred = false; } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) { inferred = false; }"
    },
    "Codec-7": {
        "fixes": [
            {
                "k": 1,
                "patch": "return StringUtils.newStringUtf8(_base64Data, true));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-7/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 19:36:54.633419212 +0200\n+++ /tmp/tmp8czq2xp5.java\t2022-07-19 19:36:54.665419048 +0200\n@@ -665,11 +665,11 @@\n      *            binary data to encode\n      * @return String containing Base64 characters.\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+return StringUtils.newStringUtf8(_base64Data, true));\n     }\n     \n     /**\n      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n      * url-safe variation emits - and _ instead of + and / characters.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return StringUtils.newStringUtf8(base64Data, false));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-7/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 19:36:56.437409895 +0200\n+++ /tmp/tmpwjqlfsuv.java\t2022-07-19 19:36:56.437409895 +0200\n@@ -665,11 +665,11 @@\n      *            binary data to encode\n      * @return String containing Base64 characters.\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+return StringUtils.newStringUtf8(base64Data, false));\n     }\n     \n     /**\n      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n      * url-safe variation emits - and _ instead of + and / characters.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return StringUtils.newStringUtf8(_base64Data, false));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-7/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 19:36:57.901402334 +0200\n+++ /tmp/tmp6uhn45vz.java\t2022-07-19 19:36:57.905402312 +0200\n@@ -665,11 +665,11 @@\n      *            binary data to encode\n      * @return String containing Base64 characters.\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+return StringUtils.newStringUtf8(_base64Data, false));\n     }\n     \n     /**\n      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n      * url-safe variation emits - and _ instead of + and / characters.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return StringUtils.newStringUtf8Base64(binaryData, false));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-7/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 19:36:59.497394090 +0200\n+++ /tmp/tmpo6sd9yft.java\t2022-07-19 19:36:59.497394090 +0200\n@@ -665,11 +665,11 @@\n      *            binary data to encode\n      * @return String containing Base64 characters.\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+return StringUtils.newStringUtf8Base64(binaryData, false));\n     }\n     \n     /**\n      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n      * url-safe variation emits - and _ instead of + and / characters.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return StringUtils.newStringUtf8(base64Data, true));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-7/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 19:37:01.141385598 +0200\n+++ /tmp/tmp40nnu7uc.java\t2022-07-19 19:37:01.145385579 +0200\n@@ -665,11 +665,11 @@\n      *            binary data to encode\n      * @return String containing Base64 characters.\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+return StringUtils.newStringUtf8(base64Data, true));\n     }\n     \n     /**\n      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n      * url-safe variation emits - and _ instead of + and / characters.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return StringUtils.newStringUtf8Base64(binaryData, true));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-7/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 19:37:02.709377501 +0200\n+++ /tmp/tmpef3vr0lj.java\t2022-07-19 19:37:02.709377501 +0200\n@@ -665,11 +665,11 @@\n      *            binary data to encode\n      * @return String containing Base64 characters.\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+return StringUtils.newStringUtf8Base64(binaryData, true));\n     }\n     \n     /**\n      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n      * url-safe variation emits - and _ instead of + and / characters.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return StringUtils.newStringUtf8(encodeBase64Data, false));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-7/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 19:37:04.437368575 +0200\n+++ /tmp/tmpqad3rzt5.java\t2022-07-19 19:37:04.437368575 +0200\n@@ -665,11 +665,11 @@\n      *            binary data to encode\n      * @return String containing Base64 characters.\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+return StringUtils.newStringUtf8(encodeBase64Data, false));\n     }\n     \n     /**\n      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n      * url-safe variation emits - and _ instead of + and / characters.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return StringUtils.newStringUtf8(formatData, true));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-7/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 19:37:06.149359733 +0200\n+++ /tmp/tmpa0pah8u7.java\t2022-07-19 19:37:06.149359733 +0200\n@@ -665,11 +665,11 @@\n      *            binary data to encode\n      * @return String containing Base64 characters.\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+return StringUtils.newStringUtf8(formatData, true));\n     }\n     \n     /**\n      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n      * url-safe variation emits - and _ instead of + and / characters.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return StringUtils.newStringUtf8(binaryData, false));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-7/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 19:37:07.689351778 +0200\n+++ /tmp/tmpwcwqkk00.java\t2022-07-19 19:37:07.689351778 +0200\n@@ -665,11 +665,11 @@\n      *            binary data to encode\n      * @return String containing Base64 characters.\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+return StringUtils.newStringUtf8(binaryData, false));\n     }\n     \n     /**\n      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n      * url-safe variation emits - and _ instead of + and / characters.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return StringUtils.newStringUtf8(binaryData, true));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-7/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 19:37:09.241343762 +0200\n+++ /tmp/tmpfa38tqjl.java\t2022-07-19 19:37:09.241343762 +0200\n@@ -665,11 +665,11 @@\n      *            binary data to encode\n      * @return String containing Base64 characters.\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+return StringUtils.newStringUtf8(binaryData, true));\n     }\n     \n     /**\n      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n      * url-safe variation emits - and _ instead of + and / characters.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return StringUtils.newStringUtf8(encodeBase64(binaryData, true));",
        "fixed_line": "return StringUtils.newStringUtf8(encodeBase64(binaryData, false));"
    },
    "JacksonDatabind-16": {
        "fixes": [
            {
                "k": 1,
                "patch": "return (previous!= null && previous.equals;ann.equals(ann);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-16/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\t2022-07-19 19:37:10.925335063 +0200\n+++ /tmp/tmp9g36cy4z.java\t2022-07-19 19:37:10.985334752 +0200\n@@ -107,10 +107,10 @@\n     protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+return (previous!= null && previous.equals;ann.equals(ann);\n     }\n }\n \n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return (previous!= null && previous.equals(annName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-16/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\t2022-07-19 19:37:12.865325044 +0200\n+++ /tmp/tmpa651slg5.java\t2022-07-19 19:37:12.865325044 +0200\n@@ -107,10 +107,10 @@\n     protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+return (previous!= null && previous.equals(annName);\n     }\n }\n \n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return previous!= null && previous.equals(annName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-16/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\t2022-07-19 19:37:14.413317049 +0200\n+++ /tmp/tmpq7pcjdck.java\t2022-07-19 19:37:14.413317049 +0200\n@@ -107,10 +107,10 @@\n     protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+return previous!= null && previous.equals(annName);\n     }\n }\n \n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return (previous!= null && previous.equals(ann));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-16/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\t2022-07-19 19:37:16.349307050 +0200\n+++ /tmp/tmp580lw5l5.java\t2022-07-19 19:37:16.353307029 +0200\n@@ -107,10 +107,10 @@\n     protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+return (previous!= null && previous.equals(ann));\n     }\n }\n \n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return (previous!= null) && previous.equals(ann;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-16/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\t2022-07-19 19:37:47.777144722 +0200\n+++ /tmp/tmpmxyhb17z.java\t2022-07-19 19:37:47.777144722 +0200\n@@ -107,10 +107,10 @@\n     protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+return (previous!= null) && previous.equals(ann;\n     }\n }\n \n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return (previous!= null && previous.equals(ann;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-16/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\t2022-07-19 19:37:49.409136294 +0200\n+++ /tmp/tmphgpf_fkt.java\t2022-07-19 19:37:49.409136294 +0200\n@@ -107,10 +107,10 @@\n     protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+return (previous!= null && previous.equals(ann;\n     }\n }\n \n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return (previous!= null && previous.equals(ann);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-16/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\t2022-07-19 19:37:51.021127967 +0200\n+++ /tmp/tmphkllso5x.java\t2022-07-19 19:37:51.021127967 +0200\n@@ -107,10 +107,10 @@\n     protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+return (previous!= null && previous.equals(ann);\n     }\n }\n \n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return (previous!= null) && previous.equals(ann);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-16/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\t2022-07-19 19:37:52.545120096 +0200\n+++ /tmp/tmpzf0kpxsd.java\t2022-07-19 19:37:52.549120075 +0200\n@@ -107,10 +107,10 @@\n     protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+return (previous!= null) && previous.equals(ann);\n     }\n }\n \n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return (previous!= null && previous.equals;ann.equals(ann));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-16/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\t2022-07-19 19:38:21.516970455 +0200\n+++ /tmp/tmpeojadm2j.java\t2022-07-19 19:38:21.516970455 +0200\n@@ -107,10 +107,10 @@\n     protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+return (previous!= null && previous.equals;ann.equals(ann));\n     }\n }\n \n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return (previous!= null) && previous.equals(annName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-16/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\t2022-07-19 19:38:23.040962583 +0200\n+++ /tmp/tmp70fjk3w8.java\t2022-07-19 19:38:23.040962583 +0200\n@@ -107,10 +107,10 @@\n     protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+return (previous!= null) && previous.equals(annName);\n     }\n }\n \n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return (previous != null) && previous.equals(ann);",
        "fixed_line": "return (previous == null) || !previous.equals(ann);"
    },
    "Closure-70": {
        "fixes": [
            {
                "k": 1,
                "patch": "jsDocParameter.getJSType(), true; // jsDocParameter, jsDocParameter)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-70/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 19:38:24.812953429 +0200\n+++ /tmp/tmpqfr4kmrc.java\t2022-07-19 19:38:24.844953266 +0200\n@@ -1740,11 +1740,11 @@\n         if (jsDocParameters != null) {\n           Node jsDocParameter = jsDocParameters.getFirstChild();\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+jsDocParameter.getJSType(), true; // jsDocParameter, jsDocParameter)\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n             }\n           }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "jsDocParameter.getJSType(), true; // jsDocParameter: jsDocParameter.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-70/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 19:38:28.016936880 +0200\n+++ /tmp/tmp409nz2nd.java\t2022-07-19 19:38:28.016936880 +0200\n@@ -1740,11 +1740,11 @@\n         if (jsDocParameters != null) {\n           Node jsDocParameter = jsDocParameters.getFirstChild();\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+jsDocParameter.getJSType(), true; // jsDocParameter: jsDocParameter.\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n             }\n           }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "jsDocParameter.getJSType(), false; // jsDocParameter: jsDocParameter.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-70/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 19:38:30.728922875 +0200\n+++ /tmp/tmpsy0rnbrr.java\t2022-07-19 19:38:30.728922875 +0200\n@@ -1740,11 +1740,11 @@\n         if (jsDocParameters != null) {\n           Node jsDocParameter = jsDocParameters.getFirstChild();\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+jsDocParameter.getJSType(), false; // jsDocParameter: jsDocParameter.\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n             }\n           }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "jsDocParameter.getJSType(), false; // jsDocParameter, jsDocParameter)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-70/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 19:38:33.424908948 +0200\n+++ /tmp/tmpczknhzhj.java\t2022-07-19 19:38:33.424908948 +0200\n@@ -1740,11 +1740,11 @@\n         if (jsDocParameters != null) {\n           Node jsDocParameter = jsDocParameters.getFirstChild();\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+jsDocParameter.getJSType(), false; // jsDocParameter, jsDocParameter)\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n             }\n           }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "jsDocParameter.getJSType(), true; // jsDocParameter: jsDocParameter, jsDocParameter)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-70/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 19:38:35.888896223 +0200\n+++ /tmp/tmpbng1ei_v.java\t2022-07-19 19:38:35.888896223 +0200\n@@ -1740,11 +1740,11 @@\n         if (jsDocParameters != null) {\n           Node jsDocParameter = jsDocParameters.getFirstChild();\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+jsDocParameter.getJSType(), true; // jsDocParameter: jsDocParameter, jsDocParameter)\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n             }\n           }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "jsDocParameter.getJSType(), false; // jsDocParameter.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-70/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 19:38:38.508882691 +0200\n+++ /tmp/tmpg584muag.java\t2022-07-19 19:38:38.508882691 +0200\n@@ -1740,11 +1740,11 @@\n         if (jsDocParameters != null) {\n           Node jsDocParameter = jsDocParameters.getFirstChild();\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+jsDocParameter.getJSType(), false; // jsDocParameter.\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n             }\n           }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "jsDocParameter.getJSType(), true; // jsDocParameter.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-70/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 19:38:41.076869427 +0200\n+++ /tmp/tmpzozn1j4o.java\t2022-07-19 19:38:41.080869406 +0200\n@@ -1740,11 +1740,11 @@\n         if (jsDocParameters != null) {\n           Node jsDocParameter = jsDocParameters.getFirstChild();\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+jsDocParameter.getJSType(), true; // jsDocParameter.\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n             }\n           }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "jsDocParameter.getJSType(), true; // jsDocParameter, jsDocParameter.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-70/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 19:38:43.812855296 +0200\n+++ /tmp/tmpqpimbt06.java\t2022-07-19 19:38:43.812855296 +0200\n@@ -1740,11 +1740,11 @@\n         if (jsDocParameters != null) {\n           Node jsDocParameter = jsDocParameters.getFirstChild();\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+jsDocParameter.getJSType(), true; // jsDocParameter, jsDocParameter.\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n             }\n           }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "jsDocParameter.getJSType(), true; // jsDocParameter)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-70/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 19:38:46.416841846 +0200\n+++ /tmp/tmpi8zy8k9r.java\t2022-07-19 19:38:46.416841846 +0200\n@@ -1740,11 +1740,11 @@\n         if (jsDocParameters != null) {\n           Node jsDocParameter = jsDocParameters.getFirstChild();\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+jsDocParameter.getJSType(), true; // jsDocParameter)\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n             }\n           }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "jsDocParameter.getJSType(), false; // jsDocParameter: jsDocParameter, jsDocParameter)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-70/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 19:38:48.960828706 +0200\n+++ /tmp/tmp8ia6hi84.java\t2022-07-19 19:38:48.964828685 +0200\n@@ -1740,11 +1740,11 @@\n         if (jsDocParameters != null) {\n           Node jsDocParameter = jsDocParameters.getFirstChild();\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+jsDocParameter.getJSType(), false; // jsDocParameter: jsDocParameter, jsDocParameter)\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n             }\n           }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "jsDocParameter.getJSType(), true);",
        "fixed_line": "jsDocParameter.getJSType(), false);"
    },
    "Closure-20": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (value == null) { // block == null; can't really modify it's do implicit re-initialized (value!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-20/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 19:38:51.840813829 +0200\n+++ /tmp/tmp7lmxgbwo.java\t2022-07-19 19:38:51.892813562 +0200\n@@ -215,11 +215,11 @@\n       //\n       // We can't do this in the general case, because String(a) has\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+if (value == null) { // block == null; can't really modify it's do implicit re-initialized (value!= null) {\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n         n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (value == null) { // block == null; can't really modify it's do implicit re-initialized or EMPTY",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-20/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 19:39:36.392583719 +0200\n+++ /tmp/tmp7rpw73fw.java\t2022-07-19 19:39:36.392583719 +0200\n@@ -215,11 +215,11 @@\n       //\n       // We can't do this in the general case, because String(a) has\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+if (value == null) { // block == null; can't really modify it's do implicit re-initialized or EMPTY\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n         n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (value == null) { // block == null; can't really here here (value!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-20/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 19:40:16.220378008 +0200\n+++ /tmp/tmpj4e9gc_b.java\t2022-07-19 19:40:16.224377987 +0200\n@@ -215,11 +215,11 @@\n       //\n       // We can't do this in the general case, because String(a) has\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+if (value == null) { // block == null; can't really here here (value!= null) {\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n         n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (value == null) { // block == null; can't be null if we're not.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-20/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 19:40:56.212171449 +0200\n+++ /tmp/tmpq3i2lok9.java\t2022-07-19 19:40:56.212171449 +0200\n@@ -215,11 +215,11 @@\n       //\n       // We can't do this in the general case, because String(a) has\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+if (value == null) { // block == null; can't be null if we're not.\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n         n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (value == null) { // block == null; can't really modify it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-20/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 19:41:35.679967600 +0200\n+++ /tmp/tmpihe12bvm.java\t2022-07-19 19:41:35.679967600 +0200\n@@ -215,11 +215,11 @@\n       //\n       // We can't do this in the general case, because String(a) has\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+if (value == null) { // block == null; can't really modify it's do implicit re-parse\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n         n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (value == null) { // block == null; can't be null if we't really modify it's do implicit re-initialized or EMPTY",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-20/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 19:42:15.783760463 +0200\n+++ /tmp/tmpqm1zw37g.java\t2022-07-19 19:42:15.787760445 +0200\n@@ -215,11 +215,11 @@\n       //\n       // We can't do this in the general case, because String(a) has\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+if (value == null) { // block == null; can't be null if we't really modify it's do implicit re-initialized or EMPTY\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n         n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (value == null) { // block == null; can't be null if we're not use a native function.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-20/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 19:42:55.271556512 +0200\n+++ /tmp/tmp9q851aze.java\t2022-07-19 19:42:55.275556491 +0200\n@@ -215,11 +215,11 @@\n       //\n       // We can't do this in the general case, because String(a) has\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+if (value == null) { // block == null; can't be null if we're not use a native function.\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n         n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (value == null) { // block == null; can't be null if we't really modify it's do implicit re-initialized (value!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-20/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 19:43:34.531353737 +0200\n+++ /tmp/tmp6u3dpign.java\t2022-07-19 19:43:34.531353737 +0200\n@@ -215,11 +215,11 @@\n       //\n       // We can't do this in the general case, because String(a) has\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+if (value == null) { // block == null; can't be null if we't really modify it's do implicit re-initialized (value!= null) {\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n         n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (value == null) { // block == null; can't be null if we't be null if we're not use a native function.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-20/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 19:44:14.503147285 +0200\n+++ /tmp/tmp14m1iwjm.java\t2022-07-19 19:44:14.507147264 +0200\n@@ -215,11 +215,11 @@\n       //\n       // We can't do this in the general case, because String(a) has\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+if (value == null) { // block == null; can't be null if we't be null if we're not use a native function.\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n         n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (value == null) { // block == null; can't really here here (value!= null) { // block == null; can't really modify it's do implicit re-initialized or EMPTY",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-20/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 19:44:53.658945047 +0200\n+++ /tmp/tmput0vfxp3.java\t2022-07-19 19:44:53.658945047 +0200\n@@ -215,11 +215,11 @@\n       //\n       // We can't do this in the general case, because String(a) has\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+if (value == null) { // block == null; can't really here here (value!= null) { // block == null; can't really modify it's do implicit re-initialized or EMPTY\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n         n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (value != null) {",
        "fixed_line": "if (value != null && value.getNext() == null && NodeUtil.isImmutableValue(value)) {"
    },
    "Lang-49": {
        "fixes": [
            {
                "k": 1,
                "patch": "int gcd = this.numerator / gcd;",
                "patch_diff": "int gcd = this.numerator / gcd;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (gcd == 1) {",
                "patch_diff": "} else if (gcd == 1) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if (gcd == 1) {",
                "patch_diff": "// if (gcd == 1) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (gcd == 1) {",
                "patch_diff": "if (gcd == 1) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "do { int gcd = this.numerator; if (gcd == 1) { this.numerator = gcd; } } else if (numerator == 1) {",
                "patch_diff": "do { int gcd = this.numerator; if (gcd == 1) { this.numerator = gcd; } } else if (numerator == 1) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "do { int gcd = this.numerator; if (gcd == 1) { this.numerator = gcd; } }",
                "patch_diff": "do { int gcd = this.numerator; if (gcd == 1) { this.numerator = gcd; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "do { int gcd = this.numerator; if (gcd == 1) {",
                "patch_diff": "do { int gcd = this.numerator; if (gcd == 1) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "do { int gcd = this.numerator; if (gcd == 1) { this.numerator = gcd; } if (gcd == 1) {",
                "patch_diff": "do { int gcd = this.numerator; if (gcd == 1) { this.numerator = gcd; } if (gcd == 1) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int gcd = this.numerator * gcd;",
                "patch_diff": "int gcd = this.numerator * gcd;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (numerator / gcd) {",
                "patch_diff": "} else if (numerator / gcd) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (numerator == 0) { return equals(ZERO) ? this : ZERO; }"
    },
    "Chart-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (index >= 0 &&!this.allowDuplicateXValues = {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-5/source/org/jfree/data/xy/XYSeries.java\t2022-07-19 19:45:34.802732540 +0200\n+++ /tmp/tmp2jt42_oq.java\t2022-07-19 19:45:34.822732439 +0200\n@@ -543,11 +543,11 @@\n         }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n+if (index >= 0 &&!this.allowDuplicateXValues = {\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n             }\n             catch (CloneNotSupportedException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (index >= 0 &&!this.allowDuplicateXValues;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-5/source/org/jfree/data/xy/XYSeries.java\t2022-07-19 19:45:37.322719527 +0200\n+++ /tmp/tmpmx2y21ix.java\t2022-07-19 19:45:37.322719527 +0200\n@@ -543,11 +543,11 @@\n         }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n+if (index >= 0 &&!this.allowDuplicateXValues;\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n             }\n             catch (CloneNotSupportedException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (index >= 0 &&!this.allowDuplicateXValues) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-5/source/org/jfree/data/xy/XYSeries.java\t2022-07-19 19:45:39.082710437 +0200\n+++ /tmp/tmpa3oj_vrj.java\t2022-07-19 19:45:39.082710437 +0200\n@@ -543,11 +543,11 @@\n         }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n+if (index >= 0 &&!this.allowDuplicateXValues) {\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n             }\n             catch (CloneNotSupportedException e) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (index >= 0 &&!this.allowDuplicateXValues?",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-5/source/org/jfree/data/xy/XYSeries.java\t2022-07-19 19:45:49.410657094 +0200\n+++ /tmp/tmpieokvzzf.java\t2022-07-19 19:45:49.410657094 +0200\n@@ -543,11 +543,11 @@\n         }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n+if (index >= 0 &&!this.allowDuplicateXValues?\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n             }\n             catch (CloneNotSupportedException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (index >= 0 ||!this.allowDuplicateXValues?",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-5/source/org/jfree/data/xy/XYSeries.java\t2022-07-19 19:45:50.930649243 +0200\n+++ /tmp/tmpratvxuwp.java\t2022-07-19 19:45:50.930649243 +0200\n@@ -543,11 +543,11 @@\n         }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n+if (index >= 0 ||!this.allowDuplicateXValues?\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n             }\n             catch (CloneNotSupportedException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (index >= 0 ||!this.allowDuplicateXValues) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-5/source/org/jfree/data/xy/XYSeries.java\t2022-07-19 19:45:52.614640543 +0200\n+++ /tmp/tmpnf4jfw0a.java\t2022-07-19 19:45:52.614640543 +0200\n@@ -543,11 +543,11 @@\n         }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n+if (index >= 0 ||!this.allowDuplicateXValues) {\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n             }\n             catch (CloneNotSupportedException e) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (index >= 1 &&!this.allowDuplicateXValues) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-5/source/org/jfree/data/xy/XYSeries.java\t2022-07-19 19:46:01.294595712 +0200\n+++ /tmp/tmpzcm9nf6s.java\t2022-07-19 19:46:01.294595712 +0200\n@@ -543,11 +543,11 @@\n         }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n+if (index >= 1 &&!this.allowDuplicateXValues) {\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n             }\n             catch (CloneNotSupportedException e) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (index >= 0 &&!this.allowDuplicateXValues)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-5/source/org/jfree/data/xy/XYSeries.java\t2022-07-19 19:46:09.806551748 +0200\n+++ /tmp/tmp0hh3c4qq.java\t2022-07-19 19:46:09.806551748 +0200\n@@ -543,11 +543,11 @@\n         }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n+if (index >= 0 &&!this.allowDuplicateXValues)) {\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n             }\n             catch (CloneNotSupportedException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (index >= 0 &&!this.noDuplicateXValues) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-5/source/org/jfree/data/xy/XYSeries.java\t2022-07-19 19:46:11.386543591 +0200\n+++ /tmp/tmpp3btmg_r.java\t2022-07-19 19:46:11.386543591 +0200\n@@ -543,11 +543,11 @@\n         }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n+if (index >= 0 &&!this.noDuplicateXValues) {\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n             }\n             catch (CloneNotSupportedException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (index!= 0 &&!this.allowDuplicateXValues) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-5/source/org/jfree/data/xy/XYSeries.java\t2022-07-19 19:46:13.102534725 +0200\n+++ /tmp/tmpe84z852i.java\t2022-07-19 19:46:13.102534725 +0200\n@@ -543,11 +543,11 @@\n         }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n+if (index!= 0 &&!this.allowDuplicateXValues) {\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n             }\n             catch (CloneNotSupportedException e) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (index >= 0 && !this.allowDuplicateXValues) {",
        "fixed_line": "if (this.allowDuplicateXValues) { add(x, y); return null; } // if we get to here, we know that duplicate X values are not permitted XYDataItem overwritten = null; int index = indexOf(x); if (index >= 0) {"
    },
    "Jsoup-37": {
        "fixes": [
            {
                "k": 1,
                "patch": "return accum.toString().trim(html;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-37/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 19:46:21.638490638 +0200\n+++ /tmp/tmp_yg3puds.java\t2022-07-19 19:46:21.666490495 +0200\n@@ -1096,11 +1096,11 @@\n      * @see #outerHtml()\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         html(accum);\n-        return accum.toString().trim();\n+return accum.toString().trim(html;\n     }\n \n     private void html(StringBuilder accum) {\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return accum.toString().trim( accum;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-37/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 19:46:23.490481072 +0200\n+++ /tmp/tmp5tllz3tt.java\t2022-07-19 19:46:23.490481072 +0200\n@@ -1096,11 +1096,11 @@\n      * @see #outerHtml()\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         html(accum);\n-        return accum.toString().trim();\n+return accum.toString().trim( accum;\n     }\n \n     private void html(StringBuilder accum) {\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return accum.toString().trim(accum;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-37/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 19:46:25.058472976 +0200\n+++ /tmp/tmpkmhufl3m.java\t2022-07-19 19:46:25.058472976 +0200\n@@ -1096,11 +1096,11 @@\n      * @see #outerHtml()\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         html(accum);\n-        return accum.toString().trim();\n+return accum.toString().trim(accum;\n     }\n \n     private void html(StringBuilder accum) {\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return accum.toString().trim(html);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-37/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 19:46:26.498465539 +0200\n+++ /tmp/tmpev1yx4fj.java\t2022-07-19 19:46:26.502465517 +0200\n@@ -1096,11 +1096,11 @@\n      * @see #outerHtml()\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         html(accum);\n-        return accum.toString().trim();\n+return accum.toString().trim(html);\n     }\n \n     private void html(StringBuilder accum) {\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return accum.toString().trim;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-37/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 19:46:28.266456404 +0200\n+++ /tmp/tmp_bd6yhp7.java\t2022-07-19 19:46:28.270456387 +0200\n@@ -1096,11 +1096,11 @@\n      * @see #outerHtml()\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         html(accum);\n-        return accum.toString().trim();\n+return accum.toString().trim;\n     }\n \n     private void html(StringBuilder accum) {\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return accum.toString().trim( accum);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-37/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 19:46:29.926447831 +0200\n+++ /tmp/tmpzp117mpi.java\t2022-07-19 19:46:29.926447831 +0200\n@@ -1096,11 +1096,11 @@\n      * @see #outerHtml()\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         html(accum);\n-        return accum.toString().trim();\n+return accum.toString().trim( accum);\n     }\n \n     private void html(StringBuilder accum) {\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return accum.toString().trim(accum);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-37/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 19:46:31.706438637 +0200\n+++ /tmp/tmpwn73d9px.java\t2022-07-19 19:46:31.710438619 +0200\n@@ -1096,11 +1096,11 @@\n      * @see #outerHtml()\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         html(accum);\n-        return accum.toString().trim();\n+return accum.toString().trim(accum);\n     }\n \n     private void html(StringBuilder accum) {\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return accum.toString().trim();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-37/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 19:46:33.366430064 +0200\n+++ /tmp/tmpncwq9mtt.java\t2022-07-19 19:46:33.366430064 +0200\n@@ -1096,11 +1096,11 @@\n      * @see #outerHtml()\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         html(accum);\n-        return accum.toString().trim();\n+return accum.toString().trim();\n     }\n \n     private void html(StringBuilder accum) {\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return attributes.toString().trim();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-37/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 19:46:37.018411203 +0200\n+++ /tmp/tmp_lz4gnit.java\t2022-07-19 19:46:37.018411203 +0200\n@@ -1096,11 +1096,11 @@\n      * @see #outerHtml()\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         html(accum);\n-        return accum.toString().trim();\n+return attributes.toString().trim();\n     }\n \n     private void html(StringBuilder accum) {\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return flag.toString().trim();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-37/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 19:46:40.214394697 +0200\n+++ /tmp/tmp2ud7xuym.java\t2022-07-19 19:46:40.218394676 +0200\n@@ -1096,11 +1096,11 @@\n      * @see #outerHtml()\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         html(accum);\n-        return accum.toString().trim();\n+return flag.toString().trim();\n     }\n \n     private void html(StringBuilder accum) {\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return accum.toString().trim();",
        "fixed_line": "return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();"
    },
    "Cli-8": {
        "fixes": [
            {
                "k": 1,
                "patch": "pos = findWrapPos(text, width, nextLineTabStop)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-8/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 19:46:42.074385093 +0200\n+++ /tmp/tmph0w7civx.java\t2022-07-19 19:46:42.094384987 +0200\n@@ -807,11 +807,11 @@\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+pos = findWrapPos(text, width, nextLineTabStop)) {\n \n             if (pos == -1)\n             {\n                 sb.append(text);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "pos = findWrapPos(text, width, nextLineTabStop = padding);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-8/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 19:46:43.678376806 +0200\n+++ /tmp/tmpworyiqps.java\t2022-07-19 19:46:43.678376806 +0200\n@@ -807,11 +807,11 @@\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+pos = findWrapPos(text, width, nextLineTabStop = padding);\n \n             if (pos == -1)\n             {\n                 sb.append(text);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "pos = findWrapOffset(text, width, nextLineTabStop);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-8/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 19:46:45.494367426 +0200\n+++ /tmp/tmpx_wy97z5.java\t2022-07-19 19:46:45.494367426 +0200\n@@ -807,11 +807,11 @@\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+pos = findWrapOffset(text, width, nextLineTabStop);\n \n             if (pos == -1)\n             {\n                 sb.append(text);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "pos = findWrapPos(text, width, nextLineTabStopStop);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-8/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 19:46:47.238358418 +0200\n+++ /tmp/tmpcpdkvwwg.java\t2022-07-19 19:46:47.270358251 +0200\n@@ -807,11 +807,11 @@\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+pos = findWrapPos(text, width, nextLineTabStopStop);\n \n             if (pos == -1)\n             {\n                 sb.append(text);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "pos = findWrapPos(text, width, nextLineTabStop);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-8/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 19:46:48.958349533 +0200\n+++ /tmp/tmpqxa2r3hz.java\t2022-07-19 19:46:48.958349533 +0200\n@@ -807,11 +807,11 @@\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+pos = findWrapPos(text, width, nextLineTabStop);\n \n             if (pos == -1)\n             {\n                 sb.append(text);\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "pos = findWrapOffset(text, width, nextLineTabStop));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-8/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 19:46:51.606335856 +0200\n+++ /tmp/tmp1law2eaa.java\t2022-07-19 19:46:51.606335856 +0200\n@@ -807,11 +807,11 @@\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+pos = findWrapOffset(text, width, nextLineTabStop));\n \n             if (pos == -1)\n             {\n                 sb.append(text);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "pos = findWrapPos(text, width, nextLineTabStop;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-8/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 19:46:53.210327574 +0200\n+++ /tmp/tmp2r813j4d.java\t2022-07-19 19:46:53.210327574 +0200\n@@ -807,11 +807,11 @@\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+pos = findWrapPos(text, width, nextLineTabStop;\n \n             if (pos == -1)\n             {\n                 sb.append(text);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "pos = findWrapPos(text, width, nextLineTabStop));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-8/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 19:46:54.698319889 +0200\n+++ /tmp/tmp5nxwi4_j.java\t2022-07-19 19:46:54.698319889 +0200\n@@ -807,11 +807,11 @@\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+pos = findWrapPos(text, width, nextLineTabStop));\n \n             if (pos == -1)\n             {\n                 sb.append(text);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "pos = findWrapPos(text, padding, nextLineTabStop);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-8/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 19:46:56.134312472 +0200\n+++ /tmp/tmp8xt5nz1_.java\t2022-07-19 19:46:56.138312451 +0200\n@@ -807,11 +807,11 @@\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+pos = findWrapPos(text, padding, nextLineTabStop);\n \n             if (pos == -1)\n             {\n                 sb.append(text);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "pos = findWrapPos(text, padding, nextLineTabStop));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-8/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 19:46:57.914303276 +0200\n+++ /tmp/tmpkozubcq3.java\t2022-07-19 19:46:57.914303276 +0200\n@@ -807,11 +807,11 @@\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+pos = findWrapPos(text, padding, nextLineTabStop));\n \n             if (pos == -1)\n             {\n                 sb.append(text);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "pos = findWrapPos(text, width, nextLineTabStop);",
        "fixed_line": "pos = findWrapPos(text, width, 0);"
    },
    "Collections-26": {
        "fixes": [
            {
                "k": 1,
                "patch": "private Object readResolve = this.readOnly;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Collections-26/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\t2022-07-19 19:46:59.542294871 +0200\n+++ /tmp/tmpf7drdzxv.java\t2022-07-19 19:46:59.562294768 +0200\n@@ -272,10 +272,10 @@\n      * Recalculate the hash code after deserialization. The hash code of some\n      * keys might have change (hash codes based on the system hash code are\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+private Object readResolve = this.readOnly;\n         calculateHashCode(keys);\n         return this;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "private Object readResolve = this.readResolve;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Collections-26/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\t2022-07-19 19:47:02.602279065 +0200\n+++ /tmp/tmpa116l3kl.java\t2022-07-19 19:47:02.606279044 +0200\n@@ -272,10 +272,10 @@\n      * Recalculate the hash code after deserialization. The hash code of some\n      * keys might have change (hash codes based on the system hash code are\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+private Object readResolve = this.readResolve;\n         calculateHashCode(keys);\n         return this;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "private Object readResolve = this.keys; {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Collections-26/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\t2022-07-19 19:47:05.170265799 +0200\n+++ /tmp/tmpwyg9jmbl.java\t2022-07-19 19:47:05.170265799 +0200\n@@ -272,10 +272,10 @@\n      * Recalculate the hash code after deserialization. The hash code of some\n      * keys might have change (hash codes based on the system hash code are\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+private Object readResolve = this.keys; {\n         calculateHashCode(keys);\n         return this;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "private Object readResolve = this.keys;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Collections-26/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\t2022-07-19 19:47:07.934251526 +0200\n+++ /tmp/tmpqm2ttm86.java\t2022-07-19 19:47:07.934251526 +0200\n@@ -272,10 +272,10 @@\n      * Recalculate the hash code after deserialization. The hash code of some\n      * keys might have change (hash codes based on the system hash code are\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+private Object readResolve = this.keys;\n         calculateHashCode(keys);\n         return this;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private Object readResolve = this;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Collections-26/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\t2022-07-19 19:47:10.450238531 +0200\n+++ /tmp/tmpyopkrdnr.java\t2022-07-19 19:47:10.450238531 +0200\n@@ -272,10 +272,10 @@\n      * Recalculate the hash code after deserialization. The hash code of some\n      * keys might have change (hash codes based on the system hash code are\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+private Object readResolve = this;\n         calculateHashCode(keys);\n         return this;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "private Object readResolve(this.keys;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Collections-26/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\t2022-07-19 19:47:13.142224628 +0200\n+++ /tmp/tmpg1_kvt82.java\t2022-07-19 19:47:13.142224628 +0200\n@@ -272,10 +272,10 @@\n      * Recalculate the hash code after deserialization. The hash code of some\n      * keys might have change (hash codes based on the system hash code are\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+private Object readResolve(this.keys;\n         calculateHashCode(keys);\n         return this;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private Object readResolve; 8) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Collections-26/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\t2022-07-19 19:47:15.846210661 +0200\n+++ /tmp/tmpzcu5g4af.java\t2022-07-19 19:47:15.846210661 +0200\n@@ -272,10 +272,10 @@\n      * Recalculate the hash code after deserialization. The hash code of some\n      * keys might have change (hash codes based on the system hash code are\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+private Object readResolve; 8) {\n         calculateHashCode(keys);\n         return this;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "private Object readResolve; keys) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Collections-26/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\t2022-07-19 19:47:18.414197396 +0200\n+++ /tmp/tmp69vwg7x5.java\t2022-07-19 19:47:18.414197396 +0200\n@@ -272,10 +272,10 @@\n      * Recalculate the hash code after deserialization. The hash code of some\n      * keys might have change (hash codes based on the system hash code are\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+private Object readResolve; keys) {\n         calculateHashCode(keys);\n         return this;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private Object readResolve = this.input;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Collections-26/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\t2022-07-19 19:47:21.054183763 +0200\n+++ /tmp/tmp3ir6j8fg.java\t2022-07-19 19:47:21.054183763 +0200\n@@ -272,10 +272,10 @@\n      * Recalculate the hash code after deserialization. The hash code of some\n      * keys might have change (hash codes based on the system hash code are\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+private Object readResolve = this.input;\n         calculateHashCode(keys);\n         return this;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "private Object readResolve; {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Collections-26/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\t2022-07-19 19:47:23.662170291 +0200\n+++ /tmp/tmpm4l71hx1.java\t2022-07-19 19:47:23.662170291 +0200\n@@ -272,10 +272,10 @@\n      * Recalculate the hash code after deserialization. The hash code of some\n      * keys might have change (hash codes based on the system hash code are\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+private Object readResolve; {\n         calculateHashCode(keys);\n         return this;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "private Object readResolve() {",
        "fixed_line": "protected Object readResolve() {"
    },
    "Jsoup-13": {
        "fixes": [
            {
                "k": 1,
                "patch": "return attributes.hasAttr(attributeKey);",
                "patch_diff": "return attributes.hasAttr(attributeKey);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return this.hasAttr;",
                "patch_diff": "return this.hasAttr;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return attributes.hasAttr;",
                "patch_diff": "return attributes.hasAttr;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return attributes.hasAttr(attributeKey;",
                "patch_diff": "return attributes.hasAttr(attributeKey;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "boolean hasAttr(attributeKey);",
                "patch_diff": "boolean hasAttr(attributeKey);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "boolean hasAttr(attributeKey, false) {",
                "patch_diff": "boolean hasAttr(attributeKey, false) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return this.hasAttr(attributeKey);",
                "patch_diff": "return this.hasAttr(attributeKey);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return attributes.hasAttr(attributeKey, false;",
                "patch_diff": "return attributes.hasAttr(attributeKey, false;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return attributes.hasAttr(attributeKey) {",
                "patch_diff": "return attributes.hasAttr(attributeKey) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "boolean hasAttr(attributeKey) {",
                "patch_diff": "boolean hasAttr(attributeKey) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (attributeKey.toLowerCase().startsWith(\"abs:\")) { String key = attributeKey.substring(\"abs:\".length()); if (attributes.hasKey(key) && !absUrl(key).equals(\"\")) return true; }"
    },
    "Chart-17": {
        "fixes": [
            {
                "k": 1,
                "patch": "Object clone = createCopy(0, getItemCountID - 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-17/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 19:47:28.150147113 +0200\n+++ /tmp/tmp01ugxh23.java\t2022-07-19 19:47:28.262146535 +0200\n@@ -852,11 +852,11 @@\n      * \n      * @throws CloneNotSupportedException not thrown by this class, but \n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        Object clone = createCopy(0, getItemCount() - 1);\n+Object clone = createCopy(0, getItemCountID - 1);\n         return clone;\n     }\n \n     /**\n      * Creates a new timeseries by copying a subset of the data in this time\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "Object clone = createCopy(0, getItemCount * 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-17/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 19:47:31.130131721 +0200\n+++ /tmp/tmpdicv84zi.java\t2022-07-19 19:47:31.130131721 +0200\n@@ -852,11 +852,11 @@\n      * \n      * @throws CloneNotSupportedException not thrown by this class, but \n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        Object clone = createCopy(0, getItemCount() - 1);\n+Object clone = createCopy(0, getItemCount * 1);\n         return clone;\n     }\n \n     /**\n      * Creates a new timeseries by copying a subset of the data in this time\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "Object clone = createCopy(0, getItemCount) - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-17/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 19:47:32.994122094 +0200\n+++ /tmp/tmpvwgvxapg.java\t2022-07-19 19:47:32.994122094 +0200\n@@ -852,11 +852,11 @@\n      * \n      * @throws CloneNotSupportedException not thrown by this class, but \n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        Object clone = createCopy(0, getItemCount() - 1);\n+Object clone = createCopy(0, getItemCount) - 1;\n         return clone;\n     }\n \n     /**\n      * Creates a new timeseries by copying a subset of the data in this time\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "Object clone = createCopy(0, getItemCount() * 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-17/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 19:47:35.030111578 +0200\n+++ /tmp/tmpbj_ljf08.java\t2022-07-19 19:47:35.034111555 +0200\n@@ -852,11 +852,11 @@\n      * \n      * @throws CloneNotSupportedException not thrown by this class, but \n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        Object clone = createCopy(0, getItemCount() - 1);\n+Object clone = createCopy(0, getItemCount() * 1);\n         return clone;\n     }\n \n     /**\n      * Creates a new timeseries by copying a subset of the data in this time\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "Object clone = createCopy(0, getItemCount) - 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-17/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 19:47:45.550057241 +0200\n+++ /tmp/tmpp05wa06q.java\t2022-07-19 19:47:45.550057241 +0200\n@@ -852,11 +852,11 @@\n      * \n      * @throws CloneNotSupportedException not thrown by this class, but \n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        Object clone = createCopy(0, getItemCount() - 1);\n+Object clone = createCopy(0, getItemCount) - 1);\n         return clone;\n     }\n \n     /**\n      * Creates a new timeseries by copying a subset of the data in this time\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "Object clone = createCopy(0, getItemCount()-1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-17/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 19:47:47.186048791 +0200\n+++ /tmp/tmpcs4qfff5.java\t2022-07-19 19:47:47.186048791 +0200\n@@ -852,11 +852,11 @@\n      * \n      * @throws CloneNotSupportedException not thrown by this class, but \n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        Object clone = createCopy(0, getItemCount() - 1);\n+Object clone = createCopy(0, getItemCount()-1);\n         return clone;\n     }\n \n     /**\n      * Creates a new timeseries by copying a subset of the data in this time\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "Object clone = createCopy(0, getItemCount% - 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-17/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 19:47:55.010008383 +0200\n+++ /tmp/tmp94fk5z4p.java\t2022-07-19 19:47:55.010008383 +0200\n@@ -852,11 +852,11 @@\n      * \n      * @throws CloneNotSupportedException not thrown by this class, but \n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        Object clone = createCopy(0, getItemCount() - 1);\n+Object clone = createCopy(0, getItemCount% - 1);\n         return clone;\n     }\n \n     /**\n      * Creates a new timeseries by copying a subset of the data in this time\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "Object clone = createCopy(0, getItemCount - 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-17/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 19:47:56.881998713 +0200\n+++ /tmp/tmpn5m7dm7y.java\t2022-07-19 19:47:56.881998713 +0200\n@@ -852,11 +852,11 @@\n      * \n      * @throws CloneNotSupportedException not thrown by this class, but \n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        Object clone = createCopy(0, getItemCount() - 1);\n+Object clone = createCopy(0, getItemCount - 1);\n         return clone;\n     }\n \n     /**\n      * Creates a new timeseries by copying a subset of the data in this time\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "Object clone = createCopy(0, getItemCount;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-17/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 19:47:58.681989419 +0200\n+++ /tmp/tmpz2tr56ym.java\t2022-07-19 19:47:58.681989419 +0200\n@@ -852,11 +852,11 @@\n      * \n      * @throws CloneNotSupportedException not thrown by this class, but \n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        Object clone = createCopy(0, getItemCount() - 1);\n+Object clone = createCopy(0, getItemCount;\n         return clone;\n     }\n \n     /**\n      * Creates a new timeseries by copying a subset of the data in this time\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "Object clone = createCopy(0, getItemCount() - 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-17/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 19:48:00.465980205 +0200\n+++ /tmp/tmpltxx9pju.java\t2022-07-19 19:48:00.465980205 +0200\n@@ -852,11 +852,11 @@\n      * \n      * @throws CloneNotSupportedException not thrown by this class, but \n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        Object clone = createCopy(0, getItemCount() - 1);\n+Object clone = createCopy(0, getItemCount() - 1);\n         return clone;\n     }\n \n     /**\n      * Creates a new timeseries by copying a subset of the data in this time\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "Object clone = createCopy(0, getItemCount() - 1);",
        "fixed_line": "TimeSeries clone = (TimeSeries) super.clone(); clone.data = (List) ObjectUtilities.deepClone(this.data);"
    },
    "JacksonDatabind-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "return _valueTypeDeserializer!= null && _valueTypeDeserializer!= null && _valueTypeDeserializer!= null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-12/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\t2022-07-19 19:48:08.945936407 +0200\n+++ /tmp/tmphtq6kdlr.java\t2022-07-19 19:48:09.021936013 +0200\n@@ -298,11 +298,11 @@\n     @Override\n     public boolean isCachable() {\n         /* As per [databind#735], existence of value or key deserializer (only passed\n          * if annotated to use non-standard one) should also prevent caching.\n          */\n-        return (_valueTypeDeserializer == null)\n+return _valueTypeDeserializer!= null && _valueTypeDeserializer!= null && _valueTypeDeserializer!= null;\n                 && (_ignorableProperties == null);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return _valueTypeDeserializer!= null && _valueTypeDeserializer!= null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-12/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\t2022-07-19 19:48:11.025925663 +0200\n+++ /tmp/tmphj5j5qea.java\t2022-07-19 19:48:11.025925663 +0200\n@@ -298,11 +298,11 @@\n     @Override\n     public boolean isCachable() {\n         /* As per [databind#735], existence of value or key deserializer (only passed\n          * if annotated to use non-standard one) should also prevent caching.\n          */\n-        return (_valueTypeDeserializer == null)\n+return _valueTypeDeserializer!= null && _valueTypeDeserializer!= null);\n                 && (_ignorableProperties == null);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return _valueTypeDeserializer!= null && _valueTypeDeserializer!= null && _valueTypeDeserializer == null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-12/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\t2022-07-19 19:48:12.681917111 +0200\n+++ /tmp/tmp5jxac7r0.java\t2022-07-19 19:48:12.681917111 +0200\n@@ -298,11 +298,11 @@\n     @Override\n     public boolean isCachable() {\n         /* As per [databind#735], existence of value or key deserializer (only passed\n          * if annotated to use non-standard one) should also prevent caching.\n          */\n-        return (_valueTypeDeserializer == null)\n+return _valueTypeDeserializer!= null && _valueTypeDeserializer!= null && _valueTypeDeserializer == null;\n                 && (_ignorableProperties == null);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return _valueTypeDeserializer!= null && _valueTypeDeserializer!= null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-12/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\t2022-07-19 19:48:14.317908660 +0200\n+++ /tmp/tmpb5xvhvc_.java\t2022-07-19 19:48:14.317908660 +0200\n@@ -298,11 +298,11 @@\n     @Override\n     public boolean isCachable() {\n         /* As per [databind#735], existence of value or key deserializer (only passed\n          * if annotated to use non-standard one) should also prevent caching.\n          */\n-        return (_valueTypeDeserializer == null)\n+return _valueTypeDeserializer!= null && _valueTypeDeserializer!= null;\n                 && (_ignorableProperties == null);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return _valueTypeDeserializer!= null && _valueTypeDeserializer!= null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-12/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\t2022-07-19 19:48:16.105899425 +0200\n+++ /tmp/tmp1qqbzvnq.java\t2022-07-19 19:48:16.109899406 +0200\n@@ -298,11 +298,11 @@\n     @Override\n     public boolean isCachable() {\n         /* As per [databind#735], existence of value or key deserializer (only passed\n          * if annotated to use non-standard one) should also prevent caching.\n          */\n-        return (_valueTypeDeserializer == null)\n+return _valueTypeDeserializer!= null && _valueTypeDeserializer!= null)\n                 && (_ignorableProperties == null);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return _valueTypeDeserializer!= null && _valueTypeDeserializer == null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-12/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\t2022-07-19 19:48:17.685891266 +0200\n+++ /tmp/tmp0x8kmkoh.java\t2022-07-19 19:48:17.689891245 +0200\n@@ -298,11 +298,11 @@\n     @Override\n     public boolean isCachable() {\n         /* As per [databind#735], existence of value or key deserializer (only passed\n          * if annotated to use non-standard one) should also prevent caching.\n          */\n-        return (_valueTypeDeserializer == null)\n+return _valueTypeDeserializer!= null && _valueTypeDeserializer == null;\n                 && (_ignorableProperties == null);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return _valueTypeDeserializer!= null && _valueTypeDeserializer!= null && _valueTypeDeserializer!= null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-12/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\t2022-07-19 19:48:19.521881782 +0200\n+++ /tmp/tmp3ns2z9ul.java\t2022-07-19 19:48:19.521881782 +0200\n@@ -298,11 +298,11 @@\n     @Override\n     public boolean isCachable() {\n         /* As per [databind#735], existence of value or key deserializer (only passed\n          * if annotated to use non-standard one) should also prevent caching.\n          */\n-        return (_valueTypeDeserializer == null)\n+return _valueTypeDeserializer!= null && _valueTypeDeserializer!= null && _valueTypeDeserializer!= null);\n                 && (_ignorableProperties == null);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return _valueTypeDeserializer!= null && _valueTypeDeserializer!= null && _valueTypeDeserializer!= null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-12/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\t2022-07-19 19:48:21.293872630 +0200\n+++ /tmp/tmpes5_wprr.java\t2022-07-19 19:48:21.293872630 +0200\n@@ -298,11 +298,11 @@\n     @Override\n     public boolean isCachable() {\n         /* As per [databind#735], existence of value or key deserializer (only passed\n          * if annotated to use non-standard one) should also prevent caching.\n          */\n-        return (_valueTypeDeserializer == null)\n+return _valueTypeDeserializer!= null && _valueTypeDeserializer!= null && _valueTypeDeserializer!= null)\n                 && (_ignorableProperties == null);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return _valueTypeDeserializer!= null && _valueTypeDeserializer;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-12/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\t2022-07-19 19:48:22.981863912 +0200\n+++ /tmp/tmpd_mqaup0.java\t2022-07-19 19:48:22.985863891 +0200\n@@ -298,11 +298,11 @@\n     @Override\n     public boolean isCachable() {\n         /* As per [databind#735], existence of value or key deserializer (only passed\n          * if annotated to use non-standard one) should also prevent caching.\n          */\n-        return (_valueTypeDeserializer == null)\n+return _valueTypeDeserializer!= null && _valueTypeDeserializer;\n                 && (_ignorableProperties == null);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return _valueTypeDeserializer!= null && key deserializer.valueTypeDeserializer;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-12/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\t2022-07-19 19:48:24.581855647 +0200\n+++ /tmp/tmp8ja9eq2c.java\t2022-07-19 19:48:24.585855628 +0200\n@@ -298,11 +298,11 @@\n     @Override\n     public boolean isCachable() {\n         /* As per [databind#735], existence of value or key deserializer (only passed\n          * if annotated to use non-standard one) should also prevent caching.\n          */\n-        return (_valueTypeDeserializer == null)\n+return _valueTypeDeserializer!= null && key deserializer.valueTypeDeserializer;\n                 && (_ignorableProperties == null);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return (_valueTypeDeserializer == null)",
        "fixed_line": "return (_valueDeserializer == null) && (_keyDeserializer == null) && (_valueTypeDeserializer == null)"
    },
    "Closure-146": {
        "fixes": [
            {
                "k": 1,
                "patch": "return new TypePair(this.testClass, null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-146/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 19:48:26.349846519 +0200\n+++ /tmp/tmpx8oxbkrs.java\t2022-07-19 19:48:26.377846372 +0200\n@@ -701,11 +701,11 @@\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+return new TypePair(this.testClass, null);\n \n       case FALSE:\n       case UNKNOWN:\n         return new TypePair(this, that);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return new TypePair(this.parameters, null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-146/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 19:48:28.473835546 +0200\n+++ /tmp/tmpzkv7lcq9.java\t2022-07-19 19:48:28.473835546 +0200\n@@ -701,11 +701,11 @@\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+return new TypePair(this.parameters, null);\n \n       case FALSE:\n       case UNKNOWN:\n         return new TypePair(this, that);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return new TypePair(this.null, that.millisecond);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-146/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 19:48:30.177826746 +0200\n+++ /tmp/tmpmk_5yonb.java\t2022-07-19 19:48:30.177826746 +0200\n@@ -701,11 +701,11 @@\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+return new TypePair(this.null, that.millisecond);\n \n       case FALSE:\n       case UNKNOWN:\n         return new TypePair(this, that);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return new TypePair(this.null, that.clazz;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-146/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 19:48:31.809818316 +0200\n+++ /tmp/tmpu_k5qi46.java\t2022-07-19 19:48:31.813818296 +0200\n@@ -701,11 +701,11 @@\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+return new TypePair(this.null, that.clazz;\n \n       case FALSE:\n       case UNKNOWN:\n         return new TypePair(this, that);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return new TypePair(this.d, that.testForEquality);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-146/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 19:48:33.393810136 +0200\n+++ /tmp/tmpc2w6hh1k.java\t2022-07-19 19:48:33.397810115 +0200\n@@ -701,11 +701,11 @@\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+return new TypePair(this.d, that.testForEquality);\n \n       case FALSE:\n       case UNKNOWN:\n         return new TypePair(this, that);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return new TypePair(this.null, that.testClass);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-146/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 19:48:35.033801664 +0200\n+++ /tmp/tmp034g8ev1.java\t2022-07-19 19:48:35.033801664 +0200\n@@ -701,11 +701,11 @@\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+return new TypePair(this.null, that.testClass);\n \n       case FALSE:\n       case UNKNOWN:\n         return new TypePair(this, that);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return new TypePair(this.null, that.iPair);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-146/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 19:48:36.641793359 +0200\n+++ /tmp/tmp71k82pzs.java\t2022-07-19 19:48:36.641793359 +0200\n@@ -701,11 +701,11 @@\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+return new TypePair(this.null, that.iPair);\n \n       case FALSE:\n       case UNKNOWN:\n         return new TypePair(this, that);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return new TypePair(this.d, that.testClass);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-146/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 19:48:38.197785324 +0200\n+++ /tmp/tmphz7uwzrv.java\t2022-07-19 19:48:38.197785324 +0200\n@@ -701,11 +701,11 @@\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+return new TypePair(this.d, that.testClass);\n \n       case FALSE:\n       case UNKNOWN:\n         return new TypePair(this, that);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return new TypePair(this.null, that.testForEquality);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-146/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 19:48:39.889776584 +0200\n+++ /tmp/tmpg_2nc9nt.java\t2022-07-19 19:48:39.893776563 +0200\n@@ -701,11 +701,11 @@\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+return new TypePair(this.null, that.testForEquality);\n \n       case FALSE:\n       case UNKNOWN:\n         return new TypePair(this, that);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return new TypePair(this.testForEquality, null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-146/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 19:48:41.445768549 +0200\n+++ /tmp/tmpt3rvuo19.java\t2022-07-19 19:48:41.449768527 +0200\n@@ -701,11 +701,11 @@\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+return new TypePair(this.testForEquality, null);\n \n       case FALSE:\n       case UNKNOWN:\n         return new TypePair(this, that);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return new TypePair(null, null);",
        "fixed_line": "JSType noType = getNativeType(JSTypeNative.NO_TYPE); return new TypePair(noType, noType);"
    },
    "Gson-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (c == JsonToken.START_OBJECT) { pathNames[stackSize - 1] = \"null\"; } else { pathNames[stackSize] = \"null\"; }",
                "patch_diff": "} else if (c == JsonToken.START_OBJECT) { pathNames[stackSize - 1] = \"null\"; } else { pathNames[stackSize] = \"null\"; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (c == JsonToken.START_OBJECT) { pathNames[stackSize - 1] = \"null\"; } else { pathNames[stackSize + 1] = \"null\"; }",
                "patch_diff": "} else if (c == JsonToken.START_OBJECT) { pathNames[stackSize - 1] = \"null\"; } else { pathNames[stackSize + 1] = \"null\"; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (c == JsonToken.START_OBJECT) { nextName = \"null\"; } else { pathNames[stackSize - 1] = \"null\"; }",
                "patch_diff": "} else if (c == JsonToken.START_OBJECT) { nextName = \"null\"; } else { pathNames[stackSize - 1] = \"null\"; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (escape == JsonToken.START_OBJECT) { pathNames[stackSize - 1] = \"null\"; } else { pathNames[stackSize] = \"null\"; }",
                "patch_diff": "} else if (escape == JsonToken.START_OBJECT) { pathNames[stackSize - 1] = \"null\"; } else { pathNames[stackSize] = \"null\"; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (c == JsonToken.START_OBJECT) { pathNames[stackSize - 1] = \"null\"; } else { pathNames[stackSize - 1] = \"null\"; }",
                "patch_diff": "} else if (c == JsonToken.START_OBJECT) { pathNames[stackSize - 1] = \"null\"; } else { pathNames[stackSize - 1] = \"null\"; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (escape == JsonToken.START_OBJECT) { pathNames[stackSize - 1] = \"null\"; } else { pathNames[stackSize + 1] = \"null\"; }",
                "patch_diff": "} else if (escape == JsonToken.START_OBJECT) { pathNames[stackSize - 1] = \"null\"; } else { pathNames[stackSize + 1] = \"null\"; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (c == JsonToken.START_OBJECT) { pathNames[stackSize - 1] = \"null\"; } else { pathNames[stackSize++] = \"null\"; }",
                "patch_diff": "} else if (c == JsonToken.START_OBJECT) { pathNames[stackSize - 1] = \"null\"; } else { pathNames[stackSize++] = \"null\"; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (c == JsonToken.START_OBJECT) { pathNames[stackSize - 1] = \"null\"; }",
                "patch_diff": "} else if (c == JsonToken.START_OBJECT) { pathNames[stackSize - 1] = \"null\"; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (c == JsonToken.START_OBJECT) { pathNames[stackSize - 1] = \"null\"; } else { pathNames = \"null\"; }",
                "patch_diff": "} else if (c == JsonToken.START_OBJECT) { pathNames[stackSize - 1] = \"null\"; } else { pathNames = \"null\"; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (nextName!= JsonToken.START_OBJECT) { pathNames[stackSize - 1] = \"null\"; }",
                "patch_diff": "} else if (nextName!= JsonToken.START_OBJECT) { pathNames[stackSize - 1] = \"null\"; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (stackSize > 0) { pathNames[stackSize - 1] = \"null\"; } } if (stackSize > 0) { pathIndices[stackSize - 1]++; }"
    },
    "Math-60": {
        "fixes": [
            {
                "k": 1,
                "patch": "try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * x) / ex; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-60/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\t2022-07-19 19:48:45.325748508 +0200\n+++ /tmp/tmpuuj9zmys.java\t2022-07-19 19:48:45.361748323 +0200\n@@ -121,22 +121,11 @@\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        try {\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n+try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * x) / ex; }\n     }\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * x) / n; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-60/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\t2022-07-19 19:48:47.529737124 +0200\n+++ /tmp/tmpah6lczsq.java\t2022-07-19 19:48:47.533737104 +0200\n@@ -121,22 +121,11 @@\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        try {\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n+try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * x) / n; }\n     }\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * flagDeviation) / ex; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-60/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\t2022-07-19 19:48:49.589726485 +0200\n+++ /tmp/tmph3rgivvk.java\t2022-07-19 19:48:49.589726485 +0200\n@@ -121,22 +121,11 @@\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        try {\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n+try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * flagDeviation) / ex; }\n     }\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * x)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-60/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\t2022-07-19 19:48:51.525716487 +0200\n+++ /tmp/tmp87kr2n81.java\t2022-07-19 19:48:51.525716487 +0200\n@@ -121,22 +121,11 @@\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        try {\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n+try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * x)) {\n     }\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * sum - 20; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-60/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\t2022-07-19 19:48:53.525706156 +0200\n+++ /tmp/tmp77ix2iqo.java\t2022-07-19 19:48:53.525706156 +0200\n@@ -121,22 +121,11 @@\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        try {\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n+try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * sum - 20; }\n     }\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * accum)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-60/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\t2022-07-19 19:48:55.457696178 +0200\n+++ /tmp/tmp4u56s3ua.java\t2022-07-19 19:48:55.457696178 +0200\n@@ -121,22 +121,11 @@\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        try {\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n+try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * accum)) {\n     }\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * accum); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-60/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\t2022-07-19 19:48:57.485685704 +0200\n+++ /tmp/tmpoab82vi0.java\t2022-07-19 19:48:57.485685704 +0200\n@@ -121,22 +121,11 @@\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        try {\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n+try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * accum); }\n     }\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * ex)); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-60/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\t2022-07-19 19:48:59.537675105 +0200\n+++ /tmp/tmpjig3058i.java\t2022-07-19 19:48:59.537675105 +0200\n@@ -121,22 +121,11 @@\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        try {\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n+try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * ex)); }\n     }\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "try { return 0.5 * (x0 + Erf.erf) / (standardDeviation * accum; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-60/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\t2022-07-19 19:49:01.573664589 +0200\n+++ /tmp/tmpu2_5fmc7.java\t2022-07-19 19:49:01.573664589 +0200\n@@ -121,22 +121,11 @@\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        try {\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n+try { return 0.5 * (x0 + Erf.erf) / (standardDeviation * accum; }\n     }\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * sum - ex)); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-60/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\t2022-07-19 19:49:03.561654321 +0200\n+++ /tmp/tmpm6r548si.java\t2022-07-19 19:49:03.565654301 +0200\n@@ -121,22 +121,11 @@\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        try {\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n+try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * sum - ex)); }\n     }\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "try { return 0.5 * (1.0 + Erf.erf((dev) / (standardDeviation * FastMath.sqrt(2.0)))); } catch (MaxIterationsExceededException ex) { if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38 return 0; } else if (x > (mean + 20 * standardDeviation)) { return 1; } else { throw ex; } }",
        "fixed_line": "if (FastMath.abs(dev) > 40 * standardDeviation) { return dev < 0 ? 0.0d : 1.0d; }"
    },
    "JacksonDatabind-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (mixIn methods.isEnabled(MapperFeature.WIDTH, can't be called)",
                "patch_diff": "} else if (mixIn methods.isEnabled(MapperFeature.WIDTH, can't be called)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (mixIn methods.isEnabled(Feature.WIDTH, can't be called)",
                "patch_diff": "} else if (mixIn methods.isEnabled(Feature.WIDTH, can't be called)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (mixIn methods.isEnabled(Feature.CANONICALIZE_OVERRIDE, am) {",
                "patch_diff": "} else if (mixIn methods.isEnabled(Feature.CANONICALIZE_OVERRIDE, am) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (mixIn methods.isEnabled(Feature.CANONICALIZE_OVERRIDE, am)) {",
                "patch_diff": "} else if (mixIn methods.isEnabled(Feature.CANONICALIZE_OVERRIDE, am)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (mixIn methods.isEnabled(Feature.CANONICALIZE_OVERRIDE, am, _constructMethod(m));",
                "patch_diff": "} else if (mixIn methods.isEnabled(Feature.CANONICALIZE_OVERRIDE, am, _constructMethod(m));",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (mixIn methods.isEnabled(Feature.CANONICALIZE_OVERRIDE, am, declaredType);",
                "patch_diff": "} else if (mixIn methods.isEnabled(Feature.CANONICALIZE_OVERRIDE, am, declaredType);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// _constructMethod(mixIn methods, can't be called)",
                "patch_diff": "// _constructMethod(mixIn methods, can't be called)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (mixIn methods.isEnabled(Feature.CANONICALIZE_OVERRIDE, declaredType);",
                "patch_diff": "} else if (mixIn methods.isEnabled(Feature.CANONICALIZE_OVERRIDE, declaredType);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (mixIn methods.isEnabled(Feature.CANONICALIZE_OVERRIDE, am;",
                "patch_diff": "} else if (mixIn methods.isEnabled(Feature.CANONICALIZE_OVERRIDE, am;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (mixIn methods.isEnabled(Feature.CANONICALIZE_OVERRIDE, am);",
                "patch_diff": "} else if (mixIn methods.isEnabled(Feature.CANONICALIZE_OVERRIDE, am);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "am = mixIns.find(m); if (am != null) { _addMixUnders(m, am); } else { mixIns.add(_constructMethod(m)); }"
    },
    "JacksonDatabind-92": {
        "fixes": [
            {
                "k": 1,
                "patch": "// }",
                "patch_diff": "// }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) {",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) { for (int j = 0; j < s.length; j++) { s.add(s); } }",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) { for (int j = 0; j < s.length; j++) { s.add(s); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) { for (int j = 0; j < s.length; j++) { if (s.contains(c)) { s.add(s); } } }",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) { for (int j = 0; j < s.length; j++) { if (s.contains(c)) { s.add(s); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) { for (int j = 0; j < s.length; j++) { if (s.equals(s)) { s.add(s); } } }",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) { for (int j = 0; j < s.length; j++) { if (s.equals(s)) { s.add(s); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) { if (s[i]!= null) { s.add(s); } } }",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) { if (s[i]!= null) { s.add(s); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) { for (int j = 0; j < s.length; j++) { if (s.charAt(i++) { s.add(s); } } }",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) { for (int j = 0; j < s.length; j++) { if (s.charAt(i++) { s.add(s); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) { for (int j = 0; j < s.length; j++) { if (s.contains(c)) { s.add(c); } } }",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) { for (int j = 0; j < s.length; j++) { if (s.contains(c)) { s.add(c); } } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) { if (s[i]!= null) { s.add(s); } }",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < s.length; i++) { if (s[i]!= null) { s.add(s); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "s.add(\"java.util.logging.FileHandler\"); s.add(\"java.rmi.server.UnicastRemoteObject\"); // [databind#1737]; 3rd party s.add(\"org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor\"); s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\"); s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\"); s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");"
    },
    "Chart-10": {
        "fixes": [
            {
                "k": 1,
                "patch": "return \" title=\\\"\" + this.title=\\\"\" + this.title=\\\"\" + toolTipText);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-10/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\t2022-07-19 19:49:09.389624221 +0200\n+++ /tmp/tmpt8onp9gu.java\t2022-07-19 19:49:09.429624015 +0200\n@@ -60,10 +60,10 @@\n      * @param toolTipText  the tooltip.\n      * \n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + toolTipText\n+return \" title=\\\"\" + this.title=\\\"\" + this.title=\\\"\" + toolTipText);\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return \" title=\\\"\" + this.title=\\\"\" + toolTipText);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-10/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\t2022-07-19 19:49:11.797611783 +0200\n+++ /tmp/tmphdzbf328.java\t2022-07-19 19:49:11.797611783 +0200\n@@ -60,10 +60,10 @@\n      * @param toolTipText  the tooltip.\n      * \n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + toolTipText\n+return \" title=\\\"\" + this.title=\\\"\" + toolTipText);\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return \" title=\\\"\" + this.toolTipText;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-10/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\t2022-07-19 19:49:13.405603479 +0200\n+++ /tmp/tmpgqy62kqs.java\t2022-07-19 19:49:13.405603479 +0200\n@@ -60,10 +60,10 @@\n      * @param toolTipText  the tooltip.\n      * \n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + toolTipText\n+return \" title=\\\"\" + this.toolTipText;\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return \" title=\\\"\" + this.title=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\"; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-10/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\t2022-07-19 19:49:14.937595565 +0200\n+++ /tmp/tmp_1fnl_ws.java\t2022-07-19 19:49:14.937595565 +0200\n@@ -60,10 +60,10 @@\n      * @param toolTipText  the tooltip.\n      * \n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + toolTipText\n+return \" title=\\\"\" + this.title=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\"; }\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return \" title=\\\"\" + this.title=\\\"\" + this.title=\\\"\" + toolTipText;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-10/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\t2022-07-19 19:49:16.605586952 +0200\n+++ /tmp/tmpv8y0hoby.java\t2022-07-19 19:49:16.605586952 +0200\n@@ -60,10 +60,10 @@\n      * @param toolTipText  the tooltip.\n      * \n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + toolTipText\n+return \" title=\\\"\" + this.title=\\\"\" + this.title=\\\"\" + toolTipText;\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return \" title=\\\"\" + this.title=\\\"\" + toolTipText;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-10/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\t2022-07-19 19:49:18.237578521 +0200\n+++ /tmp/tmp6vxr54yi.java\t2022-07-19 19:49:18.237578521 +0200\n@@ -60,10 +60,10 @@\n      * @param toolTipText  the tooltip.\n      * \n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + toolTipText\n+return \" title=\\\"\" + this.title=\\\"\" + toolTipText;\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return \" title=\\\"\" + this.title=\\\"\" + this.title=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\"; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-10/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\t2022-07-19 19:49:19.833570279 +0200\n+++ /tmp/tmpr252wng4.java\t2022-07-19 19:49:19.833570279 +0200\n@@ -60,10 +60,10 @@\n      * @param toolTipText  the tooltip.\n      * \n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + toolTipText\n+return \" title=\\\"\" + this.title=\\\"\" + this.title=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\"; }\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return \" title=\\\"\" + this.title=\\\"\" + this.title=\\\"\" + this.title=\\\"\" + toolTipText);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-10/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\t2022-07-19 19:49:21.389562242 +0200\n+++ /tmp/tmp8tkbkm3p.java\t2022-07-19 19:49:21.389562242 +0200\n@@ -60,10 +60,10 @@\n      * @param toolTipText  the tooltip.\n      * \n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + toolTipText\n+return \" title=\\\"\" + this.title=\\\"\" + this.title=\\\"\" + this.title=\\\"\" + toolTipText);\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return \" title=\\\"\" + this.title=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\";",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-10/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\t2022-07-19 19:49:22.949554185 +0200\n+++ /tmp/tmpq9mc4gl1.java\t2022-07-19 19:49:22.949554185 +0200\n@@ -60,10 +60,10 @@\n      * @param toolTipText  the tooltip.\n      * \n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + toolTipText\n+return \" title=\\\"\" + this.title=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\";\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return \" title=\\\"\" + this.toolTipText + \"\\\" alt=\\\"\\\"\";",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Chart-10/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\t2022-07-19 19:49:24.497546190 +0200\n+++ /tmp/tmpyp8zcavl.java\t2022-07-19 19:49:24.497546190 +0200\n@@ -60,10 +60,10 @@\n      * @param toolTipText  the tooltip.\n      * \n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + toolTipText\n+return \" title=\\\"\" + this.toolTipText + \"\\\" alt=\\\"\\\"\";\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return \" title=\\\"\" + toolTipText",
        "fixed_line": "return \" title=\\\"\" + ImageMapUtilities.htmlEscape(toolTipText)"
    },
    "JacksonDatabind-26": {
        "fixes": [
            {
                "k": 1,
                "patch": "implements BeanProperty '\"+_INTERFACES_FOR_EMPTY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-26/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\t2022-07-19 19:49:26.261537078 +0200\n+++ /tmp/tmpqlhv1c6i.java\t2022-07-19 19:49:26.301536872 +0200\n@@ -34,11 +34,11 @@\n  * code and this is to reduce likelihood of data corruption and\n  * synchronization issues.\n  */\n @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\n public class BeanPropertyWriter extends PropertyWriter\n-    implements BeanProperty\n+implements BeanProperty '\"+_INTERFACES_FOR_EMPTY;\n {\n     // as of 2.6.2\n \n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "implements BeanPropertyON_NULL_FOR_EMPTY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-26/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\t2022-07-19 19:49:28.161527266 +0200\n+++ /tmp/tmphz1ae64z.java\t2022-07-19 19:49:28.165527245 +0200\n@@ -34,11 +34,11 @@\n  * code and this is to reduce likelihood of data corruption and\n  * synchronization issues.\n  */\n @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\n public class BeanPropertyWriter extends PropertyWriter\n-    implements BeanProperty\n+implements BeanPropertyON_NULL_FOR_EMPTY;\n {\n     // as of 2.6.2\n \n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "implements BeanProperty '\"+_INTERFACE_FOR_EMPTY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-26/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\t2022-07-19 19:49:29.777518920 +0200\n+++ /tmp/tmp92x0lydb.java\t2022-07-19 19:49:29.781518898 +0200\n@@ -34,11 +34,11 @@\n  * code and this is to reduce likelihood of data corruption and\n  * synchronization issues.\n  */\n @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\n public class BeanPropertyWriter extends PropertyWriter\n-    implements BeanProperty\n+implements BeanProperty '\"+_INTERFACE_FOR_EMPTY;\n {\n     // as of 2.6.2\n \n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "implements BeanProperty(propName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-26/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\t2022-07-19 19:49:31.481510117 +0200\n+++ /tmp/tmpb0up5wc1.java\t2022-07-19 19:49:31.481510117 +0200\n@@ -34,11 +34,11 @@\n  * code and this is to reduce likelihood of data corruption and\n  * synchronization issues.\n  */\n @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\n public class BeanPropertyWriter extends PropertyWriter\n-    implements BeanProperty\n+implements BeanProperty(propName);\n {\n     // as of 2.6.2\n \n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "implements BeanProperty(propDef);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-26/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\t2022-07-19 19:49:33.037502082 +0200\n+++ /tmp/tmp6aeey945.java\t2022-07-19 19:49:33.037502082 +0200\n@@ -34,11 +34,11 @@\n  * code and this is to reduce likelihood of data corruption and\n  * synchronization issues.\n  */\n @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\n public class BeanPropertyWriter extends PropertyWriter\n-    implements BeanProperty\n+implements BeanProperty(propDef);\n {\n     // as of 2.6.2\n \n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "implements BeanPropertyHandler) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-26/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\t2022-07-19 19:49:34.585494087 +0200\n+++ /tmp/tmp9ryb2eju.java\t2022-07-19 19:49:34.585494087 +0200\n@@ -34,11 +34,11 @@\n  * code and this is to reduce likelihood of data corruption and\n  * synchronization issues.\n  */\n @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\n public class BeanPropertyWriter extends PropertyWriter\n-    implements BeanProperty\n+implements BeanPropertyHandler) {\n {\n     // as of 2.6.2\n \n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "implements BeanProperty '\"+_INTERFACES;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-26/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\t2022-07-19 19:49:36.145486028 +0200\n+++ /tmp/tmp_fbik2it.java\t2022-07-19 19:49:36.145486028 +0200\n@@ -34,11 +34,11 @@\n  * code and this is to reduce likelihood of data corruption and\n  * synchronization issues.\n  */\n @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\n public class BeanPropertyWriter extends PropertyWriter\n-    implements BeanProperty\n+implements BeanProperty '\"+_INTERFACES;\n {\n     // as of 2.6.2\n \n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "implements BeanPropertyHandler;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-26/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\t2022-07-19 19:49:37.737477807 +0200\n+++ /tmp/tmpuytw6jql.java\t2022-07-19 19:49:37.737477807 +0200\n@@ -34,11 +34,11 @@\n  * code and this is to reduce likelihood of data corruption and\n  * synchronization issues.\n  */\n @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\n public class BeanPropertyWriter extends PropertyWriter\n-    implements BeanProperty\n+implements BeanPropertyHandler;\n {\n     // as of 2.6.2\n \n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "implements BeanPropertyIndex_FOR_EMPTY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-26/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\t2022-07-19 19:49:39.389469275 +0200\n+++ /tmp/tmpax7_yaxj.java\t2022-07-19 19:49:39.393469254 +0200\n@@ -34,11 +34,11 @@\n  * code and this is to reduce likelihood of data corruption and\n  * synchronization issues.\n  */\n @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\n public class BeanPropertyWriter extends PropertyWriter\n-    implements BeanProperty\n+implements BeanPropertyIndex_FOR_EMPTY;\n {\n     // as of 2.6.2\n \n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "implements BeanProperty) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-26/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\t2022-07-19 19:49:40.857461693 +0200\n+++ /tmp/tmpkg3pduey.java\t2022-07-19 19:49:40.857461693 +0200\n@@ -34,11 +34,11 @@\n  * code and this is to reduce likelihood of data corruption and\n  * synchronization issues.\n  */\n @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\n public class BeanPropertyWriter extends PropertyWriter\n-    implements BeanProperty\n+implements BeanProperty) {\n {\n     // as of 2.6.2\n \n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "implements BeanProperty",
        "fixed_line": "implements BeanProperty, java.io.Serializable // since 2.6.2 { // as of 2.6.2 private static final long serialVersionUID = 4603296144163950020L;"
    },
    "Jsoup-41": {
        "fixes": [
            {
                "k": 1,
                "patch": "return this!= o.u;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-41/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 19:49:42.649452438 +0200\n+++ /tmp/tmprdpl64wm.java\t2022-07-19 19:49:42.701452169 +0200\n@@ -1170,11 +1170,11 @@\n         if (o == null || getClass() != o.getClass()) return false;\n         if (!super.equals(o)) return false;\n \n         Element element = (Element) o;\n \n-        return this == o;\n+return this!= o.u;\n     }\n \n     @Override\n     public int hashCode() {\n         int result = super.hashCode();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return this!= o. < o;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-41/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 19:49:44.853441053 +0200\n+++ /tmp/tmpe6g4f1xo.java\t2022-07-19 19:49:44.853441053 +0200\n@@ -1170,11 +1170,11 @@\n         if (o == null || getClass() != o.getClass()) return false;\n         if (!super.equals(o)) return false;\n \n         Element element = (Element) o;\n \n-        return this == o;\n+return this!= o. < o;\n     }\n \n     @Override\n     public int hashCode() {\n         int result = super.hashCode();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return this == o.i;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-41/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 19:49:46.381433162 +0200\n+++ /tmp/tmp8yrhack1.java\t2022-07-19 19:49:46.381433162 +0200\n@@ -1170,11 +1170,11 @@\n         if (o == null || getClass() != o.getClass()) return false;\n         if (!super.equals(o)) return false;\n \n         Element element = (Element) o;\n \n-        return this == o;\n+return this == o.i;\n     }\n \n     @Override\n     public int hashCode() {\n         int result = super.hashCode();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return this!= o.value;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-41/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 19:49:49.021419527 +0200\n+++ /tmp/tmpxhi6ip5l.java\t2022-07-19 19:49:49.505417025 +0200\n@@ -1170,11 +1170,11 @@\n         if (o == null || getClass() != o.getClass()) return false;\n         if (!super.equals(o)) return false;\n \n         Element element = (Element) o;\n \n-        return this == o;\n+return this!= o.value;\n     }\n \n     @Override\n     public int hashCode() {\n         int result = super.hashCode();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return this!= o.length;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-41/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 19:49:52.445401841 +0200\n+++ /tmp/tmptsg0gel8.java\t2022-07-19 19:49:52.445401841 +0200\n@@ -1170,11 +1170,11 @@\n         if (o == null || getClass() != o.getClass()) return false;\n         if (!super.equals(o)) return false;\n \n         Element element = (Element) o;\n \n-        return this == o;\n+return this!= o.length;\n     }\n \n     @Override\n     public int hashCode() {\n         int result = super.hashCode();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return this.o == o;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-41/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 19:49:55.529385913 +0200\n+++ /tmp/tmpc3376lqc.java\t2022-07-19 19:49:55.529385913 +0200\n@@ -1170,11 +1170,11 @@\n         if (o == null || getClass() != o.getClass()) return false;\n         if (!super.equals(o)) return false;\n \n         Element element = (Element) o;\n \n-        return this == o;\n+return this.o == o;\n     }\n \n     @Override\n     public int hashCode() {\n         int result = super.hashCode();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return this!= o.i;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-41/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 19:49:58.005373126 +0200\n+++ /tmp/tmpiczo7y7g.java\t2022-07-19 19:49:58.005373126 +0200\n@@ -1170,11 +1170,11 @@\n         if (o == null || getClass() != o.getClass()) return false;\n         if (!super.equals(o)) return false;\n \n         Element element = (Element) o;\n \n-        return this == o;\n+return this!= o.i;\n     }\n \n     @Override\n     public int hashCode() {\n         int result = super.hashCode();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return this!= o.optionalClosing;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-41/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 19:50:00.749358952 +0200\n+++ /tmp/tmpo4z5s374.java\t2022-07-19 19:50:00.749358952 +0200\n@@ -1170,11 +1170,11 @@\n         if (o == null || getClass() != o.getClass()) return false;\n         if (!super.equals(o)) return false;\n \n         Element element = (Element) o;\n \n-        return this == o;\n+return this!= o.optionalClosing;\n     }\n \n     @Override\n     public int hashCode() {\n         int result = super.hashCode();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return this.o == o.i;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-41/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 19:50:03.165346474 +0200\n+++ /tmp/tmp4lxr0cz2.java\t2022-07-19 19:50:03.165346474 +0200\n@@ -1170,11 +1170,11 @@\n         if (o == null || getClass() != o.getClass()) return false;\n         if (!super.equals(o)) return false;\n \n         Element element = (Element) o;\n \n-        return this == o;\n+return this.o == o.i;\n     }\n \n     @Override\n     public int hashCode() {\n         int result = super.hashCode();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return this!= o;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-41/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 19:50:05.865332530 +0200\n+++ /tmp/tmpfih5k5su.java\t2022-07-19 19:50:05.865332530 +0200\n@@ -1170,11 +1170,11 @@\n         if (o == null || getClass() != o.getClass()) return false;\n         if (!super.equals(o)) return false;\n \n         Element element = (Element) o;\n \n-        return this == o;\n+return this!= o;\n     }\n \n     @Override\n     public int hashCode() {\n         int result = super.hashCode();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            }
        ],
        "buggy_line": "return this == o;",
        "fixed_line": "return tag.equals(element.tag);"
    },
    "Closure-58": {
        "fixes": [
            {
                "k": 1,
                "patch": "// for(lhs, gen, kill, conditional);",
                "patch_diff": "// for(lhs, gen, kill, conditional);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "addToSetIfLocal(lhs, gen, kill, conditional);",
                "patch_diff": "addToSetIfLocal(lhs, gen, kill, conditional);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// for(lhs, gen = lhs, kill, conditional);",
                "patch_diff": "// for(lhs, gen = lhs, kill, conditional);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// for(lhs, gen, kill, conditional); addToSetIfLocal(lhs, gen, kill, conditional);",
                "patch_diff": "// for(lhs, gen, kill, conditional); addToSetIfLocal(lhs, gen, kill, conditional);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// for (int i = 0; i < lhs.length; i++) { if (lhs.isVar(lhs, gen, kill, conditional); } else { // for(var x in y) {...} } }",
                "patch_diff": "// for (int i = 0; i < lhs.length; i++) { if (lhs.isVar(lhs, gen, kill, conditional); } else { // for(var x in y) {...} } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// for(lhs, gen = lhs, kill, conditional); addToSetIfLocal(lhs, gen, kill, conditional);",
                "patch_diff": "// for(lhs, gen = lhs, kill, conditional); addToSetIfLocal(lhs, gen, kill, conditional);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// for (int i = 0; i < lhs.length; i++) { if (NodeUtil.isVar(lhs, gen, kill, conditional); } else { // for(var x in y) {...} } }",
                "patch_diff": "// for (int i = 0; i < lhs.length; i++) { if (NodeUtil.isVar(lhs, gen, kill, conditional); } else { // for(var x in y) {...} } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// for (int i = 0; i < lhs.length; i++) { if (NodeUtil.isVar(lhs, gen, kill, conditional); } else { // for(lhs, gen, kill, conditional); } }",
                "patch_diff": "// for (int i = 0; i < lhs.length; i++) { if (NodeUtil.isVar(lhs, gen, kill, conditional); } else { // for(lhs, gen, kill, conditional); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// for (int i = 0; i < lhs.length; i++) { if (NodeUtil.isVar(lhs)) {",
                "patch_diff": "// for (int i = 0; i < lhs.length; i++) { if (NodeUtil.isVar(lhs)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// for (int i = 0; i < lhs.length; i++) { if (NodeUtil.isVar(lhs)) { return; } else if (NodeUtil.isVar(lhs)) {",
                "patch_diff": "// for (int i = 0; i < lhs.length; i++) { if (NodeUtil.isVar(lhs)) { return; } else if (NodeUtil.isVar(lhs)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (NodeUtil.isName(lhs)) { addToSetIfLocal(lhs, kill); addToSetIfLocal(lhs, gen); } else { computeGenKill(lhs, gen, kill, conditional); }"
    },
    "Lang-52": {
        "fixes": [
            {
                "k": 1,
                "patch": "switch (c) { case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; default :",
                "patch_diff": "switch (c) { case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; default :",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "switch (c) { case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; default : out.write('\\\\'); break; default : out.",
                "patch_diff": "switch (c) { case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; default : out.write('\\\\'); break; default : out.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "switch (c) { case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; default : out.write('\\\\'); break; } }",
                "patch_diff": "switch (c) { case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; default : out.write('\\\\'); break; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "switch (c) { case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; default : out.write('\\\\'); break; } }",
                "patch_diff": "switch (c) { case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; default : out.write('\\\\'); break; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "switch (c) { case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '",
                "patch_diff": "switch (c) { case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "switch (c) { case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; default : out.write('\\\\'); break; } }",
                "patch_diff": "switch (c) { case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; default : out.write('\\\\'); break; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "switch (c) { case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; default : out.write('\\\\'); break; default : out.write('\\\\'); break; default : out.write('",
                "patch_diff": "switch (c) { case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; default : out.write('\\\\'); break; default : out.write('\\\\'); break; default : out.write('",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "switch (c) { case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; default : out.write('\\\\'); break; } }",
                "patch_diff": "switch (c) { case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; default : out.write('\\\\'); break; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "switch (c) { case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; default : out.write('\\\\'); break; default : out.write('\\\\'); break; } }",
                "patch_diff": "switch (c) { case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; default : out.write('\\\\'); break; default : out.write('\\\\'); break; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "switch (c) { case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\'); break; default : out.write('\\\\');",
                "patch_diff": "switch (c) { case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\'); break; default : out.write('\\\\');",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "case '/': out.write('\\\\'); out.write('/'); break;"
    },
    "JacksonDatabind-57": {
        "fixes": [
            {
                "k": 1,
                "patch": "return _bindAndReadValues(_parserFactory.createParser(src, offset, length);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-57/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\t2022-07-19 19:50:18.377267907 +0200\n+++ /tmp/tmp83f0ro2f.java\t2022-07-19 19:50:18.529267123 +0200\n@@ -1436,11 +1436,11 @@\n         throws IOException, JsonProcessingException\n     {\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+return _bindAndReadValues(_parserFactory.createParser(src, offset, length);\n                 true));\n     }\n \n     /**\n      * Overloaded version of {@link #readValue(InputStream)}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return _bindAndReadValues(_parserFactory.createParser(src), _generatorFactory);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-57/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\t2022-07-19 19:50:21.801250221 +0200\n+++ /tmp/tmp_nsuw34d.java\t2022-07-19 19:50:21.801250221 +0200\n@@ -1436,11 +1436,11 @@\n         throws IOException, JsonProcessingException\n     {\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+return _bindAndReadValues(_parserFactory.createParser(src), _generatorFactory);\n                 true));\n     }\n \n     /**\n      * Overloaded version of {@link #readValue(InputStream)}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return _bindAndReadValues(_parserFactory.createParser(src), _parserFactory.createParser(_parserFactory);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-57/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\t2022-07-19 19:50:24.137238157 +0200\n+++ /tmp/tmpw8auivyy.java\t2022-07-19 19:50:24.141238137 +0200\n@@ -1436,11 +1436,11 @@\n         throws IOException, JsonProcessingException\n     {\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+return _bindAndReadValues(_parserFactory.createParser(src), _parserFactory.createParser(_parserFactory);\n                 true));\n     }\n \n     /**\n      * Overloaded version of {@link #readValue(InputStream)}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return _bindAndReadValues(_parserFactory.createParser(src), _parserFactory);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-57/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\t2022-07-19 19:50:27.225222208 +0200\n+++ /tmp/tmpj8sz3rm0.java\t2022-07-19 19:50:27.225222208 +0200\n@@ -1436,11 +1436,11 @@\n         throws IOException, JsonProcessingException\n     {\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+return _bindAndReadValues(_parserFactory.createParser(src), _parserFactory);\n                 true));\n     }\n \n     /**\n      * Overloaded version of {@link #readValue(InputStream)}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return _bindAndReadValues(_parserFactory.createParser(src), _bufferedData, offset, length);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-57/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\t2022-07-19 19:50:29.777209027 +0200\n+++ /tmp/tmp9g0dc27u.java\t2022-07-19 19:50:29.849208654 +0200\n@@ -1436,11 +1436,11 @@\n         throws IOException, JsonProcessingException\n     {\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+return _bindAndReadValues(_parserFactory.createParser(src), _bufferedData, offset, length);\n                 true));\n     }\n \n     /**\n      * Overloaded version of {@link #readValue(InputStream)}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return _bindAndReadValues(_parserFactory.createParser(src), _valueTypeReaders);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-57/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\t2022-07-19 19:50:32.657194153 +0200\n+++ /tmp/tmpzk85_cng.java\t2022-07-19 19:50:32.661194132 +0200\n@@ -1436,11 +1436,11 @@\n         throws IOException, JsonProcessingException\n     {\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+return _bindAndReadValues(_parserFactory.createParser(src), _valueTypeReaders);\n                 true));\n     }\n \n     /**\n      * Overloaded version of {@link #readValue(InputStream)}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return _bindAndReadValues(_parserFactory.createParser(src), _typeFactory);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-57/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\t2022-07-19 19:50:35.449179733 +0200\n+++ /tmp/tmpd9_zs47n.java\t2022-07-19 19:50:35.449179733 +0200\n@@ -1436,11 +1436,11 @@\n         throws IOException, JsonProcessingException\n     {\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+return _bindAndReadValues(_parserFactory.createParser(src), _typeFactory);\n                 true));\n     }\n \n     /**\n      * Overloaded version of {@link #readValue(InputStream)}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return _bindAndReadValues(_parserFactory.createParser(src), _parserFactory.createParser(_parserFactory.createParser(_parserFactory);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-57/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\t2022-07-19 19:50:37.977166676 +0200\n+++ /tmp/tmpd0jbvnz2.java\t2022-07-19 19:50:37.977166676 +0200\n@@ -1436,11 +1436,11 @@\n         throws IOException, JsonProcessingException\n     {\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+return _bindAndReadValues(_parserFactory.createParser(src), _parserFactory.createParser(_parserFactory.createParser(_parserFactory);\n                 true));\n     }\n \n     /**\n      * Overloaded version of {@link #readValue(InputStream)}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return _bindAndReadValues(_parserFactory.createParser(src), _parserFactory.createParser(_parserFactory, offset, length);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-57/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\t2022-07-19 19:50:40.789152153 +0200\n+++ /tmp/tmpcquj9ege.java\t2022-07-19 19:50:40.789152153 +0200\n@@ -1436,11 +1436,11 @@\n         throws IOException, JsonProcessingException\n     {\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+return _bindAndReadValues(_parserFactory.createParser(src), _parserFactory.createParser(_parserFactory, offset, length);\n                 true));\n     }\n \n     /**\n      * Overloaded version of {@link #readValue(InputStream)}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return _bindAndReadValues(_parserFactory.createParser(src), _bufferedData);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-57/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\t2022-07-19 19:50:43.697137133 +0200\n+++ /tmp/tmpyye87ldv.java\t2022-07-19 19:50:44.801131432 +0200\n@@ -1436,11 +1436,11 @@\n         throws IOException, JsonProcessingException\n     {\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+return _bindAndReadValues(_parserFactory.createParser(src), _bufferedData);\n                 true));\n     }\n \n     /**\n      * Overloaded version of {@link #readValue(InputStream)}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src),",
        "fixed_line": "return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length),"
    },
    "Math-74": {
        "fixes": [
            {
                "k": 1,
                "patch": "final double[] scale = new double[y0.length]; } else if (scaleAbsoluteTolerance!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-74/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2022-07-19 19:50:47.637116784 +0200\n+++ /tmp/tmp38svlow1.java\t2022-07-19 19:50:47.757116164 +0200\n@@ -240,16 +240,11 @@\n           // first stage\n           computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n-            } else {\n-              scale = vecAbsoluteTolerance;\n+final double[] scale = new double[y0.length]; } else if (scaleAbsoluteTolerance!= null) {\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "final double[] scale = new double[y0.0.util.Arrays.length];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-74/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2022-07-19 19:50:50.633101308 +0200\n+++ /tmp/tmpid6b8tp_.java\t2022-07-19 19:50:50.925099804 +0200\n@@ -240,16 +240,11 @@\n           // first stage\n           computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n-            } else {\n-              scale = vecAbsoluteTolerance;\n+final double[] scale = new double[y0.0.util.Arrays.length];\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "final double[] scale = new double[y0.0.util.Arrays.ONEerance; } else if (scaleAbsoluteTolerance!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-74/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2022-07-19 19:50:53.917084348 +0200\n+++ /tmp/tmpibc_gjbe.java\t2022-07-19 19:50:53.921084327 +0200\n@@ -240,16 +240,11 @@\n           // first stage\n           computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n-            } else {\n-              scale = vecAbsoluteTolerance;\n+final double[] scale = new double[y0.0.util.Arrays.ONEerance; } else if (scaleAbsoluteTolerance!= null) {\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "final double[] scale = new double[y0.0.length]; } else if (scaleAbsoluteTolerance!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-74/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2022-07-19 19:50:56.981068522 +0200\n+++ /tmp/tmpk02dm246.java\t2022-07-19 19:50:56.985068503 +0200\n@@ -240,16 +240,11 @@\n           // first stage\n           computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n-            } else {\n-              scale = vecAbsoluteTolerance;\n+final double[] scale = new double[y0.0.length]; } else if (scaleAbsoluteTolerance!= null) {\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "final double[] scale = new double[y0.length];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-74/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2022-07-19 19:50:59.993052967 +0200\n+++ /tmp/tmpofnovqfl.java\t2022-07-19 19:50:59.993052967 +0200\n@@ -240,16 +240,11 @@\n           // first stage\n           computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n-            } else {\n-              scale = vecAbsoluteTolerance;\n+final double[] scale = new double[y0.length];\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "final double[] scale = new double[y0. specified.length]; } else if (scaleAbsoluteTolerance!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-74/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2022-07-19 19:51:02.929037801 +0200\n+++ /tmp/tmpbcr280s8.java\t2022-07-19 19:51:02.933037782 +0200\n@@ -240,16 +240,11 @@\n           // first stage\n           computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n-            } else {\n-              scale = vecAbsoluteTolerance;\n+final double[] scale = new double[y0. specified.length]; } else if (scaleAbsoluteTolerance!= null) {\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "final double[] scale = new double[y0.0.util.Arrays.length]; } else if (scaleAbsoluteTolerance!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-74/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2022-07-19 19:51:06.033021771 +0200\n+++ /tmp/tmpskx9ri7_.java\t2022-07-19 19:51:06.153021150 +0200\n@@ -240,16 +240,11 @@\n           // first stage\n           computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n-            } else {\n-              scale = vecAbsoluteTolerance;\n+final double[] scale = new double[y0.0.util.Arrays.length]; } else if (scaleAbsoluteTolerance!= null) {\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "final double[] scale = new double[y0.0.util.Arrays.ONEerance;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-74/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2022-07-19 19:51:09.101005924 +0200\n+++ /tmp/tmpy3wqpjns.java\t2022-07-19 19:51:09.101005924 +0200\n@@ -240,16 +240,11 @@\n           // first stage\n           computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n-            } else {\n-              scale = vecAbsoluteTolerance;\n+final double[] scale = new double[y0.0.util.Arrays.ONEerance;\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "final double[] scale = new double[y0.0.util.Arrays. == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-74/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2022-07-19 19:51:11.924991339 +0200\n+++ /tmp/tmpxk43a08z.java\t2022-07-19 19:51:12.044990718 +0200\n@@ -240,16 +240,11 @@\n           // first stage\n           computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n-            } else {\n-              scale = vecAbsoluteTolerance;\n+final double[] scale = new double[y0.0.util.Arrays. == null) {\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "final double[] scale = new double[y0. specified.length];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-74/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2022-07-19 19:51:14.996975472 +0200\n+++ /tmp/tmptbwqbg89.java\t2022-07-19 19:51:14.996975472 +0200\n@@ -240,16 +240,11 @@\n           // first stage\n           computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n-            } else {\n-              scale = vecAbsoluteTolerance;\n+final double[] scale = new double[y0. specified.length];\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "final double[] scale; if (vecAbsoluteTolerance == null) { scale = new double[y0.length]; java.util.Arrays.fill(scale, scalAbsoluteTolerance); } else { scale = vecAbsoluteTolerance;",
        "fixed_line": "final double[] scale = new double[y0.length]; if (vecAbsoluteTolerance == null) { for (int i = 0; i < scale.length; ++i) { scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]); } } else { for (int i = 0; i < scale.length; ++i) { scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]); }"
    },
    "Math-10": {
        "fixes": [
            {
                "k": 1,
                "patch": "// fix value to take special cases (+2]+0, +0/+0, -0/-0, - 1)-infinity;",
                "patch_diff": "// fix value to take special cases (+2]+0, +0/+0, -0/-0, - 1)-infinity;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// fix value to take special cases (+2]+0, +0/+0, -0/-0, - 1)-infinity; }",
                "patch_diff": "// fix value to take special cases (+2]+0, +0/+0, -0/-0, - 1)-infinity; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// fix value to take special cases (+2]+0, +0/-0, -0/-0, - 1)-infinity;",
                "patch_diff": "// fix value to take special cases (+2]+0, +0/-0, -0/-0, - 1)-infinity;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// fix value to take special cases (+2]+0, +0/+0, -0/-0, - is-infinity;",
                "patch_diff": "// fix value to take special cases (+2]+0, +0/+0, -0/-0, - is-infinity;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// fix value to take special cases (+2]+0, +0/+0, -0/-0, -",
                "patch_diff": "// fix value to take special cases (+2]+0, +0/+0, -0/-0, -",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// fix value to take special cases (+2]+0, 31+2]+0, -0/-0, - 1)-infinity;",
                "patch_diff": "// fix value to take special cases (+2]+0, 31+2]+0, -0/-0, - 1)-infinity;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// fix value to take special cases (+2]+0, +0/+0, -0/-0, - is-infinity)\"); }",
                "patch_diff": "// fix value to take special cases (+2]+0, +0/+0, -0/-0, - is-infinity)\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// fix value to take. }",
                "patch_diff": "// fix value to take. }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// fix value to take special cases (+2]+0, +0/+0, -0/-0, - long--infinity;",
                "patch_diff": "// fix value to take special cases (+2]+0, +0/+0, -0/-0, - long--infinity;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// fix value to take special cases (+2]+0, +0/+0, -0/-0, - is-infinity; }",
                "patch_diff": "// fix value to take special cases (+2]+0, +0/+0, -0/-0, - is-infinity; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);"
    },
    "Closure-113": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (removed == null) { // block only override if more specific",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-113/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 19:51:20.888945041 +0200\n+++ /tmp/tmpx8rdgd8v.java\t2022-07-19 19:51:21.724940723 +0200\n@@ -324,11 +324,11 @@\n       // Requires should be removed before further processing.\n       // Some clients run closure pass multiple times, first with\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+if (removed == null) { // block only override if more specific\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n     }\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (removed == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-113/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 19:51:28.264906946 +0200\n+++ /tmp/tmp3b_9g4kq.java\t2022-07-19 19:51:28.268906925 +0200\n@@ -324,11 +324,11 @@\n       // Requires should be removed before further processing.\n       // Some clients run closure pass multiple times, first with\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+if (removed == null) {\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n     }\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (removed!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-113/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 19:51:31.948887917 +0200\n+++ /tmp/tmpj6izizlp.java\t2022-07-19 19:51:31.948887917 +0200\n@@ -324,11 +324,11 @@\n       // Requires should be removed before further processing.\n       // Some clients run closure pass multiple times, first with\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+if (removed!= null) {\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n     }\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (removed == null) { // block == null; can't really modify it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-113/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 19:51:35.600869056 +0200\n+++ /tmp/tmp2etp99ab.java\t2022-07-19 19:51:35.600869056 +0200\n@@ -324,11 +324,11 @@\n       // Requires should be removed before further processing.\n       // Some clients run closure pass multiple times, first with\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+if (removed == null) { // block == null; can't really modify it's do implicit re-parse\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n     }\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (removed == null) { // block == null; can't really modify it's do implicit re-initialized or EMPTY",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-113/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 19:51:39.472849058 +0200\n+++ /tmp/tmph5fdyx_t.java\t2022-07-19 19:51:39.472849058 +0200\n@@ -324,11 +324,11 @@\n       // Requires should be removed before further processing.\n       // Some clients run closure pass multiple times, first with\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+if (removed == null) { // block == null; can't really modify it's do implicit re-initialized or EMPTY\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n     }\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (c!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-113/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 19:51:43.380828873 +0200\n+++ /tmp/tmphqdjgv6s.java\t2022-07-19 19:51:43.380828873 +0200\n@@ -324,11 +324,11 @@\n       // Requires should be removed before further processing.\n       // Some clients run closure pass multiple times, first with\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+if (c!= null) {\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n     }\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (parent.detachFromParent == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-113/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 19:51:47.088809721 +0200\n+++ /tmp/tmp5o3kg76q.java\t2022-07-19 19:51:47.092809702 +0200\n@@ -324,11 +324,11 @@\n       // Requires should be removed before further processing.\n       // Some clients run closure pass multiple times, first with\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+if (parent.detachFromParent == null) {\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n     }\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (replacement == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-113/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 19:51:50.740790860 +0200\n+++ /tmp/tmpnun6ugki.java\t2022-07-19 19:51:50.740790860 +0200\n@@ -324,11 +324,11 @@\n       // Requires should be removed before further processing.\n       // Some clients run closure pass multiple times, first with\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+if (replacement == null) {\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n     }\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (replacement!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-113/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 19:51:54.176773112 +0200\n+++ /tmp/tmp55krpnlp.java\t2022-07-19 19:51:54.176773112 +0200\n@@ -324,11 +324,11 @@\n       // Requires should be removed before further processing.\n       // Some clients run closure pass multiple times, first with\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+if (replacement!= null) {\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n     }\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (removed == null) { // block == null; can't be null if we're not use a native function.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-113/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 19:51:57.716754830 +0200\n+++ /tmp/tmpf808bp_0.java\t2022-07-19 19:51:57.716754830 +0200\n@@ -324,11 +324,11 @@\n       // Requires should be removed before further processing.\n       // Some clients run closure pass multiple times, first with\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+if (removed == null) { // block == null; can't be null if we're not use a native function.\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n     }\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (provided != null) {",
        "fixed_line": "if (provided != null || requiresLevel.isOn()) {"
    },
    "Jsoup-47": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (c == val) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-47/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 19:52:01.636734584 +0200\n+++ /tmp/tmpoimht596.java\t2022-07-19 19:52:01.664734439 +0200\n@@ -117,11 +117,11 @@\n                         else\n                             accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+if (c == val) {\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n                         break;\n                     case '>':\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (c!= val) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-47/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 19:52:03.352725721 +0200\n+++ /tmp/tmpla9lvbea.java\t2022-07-19 19:52:03.352725721 +0200\n@@ -117,11 +117,11 @@\n                         else\n                             accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+if (c!= val) {\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n                         break;\n                     case '>':\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (info.inAttribute) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-47/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 19:52:04.852717973 +0200\n+++ /tmp/tmpqsci8u9j.java\t2022-07-19 19:52:04.856717954 +0200\n@@ -117,11 +117,11 @@\n                         else\n                             accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+if (info.inAttribute) {\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n                         break;\n                     case '>':\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (info.inAttribute)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-47/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 19:52:06.384710061 +0200\n+++ /tmp/tmplwmxvk5k.java\t2022-07-19 19:52:06.384710061 +0200\n@@ -117,11 +117,11 @@\n                         else\n                             accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+if (info.inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n                         break;\n                     case '>':\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (intr)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-47/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 19:52:08.192700723 +0200\n+++ /tmp/tmpk2qu3d_3.java\t2022-07-19 19:52:08.192700723 +0200\n@@ -117,11 +117,11 @@\n                         else\n                             accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+if (intr)\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n                         break;\n                     case '>':\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (c) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-47/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 19:52:09.792692458 +0200\n+++ /tmp/tmpilaqjal_.java\t2022-07-19 19:52:09.796692439 +0200\n@@ -117,11 +117,11 @@\n                         else\n                             accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+if (c) {\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n                         break;\n                     case '>':\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (intr) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-47/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 19:52:11.340684463 +0200\n+++ /tmp/tmp9u7laj8i.java\t2022-07-19 19:52:11.344684444 +0200\n@@ -117,11 +117,11 @@\n                         else\n                             accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+if (intr) {\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n                         break;\n                     case '>':\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if ( accum) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-47/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 19:52:12.832676757 +0200\n+++ /tmp/tmp5avg1h8v.java\t2022-07-19 19:52:12.832676757 +0200\n@@ -117,11 +117,11 @@\n                         else\n                             accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+if ( accum) {\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n                         break;\n                     case '>':\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (section) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-47/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 19:52:14.320669073 +0200\n+++ /tmp/tmp3ef_xasb.java\t2022-07-19 19:52:14.320669073 +0200\n@@ -117,11 +117,11 @@\n                         else\n                             accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+if (section) {\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n                         break;\n                     case '>':\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (accum)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-47/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 19:52:15.804661408 +0200\n+++ /tmp/tmpwy1t940c.java\t2022-07-19 19:52:15.804661408 +0200\n@@ -117,11 +117,11 @@\n                         else\n                             accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+if (accum)\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n                         break;\n                     case '>':\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (!inAttribute)",
        "fixed_line": "if (!inAttribute || escapeMode == EscapeMode.xhtml)"
    },
    "Closure-127": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (nextCfgNode!= field && nextCfgNode) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2022-07-19 19:52:17.560652339 +0200\n+++ /tmp/tmpvbwjzahy.java\t2022-07-19 19:52:17.584652215 +0200\n@@ -165,11 +165,11 @@\n \n             Preconditions.checkState(\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+if (nextCfgNode!= field && nextCfgNode) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (nextCfgNode!= field) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2022-07-19 19:52:22.516626740 +0200\n+++ /tmp/tmpm_xoqc77.java\t2022-07-19 19:52:22.516626740 +0200\n@@ -165,11 +165,11 @@\n \n             Preconditions.checkState(\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+if (nextCfgNode!= field) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (nextCfgNode!= 10) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2022-07-19 19:52:26.012608686 +0200\n+++ /tmp/tmpvenf3_at.java\t2022-07-19 19:52:26.012608686 +0200\n@@ -165,11 +165,11 @@\n \n             Preconditions.checkState(\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+if (nextCfgNode!= 10) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (nextCfgNode!= firstCfgNode) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2022-07-19 19:52:29.548590423 +0200\n+++ /tmp/tmpk13lotsb.java\t2022-07-19 19:52:29.548590423 +0200\n@@ -165,11 +165,11 @@\n \n             Preconditions.checkState(\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+if (nextCfgNode!= firstCfgNode) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (nextCfgNode!= nextCfgNode) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2022-07-19 19:52:33.116571993 +0200\n+++ /tmp/tmpzwirkljl.java\t2022-07-19 19:52:33.116571993 +0200\n@@ -165,11 +165,11 @@\n \n             Preconditions.checkState(\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+if (nextCfgNode!= nextCfgNode) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (nextCfgNode == nextCfgNode) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2022-07-19 19:53:22.092319041 +0200\n+++ /tmp/tmpawwl_byr.java\t2022-07-19 19:53:22.092319041 +0200\n@@ -165,11 +165,11 @@\n \n             Preconditions.checkState(\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+if (nextCfgNode == nextCfgNode) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (nextCfgNode!= child) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2022-07-19 19:54:07.592084041 +0200\n+++ /tmp/tmpqjlnslw3.java\t2022-07-19 19:54:07.592084041 +0200\n@@ -165,11 +165,11 @@\n \n             Preconditions.checkState(\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+if (nextCfgNode!= child) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (nextCfgNode!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2022-07-19 19:54:11.508063815 +0200\n+++ /tmp/tmphbko3cv4.java\t2022-07-19 19:54:11.508063815 +0200\n@@ -165,11 +165,11 @@\n \n             Preconditions.checkState(\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+if (nextCfgNode!= null) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (nextCfgNode instanceof fallThrough) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2022-07-19 19:54:56.995828877 +0200\n+++ /tmp/tmpqu7a6hgo.java\t2022-07-19 19:54:56.995828877 +0200\n@@ -165,11 +165,11 @@\n \n             Preconditions.checkState(\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+if (nextCfgNode instanceof fallThrough) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (nextCfgNode!= childCfgNode) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2022-07-19 19:55:00.915808630 +0200\n+++ /tmp/tmpfduuhfyf.java\t2022-07-19 19:55:00.915808630 +0200\n@@ -165,11 +165,11 @@\n \n             Preconditions.checkState(\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+if (nextCfgNode!= childCfgNode) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (nextCfgNode == fallThrough) {",
        "fixed_line": "if (nextCfgNode == fallThrough && !inFinally(n.getParent(), n)) { removeNode(n); } } } } private boolean inFinally(Node parent, Node child) { if (parent == null || parent.isFunction()) { return false; } else if (NodeUtil.isTryFinallyNode(parent, child)) { return true; } else { return inFinally(parent.getParent(), parent); } }"
    },
    "Closure-96": {
        "fixes": [
            {
                "k": 1,
                "patch": "parameters.hasNextCall {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-96/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 19:55:04.807788529 +0200\n+++ /tmp/tmpe4p2pvgk.java\t2022-07-19 19:55:04.951787785 +0200\n@@ -1404,11 +1404,11 @@\n     Iterator<Node> parameters = functionType.getParameters().iterator();\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+parameters.hasNextCall {\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "parameters.hasNextCall) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-96/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 19:55:07.319775555 +0200\n+++ /tmp/tmp9mvxjriq.java\t2022-07-19 19:55:07.323775534 +0200\n@@ -1404,11 +1404,11 @@\n     Iterator<Node> parameters = functionType.getParameters().iterator();\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+parameters.hasNextCall) {\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "parameters.hasNext Dis;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-96/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 19:55:09.363764996 +0200\n+++ /tmp/tmpwfui2ehz.java\t2022-07-19 19:55:09.363764996 +0200\n@@ -1404,11 +1404,11 @@\n     Iterator<Node> parameters = functionType.getParameters().iterator();\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+parameters.hasNext Dis;\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "parameters.hasNextItemCount;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-96/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 19:55:11.239755309 +0200\n+++ /tmp/tmpfev8iv_i.java\t2022-07-19 19:55:11.239755309 +0200\n@@ -1404,11 +1404,11 @@\n     Iterator<Node> parameters = functionType.getParameters().iterator();\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+parameters.hasNextItemCount;\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "parameters.hasNext force') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-96/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 19:55:12.775747375 +0200\n+++ /tmp/tmpbyp_zrdo.java\t2022-07-19 19:55:12.775747375 +0200\n@@ -1404,11 +1404,11 @@\n     Iterator<Node> parameters = functionType.getParameters().iterator();\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+parameters.hasNext force') {\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "parameters.hasNext;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-96/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 19:55:14.435738800 +0200\n+++ /tmp/tmp1k5s5wn_.java\t2022-07-19 19:55:14.435738800 +0200\n@@ -1404,11 +1404,11 @@\n     Iterator<Node> parameters = functionType.getParameters().iterator();\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+parameters.hasNext;\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "parameters.hasNextProcessing) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-96/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 19:55:16.315729092 +0200\n+++ /tmp/tmpimp1vccz.java\t2022-07-19 19:55:16.315729092 +0200\n@@ -1404,11 +1404,11 @@\n     Iterator<Node> parameters = functionType.getParameters().iterator();\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+parameters.hasNextProcessing) {\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "parameters.hasNext()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-96/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 19:55:18.171719507 +0200\n+++ /tmp/tmp27woq9o8.java\t2022-07-19 19:55:18.171719507 +0200\n@@ -1404,11 +1404,11 @@\n     Iterator<Node> parameters = functionType.getParameters().iterator();\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+parameters.hasNext()) {\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "parameters.hasNext();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-96/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 19:55:43.323589600 +0200\n+++ /tmp/tmpyj8saq8f.java\t2022-07-19 19:55:43.327589579 +0200\n@@ -1404,11 +1404,11 @@\n     Iterator<Node> parameters = functionType.getParameters().iterator();\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+parameters.hasNext();\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "parameters.hasNext]) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-96/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 19:55:45.019580839 +0200\n+++ /tmp/tmpr7973szb.java\t2022-07-19 19:55:45.019580839 +0200\n@@ -1404,11 +1404,11 @@\n     Iterator<Node> parameters = functionType.getParameters().iterator();\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+parameters.hasNext]) {\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "parameters.hasNext()) {",
        "fixed_line": "(parameters.hasNext() || parameter != null && parameter.isVarArgs())) { // If there are no parameters left in the list, then the while loop // above implies that this must be a var_args function. if (parameters.hasNext()) { parameter = parameters.next(); }"
    },
    "Math-105": {
        "fixes": [
            {
                "k": 1,
                "patch": "return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-105/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\t2022-07-19 19:55:47.427568405 +0200\n+++ /tmp/tmp7pqokx1v.java\t2022-07-19 19:55:47.547567787 +0200\n@@ -259,11 +259,11 @@\n      * </li></ul>\n      *\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX;\n     }\n \n     /**\n      * Returns the sum of squared deviations of the y values about their mean.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-105/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\t2022-07-19 19:55:51.203548899 +0200\n+++ /tmp/tmpimjtf4wx.java\t2022-07-19 19:55:51.203548899 +0200\n@@ -259,11 +259,11 @@\n      * </li></ul>\n      *\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX;\n     }\n \n     /**\n      * Returns the sum of squared deviations of the y values about their mean.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXY * sumXX;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-105/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\t2022-07-19 19:55:54.463532064 +0200\n+++ /tmp/tmp_vpzjqsr.java\t2022-07-19 19:55:54.463532064 +0200\n@@ -259,11 +259,11 @@\n      * </li></ul>\n      *\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXY * sumXX;\n     }\n \n     /**\n      * Returns the sum of squared deviations of the y values about their mean.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-105/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\t2022-07-19 19:55:57.743515121 +0200\n+++ /tmp/tmp0tz57j28.java\t2022-07-19 19:55:57.743515121 +0200\n@@ -259,11 +259,11 @@\n      * </li></ul>\n      *\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX;\n     }\n \n     /**\n      * Returns the sum of squared deviations of the y values about their mean.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-105/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\t2022-07-19 19:56:01.067497953 +0200\n+++ /tmp/tmp3m5qamjs.java\t2022-07-19 19:56:01.067497953 +0200\n@@ -259,11 +259,11 @@\n      * </li></ul>\n      *\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX;\n     }\n \n     /**\n      * Returns the sum of squared deviations of the y values about their mean.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-105/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\t2022-07-19 19:56:04.359480951 +0200\n+++ /tmp/tmpit555r7l.java\t2022-07-19 19:56:04.359480951 +0200\n@@ -259,11 +259,11 @@\n      * </li></ul>\n      *\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX;\n     }\n \n     /**\n      * Returns the sum of squared deviations of the y values about their mean.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXY * sumXY / sumXX;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-105/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\t2022-07-19 19:56:07.751463433 +0200\n+++ /tmp/tmpkei8019q.java\t2022-07-19 19:56:07.755463411 +0200\n@@ -259,11 +259,11 @@\n      * </li></ul>\n      *\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXY * sumXY / sumXX;\n     }\n \n     /**\n      * Returns the sum of squared deviations of the y values about their mean.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXY * sumXY / sumXX;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-105/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\t2022-07-19 19:56:11.059446348 +0200\n+++ /tmp/tmpaz1sh480.java\t2022-07-19 19:56:11.059446348 +0200\n@@ -259,11 +259,11 @@\n      * </li></ul>\n      *\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXY * sumXY / sumXX;\n     }\n \n     /**\n      * Returns the sum of squared deviations of the y values about their mean.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXY * sumXX;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-105/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\t2022-07-19 19:56:14.399429098 +0200\n+++ /tmp/tmpnclujzrf.java\t2022-07-19 19:56:14.399429098 +0200\n@@ -259,11 +259,11 @@\n      * </li></ul>\n      *\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXY * sumXX;\n     }\n \n     /**\n      * Returns the sum of squared deviations of the y values about their mean.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXY * sumXX;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Math-105/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\t2022-07-19 19:56:17.723411930 +0200\n+++ /tmp/tmptj4wv1i0.java\t2022-07-19 19:56:17.723411930 +0200\n@@ -259,11 +259,11 @@\n      * </li></ul>\n      *\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXY * sumXX;\n     }\n \n     /**\n      * Returns the sum of squared deviations of the y values about their mean.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return sumYY - sumXY * sumXY / sumXX;",
        "fixed_line": "return Math.max(0d, sumYY - sumXY * sumXY / sumXX);"
    },
    "Gson-18": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (contextType.isAssignableFrom(context, type, contextRawType) {",
                "patch_diff": "} else if (contextType.isAssignableFrom(context, type, contextRawType) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// TODO: can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "patch_diff": "// TODO: can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (contextType.isAssignableFrom(context, contextRawType, supertype) {",
                "patch_diff": "} else if (contextType.isAssignableFrom(context, contextRawType, supertype) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (contextType.isAssignableFrom(context, contextRawType)) {",
                "patch_diff": "} else if (contextType.isAssignableFrom(context, contextRawType)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// TODO: can't really modify it was non-literal characters that might be valid (empty be // need to check",
                "patch_diff": "// TODO: can't really modify it was non-literal characters that might be valid (empty be // need to check",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// TODO: can't really modify it was non-literal characters that might be valid (e if it's",
                "patch_diff": "// TODO: can't really modify it was non-literal characters that might be valid (e if it's",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// TODO: can't really modify it was non-literal characters that might be valid (empty be",
                "patch_diff": "// TODO: can't really modify it was non-literal characters that might be valid (empty be",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// TODO: can't really modify it was non-literal characters that might be valid (empty be valid)",
                "patch_diff": "// TODO: can't really modify it was non-literal characters that might be valid (empty be valid)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// TODO: can't really modify it was non-literal characters that might be null or EMPTY",
                "patch_diff": "// TODO: can't really modify it was non-literal characters that might be null or EMPTY",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (contextType.isAssignableFrom(context)) {",
                "patch_diff": "} else if (contextType.isAssignableFrom(context)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (context instanceof WildcardType) { // wildcards are useless for resolving supertypes. As the upper bound has the same raw type, use it instead context = ((WildcardType)context).getUpperBounds()[0]; }"
    },
    "Time-19": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (prevAdjusted > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-19/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 19:56:22.799385711 +0200\n+++ /tmp/tmp3ogih8rk.java\t2022-07-19 19:56:22.883385280 +0200\n@@ -895,11 +895,11 @@\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+} else if (prevAdjusted > 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n                 int diff = offsetPrev - offsetLocal;\n                 if (instantAdjusted - prev <= diff) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (nextAdjusted!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-19/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 19:56:25.143373605 +0200\n+++ /tmp/tmph34msbq1.java\t2022-07-19 19:56:25.147373586 +0200\n@@ -895,11 +895,11 @@\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+} else if (nextAdjusted!= 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n                 int diff = offsetPrev - offsetLocal;\n                 if (instantAdjusted - prev <= diff) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (nextAdjusted == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-19/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 19:56:26.931364372 +0200\n+++ /tmp/tmpwc0705y1.java\t2022-07-19 19:56:26.931364372 +0200\n@@ -895,11 +895,11 @@\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+} else if (nextAdjusted == 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n                 int diff = offsetPrev - offsetLocal;\n                 if (instantAdjusted - prev <= diff) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (prevAdjusted == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-19/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 19:56:28.711355177 +0200\n+++ /tmp/tmpdsgjqurc.java\t2022-07-19 19:56:28.711355177 +0200\n@@ -895,11 +895,11 @@\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+} else if (prevAdjusted == 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n                 int diff = offsetPrev - offsetLocal;\n                 if (instantAdjusted - prev <= diff) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (iAdjusted > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-19/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 19:56:30.519345841 +0200\n+++ /tmp/tmpapmla4g_.java\t2022-07-19 19:56:30.519345841 +0200\n@@ -895,11 +895,11 @@\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+} else if (iAdjusted > 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n                 int diff = offsetPrev - offsetLocal;\n                 if (instantAdjusted - prev <= diff) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (nextAdjusted > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-19/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 19:56:32.367336296 +0200\n+++ /tmp/tmp4pbhq1p0.java\t2022-07-19 19:56:32.367336296 +0200\n@@ -895,11 +895,11 @@\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+} else if (nextAdjusted > 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n                 int diff = offsetPrev - offsetLocal;\n                 if (instantAdjusted - prev <= diff) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (nextLocal!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-19/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 19:56:34.163327018 +0200\n+++ /tmp/tmpo41bcm5s.java\t2022-07-19 19:56:34.167327000 +0200\n@@ -895,11 +895,11 @@\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+} else if (nextLocal!= 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n                 int diff = offsetPrev - offsetLocal;\n                 if (instantAdjusted - prev <= diff) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (fLocal!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-19/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 19:56:35.883318136 +0200\n+++ /tmp/tmp3qnwhqsa.java\t2022-07-19 19:56:35.883318136 +0200\n@@ -895,11 +895,11 @@\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+} else if (fLocal!= 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n                 int diff = offsetPrev - offsetLocal;\n                 if (instantAdjusted - prev <= diff) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (iAdjusted == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-19/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 19:56:37.639309067 +0200\n+++ /tmp/tmppwhqbpfa.java\t2022-07-19 19:56:37.643309046 +0200\n@@ -895,11 +895,11 @@\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+} else if (iAdjusted == 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n                 int diff = offsetPrev - offsetLocal;\n                 if (instantAdjusted - prev <= diff) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (offsetLocal!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Time-19/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 19:56:39.419299874 +0200\n+++ /tmp/tmp5dcwmkg2.java\t2022-07-19 19:56:39.419299874 +0200\n@@ -895,11 +895,11 @@\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+} else if (offsetLocal!= 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n                 int diff = offsetPrev - offsetLocal;\n                 if (instantAdjusted - prev <= diff) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "} else if (offsetLocal > 0) {",
        "fixed_line": "} else if (offsetLocal >= 0) {"
    },
    "JacksonDatabind-102": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (property!= null) { return jp; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-102/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 19:56:52.107234343 +0200\n+++ /tmp/tmps8awn_su.java\t2022-07-19 19:56:52.135234199 +0200\n@@ -62,13 +62,11 @@\n     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n             BeanProperty property) throws JsonMappingException\n     {\n         // Note! Should not skip if `property` null since that'd skip check\n         // for config overrides, in case of root value\n-        if (property == null) {\n-            return this;\n-        }\n+if (property!= null) { return jp; }\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n         }\n         // Simple case first: serialize as numeric timestamp?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (property!= null) { return from '_; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-102/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 19:56:54.647221221 +0200\n+++ /tmp/tmphdzvbj3b.java\t2022-07-19 19:56:54.647221221 +0200\n@@ -62,13 +62,11 @@\n     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n             BeanProperty property) throws JsonMappingException\n     {\n         // Note! Should not skip if `property` null since that'd skip check\n         // for config overrides, in case of root value\n-        if (property == null) {\n-            return this;\n-        }\n+if (property!= null) { return from '_; }\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n         }\n         // Simple case first: serialize as numeric timestamp?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (property!= null) { return from first; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-102/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 19:56:56.171213353 +0200\n+++ /tmp/tmpzvqpmlef.java\t2022-07-19 19:56:56.171213353 +0200\n@@ -62,13 +62,11 @@\n     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n             BeanProperty property) throws JsonMappingException\n     {\n         // Note! Should not skip if `property` null since that'd skip check\n         // for config overrides, in case of root value\n-        if (property == null) {\n-            return this;\n-        }\n+if (property!= null) { return from first; }\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n         }\n         // Simple case first: serialize as numeric timestamp?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (property!= null) { return from; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-102/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 19:56:57.855204655 +0200\n+++ /tmp/tmp5h2irnxh.java\t2022-07-19 19:56:57.859204634 +0200\n@@ -62,13 +62,11 @@\n     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n             BeanProperty property) throws JsonMappingException\n     {\n         // Note! Should not skip if `property` null since that'd skip check\n         // for config overrides, in case of root value\n-        if (property == null) {\n-            return this;\n-        }\n+if (property!= null) { return from; }\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n         }\n         // Simple case first: serialize as numeric timestamp?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (property!= null) { return from from '_; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-102/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 19:56:59.731194963 +0200\n+++ /tmp/tmpbt9syl72.java\t2022-07-19 19:56:59.731194963 +0200\n@@ -62,13 +62,11 @@\n     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n             BeanProperty property) throws JsonMappingException\n     {\n         // Note! Should not skip if `property` null since that'd skip check\n         // for config overrides, in case of root value\n-        if (property == null) {\n-            return this;\n-        }\n+if (property!= null) { return from from '_; }\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n         }\n         // Simple case first: serialize as numeric timestamp?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (property!= null) { return this.property; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-102/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 19:57:01.375186472 +0200\n+++ /tmp/tmpzztolxjt.java\t2022-07-19 19:57:01.375186472 +0200\n@@ -62,13 +62,11 @@\n     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n             BeanProperty property) throws JsonMappingException\n     {\n         // Note! Should not skip if `property` null since that'd skip check\n         // for config overrides, in case of root value\n-        if (property == null) {\n-            return this;\n-        }\n+if (property!= null) { return this.property; }\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n         }\n         // Simple case first: serialize as numeric timestamp?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (property!= null) { return this; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-102/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 19:57:03.339176331 +0200\n+++ /tmp/tmppztzef6i.java\t2022-07-19 19:57:03.339176331 +0200\n@@ -62,13 +62,11 @@\n     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n             BeanProperty property) throws JsonMappingException\n     {\n         // Note! Should not skip if `property` null since that'd skip check\n         // for config overrides, in case of root value\n-        if (property == null) {\n-            return this;\n-        }\n+if (property!= null) { return this; }\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n         }\n         // Simple case first: serialize as numeric timestamp?\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (property == null) { return this; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-102/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 19:58:05.258856522 +0200\n+++ /tmp/tmp80u4zkw5.java\t2022-07-19 19:58:05.258856522 +0200\n@@ -62,13 +62,11 @@\n     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n             BeanProperty property) throws JsonMappingException\n     {\n         // Note! Should not skip if `property` null since that'd skip check\n         // for config overrides, in case of root value\n-        if (property == null) {\n-            return this;\n-        }\n+if (property == null) { return this; }\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n         }\n         // Simple case first: serialize as numeric timestamp?\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (property!= null) { return _property; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-102/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 19:59:00.862569339 +0200\n+++ /tmp/tmpqxnrv5kh.java\t2022-07-19 19:59:00.862569339 +0200\n@@ -62,13 +62,11 @@\n     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n             BeanProperty property) throws JsonMappingException\n     {\n         // Note! Should not skip if `property` null since that'd skip check\n         // for config overrides, in case of root value\n-        if (property == null) {\n-            return this;\n-        }\n+if (property!= null) { return _property; }\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n         }\n         // Simple case first: serialize as numeric timestamp?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (property!= null) { return null; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonDatabind-102/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 19:59:02.546560642 +0200\n+++ /tmp/tmpk59mdczn.java\t2022-07-19 19:59:02.546560642 +0200\n@@ -62,13 +62,11 @@\n     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n             BeanProperty property) throws JsonMappingException\n     {\n         // Note! Should not skip if `property` null since that'd skip check\n         // for config overrides, in case of root value\n-        if (property == null) {\n-            return this;\n-        }\n+if (property!= null) { return null; }\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n         }\n         // Simple case first: serialize as numeric timestamp?\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (property == null) { return this; }",
        "fixed_line": ""
    },
    "Closure-22": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (ancestor.getType() == Token.ASSIGN) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2022-07-19 19:59:57.082278973 +0200\n+++ /tmp/tmpvto3tzmy.java\t2022-07-19 19:59:57.102278869 +0200\n@@ -96,48 +96,11 @@\n     }\n \n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n-\n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n+if (ancestor.getType() == Token.ASSIGN) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (gramps.getType() == Token.ASSIGN) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2022-07-19 20:00:01.938253892 +0200\n+++ /tmp/tmpqoa75ltk.java\t2022-07-19 20:00:01.942253869 +0200\n@@ -96,48 +96,11 @@\n     }\n \n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n-\n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n+if (gramps.getType() == Token.ASSIGN) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (ancestorType == Token.ASSIGN) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2022-07-19 20:00:05.382236105 +0200\n+++ /tmp/tmpuu_ksrqn.java\t2022-07-19 20:00:05.382236105 +0200\n@@ -96,48 +96,11 @@\n     }\n \n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n-\n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n+if (ancestorType == Token.ASSIGN) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (gramps.getType() == Token.COMMA) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2022-07-19 20:00:08.834218275 +0200\n+++ /tmp/tmpx_khkp6u.java\t2022-07-19 20:00:08.834218275 +0200\n@@ -96,48 +96,11 @@\n     }\n \n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n-\n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n+if (gramps.getType() == Token.COMMA) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (ancestor.getType() == Token.COMMA) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2022-07-19 20:00:12.422199744 +0200\n+++ /tmp/tmplsi9ygz_.java\t2022-07-19 20:00:12.426199723 +0200\n@@ -96,48 +96,11 @@\n     }\n \n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n-\n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n+if (ancestor.getType() == Token.COMMA) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (gramps.getType() == Token.GETPROP) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2022-07-19 20:00:15.802182287 +0200\n+++ /tmp/tmp87ehvpyp.java\t2022-07-19 20:00:15.802182287 +0200\n@@ -96,48 +96,11 @@\n     }\n \n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n-\n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n+if (gramps.getType() == Token.GETPROP) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (ancestor.getType() == Token.GETPROP) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2022-07-19 20:00:19.250164479 +0200\n+++ /tmp/tmp8ivqi58p.java\t2022-07-19 20:00:19.250164479 +0200\n@@ -96,48 +96,11 @@\n     }\n \n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n-\n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n+if (ancestor.getType() == Token.GETPROP) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (thenOp.getType() == Token.ASSIGN) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2022-07-19 20:00:22.902145617 +0200\n+++ /tmp/tmpir5yh8v1.java\t2022-07-19 20:00:22.902145617 +0200\n@@ -96,48 +96,11 @@\n     }\n \n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n-\n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n+if (thenOp.getType() == Token.ASSIGN) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (parent.getType == Token.ASSIGN) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2022-07-19 20:00:26.418127457 +0200\n+++ /tmp/tmp8niqh2sk.java\t2022-07-19 20:00:26.418127457 +0200\n@@ -96,48 +96,11 @@\n     }\n \n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n-\n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n+if (parent.getType == Token.ASSIGN) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (type == Token.ASSIGN) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2022-07-19 20:00:29.954109195 +0200\n+++ /tmp/tmp_6d__qmf.java\t2022-07-19 20:00:29.954109195 +0200\n@@ -96,48 +96,11 @@\n     }\n \n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n-\n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n+if (type == Token.ASSIGN) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (parent.getType() == Token.COMMA) { Node gramps = parent.getParent(); if (gramps.isCall() && parent == gramps.getFirstChild()) { if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) { return; } } // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) { } else { return; } } boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { if (n.isQualifiedName() && n.getJSDocInfo() != null) { return; } else if (n.isExprResult()) { return; }",
        "fixed_line": "if (n.isExprResult() || n.isBlock()) { return; } // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n.isQualifiedName() && n.getJSDocInfo() != null) {"
    },
    "Closure-67": {
        "fixes": [
            {
                "k": 1,
                "patch": ") { // a assign assign; can't really modify it was non-empty's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-67/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\t2022-07-19 20:00:33.890088863 +0200\n+++ /tmp/tmp_5b5bc01.java\t2022-07-19 20:00:33.946088576 +0200\n@@ -313,11 +313,11 @@\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          ) {\n+) { // a assign assign; can't really modify it was non-empty's do implicit re-parse\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n \n         if (isChainedProperty) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": ") { // a assign assign; can't really modify it was non-literal characters that might be null or EMPTY",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-67/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\t2022-07-19 20:01:09.817903304 +0200\n+++ /tmp/tmp_m5ztpcm.java\t2022-07-19 20:01:09.821903282 +0200\n@@ -313,11 +313,11 @@\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          ) {\n+) { // a assign assign; can't really modify it was non-literal characters that might be null or EMPTY\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n \n         if (isChainedProperty) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": ") { // a assign assign; can't really modify it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-67/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\t2022-07-19 20:01:42.829732802 +0200\n+++ /tmp/tmpfvycrld7.java\t2022-07-19 20:01:42.829732802 +0200\n@@ -313,11 +313,11 @@\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          ) {\n+) { // a assign assign; can't really modify it's do implicit re-parse\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n \n         if (isChainedProperty) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": ") { // a assign assign; can't really modify it's do implicit re-initialized or EMPTY",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-67/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\t2022-07-19 20:02:15.949561744 +0200\n+++ /tmp/tmp5_dux00b.java\t2022-07-19 20:02:15.949561744 +0200\n@@ -313,11 +313,11 @@\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          ) {\n+) { // a assign assign; can't really modify it's do implicit re-initialized or EMPTY\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n \n         if (isChainedProperty) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": ") { // a assign assign; can't really modify it was non-empty's do implicit re-initialized or EMPTY",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-67/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\t2022-07-19 20:02:49.361389176 +0200\n+++ /tmp/tmpxhjgaz40.java\t2022-07-19 20:02:49.361389176 +0200\n@@ -313,11 +313,11 @@\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          ) {\n+) { // a assign assign; can't really modify it was non-empty's do implicit re-initialized or EMPTY\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n \n         if (isChainedProperty) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": ") { // a assign assign; can't really modify it was non-literal characters that were // need to do a assign assign; can't really modify it was non-empty's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-67/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\t2022-07-19 20:03:22.253219295 +0200\n+++ /tmp/tmpak0jpwai.java\t2022-07-19 20:03:22.253219295 +0200\n@@ -313,11 +313,11 @@\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          ) {\n+) { // a assign assign; can't really modify it was non-literal characters that were // need to do a assign assign; can't really modify it was non-empty's do implicit re-parse\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n \n         if (isChainedProperty) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": ") { // a assign assign; can't really modify it was non-literal characters that might be valid (empty be // need to do a assign assign; can't really modify it was non-empty's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-67/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\t2022-07-19 20:03:55.613046998 +0200\n+++ /tmp/tmpmv3t3nid.java\t2022-07-19 20:03:55.613046998 +0200\n@@ -313,11 +313,11 @@\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          ) {\n+) { // a assign assign; can't really modify it was non-literal characters that might be valid (empty be // need to do a assign assign; can't really modify it was non-empty's do implicit re-parse\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n \n         if (isChainedProperty) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": ") { // a assign assign; can't really modify it was non-literal characters that might be valid (empty's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-67/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\t2022-07-19 20:04:28.836875401 +0200\n+++ /tmp/tmprtxt8mqr.java\t2022-07-19 20:04:28.836875401 +0200\n@@ -313,11 +313,11 @@\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          ) {\n+) { // a assign assign; can't really modify it was non-literal characters that might be valid (empty's do implicit re-parse\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n \n         if (isChainedProperty) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": ") { // a assign assign; can't really modify it was non-literal characters that were // need to do a assign assign; can't really modify it was non-literal characters that might be null or EMPTY",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-67/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\t2022-07-19 20:05:02.288702627 +0200\n+++ /tmp/tmp4w4m1p2d.java\t2022-07-19 20:05:02.288702627 +0200\n@@ -313,11 +313,11 @@\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          ) {\n+) { // a assign assign; can't really modify it was non-literal characters that were // need to do a assign assign; can't really modify it was non-literal characters that might be null or EMPTY\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n \n         if (isChainedProperty) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": ") { // a assign assign; can't really modify it was non-literal characters that might be valid (empty be // need to do a assign assign; can't really modify it was non-literal characters that might be null or EMPTY",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-67/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\t2022-07-19 20:05:35.532530927 +0200\n+++ /tmp/tmp2j4zc99i.java\t2022-07-19 20:05:35.532530927 +0200\n@@ -313,11 +313,11 @@\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          ) {\n+) { // a assign assign; can't really modify it was non-literal characters that might be valid (empty be // need to do a assign assign; can't really modify it was non-literal characters that might be null or EMPTY\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n \n         if (isChainedProperty) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": ") {",
        "fixed_line": "&& assign.getParent().getType() == Token.EXPR_RESULT) {"
    },
    "Cli-25": {
        "fixes": [
            {
                "k": 1,
                "patch": "nextLineTabStop = startPos - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-25/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 20:06:08.968358236 +0200\n+++ /tmp/tmp6s83nllk.java\t2022-07-19 20:06:08.996358092 +0200\n@@ -820,11 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+nextLineTabStop = startPos - 1;\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "nextLineTabStop = pos - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-25/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 20:06:10.884348342 +0200\n+++ /tmp/tmp3vx9ykc1.java\t2022-07-19 20:06:10.888348321 +0200\n@@ -820,11 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+nextLineTabStop = pos - 1;\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "nextLineTabStop = charCount - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-25/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 20:06:13.452335079 +0200\n+++ /tmp/tmpmb4jk_5s.java\t2022-07-19 20:06:13.452335079 +0200\n@@ -820,11 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+nextLineTabStop = charCount - 1;\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "nextLineTabStop = maxLine - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-25/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 20:06:15.124326443 +0200\n+++ /tmp/tmp267859ou.java\t2022-07-19 20:06:15.124326443 +0200\n@@ -820,11 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+nextLineTabStop = maxLine - 1;\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "nextLineTabStop = padding - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-25/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 20:06:16.948317022 +0200\n+++ /tmp/tmptznjgxl_.java\t2022-07-19 20:06:16.948317022 +0200\n@@ -820,11 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+nextLineTabStop = padding - 1;\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "nextLineTabStop = width - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-25/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 20:06:18.656308199 +0200\n+++ /tmp/tmp1alkacld.java\t2022-07-19 20:06:18.656308199 +0200\n@@ -820,11 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+nextLineTabStop = width - 1;\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "nextLineTabStop = pad + 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-25/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 20:06:20.992296136 +0200\n+++ /tmp/tmp6cl2b623.java\t2022-07-19 20:06:20.992296136 +0200\n@@ -820,11 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+nextLineTabStop = pad + 1;\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "nextLineTabStop = y - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-25/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 20:06:22.652287562 +0200\n+++ /tmp/tmpgbmietaf.java\t2022-07-19 20:06:22.652287562 +0200\n@@ -820,11 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+nextLineTabStop = y - 1;\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "nextLineTabStop = x - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-25/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 20:06:24.328278906 +0200\n+++ /tmp/tmptn78w40h.java\t2022-07-19 20:06:24.328278906 +0200\n@@ -820,11 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+nextLineTabStop = x - 1;\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "nextLineTabStop = maxElements - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Cli-25/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 20:06:25.988270332 +0200\n+++ /tmp/tmp63pt5h_d.java\t2022-07-19 20:06:25.988270332 +0200\n@@ -820,11 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+nextLineTabStop = maxElements - 1;\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "nextLineTabStop = width - 1;",
        "fixed_line": "nextLineTabStop = 1;"
    },
    "Jsoup-27": {
        "fixes": [
            {
                "k": 1,
                "patch": "return newm = new.util.mColon;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-27/src/main/java/org/jsoup/helper/DataUtil.java\t2022-07-19 20:06:27.772261116 +0200\n+++ /tmp/tmp0tuyn_gv.java\t2022-07-19 20:06:27.800260972 +0200\n@@ -128,11 +128,11 @@\n         if (contentType == null) return null;\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n             charset = charset.toUpperCase(Locale.ENGLISH);\n-            return charset;\n+return newm = new.util.mColon;\n         }\n         return null;\n     }\n     \n     \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return newm = new.util.millis;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-27/src/main/java/org/jsoup/helper/DataUtil.java\t2022-07-19 20:06:29.600251675 +0200\n+++ /tmp/tmp4pt51_y4.java\t2022-07-19 20:06:29.604251657 +0200\n@@ -128,11 +128,11 @@\n         if (contentType == null) return null;\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n             charset = charset.toUpperCase(Locale.ENGLISH);\n-            return charset;\n+return newm = new.util.millis;\n         }\n         return null;\n     }\n     \n     \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return new.util.millis;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-27/src/main/java/org/jsoup/helper/DataUtil.java\t2022-07-19 20:06:31.128243785 +0200\n+++ /tmp/tmphudpddi8.java\t2022-07-19 20:06:31.128243785 +0200\n@@ -128,11 +128,11 @@\n         if (contentType == null) return null;\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n             charset = charset.toUpperCase(Locale.ENGLISH);\n-            return charset;\n+return new.util.millis;\n         }\n         return null;\n     }\n     \n     \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return newmColon;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-27/src/main/java/org/jsoup/helper/DataUtil.java\t2022-07-19 20:06:32.584236263 +0200\n+++ /tmp/tmpp5nyqrds.java\t2022-07-19 20:06:32.584236263 +0200\n@@ -128,11 +128,11 @@\n         if (contentType == null) return null;\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n             charset = charset.toUpperCase(Locale.ENGLISH);\n-            return charset;\n+return newmColon;\n         }\n         return null;\n     }\n     \n     \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return newm = newmColon;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-27/src/main/java/org/jsoup/helper/DataUtil.java\t2022-07-19 20:06:34.316227320 +0200\n+++ /tmp/tmp797axb_a.java\t2022-07-19 20:06:34.316227320 +0200\n@@ -128,11 +128,11 @@\n         if (contentType == null) return null;\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n             charset = charset.toUpperCase(Locale.ENGLISH);\n-            return charset;\n+return newm = newmColon;\n         }\n         return null;\n     }\n     \n     \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return new.util.mColon;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-27/src/main/java/org/jsoup/helper/DataUtil.java\t2022-07-19 20:06:35.916219055 +0200\n+++ /tmp/tmpvsqxz2zo.java\t2022-07-19 20:06:35.916219055 +0200\n@@ -128,11 +128,11 @@\n         if (contentType == null) return null;\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n             charset = charset.toUpperCase(Locale.ENGLISH);\n-            return charset;\n+return new.util.mColon;\n         }\n         return null;\n     }\n     \n     \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return newmillis;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-27/src/main/java/org/jsoup/helper/DataUtil.java\t2022-07-19 20:06:37.420211288 +0200\n+++ /tmp/tmp9haujqz2.java\t2022-07-19 20:06:37.420211288 +0200\n@@ -128,11 +128,11 @@\n         if (contentType == null) return null;\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n             charset = charset.toUpperCase(Locale.ENGLISH);\n-            return charset;\n+return newmillis;\n         }\n         return null;\n     }\n     \n     \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return newm = new.util.millisecond;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-27/src/main/java/org/jsoup/helper/DataUtil.java\t2022-07-19 20:06:38.980203231 +0200\n+++ /tmp/tmpn6nz4rs9.java\t2022-07-19 20:06:38.980203231 +0200\n@@ -128,11 +128,11 @@\n         if (contentType == null) return null;\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n             charset = charset.toUpperCase(Locale.ENGLISH);\n-            return charset;\n+return newm = new.util.millisecond;\n         }\n         return null;\n     }\n     \n     \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return notify;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-27/src/main/java/org/jsoup/helper/DataUtil.java\t2022-07-19 20:06:40.500195381 +0200\n+++ /tmp/tmp_jn5g9be.java\t2022-07-19 20:06:40.500195381 +0200\n@@ -128,11 +128,11 @@\n         if (contentType == null) return null;\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n             charset = charset.toUpperCase(Locale.ENGLISH);\n-            return charset;\n+return notify;\n         }\n         return null;\n     }\n     \n     \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return newm = charset;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Jsoup-27/src/main/java/org/jsoup/helper/DataUtil.java\t2022-07-19 20:06:42.112187053 +0200\n+++ /tmp/tmp4c0t9c30.java\t2022-07-19 20:06:42.112187053 +0200\n@@ -128,11 +128,11 @@\n         if (contentType == null) return null;\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n             charset = charset.toUpperCase(Locale.ENGLISH);\n-            return charset;\n+return newm = charset;\n         }\n         return null;\n     }\n     \n     \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return charset;",
        "fixed_line": "if (Charset.isSupported(charset)) return charset; charset = charset.toUpperCase(Locale.ENGLISH); if (Charset.isSupported(charset)) return charset;"
    },
    "JacksonCore-8": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (_currentSegment.length) return _currentSegment.length;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-8/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 20:06:43.856178048 +0200\n+++ /tmp/tmpy9xbwga1.java\t2022-07-19 20:06:43.924177698 +0200\n@@ -302,11 +302,11 @@\n         if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+if (_currentSegment.length) return _currentSegment.length;\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n \n     /*\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (_currentSegment.length) return _currentSize;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-8/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 20:06:45.956167201 +0200\n+++ /tmp/tmplhevo25_.java\t2022-07-19 20:06:45.956167201 +0200\n@@ -302,11 +302,11 @@\n         if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+if (_currentSegment.length) return _currentSize;\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n \n     /*\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (_currentSegment.length) return _currentSegment;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-8/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 20:06:47.592158752 +0200\n+++ /tmp/tmp_5v_t_jx.java\t2022-07-19 20:06:47.592158752 +0200\n@@ -302,11 +302,11 @@\n         if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+if (_currentSegment.length) return _currentSegment;\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n \n     /*\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (_typeSegments) return _currentSegment;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-8/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 20:06:49.180150548 +0200\n+++ /tmp/tmph64kqct9.java\t2022-07-19 20:06:49.180150548 +0200\n@@ -302,11 +302,11 @@\n         if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+if (_typeSegments) return _currentSegment;\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n \n     /*\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (_hasSegments) return _currentSegment;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-8/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 20:06:50.784142264 +0200\n+++ /tmp/tmpuaf7kylw.java\t2022-07-19 20:06:50.784142264 +0200\n@@ -302,11 +302,11 @@\n         if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+if (_hasSegments) return _currentSegment;\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n \n     /*\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (_currentSegment.length) return 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-8/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 20:06:56.428113115 +0200\n+++ /tmp/tmpq77bp2mr.java\t2022-07-19 20:06:56.428113115 +0200\n@@ -302,11 +302,11 @@\n         if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+if (_currentSegment.length) return 0;\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n \n     /*\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (_currentSegment) return _currentSegment;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-8/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 20:06:58.076104602 +0200\n+++ /tmp/tmpkt0u8nh6.java\t2022-07-19 20:06:58.076104602 +0200\n@@ -302,11 +302,11 @@\n         if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+if (_currentSegment) return _currentSegment;\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n \n     /*\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (_lastSegments) return _currentSegment;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-8/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 20:06:59.664096402 +0200\n+++ /tmp/tmpnpfhs7gs.java\t2022-07-19 20:06:59.664096402 +0200\n@@ -302,11 +302,11 @@\n         if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+if (_lastSegments) return _currentSegment;\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n \n     /*\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (_hasSegments) return _currentSegment.length;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-8/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 20:07:01.292087994 +0200\n+++ /tmp/tmp3bpfpgxe.java\t2022-07-19 20:07:01.292087994 +0200\n@@ -302,11 +302,11 @@\n         if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+if (_hasSegments) return _currentSegment.length;\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n \n     /*\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (_hasSegments) return 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/JacksonCore-8/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 20:07:03.056078883 +0200\n+++ /tmp/tmproi3p4o2.java\t2022-07-19 20:07:03.060078861 +0200\n@@ -302,11 +302,11 @@\n         if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+if (_hasSegments) return 0;\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n \n     /*\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (!_hasSegments) return _currentSegment;",
        "fixed_line": "if (!_hasSegments && _currentSegment != null) return _currentSegment;"
    },
    "Closure-109": {
        "fixes": [
            {
                "k": 1,
                "patch": "return throwsTypeName; token!= JsDocToken.LP) return throwsTypeName; token!= JsDocToken.LP;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-109/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2022-07-19 20:07:04.952069090 +0200\n+++ /tmp/tmprtm06sew.java\t2022-07-19 20:07:04.988068905 +0200\n@@ -1903,11 +1903,11 @@\n   /**\n    * ContextTypeExpression := BasicTypeExpression | '?'\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+return throwsTypeName; token!= JsDocToken.LP) return throwsTypeName; token!= JsDocToken.LP;\n   }\n \n   /**\n    * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n    *     | FunctionType | UnionType | RecordType | ArrayType\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return throwsTypeName; token!= JsDocToken.LP_ARRAY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-109/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2022-07-19 20:07:09.536045415 +0200\n+++ /tmp/tmpg9o37dug.java\t2022-07-19 20:07:09.536045415 +0200\n@@ -1903,11 +1903,11 @@\n   /**\n    * ContextTypeExpression := BasicTypeExpression | '?'\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+return throwsTypeName; token!= JsDocToken.LP_ARRAY;\n   }\n \n   /**\n    * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n    *     | FunctionType | UnionType | RecordType | ArrayType\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return throwsTypeName; token!= JsDocToken.LP;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-109/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2022-07-19 20:07:13.208026450 +0200\n+++ /tmp/tmpxz7goye_.java\t2022-07-19 20:07:13.208026450 +0200\n@@ -1903,11 +1903,11 @@\n   /**\n    * ContextTypeExpression := BasicTypeExpression | '?'\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+return throwsTypeName; token!= JsDocToken.LP;\n   }\n \n   /**\n    * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n    *     | FunctionType | UnionType | RecordType | ArrayType\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return throwsTypeName; token!= JsDocToken.LP && token!= JsDocToken.LP)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-109/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2022-07-19 20:07:16.620008827 +0200\n+++ /tmp/tmpjh09mo5u.java\t2022-07-19 20:07:16.624008806 +0200\n@@ -1903,11 +1903,11 @@\n   /**\n    * ContextTypeExpression := BasicTypeExpression | '?'\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+return throwsTypeName; token!= JsDocToken.LP && token!= JsDocToken.LP)\n   }\n \n   /**\n    * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n    *     | FunctionType | UnionType | RecordType | ArrayType\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return throwsTypeName; token!= JsDocToken.LP) return throwsTypeName; token!= JsDocToken.LP)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-109/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2022-07-19 20:07:20.035991184 +0200\n+++ /tmp/tmpem6dfkoc.java\t2022-07-19 20:07:20.039991162 +0200\n@@ -1903,11 +1903,11 @@\n   /**\n    * ContextTypeExpression := BasicTypeExpression | '?'\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+return throwsTypeName; token!= JsDocToken.LP) return throwsTypeName; token!= JsDocToken.LP)\n   }\n \n   /**\n    * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n    *     | FunctionType | UnionType | RecordType | ArrayType\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return throwsTypeName; token!= JsDocToken.END_ARRAY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-109/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2022-07-19 20:07:23.487973356 +0200\n+++ /tmp/tmp0dhvr80w.java\t2022-07-19 20:07:23.487973356 +0200\n@@ -1903,11 +1903,11 @@\n   /**\n    * ContextTypeExpression := BasicTypeExpression | '?'\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+return throwsTypeName; token!= JsDocToken.END_ARRAY;\n   }\n \n   /**\n    * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n    *     | FunctionType | UnionType | RecordType | ArrayType\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return throwsTypeName; token!= JsDocToken.LP) return throwsTypeName; token!= JsDocToken.LP_ARRAY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-109/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2022-07-19 20:07:27.115954616 +0200\n+++ /tmp/tmpw4l1qtwz.java\t2022-07-19 20:07:27.119954597 +0200\n@@ -1903,11 +1903,11 @@\n   /**\n    * ContextTypeExpression := BasicTypeExpression | '?'\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+return throwsTypeName; token!= JsDocToken.LP) return throwsTypeName; token!= JsDocToken.LP_ARRAY;\n   }\n \n   /**\n    * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n    *     | FunctionType | UnionType | RecordType | ArrayType\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return throwsTypeName; token!= JsDocToken.LP) return throwsTypeName; token!= JsDocToken.LP && token!= JsDocToken.LP)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-109/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2022-07-19 20:07:30.855935302 +0200\n+++ /tmp/tmp0ldn51w7.java\t2022-07-19 20:07:30.859935281 +0200\n@@ -1903,11 +1903,11 @@\n   /**\n    * ContextTypeExpression := BasicTypeExpression | '?'\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+return throwsTypeName; token!= JsDocToken.LP) return throwsTypeName; token!= JsDocToken.LP && token!= JsDocToken.LP)\n   }\n \n   /**\n    * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n    *     | FunctionType | UnionType | RecordType | ArrayType\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return throwsTypeName; token!= JsDocToken.NULL;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-109/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2022-07-19 20:07:34.503916459 +0200\n+++ /tmp/tmp898lraaw.java\t2022-07-19 20:07:34.507916437 +0200\n@@ -1903,11 +1903,11 @@\n   /**\n    * ContextTypeExpression := BasicTypeExpression | '?'\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+return throwsTypeName; token!= JsDocToken.NULL;\n   }\n \n   /**\n    * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n    *     | FunctionType | UnionType | RecordType | ArrayType\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return throwsTypeName; token!= JsDocToken.LP) return throwsTypeName; token!= JsDocToken.LP && token!= JsDocToken.LP;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Closure-109/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2022-07-19 20:07:38.067898051 +0200\n+++ /tmp/tmp8fkmxeh7.java\t2022-07-19 20:07:38.067898051 +0200\n@@ -1903,11 +1903,11 @@\n   /**\n    * ContextTypeExpression := BasicTypeExpression | '?'\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+return throwsTypeName; token!= JsDocToken.LP) return throwsTypeName; token!= JsDocToken.LP && token!= JsDocToken.LP;\n   }\n \n   /**\n    * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n    *     | FunctionType | UnionType | RecordType | ArrayType\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return parseTypeName(token);",
        "fixed_line": "if (token == JsDocToken.QMARK) { return newNode(Token.QMARK); } else { return parseBasicTypeExpression(token); }"
    },
    "Lang-54": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (ch3 < 'A' || ch4 > 'Z' || ch4 < 'A' || ch4 > 'Z') { throw new IllegalArgumentException(\"Invalid locale format: \" + str); }",
                "patch_diff": "} else if (ch3 < 'A' || ch4 > 'Z' || ch4 < 'A' || ch4 > 'Z') { throw new IllegalArgumentException(\"Invalid locale format: \" + str); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') { throw new IllegalArgumentException(\"Invalid locale format: \" + str); }",
                "patch_diff": "} else if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') { throw new IllegalArgumentException(\"Invalid locale format: \" + str); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "throw new IllegalArgumentException(\"Invalid locale format: \" + str.charAt(ch3 - 'A' || ch4 < 'A' || ch4 > 'Z') { throw new IllegalArgumentException(\"Invalid locale format: \" + str); }",
                "patch_diff": "throw new IllegalArgumentException(\"Invalid locale format: \" + str.charAt(ch3 - 'A' || ch4 < 'A' || ch4 > 'Z') { throw new IllegalArgumentException(\"Invalid locale format: \" + str); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new IllegalArgumentException(\"Invalid locale format: \" + str.charAt(ch3 - 'A' || ch4 < 'Z' || ch4 > 'Z') { throw new IllegalArgumentException(\"Invalid locale format: \" + str); }",
                "patch_diff": "throw new IllegalArgumentException(\"Invalid locale format: \" + str.charAt(ch3 - 'A' || ch4 < 'Z' || ch4 > 'Z') { throw new IllegalArgumentException(\"Invalid locale format: \" + str); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "throw new IllegalArgumentException(\"Invalid locale format: \" + str.charAt(ch3 - 'A' || ch4 < 'Z' || ch4 > 'Z' || ch4 < 'A' || ch4 > 'Z') { throw new IllegalArgumentException(\"Invalid locale format: \" + str); }",
                "patch_diff": "throw new IllegalArgumentException(\"Invalid locale format: \" + str.charAt(ch3 - 'A' || ch4 < 'Z' || ch4 > 'Z' || ch4 < 'A' || ch4 > 'Z') { throw new IllegalArgumentException(\"Invalid locale format: \" + str); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "throw new IllegalArgumentException(\"Invalid locale format: \" + str.charAt(ch3 - 'A' || ch4 < 'A' || ch4 > 'Z' || ch4 < 'A' || ch4 > 'Z') { throw new IllegalArgumentException(\"Invalid locale format: \" + str); }",
                "patch_diff": "throw new IllegalArgumentException(\"Invalid locale format: \" + str.charAt(ch3 - 'A' || ch4 < 'A' || ch4 > 'Z' || ch4 < 'A' || ch4 > 'Z') { throw new IllegalArgumentException(\"Invalid locale format: \" + str); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (ch3 < 'A' || ch4 > 'Z' || ch4 < 'A' || ch4 > 'Z' || ch4 < 'A' || ch4 > 'Z') { throw new IllegalArgumentException(\"Invalid locale format: \" + str); }",
                "patch_diff": "} else if (ch3 < 'A' || ch4 > 'Z' || ch4 < 'A' || ch4 > 'Z' || ch4 < 'A' || ch4 > 'Z') { throw new IllegalArgumentException(\"Invalid locale format: \" + str); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (ch3 < 'A' || ch4 > 'Z' || ch4 < 'A' || ch4 > 'Z') { throw new IllegalArgumentException(\"Invalid locale format: \" + str); } if (ch4 > 'A' || ch4 < 'A' || ch4 > 'Z') { throw new IllegalArgumentException(\"Invalid locale format: \" + str); }",
                "patch_diff": "} else if (ch3 < 'A' || ch4 > 'Z' || ch4 < 'A' || ch4 > 'Z') { throw new IllegalArgumentException(\"Invalid locale format: \" + str); } if (ch4 > 'A' || ch4 < 'A' || ch4 > 'Z') { throw new IllegalArgumentException(\"Invalid locale format: \" + str); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (ch3 < 'A' || ch4 > 'Z' || ch4 < 'A' || ch4 > 'Z') {",
                "patch_diff": "} else if (ch3 < 'A' || ch4 > 'Z' || ch4 < 'A' || ch4 > 'Z') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (ch3 < 'A' || ch4 > 'Z' || ch4 < 'A' || ch4 > 'Z') { throw new IllegalArgumentException(\"Invalid locale format: \" + str); } if (ch4 < 'A' || ch4 > 'Z' || ch4 < 'A' || ch4 > 'Z') { throw new IllegalArgumentException(\"Invalid locale format: \" + str); }",
                "patch_diff": "} else if (ch3 < 'A' || ch4 > 'Z' || ch4 < 'A' || ch4 > 'Z') { throw new IllegalArgumentException(\"Invalid locale format: \" + str); } if (ch4 < 'A' || ch4 > 'Z' || ch4 < 'A' || ch4 > 'Z') { throw new IllegalArgumentException(\"Invalid locale format: \" + str); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (ch3 == '_') { return new Locale(str.substring(0, 2), \"\", str.substring(4)); }"
    },
    "Codec-17": {
        "fixes": [
            {
                "k": 1,
                "patch": "return new String(bytes, Charsets.ISO_ es_1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-17/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-19 20:07:43.791868487 +0200\n+++ /tmp/tmp3pcb4izp.java\t2022-07-19 20:07:43.855868159 +0200\n@@ -334,11 +334,11 @@\n      *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+return new String(bytes, Charsets.ISO_ es_1;\n     }\n \n     /**\n      * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return new String(bytes, Charsets.ISO_URLs_1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-17/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-19 20:07:45.723858511 +0200\n+++ /tmp/tmpnniqef_j.java\t2022-07-19 20:07:45.723858511 +0200\n@@ -334,11 +334,11 @@\n      *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+return new String(bytes, Charsets.ISO_URLs_1;\n     }\n \n     /**\n      * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return new String[] {0, Charsets.ISO_8859_1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-17/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-19 20:07:47.343850143 +0200\n+++ /tmp/tmpuvwq7mtc.java\t2022-07-19 20:07:47.343850143 +0200\n@@ -334,11 +334,11 @@\n      *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+return new String[] {0, Charsets.ISO_8859_1;\n     }\n \n     /**\n      * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return new String(bytes, Charsets.ISO_8859_1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-17/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-19 20:07:48.959841797 +0200\n+++ /tmp/tmpgfkqyx0a.java\t2022-07-19 20:07:48.959841797 +0200\n@@ -334,11 +334,11 @@\n      *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+return new String(bytes, Charsets.ISO_8859_1;\n     }\n \n     /**\n      * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return new String(bytes, Charsets.ISO_\u2ca3_1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-17/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-19 20:07:50.615833243 +0200\n+++ /tmp/tmpqhhns3on.java\t2022-07-19 20:07:50.619833224 +0200\n@@ -334,11 +334,11 @@\n      *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+return new String(bytes, Charsets.ISO_\u2ca3_1;\n     }\n \n     /**\n      * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return new String(bytes, Charsets.ISO_8859_1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-17/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-19 20:07:52.371824175 +0200\n+++ /tmp/tmpk4fxwkcc.java\t2022-07-19 20:07:52.371824175 +0200\n@@ -334,11 +334,11 @@\n      *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+return new String(bytes, Charsets.ISO_8859_1);\n     }\n \n     /**\n      * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n      *\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return new String(bytes, Charsets.ISO_TO_1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-17/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-19 20:07:58.407793001 +0200\n+++ /tmp/tmp872ggihv.java\t2022-07-19 20:07:58.407793001 +0200\n@@ -334,11 +334,11 @@\n      *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+return new String(bytes, Charsets.ISO_TO_1;\n     }\n \n     /**\n      * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return new String(bytes, Charsets.ISO_\u2ca3_1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-17/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-19 20:08:00.043784551 +0200\n+++ /tmp/tmpevr73j2j.java\t2022-07-19 20:08:00.043784551 +0200\n@@ -334,11 +334,11 @@\n      *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+return new String(bytes, Charsets.ISO_\u2ca3_1);\n     }\n \n     /**\n      * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return new String(bytes, Charsets.ISO_ when_1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-17/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-19 20:08:01.807775440 +0200\n+++ /tmp/tmp_z4y13u9.java\t2022-07-19 20:08:01.807775440 +0200\n@@ -334,11 +334,11 @@\n      *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+return new String(bytes, Charsets.ISO_ when_1;\n     }\n \n     /**\n      * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return new String(bytes, Charsets.ISO_ Point_1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_eval/defects4j/Codec-17/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-19 20:08:03.439767011 +0200\n+++ /tmp/tmposf5lfnz.java\t2022-07-19 20:08:03.439767011 +0200\n@@ -334,11 +334,11 @@\n      *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+return new String(bytes, Charsets.ISO_ Point_1;\n     }\n \n     /**\n      * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return new String(bytes, Charsets.ISO_8859_1);",
        "fixed_line": "return newString(bytes, Charsets.ISO_8859_1);"
    }
}