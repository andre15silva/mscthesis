{
    "JacksonDatabind-57": {
        "fixes": [
            {
                "k": 1,
                "patch": "return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-57/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\t2022-07-18 23:17:02.137567390 +0200\n+++ /tmp/tmpsqxtlqok.java\t2022-07-18 23:17:03.233559446 +0200\n@@ -1436,11 +1436,11 @@\n         throws IOException, JsonProcessingException\n     {\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src),\n                 true));\n     }\n \n     /**\n      * Overloaded version of {@link #readValue(InputStream)}.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return _bindAndReadValues(_jsonFactory.createParser(src),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-57/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\t2022-07-18 23:17:42.033278741 +0200\n+++ /tmp/tmpimm60e32.java\t2022-07-18 23:17:42.033278741 +0200\n@@ -1436,11 +1436,11 @@\n         throws IOException, JsonProcessingException\n     {\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+return _bindAndReadValues(_jsonFactory.createParser(src),\n                 true));\n     }\n \n     /**\n      * Overloaded version of {@link #readValue(InputStream)}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return _bindAndReadValues(_parserFactory.createParser(src),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-57/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\t2022-07-18 23:17:43.637267159 +0200\n+++ /tmp/tmpijolmgad.java\t2022-07-18 23:17:43.641267129 +0200\n@@ -1436,11 +1436,11 @@\n         throws IOException, JsonProcessingException\n     {\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+return _bindAndReadValues(_parserFactory.createParser(src),\n                 true));\n     }\n \n     /**\n      * Overloaded version of {@link #readValue(InputStream)}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return _bindAndReadValues(_bufferedFactory.createParser(src),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-57/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\t2022-07-18 23:17:45.285255262 +0200\n+++ /tmp/tmpeenp8deq.java\t2022-07-18 23:17:45.289255231 +0200\n@@ -1436,11 +1436,11 @@\n         throws IOException, JsonProcessingException\n     {\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+return _bindAndReadValues(_bufferedFactory.createParser(src),\n                 true));\n     }\n \n     /**\n      * Overloaded version of {@link #readValue(InputStream)}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return _bindAndReadValues(_cfgFactory.createParser(src),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-57/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\t2022-07-18 23:17:46.929243394 +0200\n+++ /tmp/tmpo3mt_66n.java\t2022-07-18 23:17:46.933243366 +0200\n@@ -1436,11 +1436,11 @@\n         throws IOException, JsonProcessingException\n     {\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+return _bindAndReadValues(_cfgFactory.createParser(src),\n                 true));\n     }\n \n     /**\n      * Overloaded version of {@link #readValue(InputStream)}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return _bindAndReadValues(_ enablediderFilter(_parserFactory.createParser(src),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-57/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\t2022-07-18 23:17:48.597231356 +0200\n+++ /tmp/tmpkx9newb1.java\t2022-07-18 23:17:48.597231356 +0200\n@@ -1436,11 +1436,11 @@\n         throws IOException, JsonProcessingException\n     {\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+return _bindAndReadValues(_ enablediderFilter(_parserFactory.createParser(src),\n                 true));\n     }\n \n     /**\n      * Overloaded version of {@link #readValue(InputStream)}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return _bindAndReadValues(_considerFilterIdFactory.createParser(src),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-57/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\t2022-07-18 23:17:50.197219811 +0200\n+++ /tmp/tmpw6tp6qvb.java\t2022-07-18 23:17:50.197219811 +0200\n@@ -1436,11 +1436,11 @@\n         throws IOException, JsonProcessingException\n     {\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+return _bindAndReadValues(_considerFilterIdFactory.createParser(src),\n                 true));\n     }\n \n     /**\n      * Overloaded version of {@link #readValue(InputStream)}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return _bindAndReadValues(_createParser(src), _parserFactory.createParser(src),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-57/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\t2022-07-18 23:17:51.861207807 +0200\n+++ /tmp/tmp6miqrr5l.java\t2022-07-18 23:17:51.861207807 +0200\n@@ -1436,11 +1436,11 @@\n         throws IOException, JsonProcessingException\n     {\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+return _bindAndReadValues(_createParser(src), _parserFactory.createParser(src),\n                 true));\n     }\n \n     /**\n      * Overloaded version of {@link #readValue(InputStream)}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return _bindAndReadValues(_bigFactory.createParser(src),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-57/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\t2022-07-18 23:17:53.489196063 +0200\n+++ /tmp/tmpvm40btqg.java\t2022-07-18 23:17:53.489196063 +0200\n@@ -1436,11 +1436,11 @@\n         throws IOException, JsonProcessingException\n     {\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+return _bindAndReadValues(_bigFactory.createParser(src),\n                 true));\n     }\n \n     /**\n      * Overloaded version of {@link #readValue(InputStream)}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return _bindAndReadValues(_ExcludedFactory.createParser(src),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-57/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\t2022-07-18 23:17:55.245183397 +0200\n+++ /tmp/tmp26cqw6py.java\t2022-07-18 23:17:55.249183367 +0200\n@@ -1436,11 +1436,11 @@\n         throws IOException, JsonProcessingException\n     {\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+return _bindAndReadValues(_ExcludedFactory.createParser(src),\n                 true));\n     }\n \n     /**\n      * Overloaded version of {@link #readValue(InputStream)}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src),",
        "fixed_line": "return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length),"
    },
    "Closure-122": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (comment.getValue().indexOf(\"/* @\") == -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2022-07-18 23:17:57.065170273 +0200\n+++ /tmp/tmpblxhcazo.java\t2022-07-18 23:17:57.077170187 +0200\n@@ -247,11 +247,11 @@\n \n   /**\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+if (comment.getValue().indexOf(\"/* @\") == -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n           comment.getLineno(), \"\", 0);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (comment.getValue().indexOf(\"/* @\") == -1 || comment.getValue().indexOf(\"\\n * @ @\")!= -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2022-07-18 23:18:46.976811180 +0200\n+++ /tmp/tmpgqtpib46.java\t2022-07-18 23:18:46.976811180 +0200\n@@ -247,11 +247,11 @@\n \n   /**\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+if (comment.getValue().indexOf(\"/* @\") == -1 || comment.getValue().indexOf(\"\\n * @ @\")!= -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n           comment.getLineno(), \"\", 0);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2022-07-18 23:19:36.728454746 +0200\n+++ /tmp/tmpxeaudf2j.java\t2022-07-18 23:19:36.728454746 +0200\n@@ -247,11 +247,11 @@\n \n   /**\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n           comment.getLineno(), \"\", 0);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @ @\")!= -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2022-07-18 23:20:25.948103471 +0200\n+++ /tmp/tmp3qtfn08g.java\t2022-07-18 23:20:25.952103443 +0200\n@@ -247,11 +247,11 @@\n \n   /**\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @ @\")!= -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n           comment.getLineno(), \"\", 0);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (comment.getValue().indexOf(\"/* @\") == -1 || comment.getValue().indexOf(\"\\n * @\") == -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2022-07-18 23:21:15.171753382 +0200\n+++ /tmp/tmppprajcm_.java\t2022-07-18 23:21:15.175753355 +0200\n@@ -247,11 +247,11 @@\n \n   /**\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+if (comment.getValue().indexOf(\"/* @\") == -1 || comment.getValue().indexOf(\"\\n * @\") == -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n           comment.getLineno(), \"\", 0);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (comment.getValue().indexOf(\"/* @\") == -1 || comment.getValue().indexOf(\"\\n * @ @\") == -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2022-07-18 23:22:04.227405587 +0200\n+++ /tmp/tmp9i0uosm0.java\t2022-07-18 23:22:04.227405587 +0200\n@@ -247,11 +247,11 @@\n \n   /**\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+if (comment.getValue().indexOf(\"/* @\") == -1 || comment.getValue().indexOf(\"\\n * @ @\") == -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n           comment.getLineno(), \"\", 0);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\") == -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2022-07-18 23:22:53.515057146 +0200\n+++ /tmp/tmpgt6637k_.java\t2022-07-18 23:22:53.515057146 +0200\n@@ -247,11 +247,11 @@\n \n   /**\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\") == -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n           comment.getLineno(), \"\", 0);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (comment.getValue().indexOf(\"/* @\") == -1 || comment.getValue().indexOf(\"\\n * @ @ @\")!= -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2022-07-18 23:23:43.190706890 +0200\n+++ /tmp/tmpe3hn3et6.java\t2022-07-18 23:23:43.194706862 +0200\n@@ -247,11 +247,11 @@\n \n   /**\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+if (comment.getValue().indexOf(\"/* @\") == -1 || comment.getValue().indexOf(\"\\n * @ @ @\")!= -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n           comment.getLineno(), \"\", 0);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @ @\") == -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2022-07-18 23:24:33.034356293 +0200\n+++ /tmp/tmpsorzend1.java\t2022-07-18 23:24:33.034356293 +0200\n@@ -247,11 +247,11 @@\n \n   /**\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @ @\") == -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n           comment.getLineno(), \"\", 0);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (comment.getValue().indexOf(\"/* @\") > -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2022-07-18 23:25:22.662007978 +0200\n+++ /tmp/tmp79mrjl27.java\t2022-07-18 23:25:22.666007948 +0200\n@@ -247,11 +247,11 @@\n \n   /**\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+if (comment.getValue().indexOf(\"/* @\") > -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n           comment.getLineno(), \"\", 0);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {",
        "fixed_line": "Pattern p = Pattern.compile(\"(/|(\\n[ \\t]*))\\\\*[ \\t]*@[a-zA-Z]\"); if (p.matcher(comment.getValue()).find()) {"
    },
    "JacksonDatabind-99": {
        "fixes": [
            {
                "k": 1,
                "patch": "// sb.append(_class.getName()); sb.append('<'); return sb.toString();",
                "patch_diff": "// sb.append(_class.getName()); sb.append('<'); return sb.toString();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "StringBuilder sb = new StringBuilder(); sb.append('<'); sb.append('<'); return sb.toString();",
                "patch_diff": "StringBuilder sb = new StringBuilder(); sb.append('<'); sb.append('<'); return sb.toString();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// sb.append(_class.getName()); sb.append('<'); sb.append('<'); return sb.toString();",
                "patch_diff": "// sb.append(_class.getName()); sb.append('<'); sb.append('<'); return sb.toString();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// sb.append(_class.getName()); sb.append('<'); return sb.append(_referencedType.toString();",
                "patch_diff": "// sb.append(_class.getName()); sb.append('<'); return sb.append(_referencedType.toString();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// sb.append(_class.getName()); sb.append('<'); sb.append(_referencedType.toString();",
                "patch_diff": "// sb.append(_class.getName()); sb.append('<'); sb.append(_referencedType.toString();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// sb.append(_class.getName()); sb.append('<'); return sb.toString(); }",
                "patch_diff": "// sb.append(_class.getName()); sb.append('<'); return sb.toString(); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// sb.append(_class.getName()); sb.append('<'); return sb.append(_referencedType.toString(); } /* /************************************************",
                "patch_diff": "// sb.append(_class.getName()); sb.append('<'); return sb.append(_referencedType.toString(); } /* /************************************************",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// sb.append(_class.getName()); sb.append('<'); return sb.append(_referencedType.toString(); } /* /********************************<",
                "patch_diff": "// sb.append(_class.getName()); sb.append('<'); return sb.append(_referencedType.toString(); } /* /********************************<",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// sb.append(_class.getName()); sb.append('<'); return sb.append(_referencedType.toString(); } /* /************************************************.",
                "patch_diff": "// sb.append(_class.getName()); sb.append('<'); return sb.append(_referencedType.toString(); } /* /************************************************.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// sb.append(_class.getName()); sb.append('<'); return sb.append(_referencedType.toString(); } /* /************************************************<",
                "patch_diff": "// sb.append(_class.getName()); sb.append('<'); return sb.append(_referencedType.toString(); } /* /************************************************<",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "sb.append('>');"
    },
    "JacksonDatabind-47": {
        "fixes": [
            {
                "k": 1,
                "patch": "throw new JsonMappingException(\"Failed to widen type %s with annotation (type!= null) {",
                "patch_diff": "throw new JsonMappingException(\"Failed to widen type %s with annotation (type!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "throw new JsonMappingException(\"Failed to widen type %s with annotation (type == Type.DOUBLE) {",
                "patch_diff": "throw new JsonMappingException(\"Failed to widen type %s with annotation (type == Type.DOUBLE) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "throw new JsonMappingException(\"Failed to widen type %s with annotation (type.getName()+\") {",
                "patch_diff": "throw new JsonMappingException(\"Failed to widen type %s with annotation (type.getName()+\") {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new JsonMappingException(\"Failed to widen type %s with annotation (type == null) {",
                "patch_diff": "throw new JsonMappingException(\"Failed to widen type %s with annotation (type == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "throw new JsonMappingException(\"Failed to widen type %s with annotation (type == Type.DOUBLE_TYPE) {",
                "patch_diff": "throw new JsonMappingException(\"Failed to widen type %s with annotation (type == Type.DOUBLE_TYPE) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "throw new JsonMappingException(\"Failed to widen type %s.getName() {",
                "patch_diff": "throw new JsonMappingException(\"Failed to widen type %s.getName() {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "throw new JsonMappingException(\"Failed to widen type %s: \" + type.getName(), to widen type,",
                "patch_diff": "throw new JsonMappingException(\"Failed to widen type %s: \" + type.getName(), to widen type,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "throw new JsonMappingException(\"Failed to widen type %s with annotation (type.getName()+\") || type %s.getName(),",
                "patch_diff": "throw new JsonMappingException(\"Failed to widen type %s with annotation (type.getName()+\") || type %s.getName(),",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "throw new JsonMappingException(\"Failed to widen type %s: \" + type.getName(), to widen type, serClass);",
                "patch_diff": "throw new JsonMappingException(\"Failed to widen type %s: \" + type.getName(), to widen type, serClass);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "throw new JsonMappingException(\"Failed to widen type %s with annotation (type.getName()+\") || type == Type.DOUBLE.getName(),",
                "patch_diff": "throw new JsonMappingException(\"Failed to widen type %s with annotation (type.getName()+\") || type == Type.DOUBLE.getName(),",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "Class<?> currRaw = type.getRawClass(); try { // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`, // may be needed here too in future? if (serClass.isAssignableFrom(currRaw)) { // common case type = tf.constructGeneralizedType(type, serClass); } else if (currRaw.isAssignableFrom(serClass)) { // specialization, ok as well type = tf.constructSpecializedType(type, serClass); } else { throw new JsonMappingException(null, String.format(\"Can not refine serialization type %s into %s; types not related\", type, serClass.getName())); }"
    },
    "Time-19": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (offsetLocal > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-19/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-18 23:26:15.545637571 +0200\n+++ /tmp/tmp6fbpysvj.java\t2022-07-18 23:26:15.577637347 +0200\n@@ -895,11 +895,11 @@\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+} else if (offsetLocal > 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n                 int diff = offsetPrev - offsetLocal;\n                 if (instantAdjusted - prev <= diff) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (offsetLocal!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-19/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-18 23:26:31.709524500 +0200\n+++ /tmp/tmpvdmltv7k.java\t2022-07-18 23:26:31.713524474 +0200\n@@ -895,11 +895,11 @@\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+} else if (offsetLocal!= 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n                 int diff = offsetPrev - offsetLocal;\n                 if (instantAdjusted - prev <= diff) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (offsetLocal < 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-19/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-18 23:26:43.393442809 +0200\n+++ /tmp/tmpi41blxlg.java\t2022-07-18 23:26:43.393442809 +0200\n@@ -895,11 +895,11 @@\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+} else if (offsetLocal < 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n                 int diff = offsetPrev - offsetLocal;\n                 if (instantAdjusted - prev <= diff) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (offsetLocal > 0) { // block == null; return offsetLocal; } else if (offsetLocal > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-19/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-18 23:26:52.653378089 +0200\n+++ /tmp/tmp8ifl5aqx.java\t2022-07-18 23:26:52.653378089 +0200\n@@ -895,11 +895,11 @@\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+} else if (offsetLocal > 0) { // block == null; return offsetLocal; } else if (offsetLocal > 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n                 int diff = offsetPrev - offsetLocal;\n                 if (instantAdjusted - prev <= diff) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (offsetLocal > 0) { // block == null; return offsetLocal - offsetLocal; } else if (offsetLocal > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-19/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-18 23:27:01.681315010 +0200\n+++ /tmp/tmpu8kit0cg.java\t2022-07-18 23:27:01.681315010 +0200\n@@ -895,11 +895,11 @@\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+} else if (offsetLocal > 0) { // block == null; return offsetLocal - offsetLocal; } else if (offsetLocal > 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n                 int diff = offsetPrev - offsetLocal;\n                 if (instantAdjusted - prev <= diff) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (offsetLocal > 0) { // if (offsetLocal - offsetLocal = nextLocal - offsetLocal; } else if (offsetLocal > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-19/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-18 23:27:10.809251249 +0200\n+++ /tmp/tmp2zhme2r4.java\t2022-07-18 23:27:10.813251223 +0200\n@@ -895,11 +895,11 @@\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+} else if (offsetLocal > 0) { // if (offsetLocal - offsetLocal = nextLocal - offsetLocal; } else if (offsetLocal > 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n                 int diff = offsetPrev - offsetLocal;\n                 if (instantAdjusted - prev <= diff) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (offsetLocal > 0) { return offsetLocal; } else if (offsetLocal > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-19/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-18 23:27:20.017186951 +0200\n+++ /tmp/tmpjh6z749f.java\t2022-07-18 23:27:20.017186951 +0200\n@@ -895,11 +895,11 @@\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+} else if (offsetLocal > 0) { return offsetLocal; } else if (offsetLocal > 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n                 int diff = offsetPrev - offsetLocal;\n                 if (instantAdjusted - prev <= diff) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (offsetLocal >= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-19/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-18 23:27:29.201122840 +0200\n+++ /tmp/tmpvitgip_0.java\t2022-07-18 23:27:29.201122840 +0200\n@@ -895,11 +895,11 @@\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+} else if (offsetLocal >= 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n                 int diff = offsetPrev - offsetLocal;\n                 if (instantAdjusted - prev <= diff) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 9,
                "patch": "} else if (offsetLocal == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-19/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-18 23:27:38.421058495 +0200\n+++ /tmp/tmpulw6u27w.java\t2022-07-18 23:27:38.421058495 +0200\n@@ -895,11 +895,11 @@\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+} else if (offsetLocal == 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n                 int diff = offsetPrev - offsetLocal;\n                 if (instantAdjusted - prev <= diff) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (offsetLocal > 0) { // if (offsetLocal - offsetLocal; } else if (offsetLocal > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-19/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-18 23:27:47.480995283 +0200\n+++ /tmp/tmp5aozzvky.java\t2022-07-18 23:27:47.480995283 +0200\n@@ -895,11 +895,11 @@\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+} else if (offsetLocal > 0) { // if (offsetLocal - offsetLocal; } else if (offsetLocal > 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n                 int diff = offsetPrev - offsetLocal;\n                 if (instantAdjusted - prev <= diff) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "} else if (offsetLocal > 0) {",
        "fixed_line": "} else if (offsetLocal >= 0) {"
    },
    "Closure-127": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (nextCfgNode!= nextCfgNode) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2022-07-18 23:27:56.656931281 +0200\n+++ /tmp/tmpppxywi76.java\t2022-07-18 23:27:56.676931142 +0200\n@@ -165,11 +165,11 @@\n \n             Preconditions.checkState(\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+if (nextCfgNode!= nextCfgNode) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (nextCfgNode == nextCfgNode) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2022-07-18 23:28:41.528618546 +0200\n+++ /tmp/tmp46_4y8hv.java\t2022-07-18 23:28:41.528618546 +0200\n@@ -165,11 +165,11 @@\n \n             Preconditions.checkState(\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+if (nextCfgNode == nextCfgNode) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (nextCfgNode!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2022-07-18 23:29:26.872302912 +0200\n+++ /tmp/tmpaf5f_9ba.java\t2022-07-18 23:29:26.872302912 +0200\n@@ -165,11 +165,11 @@\n \n             Preconditions.checkState(\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+if (nextCfgNode!= null) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (nextCfgNode!= null && nextCfgNode!= nextCfgNode) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2022-07-18 23:30:11.959989415 +0200\n+++ /tmp/tmp26jf3_7d.java\t2022-07-18 23:30:11.959989415 +0200\n@@ -165,11 +165,11 @@\n \n             Preconditions.checkState(\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+if (nextCfgNode!= null && nextCfgNode!= nextCfgNode) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (nextCfgNode!= nextCfgNode && nextCfgNode!= nextCfgNode) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2022-07-18 23:30:56.607679295 +0200\n+++ /tmp/tmpupx0x3tn.java\t2022-07-18 23:30:56.607679295 +0200\n@@ -165,11 +165,11 @@\n \n             Preconditions.checkState(\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+if (nextCfgNode!= nextCfgNode && nextCfgNode!= nextCfgNode) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (nextCfgNode!= null && nextCfgNode.nextCfgNode!= nextCfgNode) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2022-07-18 23:31:41.655366691 +0200\n+++ /tmp/tmpwshzko0a.java\t2022-07-18 23:31:41.655366691 +0200\n@@ -165,11 +165,11 @@\n \n             Preconditions.checkState(\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+if (nextCfgNode!= null && nextCfgNode.nextCfgNode!= nextCfgNode) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (nextCfgNode!= null && nextCfgNode.nextCfgNode == nextCfgNode) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2022-07-18 23:31:45.307341363 +0200\n+++ /tmp/tmpw7unp7is.java\t2022-07-18 23:31:45.307341363 +0200\n@@ -165,11 +165,11 @@\n \n             Preconditions.checkState(\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+if (nextCfgNode!= null && nextCfgNode.nextCfgNode == nextCfgNode) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (nextCfgNode!= null && nextCfgNode == nextCfgNode) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2022-07-18 23:31:48.795317169 +0200\n+++ /tmp/tmp9j_ssl2b.java\t2022-07-18 23:31:48.799317144 +0200\n@@ -165,11 +165,11 @@\n \n             Preconditions.checkState(\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+if (nextCfgNode!= null && nextCfgNode == nextCfgNode) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (nextCfgNode!= nextCfgNode && nextCfgNode!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2022-07-18 23:32:33.743005574 +0200\n+++ /tmp/tmp40j0rj4p.java\t2022-07-18 23:32:33.743005574 +0200\n@@ -165,11 +165,11 @@\n \n             Preconditions.checkState(\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+if (nextCfgNode!= nextCfgNode && nextCfgNode!= null) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (nextCfgNode!= nextCfgNode && nextCfgNode == nextCfgNode) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2022-07-18 23:33:18.510695466 +0200\n+++ /tmp/tmpiizgpxm_.java\t2022-07-18 23:33:18.514695441 +0200\n@@ -165,11 +165,11 @@\n \n             Preconditions.checkState(\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+if (nextCfgNode!= nextCfgNode && nextCfgNode == nextCfgNode) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (nextCfgNode == fallThrough) {",
        "fixed_line": "if (nextCfgNode == fallThrough && !inFinally(n.getParent(), n)) { removeNode(n); } } } } private boolean inFinally(Node parent, Node child) { if (parent == null || parent.isFunction()) { return false; } else if (NodeUtil.isTryFinallyNode(parent, child)) { return true; } else { return inFinally(parent.getParent(), parent); } }"
    },
    "Closure-150": {
        "fixes": [
            {
                "k": 1,
                "patch": "attachLiteralTypes(n.getType()) { case Token.FUNCTION: if (parent.getType() == Token.NAME) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-150/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-18 23:34:03.314385334 +0200\n+++ /tmp/tmp81qh7_j7.java\t2022-07-18 23:34:03.326385252 +0200\n@@ -1446,25 +1446,11 @@\n       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+attachLiteralTypes(n.getType()) { case Token.FUNCTION: if (parent.getType() == Token.NAME) {\n     }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {\n       // Handle bleeding functions.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "attachLiteralTypes(parent.getType()) { case Token.FUNCTION: if (parent.getType() == Token.NAME) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-150/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-18 23:34:04.886374454 +0200\n+++ /tmp/tmpe_muh6pc.java\t2022-07-18 23:34:04.886374454 +0200\n@@ -1446,25 +1446,11 @@\n       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+attachLiteralTypes(parent.getType()) { case Token.FUNCTION: if (parent.getType() == Token.NAME) {\n     }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {\n       // Handle bleeding functions.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "attachLiteralTypes(n); break; case Token.FUNCTION: if (parent.getType() == Token.NAME) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-150/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-18 23:34:06.498363303 +0200\n+++ /tmp/tmp1k7sfpu4.java\t2022-07-18 23:34:06.498363303 +0200\n@@ -1446,25 +1446,11 @@\n       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+attachLiteralTypes(n); break; case Token.FUNCTION: if (parent.getType() == Token.NAME) {\n     }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {\n       // Handle bleeding functions.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "attachLiteralTypes(n); case Token.FUNCTION: if (parent.getType() == Token.NAME) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-150/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-18 23:34:08.146351897 +0200\n+++ /tmp/tmpwg2zsxk8.java\t2022-07-18 23:34:08.150351872 +0200\n@@ -1446,25 +1446,11 @@\n       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+attachLiteralTypes(n); case Token.FUNCTION: if (parent.getType() == Token.NAME) {\n     }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {\n       // Handle bleeding functions.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "attachLiteralTypes(n); // Token.FUNCTION: if (parent.getType() == Token.NAME) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-150/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-18 23:34:09.726340968 +0200\n+++ /tmp/tmpbsvy6iiu.java\t2022-07-18 23:34:09.730340938 +0200\n@@ -1446,25 +1446,11 @@\n       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+attachLiteralTypes(n); // Token.FUNCTION: if (parent.getType() == Token.NAME) {\n     }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {\n       // Handle bleeding functions.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "attachLiteralTypes(n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-150/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-18 23:34:34.538169324 +0200\n+++ /tmp/tmp2s1qh11_.java\t2022-07-18 23:34:34.538169324 +0200\n@@ -1446,25 +1446,11 @@\n       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+attachLiteralTypes(n);\n     }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {\n       // Handle bleeding functions.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "attachLiteralTypes(n.getType()) { case Token.FUNCTION: if (parent!= Token.NAME) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-150/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-18 23:34:58.146006061 +0200\n+++ /tmp/tmpzyr64mys.java\t2022-07-18 23:34:58.146006061 +0200\n@@ -1446,25 +1446,11 @@\n       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+attachLiteralTypes(n.getType()) { case Token.FUNCTION: if (parent!= Token.NAME) {\n     }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {\n       // Handle bleeding functions.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "attachLiteralTypes(n.getType()) { case Token.FUNCTION: if (parent.getType() == Token.VAR) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-150/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-18 23:34:59.793994668 +0200\n+++ /tmp/tmpr6walfqo.java\t2022-07-18 23:34:59.793994668 +0200\n@@ -1446,25 +1446,11 @@\n       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+attachLiteralTypes(n.getType()) { case Token.FUNCTION: if (parent.getType() == Token.VAR) {\n     }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {\n       // Handle bleeding functions.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "attachLiteralTypes(n); switch (parent.getType()) { case Token.FUNCTION: if (parent.getType() == Token.NAME) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-150/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-18 23:35:01.425983384 +0200\n+++ /tmp/tmp0s5hqlme.java\t2022-07-18 23:35:01.433983327 +0200\n@@ -1446,25 +1446,11 @@\n       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+attachLiteralTypes(n); switch (parent.getType()) { case Token.FUNCTION: if (parent.getType() == Token.NAME) {\n     }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {\n       // Handle bleeding functions.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "attachLiteralTypes(n.getType()) { case Token.FUNCTION: if (parent == Token.NAME) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-150/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-18 23:35:03.009972431 +0200\n+++ /tmp/tmpzd9ws4tl.java\t2022-07-18 23:35:03.013972405 +0200\n@@ -1446,25 +1446,11 @@\n       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+attachLiteralTypes(n.getType()) { case Token.FUNCTION: if (parent == Token.NAME) {\n     }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {\n       // Handle bleeding functions.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "attachLiteralTypes(n); switch (n.getType()) { case Token.FUNCTION: if (parent.getType() == Token.NAME) { return; } defineDeclaredFunction(n, parent); break; case Token.CATCH: defineCatch(n, parent); break; case Token.VAR: defineVar(n, parent); break; }",
        "fixed_line": "super.visit(t, n, parent);"
    },
    "JacksonDatabind-86": {
        "fixes": [
            {
                "k": 1,
                "patch": "_referencedType = new IllegalStateException(\"Trying to re-set self reference \"+_referencedType+\", new = \"+_referencedType; }",
                "patch_diff": "_referencedType = new IllegalStateException(\"Trying to re-set self reference \"+_referencedType+\", new = \"+_referencedType; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "throw new IllegalStateException(\"Trying to re-set self reference \"+_referencedType+\", new = \"+_referencedType; }",
                "patch_diff": "throw new IllegalStateException(\"Trying to re-set self reference \"+_referencedType+\", new = \"+_referencedType; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "_referencedType = new IllegalStateException(\"Trying to re-set self reference; }",
                "patch_diff": "_referencedType = new IllegalStateException(\"Trying to re-set self reference; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "_referencedType = null; old value = \"+_referencedType+\", new = \"+_referencedType; }",
                "patch_diff": "_referencedType = null; old value = \"+_referencedType+\", new = \"+_referencedType; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "_referencedType = new IllegalStateException(\"Trying to re-set self reference \"+_referencedType+\", new = \"+ref); }",
                "patch_diff": "_referencedType = new IllegalStateException(\"Trying to re-set self reference \"+_referencedType+\", new = \"+ref); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "_referencedType = new IllegalStateException(\"Trying to re-set self reference \"+_referencedType+\", new = \"+_referencedType); }",
                "patch_diff": "_referencedType = new IllegalStateException(\"Trying to re-set self reference \"+_referencedType+\", new = \"+_referencedType); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "_referencedType = new IllegalStateException(\"Trying to re-set self reference \"+_referencedType+\", new = \"+_referencedType+\", new = \"+_referencedType; }",
                "patch_diff": "_referencedType = new IllegalStateException(\"Trying to re-set self reference \"+_referencedType+\", new = \"+_referencedType+\", new = \"+_referencedType; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "_referencedType = new IllegalStateException(\"Trying to re-set self reference \"+_referencedType+\", new = \"+_referencedType)) { return _referencedType; }",
                "patch_diff": "_referencedType = new IllegalStateException(\"Trying to re-set self reference \"+_referencedType+\", new = \"+_referencedType)) { return _referencedType; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "_referencedType = new IllegalStateException(\"Trying to re-set self reference \"+_referencedType+\", new = \"+ref; }",
                "patch_diff": "_referencedType = new IllegalStateException(\"Trying to re-set self reference \"+_referencedType+\", new = \"+ref; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "JavaType(\"Trying to re-set self reference \"+_referencedType+\", new = \"+_referencedType; }",
                "patch_diff": "JavaType(\"Trying to re-set self reference \"+_referencedType+\", new = \"+_referencedType; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "@Override public JavaType getSuperClass() { if (_referencedType != null) { return _referencedType.getSuperClass(); } return super.getSuperClass(); }"
    },
    "Mockito-7": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (Type type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } }",
                "patch_diff": "for (Type type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "private int type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type);",
                "patch_diff": "private int type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (Type type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type);",
                "patch_diff": "for (Type type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "private int type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type);",
                "patch_diff": "private int type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type);",
                "patch_diff": "} else if (typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type);",
                "patch_diff": "} else if (typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (Type type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type);",
                "patch_diff": "for (Type type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type);",
                "patch_diff": "} else if (typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (Type type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type);",
                "patch_diff": "for (Type type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "private int type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type);",
                "patch_diff": "private int type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "registerTypeParametersOn(new TypeVariable[] { typeVariable });"
    },
    "Gson-6": {
        "fixes": [
            {
                "k": 1,
                "patch": "throw new IllegalArgumentException(\"Adapter value must be TypeAdapter or TypeAdapterFactory reference.\"); } }",
                "patch_diff": "throw new IllegalArgumentException(\"Adapter value must be TypeAdapter or TypeAdapterFactory reference.\"); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "throw new IllegalArgumentException(\"Adapter value must be TypeAdapter or TypeAdapterFactory reference.\"); }",
                "patch_diff": "throw new IllegalArgumentException(\"Adapter value must be TypeAdapter or TypeAdapterFactory reference.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "throw new IllegalArgumentException(\"Invalid Object value must be TypeAdapter or TypeAdapterFactory reference.\"); } }",
                "patch_diff": "throw new IllegalArgumentException(\"Invalid Object value must be TypeAdapter or TypeAdapterFactory reference.\"); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new IllegalArgumentException( \"@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.\"); } }",
                "patch_diff": "throw new IllegalArgumentException( \"@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.\"); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "throw new IllegalArgumentException(\"Adapter value must be TypeAdapter or TypeAdapterFactory reference.\"); } else {",
                "patch_diff": "throw new IllegalArgumentException(\"Adapter value must be TypeAdapter or TypeAdapterFactory reference.\"); } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "throw new IllegalArgumentException (\"Adapter value must be TypeAdapter or TypeAdapterFactory reference.\"); } }",
                "patch_diff": "throw new IllegalArgumentException (\"Adapter value must be TypeAdapter or TypeAdapterFactory reference.\"); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "throw new IllegalArgumentException(\"Invalid Object value must be TypeAdapter or TypeAdapterFactory reference.\"); }",
                "patch_diff": "throw new IllegalArgumentException(\"Invalid Object value must be TypeAdapter or TypeAdapterFactory reference.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "throw new IllegalArgumentException( \"@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.\"); }",
                "patch_diff": "throw new IllegalArgumentException( \"@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "throw new IllegalArgumentException(\"Adapter value must be TypeAdapter or TypeAdapterFactory reference.\"); } else if (typeAdapter == Type.FLOAT_TYPE) { return typeAdapter; } }",
                "patch_diff": "throw new IllegalArgumentException(\"Adapter value must be TypeAdapter or TypeAdapterFactory reference.\"); } else if (typeAdapter == Type.FLOAT_TYPE) { return typeAdapter; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "throw new IllegalArgumentException (\"Adapter value must be TypeAdapter or TypeAdapterFactory reference.\"); }",
                "patch_diff": "throw new IllegalArgumentException (\"Adapter value must be TypeAdapter or TypeAdapterFactory reference.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (typeAdapter != null) { typeAdapter = typeAdapter.nullSafe(); }"
    },
    "JacksonDatabind-93": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-93/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\t2022-07-18 23:35:10.509920579 +0200\n+++ /tmp/tmp_77b2bw2.java\t2022-07-18 23:35:10.577920109 +0200\n@@ -78,12 +78,11 @@\n             }\n \n             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n             //    for some Spring framework types\n             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n-            if (full.startsWith(PREFIX_STRING)) {\n-                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n+if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n                     String name = cls.getSimpleName();\n                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                             || \"AbstractApplicationContext\".equals(name)) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (full.startsWith(\"0)) { for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-93/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\t2022-07-18 23:35:56.161605063 +0200\n+++ /tmp/tmplzdce2cv.java\t2022-07-18 23:35:56.165605037 +0200\n@@ -78,12 +78,11 @@\n             }\n \n             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n             //    for some Spring framework types\n             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n-            if (full.startsWith(PREFIX_STRING)) {\n-                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n+if (full.startsWith(\"0)) { for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n                     String name = cls.getSimpleName();\n                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                             || \"AbstractApplicationContext\".equals(name)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (needed.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-93/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\t2022-07-18 23:35:57.773593925 +0200\n+++ /tmp/tmpx1iomqil.java\t2022-07-18 23:35:57.773593925 +0200\n@@ -78,12 +78,11 @@\n             }\n \n             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n             //    for some Spring framework types\n             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n-            if (full.startsWith(PREFIX_STRING)) {\n-                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n+if (needed.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n                     String name = cls.getSimpleName();\n                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                             || \"AbstractApplicationContext\".equals(name)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (cls.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-93/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\t2022-07-18 23:35:59.513581905 +0200\n+++ /tmp/tmpacapjb7v.java\t2022-07-18 23:35:59.513581905 +0200\n@@ -78,12 +78,11 @@\n             }\n \n             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n             //    for some Spring framework types\n             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n-            if (full.startsWith(PREFIX_STRING)) {\n-                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n+if (cls.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n                     String name = cls.getSimpleName();\n                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                             || \"AbstractApplicationContext\".equals(name)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (sub_STRING.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-93/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\t2022-07-18 23:36:01.217570130 +0200\n+++ /tmp/tmpui7lckbe.java\t2022-07-18 23:36:01.217570130 +0200\n@@ -78,12 +78,11 @@\n             }\n \n             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n             //    for some Spring framework types\n             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n-            if (full.startsWith(PREFIX_STRING)) {\n-                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n+if (sub_STRING.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n                     String name = cls.getSimpleName();\n                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                             || \"AbstractApplicationContext\".equals(name)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls = raw.class; cls = cls.getSuperclass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-93/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\t2022-07-18 23:36:03.173556618 +0200\n+++ /tmp/tmpr7w4o1yk.java\t2022-07-18 23:36:03.173556618 +0200\n@@ -78,12 +78,11 @@\n             }\n \n             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n             //    for some Spring framework types\n             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n-            if (full.startsWith(PREFIX_STRING)) {\n-                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n+if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls = raw.class; cls = cls.getSuperclass()) {\n                     String name = cls.getSimpleName();\n                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                             || \"AbstractApplicationContext\".equals(name)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (full.startsWith(\") { for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-93/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\t2022-07-18 23:36:05.057543601 +0200\n+++ /tmp/tmp30ce2mh8.java\t2022-07-18 23:36:05.057543601 +0200\n@@ -78,12 +78,11 @@\n             }\n \n             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n             //    for some Spring framework types\n             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n-            if (full.startsWith(PREFIX_STRING)) {\n-                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n+if (full.startsWith(\") { for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n                     String name = cls.getSimpleName();\n                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                             || \"AbstractApplicationContext\".equals(name)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (full.startsWith(\"0)) { for (Class<?> cls = raw; cls = raw.class; cls = cls.getSuperclass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-93/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\t2022-07-18 23:36:06.661532520 +0200\n+++ /tmp/tmpfnl_ru97.java\t2022-07-18 23:36:06.661532520 +0200\n@@ -78,12 +78,11 @@\n             }\n \n             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n             //    for some Spring framework types\n             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n-            if (full.startsWith(PREFIX_STRING)) {\n-                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n+if (full.startsWith(\"0)) { for (Class<?> cls = raw; cls = raw.class; cls = cls.getSuperclass()) {\n                     String name = cls.getSimpleName();\n                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                             || \"AbstractApplicationContext\".equals(name)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls!= Object.class; cls = raw.getSuperclass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-93/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\t2022-07-18 23:36:08.321521052 +0200\n+++ /tmp/tmp8iir6skn.java\t2022-07-18 23:36:08.321521052 +0200\n@@ -78,12 +78,11 @@\n             }\n \n             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n             //    for some Spring framework types\n             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n-            if (full.startsWith(PREFIX_STRING)) {\n-                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n+if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls!= Object.class; cls = raw.getSuperclass()) {\n                     String name = cls.getSimpleName();\n                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                             || \"AbstractApplicationContext\".equals(name)) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (full.startsWith(\"0)) { for (Class<?> cls = raw.class; cls = raw.getSuperclass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-93/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\t2022-07-18 23:36:50.209291670 +0200\n+++ /tmp/tmplmb58d_p.java\t2022-07-18 23:36:50.209291670 +0200\n@@ -78,12 +78,11 @@\n             }\n \n             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n             //    for some Spring framework types\n             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n-            if (full.startsWith(PREFIX_STRING)) {\n-                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n+if (full.startsWith(\"0)) { for (Class<?> cls = raw.class; cls = raw.getSuperclass()) {\n                     String name = cls.getSimpleName();\n                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                             || \"AbstractApplicationContext\".equals(name)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {",
        "fixed_line": "if (!raw.isInterface() && full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()) {"
    },
    "Math-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-12/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\t2022-07-18 23:36:52.165283566 +0200\n+++ /tmp/tmpgitowwgd.java\t2022-07-18 23:36:52.193283449 +0200\n@@ -24,11 +24,11 @@\n  *\n  * @version $Id$\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator {\n+implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnot real number\n     /** Serializable version identifier */\n     /** Next gaussian. */\n     private double nextGaussian;\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-12/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\t2022-07-18 23:37:41.461073556 +0200\n+++ /tmp/tmpv6hy303m.java\t2022-07-18 23:37:41.461073556 +0200\n@@ -24,11 +24,11 @@\n  *\n  * @version $Id$\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator {\n+implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnot real number\n     /** Serializable version identifier */\n     /** Next gaussian. */\n     private double nextGaussian;\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-12/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\t2022-07-18 23:38:27.388868527 +0200\n+++ /tmp/tmpltq58159.java\t2022-07-18 23:38:27.392868510 +0200\n@@ -24,11 +24,11 @@\n  *\n  * @version $Id$\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator {\n+implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnot real number\n     /** Serializable version identifier */\n     /** Next gaussian. */\n     private double nextGaussian;\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-12/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\t2022-07-18 23:39:14.228650946 +0200\n+++ /tmp/tmpu06wzyzo.java\t2022-07-18 23:39:14.228650946 +0200\n@@ -24,11 +24,11 @@\n  *\n  * @version $Id$\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator {\n+implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n     /** Serializable version identifier */\n     /** Next gaussian. */\n     private double nextGaussian;\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-12/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\t2022-07-18 23:40:01.508423389 +0200\n+++ /tmp/tmpq6x60ulg.java\t2022-07-18 23:40:01.508423389 +0200\n@@ -24,11 +24,11 @@\n  *\n  * @version $Id$\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator {\n+implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n     /** Serializable version identifier */\n     /** Next gaussian. */\n     private double nextGaussian;\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-12/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\t2022-07-18 23:40:48.184191611 +0200\n+++ /tmp/tmptlsw_6x3.java\t2022-07-18 23:40:48.184191611 +0200\n@@ -24,11 +24,11 @@\n  *\n  * @version $Id$\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator {\n+implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n     /** Serializable version identifier */\n     /** Next gaussian. */\n     private double nextGaussian;\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-12/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\t2022-07-18 23:41:34.011957752 +0200\n+++ /tmp/tmp66as8b4s.java\t2022-07-18 23:41:34.011957752 +0200\n@@ -24,11 +24,11 @@\n  *\n  * @version $Id$\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator {\n+implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number\n     /** Serializable version identifier */\n     /** Next gaussian. */\n     private double nextGaussian;\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "implements RandomGenerator { // 1; // we didn't really modify it's totalGaussian (not real number)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-12/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\t2022-07-18 23:42:20.895712612 +0200\n+++ /tmp/tmpd8d_yidt.java\t2022-07-18 23:42:20.899712591 +0200\n@@ -24,11 +24,11 @@\n  *\n  * @version $Id$\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator {\n+implements RandomGenerator { // 1; // we didn't really modify it's totalGaussian (not real number)\n     /** Serializable version identifier */\n     /** Next gaussian. */\n     private double nextGaussian;\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-12/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\t2022-07-18 23:43:07.363464278 +0200\n+++ /tmp/tmp7tw0uy19.java\t2022-07-18 23:43:07.363464278 +0200\n@@ -24,11 +24,11 @@\n  *\n  * @version $Id$\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator {\n+implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number\n     /** Serializable version identifier */\n     /** Next gaussian. */\n     private double nextGaussian;\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-not real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-12/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\t2022-07-18 23:43:54.755205980 +0200\n+++ /tmp/tmpmighdb7z.java\t2022-07-18 23:43:54.755205980 +0200\n@@ -24,11 +24,11 @@\n  *\n  * @version $Id$\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator {\n+implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-not real number\n     /** Serializable version identifier */\n     /** Next gaussian. */\n     private double nextGaussian;\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "implements RandomGenerator {",
        "fixed_line": "import java.io.Serializable; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.apache.commons.math3.util.FastMath; /** Base class for random number generators that generates bits streams. * * @version $Id$ * @since 2.0 */ public abstract class BitsStreamGenerator implements RandomGenerator, Serializable { /** Serializable version identifier */ private static final long serialVersionUID = 20130104L;"
    },
    "JacksonDatabind-44": {
        "fixes": [
            {
                "k": 1,
                "patch": "throw new IllegalArgumentException(\"Simple types have no content types = _superInterfaces.getName()+\";",
                "patch_diff": "throw new IllegalArgumentException(\"Simple types have no content types = _superInterfaces.getName()+\";",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "throw new IllegalArgumentException(\"Simple types have no content types = _superInterfaces.getName()+\"_class;",
                "patch_diff": "throw new IllegalArgumentException(\"Simple types have no content types = _superInterfaces.getName()+\"_class;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "throw new IllegalArgumentException(\"Simple types have no content types, _superInterfaces.getName() {",
                "patch_diff": "throw new IllegalArgumentException(\"Simple types have no content types, _superInterfaces.getName() {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new IllegalArgumentException(\"Simple types have no content types; }",
                "patch_diff": "throw new IllegalArgumentException(\"Simple types have no content types; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "throw new IllegalArgumentException(\"Simple types have no content types, _superInterfaces.getName()+\") || _valueHandler.typeHandler == null) {",
                "patch_diff": "throw new IllegalArgumentException(\"Simple types have no content types, _superInterfaces.getName()+\") || _valueHandler.typeHandler == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "throw new IllegalArgumentException(\"Simple types have no content types = _superInterfaces.getName()+\"_class, _superInterfaces, _typeHandler, _asStatic);",
                "patch_diff": "throw new IllegalArgumentException(\"Simple types have no content types = _superInterfaces.getName()+\"_class, _superInterfaces, _typeHandler, _asStatic);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "throw new IllegalArgumentException(\"Simple types have no content types, _superInterfaces.getName()+\") {",
                "patch_diff": "throw new IllegalArgumentException(\"Simple types have no content types, _superInterfaces.getName()+\") {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "throw new IllegalArgumentException(\"Simple types have no content types, _typeFactory.getName()+\") {",
                "patch_diff": "throw new IllegalArgumentException(\"Simple types have no content types, _typeFactory.getName()+\") {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "throw new IllegalArgumentException(\"Simple types have no content types = _superInterfaces.getName()+\"_class, _superInterfaces, _typeHandler.getName());",
                "patch_diff": "throw new IllegalArgumentException(\"Simple types have no content types = _superInterfaces.getName()+\"_class, _superInterfaces, _typeHandler.getName());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "throw new IllegalArgumentException(\"Simple types have no content types, _superInterfaces.getName()+\") || _superInterfaces.class.getName()+\") {",
                "patch_diff": "throw new IllegalArgumentException(\"Simple types have no content types, _superInterfaces.getName()+\") || _superInterfaces.class.getName()+\") {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (!_class.isAssignableFrom(subclass)) { /* throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \" +_class.getName()); */ return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic); } // Otherwise, stitch together the hierarchy. First, super-class Class<?> next = subclass.getSuperclass(); if (next == _class) { // straight up parent class? Great. return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic); } if ((next != null) && _class.isAssignableFrom(next)) { JavaType superb = _narrow(next); return new SimpleType(subclass, _bindings, superb, null, _valueHandler, _typeHandler, _asStatic); } // if not found, try a super-interface Class<?>[] nextI = subclass.getInterfaces(); for (Class<?> iface : nextI) { if (iface == _class) { // directly implemented return new SimpleType(subclass, _bindings, null, new JavaType[] { this }, _valueHandler, _typeHandler, _asStatic); } if (_class.isAssignableFrom(iface)) { // indirect, so recurse JavaType superb = _narrow(iface); return new SimpleType(subclass, _bindings, null, new JavaType[] { superb }, _valueHandler, _typeHandler, _asStatic); } } // should not get here but... throw new IllegalArgumentException(\"Internal error: Can not resolve sub-type for Class \"+subclass.getName()+\" to \" +_class.getName());"
    },
    "Lang-45": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (upper == -1 || upper > str.length()) {",
                "patch_diff": "if (upper == -1 || upper > str.length()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (upper == -1 || upper > str.length()) { return StringUtils.EMPTY; }",
                "patch_diff": "if (upper == -1 || upper > str.length()) { return StringUtils.EMPTY; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (upper == -1 || upper > str.length()) { return StringUtils.EMPTY; } else if (upper == -1 || upper > str.length()) {",
                "patch_diff": "if (upper == -1 || upper > str.length()) { return StringUtils.EMPTY; } else if (upper == -1 || upper > str.length()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (upper == -1 || upper > str.length()) { return StringUtils.EMPTY; } else if (upper < 0 || upper > str.length()) {",
                "patch_diff": "if (upper == -1 || upper > str.length()) { return StringUtils.EMPTY; } else if (upper < 0 || upper > str.length()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (upper == -1 || upper > str.length()) { return StringUtils.EMPTY; } else if (upper == 0 || upper > str.length()) {",
                "patch_diff": "if (upper == -1 || upper > str.length()) { return StringUtils.EMPTY; } else if (upper == 0 || upper > str.length()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (upper == -1 || upper > upper.length()) {",
                "patch_diff": "if (upper == -1 || upper > upper.length()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (upper == -1 || upper > str.length()) { return StringUtils.EMPTY; } else if (upper == -1 || upper > str.length()) { upper = size; }",
                "patch_diff": "if (upper == -1 || upper > str.length()) { return StringUtils.EMPTY; } else if (upper == -1 || upper > str.length()) { upper = size; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (upper == -1 || upper > str.length()) { return StringUtils.EMPTY; } else if (upper == -1 || upper > str.length()) { return StringUtils.EMPTY; }",
                "patch_diff": "if (upper == -1 || upper > str.length()) { return StringUtils.EMPTY; } else if (upper == -1 || upper > str.length()) { return StringUtils.EMPTY; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (upper == -1 || upper > str.length()) { return StringUtils.EMPTY; } else if (upper == -1 || upper > upper.length()) {",
                "patch_diff": "if (upper == -1 || upper > str.length()) { return StringUtils.EMPTY; } else if (upper == -1 || upper > upper.length()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (upper == -1 || upper > str.length()) { return StringUtils.EMPTY; } else if (upper < 0 || upper > str.length()) { return StringUtils.EMPTY; }",
                "patch_diff": "if (upper == -1 || upper > str.length()) { return StringUtils.EMPTY; } else if (upper < 0 || upper > str.length()) { return StringUtils.EMPTY; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (lower > str.length()) { lower = str.length(); }"
    },
    "JacksonDatabind-42": {
        "fixes": [
            {
                "k": 1,
                "patch": "// As per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "// As per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// As per [JACKSON-407] -- allow disabling wrapping for (int i = URI.create(\"\");",
                "patch_diff": "// As per [JACKSON-407] -- allow disabling wrapping for (int i = URI.create(\"\");",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// As per [JACKSON-notnotnotnotnot real number",
                "patch_diff": "// As per [JACKSON-notnotnotnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// As per [JACKSON-notnotnotnot real number",
                "patch_diff": "// As per [JACKSON-notnotnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// As per [JACKSON-notnotnotnotnotnot real number",
                "patch_diff": "// As per [JACKSON-notnotnotnotnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// As per [JACKSON-notnotnot real number",
                "patch_diff": "// As per [JACKSON-notnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// As per [JACKSON-407] -- allow use a digit after the",
                "patch_diff": "// As per [JACKSON-407] -- allow use a digit after the",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// As per [JACKSON-407] -- allow disabling wrapping for (int j = URI.create(\"\");",
                "patch_diff": "// As per [JACKSON-407] -- allow disabling wrapping for (int j = URI.create(\"\");",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// As per [JACKSON-notnot real number",
                "patch_diff": "// As per [JACKSON-notnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// As per [JACKSON-407] -- allow disabling wrapping for Types.\");",
                "patch_diff": "// As per [JACKSON-407] -- allow disabling wrapping for Types.\");",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (_kind == STD_LOCALE) { return Locale.ROOT; }"
    },
    "Math-3": {
        "fixes": [
            {
                "k": 1,
                "patch": "final double[] prodHigh = new double[len];",
                "patch_diff": "final double[] prodHigh = new double[len];",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = 0; i < len; i++) {",
                "patch_diff": "for (int i = 0; i < len; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "throw new DimensionMismatchException(len, b.length) {",
                "patch_diff": "throw new DimensionMismatchException(len, b.length) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "final double[] prodHigh = new double[len]; if (len == b.length) {",
                "patch_diff": "final double[] prodHigh = new double[len]; if (len == b.length) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "final double[] prodHigh = new double[len]; double[len];",
                "patch_diff": "final double[] prodHigh = new double[len]; double[len];",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = 0; i < len; ++i) {",
                "patch_diff": "for (int i = 0; i < len; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "throw new DimensionMismatchException(len, b.length);",
                "patch_diff": "throw new DimensionMismatchException(len, b.length);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "final double[] prodHigh = new double[len]; if (len!= b.length) {",
                "patch_diff": "final double[] prodHigh = new double[len]; if (len!= b.length) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "throw new DimensionMismatchException(len, b.length); }",
                "patch_diff": "throw new DimensionMismatchException(len, b.length); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "final double[] prodHigh = new double[len]; }",
                "patch_diff": "final double[] prodHigh = new double[len]; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (len == 1) { // Revert to scalar multiplication. return a[0] * b[0]; }"
    },
    "JxPath-22": {
        "fixes": [
            {
                "k": 1,
                "patch": "return attr.getValue(); } else if (aNode = aNode.getParentNode(); } return null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-22/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-18 23:44:48.546907220 +0200\n+++ /tmp/tmp5xdstyr2.java\t2022-07-18 23:44:48.594906951 +0200\n@@ -684,18 +684,11 @@\n             Node aNode = node;\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                     if (attr != null) {\n-                        return attr.getValue();\n-                    }\n-                }\n-                aNode = aNode.getParentNode();\n-            }\n-            return null;\n-        }\n-        return uri;\n+return attr.getValue(); } else if (aNode = aNode.getParentNode(); } return null;\n     }\n \n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return attr.getValue(); } else { aNode = aNode.getParentNode(); } return null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-22/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-18 23:44:50.402896816 +0200\n+++ /tmp/tmpuswp86wf.java\t2022-07-18 23:44:50.406896793 +0200\n@@ -684,18 +684,11 @@\n             Node aNode = node;\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                     if (attr != null) {\n-                        return attr.getValue();\n-                    }\n-                }\n-                aNode = aNode.getParentNode();\n-            }\n-            return null;\n-        }\n-        return uri;\n+return attr.getValue(); } else { aNode = aNode.getParentNode(); } return null;\n     }\n \n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return attr.getValue(); } else if ( aNode = aNode.getParentNode(); } return null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-22/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-18 23:44:52.066887480 +0200\n+++ /tmp/tmpu7ygon5v.java\t2022-07-18 23:44:52.066887480 +0200\n@@ -684,18 +684,11 @@\n             Node aNode = node;\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                     if (attr != null) {\n-                        return attr.getValue();\n-                    }\n-                }\n-                aNode = aNode.getParentNode();\n-            }\n-            return null;\n-        }\n-        return uri;\n+return attr.getValue(); } else if ( aNode = aNode.getParentNode(); } return null;\n     }\n \n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return attr.getValue(); } else if (aNode.getParentNode(); } return null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-22/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-18 23:44:53.562879081 +0200\n+++ /tmp/tmpzng4drpc.java\t2022-07-18 23:44:53.562879081 +0200\n@@ -684,18 +684,11 @@\n             Node aNode = node;\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                     if (attr != null) {\n-                        return attr.getValue();\n-                    }\n-                }\n-                aNode = aNode.getParentNode();\n-            }\n-            return null;\n-        }\n-        return uri;\n+return attr.getValue(); } else if (aNode.getParentNode(); } return null;\n     }\n \n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return attr.getValue(); } else if (aNode ==Node.getParentNode(); } return null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-22/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-18 23:44:55.062870655 +0200\n+++ /tmp/tmpuf7sm4rz.java\t2022-07-18 23:44:55.062870655 +0200\n@@ -684,18 +684,11 @@\n             Node aNode = node;\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                     if (attr != null) {\n-                        return attr.getValue();\n-                    }\n-                }\n-                aNode = aNode.getParentNode();\n-            }\n-            return null;\n-        }\n-        return uri;\n+return attr.getValue(); } else if (aNode ==Node.getParentNode(); } return null;\n     }\n \n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return attr.getValue(); } } return null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-22/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-18 23:44:56.666861645 +0200\n+++ /tmp/tmp6ly8j70i.java\t2022-07-18 23:44:56.666861645 +0200\n@@ -684,18 +684,11 @@\n             Node aNode = node;\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                     if (attr != null) {\n-                        return attr.getValue();\n-                    }\n-                }\n-                aNode = aNode.getParentNode();\n-            }\n-            return null;\n-        }\n-        return uri;\n+return attr.getValue(); } } return null;\n     }\n \n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return attr.getValue(); } } else if (aNode.getParentNode(); } return null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-22/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-18 23:44:58.290852514 +0200\n+++ /tmp/tmptyxyv8kz.java\t2022-07-18 23:44:58.290852514 +0200\n@@ -684,18 +684,11 @@\n             Node aNode = node;\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                     if (attr != null) {\n-                        return attr.getValue();\n-                    }\n-                }\n-                aNode = aNode.getParentNode();\n-            }\n-            return null;\n-        }\n-        return uri;\n+return attr.getValue(); } } else if (aNode.getParentNode(); } return null;\n     }\n \n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return attr.getValue(); } } return null; } return null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-22/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-18 23:44:59.882843559 +0200\n+++ /tmp/tmpb9ow74b0.java\t2022-07-18 23:44:59.886843536 +0200\n@@ -684,18 +684,11 @@\n             Node aNode = node;\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                     if (attr != null) {\n-                        return attr.getValue();\n-                    }\n-                }\n-                aNode = aNode.getParentNode();\n-            }\n-            return null;\n-        }\n-        return uri;\n+return attr.getValue(); } } return null; } return null;\n     }\n \n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return attr.getValue(); } else { aNode = aNode.getParentNode(); } return null; } return uri;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-22/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-18 23:45:01.478834577 +0200\n+++ /tmp/tmpm2b2aut1.java\t2022-07-18 23:45:01.482834554 +0200\n@@ -684,18 +684,11 @@\n             Node aNode = node;\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                     if (attr != null) {\n-                        return attr.getValue();\n-                    }\n-                }\n-                aNode = aNode.getParentNode();\n-            }\n-            return null;\n-        }\n-        return uri;\n+return attr.getValue(); } else { aNode = aNode.getParentNode(); } return null; } return uri;\n     }\n \n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return attr.getValue(); } else { aNode = aNode.getParentNode(); return null; } return uri;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-22/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-18 23:45:02.970826177 +0200\n+++ /tmp/tmpudluj6r9.java\t2022-07-18 23:45:02.970826177 +0200\n@@ -684,18 +684,11 @@\n             Node aNode = node;\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                     if (attr != null) {\n-                        return attr.getValue();\n-                    }\n-                }\n-                aNode = aNode.getParentNode();\n-            }\n-            return null;\n-        }\n-        return uri;\n+return attr.getValue(); } else { aNode = aNode.getParentNode(); return null; } return uri;\n     }\n \n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return attr.getValue(); } } aNode = aNode.getParentNode(); } return null; } return uri;",
        "fixed_line": "uri = attr.getValue(); break; } } aNode = aNode.getParentNode(); } } return \"\".equals(uri) ? null : uri;"
    },
    "Math-69": {
        "fixes": [
            {
                "k": 1,
                "patch": "out[i][j] = 2 * r - t;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-69/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\t2022-07-18 23:45:04.586817071 +0200\n+++ /tmp/tmpl_l1rth5.java\t2022-07-18 23:45:04.666816621 +0200\n@@ -166,11 +166,11 @@\n                 if (i == j) {\n                     out[i][j] = 0d;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+out[i][j] = 2 * r - t;\n                 }\n             }\n         }\n         return new BlockRealMatrix(out);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "out[i][j] = 2 * r;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-69/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\t2022-07-18 23:45:12.450772705 +0200\n+++ /tmp/tmpqfpppetp.java\t2022-07-18 23:45:12.450772705 +0200\n@@ -166,11 +166,11 @@\n                 if (i == j) {\n                     out[i][j] = 0d;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+out[i][j] = 2 * r;\n                 }\n             }\n         }\n         return new BlockRealMatrix(out);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "out[0][i][j] = 2 * r - t;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-69/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\t2022-07-18 23:45:19.526732689 +0200\n+++ /tmp/tmpquowbc8w.java\t2022-07-18 23:45:19.526732689 +0200\n@@ -166,11 +166,11 @@\n                 if (i == j) {\n                     out[i][j] = 0d;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+out[0][i][j] = 2 * r - t;\n                 }\n             }\n         }\n         return new BlockRealMatrix(out);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "out[i][j] = 2 * r.cumulativeProbability(t));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-69/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\t2022-07-18 23:45:21.834719617 +0200\n+++ /tmp/tmpfaus58pt.java\t2022-07-18 23:45:21.838719594 +0200\n@@ -166,11 +166,11 @@\n                 if (i == j) {\n                     out[i][j] = 0d;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+out[i][j] = 2 * r.cumulativeProbability(t));\n                 }\n             }\n         }\n         return new BlockRealMatrix(out);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "out[i][j] = 2 * r + t;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-69/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\t2022-07-18 23:45:23.866708100 +0200\n+++ /tmp/tmpkyqv04zx.java\t2022-07-18 23:45:23.866708100 +0200\n@@ -166,11 +166,11 @@\n                 if (i == j) {\n                     out[i][j] = 0d;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+out[i][j] = 2 * r + t;\n                 }\n             }\n         }\n         return new BlockRealMatrix(out);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "out[i][j] -= 2 * r - t;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-69/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\t2022-07-18 23:45:31.030667446 +0200\n+++ /tmp/tmpgm73ja64.java\t2022-07-18 23:45:31.034667423 +0200\n@@ -166,11 +166,11 @@\n                 if (i == j) {\n                     out[i][j] = 0d;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+out[i][j] -= 2 * r - t;\n                 }\n             }\n         }\n         return new BlockRealMatrix(out);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "out[i][j] = 2 * r - t.cumulativeProbability(t));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-69/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\t2022-07-18 23:45:38.242626432 +0200\n+++ /tmp/tmps7q8oixw.java\t2022-07-18 23:45:38.242626432 +0200\n@@ -166,11 +166,11 @@\n                 if (i == j) {\n                     out[i][j] = 0d;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+out[i][j] = 2 * r - t.cumulativeProbability(t));\n                 }\n             }\n         }\n         return new BlockRealMatrix(out);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "out[i][j] = 2 * r.cumulativeProbability(t);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-69/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\t2022-07-18 23:45:40.302614695 +0200\n+++ /tmp/tmpy87eghn4.java\t2022-07-18 23:45:40.302614695 +0200\n@@ -166,11 +166,11 @@\n                 if (i == j) {\n                     out[i][j] = 0d;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+out[i][j] = 2 * r.cumulativeProbability(t);\n                 }\n             }\n         }\n         return new BlockRealMatrix(out);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "out[i][j] = 2 * r - t; // weulativeProbability(t));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-69/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\t2022-07-18 23:45:42.578601727 +0200\n+++ /tmp/tmp5j_r6eci.java\t2022-07-18 23:45:42.578601727 +0200\n@@ -166,11 +166,11 @@\n                 if (i == j) {\n                     out[i][j] = 0d;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+out[i][j] = 2 * r - t; // weulativeProbability(t));\n                 }\n             }\n         }\n         return new BlockRealMatrix(out);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "out[i][j] = 2 * r / n - t;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-69/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\t2022-07-18 23:45:49.478562352 +0200\n+++ /tmp/tmpr1erg2m0.java\t2022-07-18 23:45:49.478562352 +0200\n@@ -166,11 +166,11 @@\n                 if (i == j) {\n                     out[i][j] = 0d;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+out[i][j] = 2 * r / n - t;\n                 }\n             }\n         }\n         return new BlockRealMatrix(out);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));",
        "fixed_line": "out[i][j] = 2 * tDistribution.cumulativeProbability(-t);"
    },
    "Gson-14": {
        "fixes": [
            {
                "k": 1,
                "patch": "private static WildcardType supertype(typeBounds.class }, lowerBounds);",
                "patch_diff": "private static WildcardType supertype(typeBounds.class }, lowerBounds);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "private static WildcardType supertype(typeBounds.class }, lowerBounds); }",
                "patch_diff": "private static WildcardType supertype(typeBounds.class }, lowerBounds); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "private static WildcardType supertype.class }, lowerBounds = new WildcardType(type);",
                "patch_diff": "private static WildcardType supertype.class }, lowerBounds = new WildcardType(type);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "private static WildcardType supertype(typeBounds.class }, lowerBounds); return new WildcardType(type); }",
                "patch_diff": "private static WildcardType supertype(typeBounds.class }, lowerBounds); return new WildcardType(type); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private static WildcardType supertype.class }, lowerBounds = new WildcardType(type); }",
                "patch_diff": "private static WildcardType supertype.class }, lowerBounds = new WildcardType(type); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "private static WildcardType supertype(typeBounds.class }, lowerBounds); return new WildcardType(type);",
                "patch_diff": "private static WildcardType supertype(typeBounds.class }, lowerBounds); return new WildcardType(type);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private static WildcardType supertype.class }, lowerBounds = new WildcardType(type); return new WildcardType(t.class }, lowerBounds); }",
                "patch_diff": "private static WildcardType supertype.class }, lowerBounds = new WildcardType(type); return new WildcardType(t.class }, lowerBounds); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "private static WildcardType supertype.class }, lowerBounds = new WildcardType(type); return new WildcardType(t.class }, lowerBounds);",
                "patch_diff": "private static WildcardType supertype.class }, lowerBounds = new WildcardType(type); return new WildcardType(t.class }, lowerBounds);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private static WildcardType supertypeOfBounds = new WildcardType {",
                "patch_diff": "private static WildcardType supertypeOfBounds = new WildcardType {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "private static WildcardType supertype(typeBounds.class }, lowerBounds); return new WildcardType(upperBounds); }",
                "patch_diff": "private static WildcardType supertype(typeBounds.class }, lowerBounds); return new WildcardType(upperBounds); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (bound instanceof WildcardType) { upperBounds = ((WildcardType) bound).getUpperBounds(); } else { upperBounds = new Type[] { bound }; } return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY); } /** * Returns a type that represents an unknown supertype of {@code bound}. For * example, if {@code bound} is {@code String.class}, this returns {@code ? * super String}. */ public static WildcardType supertypeOf(Type bound) { Type[] lowerBounds; if (bound instanceof WildcardType) { lowerBounds = ((WildcardType) bound).getLowerBounds(); } else { lowerBounds = new Type[] { bound }; }"
    },
    "Lang-28": {
        "fixes": [
            {
                "k": 1,
                "patch": "return (start + length * 2 + (isHex? 1 : 0 + 1; } return 0;",
                "patch_diff": "return (start + length * 2 + (isHex? 1 : 0 + 1; } return 0;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return (start + length * 2 + (isHex? 1 : 0 + 1; } return",
                "patch_diff": "return (start + length * 2 + (isHex? 1 : 0 + 1; } return",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return (start + 2 * 10) + (isHex? 1 : 0; } return 0;",
                "patch_diff": "return (start + 2 * 10) + (isHex? 1 : 0; } return 0;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return (start + 2 + (isHex? 1 : 0 + 1; } return 0;",
                "patch_diff": "return (start + 2 + (isHex? 1 : 0 + 1; } return 0;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return (start + 2 * 10) + (isHex? 1 : 0; } return",
                "patch_diff": "return (start + 2 * 10) + (isHex? 1 : 0; } return",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return (start + length * 2 + (isHex? 1 : 0 + 1; } return 0; }",
                "patch_diff": "return (start + length * 2 + (isHex? 1 : 0 + 1; } return 0; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return (start + 2 + (isHex? 1 : 0 + 1; } return",
                "patch_diff": "return (start + 2 + (isHex? 1 : 0 + 1; } return",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return (start + 2 * 10) + (isHex? 1 : 0; } return 1; }",
                "patch_diff": "return (start + 2 * 10) + (isHex? 1 : 0; } return 1; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return (start + 2 * 10) + (isHex? 1 : 0 + 1; } return",
                "patch_diff": "return (start + 2 * 10) + (isHex? 1 : 0 + 1; } return",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return (start + 2 * 10) + (isHex? 1 : 0 + 1; } return 0;",
                "patch_diff": "return (start + 2 * 10) + (isHex? 1 : 0 + 1; } return 0;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if(entityValue > 0xFFFF) { char[] chrs = Character.toChars(entityValue); out.write(chrs[0]); out.write(chrs[1]); } else { out.write(entityValue); }"
    },
    "Lang-10": {
        "fixes": [
            {
                "k": 1,
                "patch": "boolean wasWhite= false; for (int i=0; i<value.charAt(i)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-10/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\t2022-07-18 23:45:55.562527571 +0200\n+++ /tmp/tmp992vmrh5.java\t2022-07-18 23:45:55.638527135 +0200\n@@ -299,21 +299,11 @@\n      * @param value The source field\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n-            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n+boolean wasWhite= false; for (int i=0; i<value.charAt(i)) {\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n                     if(++i==value.length()) {\n                         return regex;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "boolean wasWhite= false; for (int i=0; i<value.charAt(i); regex.next;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-10/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\t2022-07-18 23:45:57.346517360 +0200\n+++ /tmp/tmpyhfs1yfr.java\t2022-07-18 23:45:57.346517360 +0200\n@@ -299,21 +299,11 @@\n      * @param value The source field\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n-            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n+boolean wasWhite= false; for (int i=0; i<value.charAt(i); regex.next;\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n                     if(++i==value.length()) {\n                         return regex;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "boolean wasWhite= false; for (int i=0; i<value.charAt(i);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-10/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\t2022-07-18 23:45:58.922508336 +0200\n+++ /tmp/tmp5stc5m_t.java\t2022-07-18 23:45:58.926508313 +0200\n@@ -299,21 +299,11 @@\n      * @param value The source field\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n-            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n+boolean wasWhite= false; for (int i=0; i<value.charAt(i);\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n                     if(++i==value.length()) {\n                         return regex;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "boolean wasWhite= false; for (int i=0; i<value.charAt(i)); regex.next;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-10/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\t2022-07-18 23:46:00.522499169 +0200\n+++ /tmp/tmpz0lowtr1.java\t2022-07-18 23:46:00.522499169 +0200\n@@ -299,21 +299,11 @@\n      * @param value The source field\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n-            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n+boolean wasWhite= false; for (int i=0; i<value.charAt(i)); regex.next;\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n                     if(++i==value.length()) {\n                         return regex;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "boolean wasWhite= false; for (int i=0; i<value.charAt(i); regex.append(\"\\\\s*+\") {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-10/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\t2022-07-18 23:46:02.070490296 +0200\n+++ /tmp/tmpknwse36y.java\t2022-07-18 23:46:02.070490296 +0200\n@@ -299,21 +299,11 @@\n      * @param value The source field\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n-            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n+boolean wasWhite= false; for (int i=0; i<value.charAt(i); regex.append(\"\\\\s*+\") {\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n                     if(++i==value.length()) {\n                         return regex;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "boolean wasWhite= false; for (int i=0; i<value.charAt(i); limit.isWhitespace(c)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-10/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\t2022-07-18 23:46:03.906479759 +0200\n+++ /tmp/tmp97go2v7_.java\t2022-07-18 23:46:03.906479759 +0200\n@@ -299,21 +299,11 @@\n      * @param value The source field\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n-            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n+boolean wasWhite= false; for (int i=0; i<value.charAt(i); limit.isWhitespace(c)) {\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n                     if(++i==value.length()) {\n                         return regex;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "boolean wasWhite= false; for(int i=0; i<value.charAt(i)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-10/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\t2022-07-18 23:46:05.742469234 +0200\n+++ /tmp/tmpygx0_di6.java\t2022-07-18 23:46:05.746469211 +0200\n@@ -299,21 +299,11 @@\n      * @param value The source field\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n-            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n+boolean wasWhite= false; for(int i=0; i<value.charAt(i)) {\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n                     if(++i==value.length()) {\n                         return regex;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "boolean wasWhite= false; for (int i=0; i<value.charAt(i); i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-10/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\t2022-07-18 23:46:07.450459430 +0200\n+++ /tmp/tmpbyc245wa.java\t2022-07-18 23:46:07.454459407 +0200\n@@ -299,21 +299,11 @@\n      * @param value The source field\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n-            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n+boolean wasWhite= false; for (int i=0; i<value.charAt(i); i++) {\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n                     if(++i==value.length()) {\n                         return regex;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "boolean wasWhite= false; for(int i=0; i<value.charAt(i); regex.next;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-10/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\t2022-07-18 23:46:09.302448795 +0200\n+++ /tmp/tmpprsbjulj.java\t2022-07-18 23:46:09.302448795 +0200\n@@ -299,21 +299,11 @@\n      * @param value The source field\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n-            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n+boolean wasWhite= false; for(int i=0; i<value.charAt(i); regex.next;\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n                     if(++i==value.length()) {\n                         return regex;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "boolean wasWhite= false; for (int i=0; i<value.charAt(i);) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-10/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\t2022-07-18 23:46:10.754440454 +0200\n+++ /tmp/tmp3_1s55mi.java\t2022-07-18 23:46:10.754440454 +0200\n@@ -299,21 +299,11 @@\n      * @param value The source field\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n-            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n+boolean wasWhite= false; for (int i=0; i<value.charAt(i);) {\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n                     if(++i==value.length()) {\n                         return regex;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\s*+\"); } continue; } wasWhite= false;",
        "fixed_line": ""
    },
    "Cli-38": {
        "fixes": [
            {
                "k": 1,
                "patch": "return options.hasShortOption(optName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-38/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-18 23:46:12.818428590 +0200\n+++ /tmp/tmpmkxw1y5x.java\t2022-07-18 23:46:12.902428103 +0200\n@@ -305,11 +305,11 @@\n         }\n \n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n+return options.hasShortOption(optName);\n         // check for several concatenated short options\n     }\n \n     /**\n      * Tells if the token looks like a long option.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return options.hasShortOption(optName); // remove old items if it.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-38/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-18 23:46:15.822411311 +0200\n+++ /tmp/tmp1lhxt05h.java\t2022-07-18 23:46:15.822411311 +0200\n@@ -305,11 +305,11 @@\n         }\n \n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n+return options.hasShortOption(optName); // remove old items if it.\n         // check for several concatenated short options\n     }\n \n     /**\n      * Tells if the token looks like a long option.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return options.hasShortOption(optName); // remove old items if it's",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-38/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-18 23:46:18.538395676 +0200\n+++ /tmp/tmpykwc58ad.java\t2022-07-18 23:46:18.538395676 +0200\n@@ -305,11 +305,11 @@\n         }\n \n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n+return options.hasShortOption(optName); // remove old items if it's\n         // check for several concatenated short options\n     }\n \n     /**\n      * Tells if the token looks like a long option.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return options.hasShortOption(optName); // remove old items if necessary, but",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-38/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-18 23:46:21.262379987 +0200\n+++ /tmp/tmphdbb7ovl.java\t2022-07-18 23:46:21.262379987 +0200\n@@ -305,11 +305,11 @@\n         }\n \n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n+return options.hasShortOption(optName); // remove old items if necessary, but\n         // check for several concatenated short options\n     }\n \n     /**\n      * Tells if the token looks like a long option.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return options.hasShortOption(optName); // remove old items if (optName!= null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-38/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-18 23:46:23.814365272 +0200\n+++ /tmp/tmpxjh3fh7u.java\t2022-07-18 23:46:23.814365272 +0200\n@@ -305,11 +305,11 @@\n         }\n \n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n+return options.hasShortOption(optName); // remove old items if (optName!= null)\n         // check for several concatenated short options\n     }\n \n     /**\n      * Tells if the token looks like a long option.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return options.hasShortOption(optName); // remove old items if (optName!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-38/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-18 23:46:26.618349096 +0200\n+++ /tmp/tmpfcwxraki.java\t2022-07-18 23:46:26.618349096 +0200\n@@ -305,11 +305,11 @@\n         }\n \n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n+return options.hasShortOption(optName); // remove old items if (optName!= null) {\n         // check for several concatenated short options\n     }\n \n     /**\n      * Tells if the token looks like a long option.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return options.hasShortOption(optName); // remove old items if necessary",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-38/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-18 23:46:29.038335127 +0200\n+++ /tmp/tmpovh5rfg2.java\t2022-07-18 23:46:29.038335127 +0200\n@@ -305,11 +305,11 @@\n         }\n \n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n+return options.hasShortOption(optName); // remove old items if necessary\n         // check for several concatenated short options\n     }\n \n     /**\n      * Tells if the token looks like a long option.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return options.hasShortOption(optName); // remove old items if (optName.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-38/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-18 23:46:31.722319622 +0200\n+++ /tmp/tmpmatp1006.java\t2022-07-18 23:46:31.726319599 +0200\n@@ -305,11 +305,11 @@\n         }\n \n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n+return options.hasShortOption(optName); // remove old items if (optName.\n         // check for several concatenated short options\n     }\n \n     /**\n      * Tells if the token looks like a long option.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return options.hasShortOption(optName); // remove old items if it was -->",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-38/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-18 23:46:34.302304708 +0200\n+++ /tmp/tmpg1ng1f47.java\t2022-07-18 23:46:34.306304687 +0200\n@@ -305,11 +305,11 @@\n         }\n \n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n+return options.hasShortOption(optName); // remove old items if it was -->\n         // check for several concatenated short options\n     }\n \n     /**\n      * Tells if the token looks like a long option.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return options.hasShortOption(optName); // remove old items if it's.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-38/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-18 23:46:36.998289112 +0200\n+++ /tmp/tmpo1rha3nz.java\t2022-07-18 23:46:36.998289112 +0200\n@@ -305,11 +305,11 @@\n         }\n \n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n+return options.hasShortOption(optName); // remove old items if it's.\n         // check for several concatenated short options\n     }\n \n     /**\n      * Tells if the token looks like a long option.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return options.hasShortOption(optName);",
        "fixed_line": "if (options.hasShortOption(optName)) { return true; } // check for several concatenated short options return optName.length() > 0 && options.hasShortOption(String.valueOf(optName.charAt(0)));"
    },
    "Closure-8": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (Node var = s.getVar(var.getString()); return var.getScope() == null;",
                "patch_diff": "for (Node var = s.getVar(var.getString()); return var.getScope() == null;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (Node var = s.getVar(var.getString()); return var.getScope() == null &&!blacklistedVars.contains(var);",
                "patch_diff": "for (Node var = s.getVar(var.getString()); return var.getScope() == null &&!blacklistedVars.contains(var);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (Node var = s.getVar(var.getString()); return var.getScope() == null &&!blacklistedVars.contains(var); }",
                "patch_diff": "for (Node var = s.getVar(var.getString()); return var.getScope() == null &&!blacklistedVars.contains(var); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (Node var = s.getVar(var.getString()); return var.getScope() == null &&!blacklistedVars.contains(var); } else {",
                "patch_diff": "for (Node var = s.getVar(var.getString()); return var.getScope() == null &&!blacklistedVars.contains(var); } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int var = s.getVar(var.getString()); return var.getScope() == null &&!blacklistedVars.contains(var);",
                "patch_diff": "for (int var = s.getVar(var.getString()); return var.getScope() == null &&!blacklistedVars.contains(var);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (Node var = s.getVar(var.getString()); return var.getScope() == null &&!blacklistedVars.contains(var); } else if (var == null) {",
                "patch_diff": "for (Node var = s.getVar(var.getString()); return var.getScope() == null &&!blacklistedVars.contains(var); } else if (var == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int var = s.getVar(var.getString()); return var.getScope() == null &&!blacklistedVars.contains(var); } else {",
                "patch_diff": "for (int var = s.getVar(var.getString()); return var.getScope() == null &&!blacklistedVars.contains(var); } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int var = s.getVar(var.getString()); return var.getScope() == null &&!blacklistedVars.contains(var); }",
                "patch_diff": "for (int var = s.getVar(var.getString()); return var.getScope() == null &&!blacklistedVars.contains(var); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int var = s.getVar(var.getString()); return var.getScope() == null &&!blacklistedVars.contains(var); } else if (var == null) {",
                "patch_diff": "for (int var = s.getVar(var.getString()); return var.getScope() == null &&!blacklistedVars.contains(var); } else if (var == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int var = s.getVar(var.getString()); return var.getScope() == null && var.getCollistedVars.contains(var);",
                "patch_diff": "for (int var = s.getVar(var.getString()); return var.getScope() == null && var.getCollistedVars.contains(var);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "&& !isNamedParameter(var) && !blacklistedVars.contains(var); } } private boolean isNamedParameter(Var v) { return v.getParentNode().isParamList(); }"
    },
    "Closure-31": {
        "fixes": [
            {
                "k": 1,
                "patch": "!options.skipAllPasses &&",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-31/src/com/google/javascript/jscomp/Compiler.java\t2022-07-18 23:46:41.586262546 +0200\n+++ /tmp/tmpl32uqvrt.java\t2022-07-18 23:46:41.638262247 +0200\n@@ -1280,11 +1280,11 @@\n       // Check if inputs need to be rebuilt from modules.\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+!options.skipAllPasses &&\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "!options.skipAllPasses && // Make sure that we're not handling object literals being // assigned to check whether a prototype, as per [JACKSON-407] -- allow use a native function.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-31/src/com/google/javascript/jscomp/Compiler.java\t2022-07-18 23:47:23.322019487 +0200\n+++ /tmp/tmps6ih14bf.java\t2022-07-18 23:47:23.326019466 +0200\n@@ -1280,11 +1280,11 @@\n       // Check if inputs need to be rebuilt from modules.\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+!options.skipAllPasses && // Make sure that we're not handling object literals being // assigned to check whether a prototype, as per [JACKSON-407] -- allow use a native function.\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "!options.skipAllPasses && // Make sure that we're not handling object literals being // assigned to do a prototype, as per [JACKSON-407] -- allow use a native function.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-31/src/com/google/javascript/jscomp/Compiler.java\t2022-07-18 23:48:02.753787650 +0200\n+++ /tmp/tmpcdma4dc1.java\t2022-07-18 23:48:02.753787650 +0200\n@@ -1280,11 +1280,11 @@\n       // Check if inputs need to be rebuilt from modules.\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+!options.skipAllPasses && // Make sure that we're not handling object literals being // assigned to do a prototype, as per [JACKSON-407] -- allow use a native function.\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "!options.skipAllPasses && // Make sure that we're not handling object literals being // assigned to a prototype, as per [JACKSON-407] -- allow use a native function.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-31/src/com/google/javascript/jscomp/Compiler.java\t2022-07-18 23:48:41.873555698 +0200\n+++ /tmp/tmpaiqna9r_.java\t2022-07-18 23:48:41.877555673 +0200\n@@ -1280,11 +1280,11 @@\n       // Check if inputs need to be rebuilt from modules.\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+!options.skipAllPasses && // Make sure that we're not handling object literals being // assigned to a prototype, as per [JACKSON-407] -- allow use a native function.\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "!options.skipAllPasses && // Make sure that we're not handling object literals being // assigned to do a prototype, as per [JACKSON-407] -- allow disabling wrapping for the",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-31/src/com/google/javascript/jscomp/Compiler.java\t2022-07-18 23:49:21.209320653 +0200\n+++ /tmp/tmp5sr8x_e2.java\t2022-07-18 23:49:21.209320653 +0200\n@@ -1280,11 +1280,11 @@\n       // Check if inputs need to be rebuilt from modules.\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+!options.skipAllPasses && // Make sure that we're not handling object literals being // assigned to do a prototype, as per [JACKSON-407] -- allow disabling wrapping for the\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "!options.skipAllPasses && // Make sure that we're not handling object literals being // assigned to check whether a prototype, as per [JACKSON-407] -- allow disabling wrapping for the",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-31/src/com/google/javascript/jscomp/Compiler.java\t2022-07-18 23:50:00.065086820 +0200\n+++ /tmp/tmpc8v57sy0.java\t2022-07-18 23:50:00.069086798 +0200\n@@ -1280,11 +1280,11 @@\n       // Check if inputs need to be rebuilt from modules.\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+!options.skipAllPasses && // Make sure that we're not handling object literals being // assigned to check whether a prototype, as per [JACKSON-407] -- allow disabling wrapping for the\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "!options.skipAllPasses && // Make sure that we're not handling object literals being // assigned to check whether a prototype, as per [JACKSON-407] --raw)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-31/src/com/google/javascript/jscomp/Compiler.java\t2022-07-18 23:50:39.148850083 +0200\n+++ /tmp/tmptn7j0hdo.java\t2022-07-18 23:50:39.148850083 +0200\n@@ -1280,11 +1280,11 @@\n       // Check if inputs need to be rebuilt from modules.\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+!options.skipAllPasses && // Make sure that we're not handling object literals being // assigned to check whether a prototype, as per [JACKSON-407] --raw)\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "!options.skipAllPasses && // Make sure that we're not handling object literals being // assigned to check whether a prototype, as per [JACKSON-407] -- allow use a digit after the",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-31/src/com/google/javascript/jscomp/Compiler.java\t2022-07-18 23:51:18.092612772 +0200\n+++ /tmp/tmp6vrc702a.java\t2022-07-18 23:51:18.092612772 +0200\n@@ -1280,11 +1280,11 @@\n       // Check if inputs need to be rebuilt from modules.\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+!options.skipAllPasses && // Make sure that we're not handling object literals being // assigned to check whether a prototype, as per [JACKSON-407] -- allow use a digit after the\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "!options.skipAllPasses && // Make sure that we're not handling object literals being // assigned to a prototype, as per [JACKSON-407] -- allow disabling wrapping for the",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-31/src/com/google/javascript/jscomp/Compiler.java\t2022-07-18 23:51:56.856375256 +0200\n+++ /tmp/tmp4xftfcn1.java\t2022-07-18 23:51:56.856375256 +0200\n@@ -1280,11 +1280,11 @@\n       // Check if inputs need to be rebuilt from modules.\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+!options.skipAllPasses && // Make sure that we're not handling object literals being // assigned to a prototype, as per [JACKSON-407] -- allow disabling wrapping for the\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "!options.skipAllPasses && // Make sure that we're not handling object literals being // assigned to do a prototype, as per [JACKSON-407] --raw)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-31/src/com/google/javascript/jscomp/Compiler.java\t2022-07-18 23:52:35.756135690 +0200\n+++ /tmp/tmpdm1kua8f.java\t2022-07-18 23:52:35.756135690 +0200\n@@ -1280,11 +1280,11 @@\n       // Check if inputs need to be rebuilt from modules.\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+!options.skipAllPasses && // Make sure that we're not handling object literals being // assigned to do a prototype, as per [JACKSON-407] --raw)\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "!options.skipAllPasses &&",
        "fixed_line": ""
    },
    "Lang-55": {
        "fixes": [
            {
                "k": 1,
                "patch": "this.runningState = STATE_STOPPED; }",
                "patch_diff": "this.runningState = STATE_STOPPED; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if(this.runningState!= STATE_RUNNING && this.runningState!= STATE_SUSPENDED) {",
                "patch_diff": "if(this.runningState!= STATE_RUNNING && this.runningState!= STATE_SUSPENDED) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "this.runningState = STATE_STOPPED; this.runningState = STATE_SUSPENDED; }",
                "patch_diff": "this.runningState = STATE_STOPPED; this.runningState = STATE_SUSPENDED; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if(this.runningState!= STATE_RUNNING && this.runningState!= STATE_SUSPENDED; }",
                "patch_diff": "if(this.runningState!= STATE_RUNNING && this.runningState!= STATE_SUSPENDED; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if(this.runningState!= STATE_RUNNING && this.runningState == STATE_SUSPENDED; }",
                "patch_diff": "if(this.runningState!= STATE_RUNNING && this.runningState == STATE_SUSPENDED; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "this.runningState = STATE_STOPPED; this.runningState = STATE_SUSPENDED;",
                "patch_diff": "this.runningState = STATE_STOPPED; this.runningState = STATE_SUSPENDED;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// STATE_SUSPENDED = System.currentTimeMillis(); this.runningState = STATE_SUSPENDED; }",
                "patch_diff": "// STATE_SUSPENDED = System.currentTimeMillis(); this.runningState = STATE_SUSPENDED; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if(this.runningState!= STATE_RUNNING && this.runningState == STATE_SUSPENDED) {",
                "patch_diff": "if(this.runningState!= STATE_RUNNING && this.runningState == STATE_SUSPENDED) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "this.runningState = STATE_RUNNING && this.runningState!= STATE_SUSPENDED; }",
                "patch_diff": "this.runningState = STATE_RUNNING && this.runningState!= STATE_SUSPENDED; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if(this.runningState!= STATE_RUNNING && this.runningState!= STATE_SUSPENDED; } else if(this.runningState == STATE_SUSPENDED) {",
                "patch_diff": "if(this.runningState!= STATE_RUNNING && this.runningState!= STATE_SUSPENDED; } else if(this.runningState == STATE_SUSPENDED) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if(this.runningState == STATE_RUNNING) { stopTime = System.currentTimeMillis(); }"
    },
    "JacksonDatabind-83": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (_deserialize(text, ctxt)!= null) { return _deserialize(text, ctxt); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-83/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\t2022-07-18 23:53:16.955880739 +0200\n+++ /tmp/tmp_lxjmp3l.java\t2022-07-18 23:53:16.979880589 +0200\n@@ -114,13 +114,11 @@\n             Exception cause = null;\n             try {\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n+if (_deserialize(text, ctxt)!= null) { return _deserialize(text, ctxt); }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n                 cause = me;\n             }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (_deserialize(text, ctxt) == null) { return _deserialize(text, ctxt); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-83/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\t2022-07-18 23:53:59.991613183 +0200\n+++ /tmp/tmpw3s8fjhi.java\t2022-07-18 23:53:59.991613183 +0200\n@@ -114,13 +114,11 @@\n             Exception cause = null;\n             try {\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n+if (_deserialize(text, ctxt) == null) { return _deserialize(text, ctxt); }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n                 cause = me;\n             }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (_deserialize(text, ctxt)!= null) { return _deserialize(text, ctxt); return _deserialize(text, ctxt); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-83/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\t2022-07-18 23:54:40.303361499 +0200\n+++ /tmp/tmpybd0vjf4.java\t2022-07-18 23:54:40.319361399 +0200\n@@ -114,13 +114,11 @@\n             Exception cause = null;\n             try {\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n+if (_deserialize(text, ctxt)!= null) { return _deserialize(text, ctxt); return _deserialize(text, ctxt); }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n                 cause = me;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (_deserialize(text, ctxt))!= null) { return _deserialize(text, ctxt); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-83/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\t2022-07-18 23:54:42.023350739 +0200\n+++ /tmp/tmp1ic_7bgp.java\t2022-07-18 23:54:42.023350739 +0200\n@@ -114,13 +114,11 @@\n             Exception cause = null;\n             try {\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n+if (_deserialize(text, ctxt))!= null) { return _deserialize(text, ctxt); }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n                 cause = me;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (_deserialize(text, ctxt)!= null) { return _deserialize(text, ctxt); } else { return _deserialize(text, ctxt); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-83/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\t2022-07-18 23:54:43.559341130 +0200\n+++ /tmp/tmp6x3lmyoi.java\t2022-07-18 23:54:43.559341130 +0200\n@@ -114,13 +114,11 @@\n             Exception cause = null;\n             try {\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n+if (_deserialize(text, ctxt)!= null) { return _deserialize(text, ctxt); } else { return _deserialize(text, ctxt); }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n                 cause = me;\n             }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 6,
                "patch": "if (_deserialize(text, ctxt)!= null) { return _deserialize(text, ctxt); } else if (deserialize(text, ctxt); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-83/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\t2022-07-18 23:55:23.599090135 +0200\n+++ /tmp/tmpzq32kper.java\t2022-07-18 23:55:23.607090083 +0200\n@@ -114,13 +114,11 @@\n             Exception cause = null;\n             try {\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n+if (_deserialize(text, ctxt)!= null) { return _deserialize(text, ctxt); } else if (deserialize(text, ctxt); }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n                 cause = me;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (_deserialize(text, ctxt)!= null) { return _deserialize(text, ctxt)); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-83/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\t2022-07-18 23:55:25.211080009 +0200\n+++ /tmp/tmp23i5ytv8.java\t2022-07-18 23:55:25.211080009 +0200\n@@ -114,13 +114,11 @@\n             Exception cause = null;\n             try {\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n+if (_deserialize(text, ctxt)!= null) { return _deserialize(text, ctxt)); }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n                 cause = me;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (_deserialize(text, ctxt)!= null) { return _deserialize(text, ctxt); } else if (text, ctxt); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-83/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\t2022-07-18 23:55:26.759070287 +0200\n+++ /tmp/tmp9nsvzwow.java\t2022-07-18 23:55:26.759070287 +0200\n@@ -114,13 +114,11 @@\n             Exception cause = null;\n             try {\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n+if (_deserialize(text, ctxt)!= null) { return _deserialize(text, ctxt); } else if (text, ctxt); }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n                 cause = me;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (_deserialize(text, ctxt)!= null) { return _deserialize(text, ctxt); } else if (_deserialize(text, ctxt); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-83/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\t2022-07-18 23:55:28.315060512 +0200\n+++ /tmp/tmpe2nw__o1.java\t2022-07-18 23:55:28.319060488 +0200\n@@ -114,13 +114,11 @@\n             Exception cause = null;\n             try {\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n+if (_deserialize(text, ctxt)!= null) { return _deserialize(text, ctxt); } else if (_deserialize(text, ctxt); }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n                 cause = me;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (_deserialize(jp, ctxt)!= null) { return _deserialize(text, ctxt); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-83/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\t2022-07-18 23:55:29.955050211 +0200\n+++ /tmp/tmpan5w950z.java\t2022-07-18 23:55:29.955050211 +0200\n@@ -114,13 +114,11 @@\n             Exception cause = null;\n             try {\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n+if (_deserialize(jp, ctxt)!= null) { return _deserialize(text, ctxt); }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n                 cause = me;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (_deserialize(text, ctxt) != null) { return _deserialize(text, ctxt); }",
        "fixed_line": ""
    },
    "Codec-18": {
        "fixes": [
            {
                "k": 1,
                "patch": "return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-18/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-18 23:55:31.987037443 +0200\n+++ /tmp/tmpy82k9690.java\t2022-07-18 23:55:32.019037242 +0200\n@@ -76,11 +76,11 @@\n             return false;\n         }\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n     }\n \n     /**\n      * Calls {@link String#getBytes(Charset)}\n      *\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length, cs2.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-18/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-18 23:55:38.666995451 +0200\n+++ /tmp/tmpe6utltxs.java\t2022-07-18 23:55:38.670995427 +0200\n@@ -76,11 +76,11 @@\n             return false;\n         }\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length, cs2.length()));\n     }\n \n     /**\n      * Calls {@link String#getBytes(Charset)}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return CharSequenceUtils.regionMatches(cs1, true, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-18/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-18 23:55:40.274985342 +0200\n+++ /tmp/tmpzx06llyq.java\t2022-07-18 23:55:40.274985342 +0200\n@@ -76,11 +76,11 @@\n             return false;\n         }\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+return CharSequenceUtils.regionMatches(cs1, true, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n     }\n \n     /**\n      * Calls {@link String#getBytes(Charset)}\n      *\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return CharSequenceUtils.regionMatches(cs1, true, 0, cs2, 0, Math.max(cs1.length, cs2.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-18/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-18 23:55:45.382953213 +0200\n+++ /tmp/tmpxah900n9.java\t2022-07-18 23:55:45.382953213 +0200\n@@ -76,11 +76,11 @@\n             return false;\n         }\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+return CharSequenceUtils.regionMatches(cs1, true, 0, cs2, 0, Math.max(cs1.length, cs2.length()));\n     }\n \n     /**\n      * Calls {@link String#getBytes(Charset)}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return CharSequenceUtils.regionMatches(cs1, false, 0, cs1, 0, Math.max(cs1.length(), cs2.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-18/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-18 23:55:47.058942668 +0200\n+++ /tmp/tmpmqw48jjs.java\t2022-07-18 23:55:47.062942645 +0200\n@@ -76,11 +76,11 @@\n             return false;\n         }\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+return CharSequenceUtils.regionMatches(cs1, false, 0, cs1, 0, Math.max(cs1.length(), cs2.length()));\n     }\n \n     /**\n      * Calls {@link String#getBytes(Charset)}\n      *\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length + cs2.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-18/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-18 23:55:52.386909137 +0200\n+++ /tmp/tmppoect2xf.java\t2022-07-18 23:55:52.386909137 +0200\n@@ -76,11 +76,11 @@\n             return false;\n         }\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length + cs2.length()));\n     }\n \n     /**\n      * Calls {@link String#getBytes(Charset)}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-18/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-18 23:55:54.066898561 +0200\n+++ /tmp/tmpw26_oi4w.java\t2022-07-18 23:55:54.066898561 +0200\n@@ -76,11 +76,11 @@\n             return false;\n         }\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length);\n     }\n \n     /**\n      * Calls {@link String#getBytes(Charset)}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-18/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-18 23:55:55.566889120 +0200\n+++ /tmp/tmpk01yj5il.java\t2022-07-18 23:55:55.566889120 +0200\n@@ -76,11 +76,11 @@\n             return false;\n         }\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length));\n     }\n \n     /**\n      * Calls {@link String#getBytes(Charset)}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length() - cs2.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-18/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-18 23:55:57.210878768 +0200\n+++ /tmp/tmp8fy1ffbg.java\t2022-07-18 23:55:57.210878768 +0200\n@@ -76,11 +76,11 @@\n             return false;\n         }\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length() - cs2.length()));\n     }\n \n     /**\n      * Calls {@link String#getBytes(Charset)}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length)(), cs2.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-18/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-18 23:55:58.866868338 +0200\n+++ /tmp/tmpdfhwz4s0.java\t2022-07-18 23:55:58.866868338 +0200\n@@ -76,11 +76,11 @@\n             return false;\n         }\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length)(), cs2.length()));\n     }\n \n     /**\n      * Calls {@link String#getBytes(Charset)}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));",
        "fixed_line": "return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length());"
    },
    "Closure-145": {
        "fixes": [
            {
                "k": 1,
                "patch": "// while ((n.getType() == Token.NAME || n.getType() == Token.DO);",
                "patch_diff": "// while ((n.getType() == Token.NAME || n.getType() == Token.DO);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// while (n.getType() == Token.NAME || n.getType() == Token.DO);",
                "patch_diff": "// while (n.getType() == Token.NAME || n.getType() == Token.DO);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// // can be null if ((n.getType() == Token.NAME || n.getType() == Token.DO);",
                "patch_diff": "// // can be null if ((n.getType() == Token.NAME || n.getType() == Token.DO);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// while ((n.getType() == Token.NAME || n.getType() == Token.DO) {",
                "patch_diff": "// while ((n.getType() == Token.NAME || n.getType() == Token.DO) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// while ((n.getType()!= Token.NAME || n.getType() == Token.DO);",
                "patch_diff": "// while ((n.getType()!= Token.NAME || n.getType() == Token.DO);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// while (n.getType() == Token.NAME || n.getType() == Token.DO) {",
                "patch_diff": "// while (n.getType() == Token.NAME || n.getType() == Token.DO) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// while (n.getType()!= Token.NAME || n.getType() == Token.DO);",
                "patch_diff": "// while (n.getType()!= Token.NAME || n.getType() == Token.DO);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// // can be null if ((n.getType() == Token.NAME || n.getType() == Token.DO) {",
                "patch_diff": "// // can be null if ((n.getType() == Token.NAME || n.getType() == Token.DO) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// while ((n.getType()!= Token.NAME || n.getType() == Token.DO) {",
                "patch_diff": "// while ((n.getType()!= Token.NAME || n.getType() == Token.DO) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// while (n.getType()!= Token.NAME || n.getType() == Token.DO) {",
                "patch_diff": "// while (n.getType()!= Token.NAME || n.getType() == Token.DO) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (n.getType() == Token.LABEL) { Node labeledStatement = n.getLastChild(); if (labeledStatement.getType() != Token.BLOCK) { return isOneExactlyFunctionOrDo(labeledStatement); } else { // For labels with block children, we need to ensure that a // labeled FUNCTION or DO isn't generated when extraneous BLOCKs // are skipped. if (getNonEmptyChildCount(n, 2) == 1) { return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n)); } else { // Either a empty statement or an block with more than one child, // way it isn't a FUNCTION or DO. return false; } } } else { return (n.getType() == Token.FUNCTION || n.getType() == Token.DO); }"
    },
    "Mockito-27": {
        "fixes": [
            {
                "k": 1,
                "patch": "MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter.Mockito.RETURNS_DEFAULTS));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-27/src/org/mockito/internal/util/MockUtil.java\t2022-07-18 23:56:02.506845410 +0200\n+++ /tmp/tmpk5moiq3l.java\t2022-07-18 23:56:02.586844909 +0200\n@@ -59,12 +59,11 @@\n         return mock;\n     }\n \n     public <T> void resetMock(T mock) {\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter.Mockito.RETURNS_DEFAULTS));\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = newMockSettingsImpl) org.RETURNS_DEFAULTS));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-27/src/org/mockito/internal/util/MockUtil.java\t2022-07-18 23:56:04.758831221 +0200\n+++ /tmp/tmpuwky4_1_.java\t2022-07-18 23:56:04.758831221 +0200\n@@ -59,12 +59,11 @@\n         return mock;\n     }\n \n     public <T> void resetMock(T mock) {\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = newMockSettingsImpl) org.RETURNS_DEFAULTS));\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter new MethodInterceptorFilter.Mockito.Mockito.RETURNS_DEFAULTS));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-27/src/org/mockito/internal/util/MockUtil.java\t2022-07-18 23:56:06.662819224 +0200\n+++ /tmp/tmpadm27adi.java\t2022-07-18 23:56:06.662819224 +0200\n@@ -59,12 +59,11 @@\n         return mock;\n     }\n \n     public <T> void resetMock(T mock) {\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter new MethodInterceptorFilter.Mockito.Mockito.RETURNS_DEFAULTS));\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter new MethodInterceptorFilter.Mockito.RETURNS_DEFAULTS));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-27/src/org/mockito/internal/util/MockUtil.java\t2022-07-18 23:56:08.630806821 +0200\n+++ /tmp/tmp4t9zuobp.java\t2022-07-18 23:56:08.630806821 +0200\n@@ -59,12 +59,11 @@\n         return mock;\n     }\n \n     public <T> void resetMock(T mock) {\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter new MethodInterceptorFilter.Mockito.RETURNS_DEFAULTS));\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "MockHandler<T> newMockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter.Mockito.RETURNS_DEFAULTS));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-27/src/org/mockito/internal/util/MockUtil.java\t2022-07-18 23:56:10.470795226 +0200\n+++ /tmp/tmpztb13xf8.java\t2022-07-18 23:56:10.470795226 +0200\n@@ -59,12 +59,11 @@\n         return mock;\n     }\n \n     public <T> void resetMock(T mock) {\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+MockHandler<T> newMockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter.Mockito.RETURNS_DEFAULTS));\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter new MethodInterceptorFilter<Mockito.Mockito.RETURNS_DEFAULTS));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-27/src/org/mockito/internal/util/MockUtil.java\t2022-07-18 23:56:12.306783649 +0200\n+++ /tmp/tmp2u556t9l.java\t2022-07-18 23:56:12.306783649 +0200\n@@ -59,12 +59,11 @@\n         return mock;\n     }\n \n     public <T> void resetMock(T mock) {\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter new MethodInterceptorFilter<Mockito.Mockito.RETURNS_DEFAULTS));\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilterImpl) org.RETURNS_DEFAULTS));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-27/src/org/mockito/internal/util/MockUtil.java\t2022-07-18 23:56:14.202771695 +0200\n+++ /tmp/tmplspatk3s.java\t2022-07-18 23:56:14.202771695 +0200\n@@ -59,12 +59,11 @@\n         return mock;\n     }\n \n     public <T> void resetMock(T mock) {\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilterImpl) org.RETURNS_DEFAULTS));\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter.Mockito.Mockito.RETURNS_DEFAULTS));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-27/src/org/mockito/internal/util/MockUtil.java\t2022-07-18 23:56:16.146759437 +0200\n+++ /tmp/tmpk1g0st7x.java\t2022-07-18 23:56:16.146759437 +0200\n@@ -59,12 +59,11 @@\n         return mock;\n     }\n \n     public <T> void resetMock(T mock) {\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter.Mockito.Mockito.RETURNS_DEFAULTS));\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler, (MockSettingsImpl) org.mockito.RETURNS_DEFAULTS));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-27/src/org/mockito/internal/util/MockUtil.java\t2022-07-18 23:56:18.046747454 +0200\n+++ /tmp/tmple_2bq0r.java\t2022-07-18 23:56:18.046747454 +0200\n@@ -59,12 +59,11 @@\n         return mock;\n     }\n \n     public <T> void resetMock(T mock) {\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler, (MockSettingsImpl) org.mockito.RETURNS_DEFAULTS));\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter new intito.Mockito.RETURNS_DEFAULTS));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-27/src/org/mockito/internal/util/MockUtil.java\t2022-07-18 23:56:19.950735444 +0200\n+++ /tmp/tmplks4ljea.java\t2022-07-18 23:56:19.950735444 +0200\n@@ -59,12 +59,11 @@\n         return mock;\n     }\n \n     public <T> void resetMock(T mock) {\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter new intito.Mockito.RETURNS_DEFAULTS));\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));",
        "fixed_line": "MethodInterceptorFilter newFilter = newMethodInterceptorFilter(oldMockHandler.getMockSettings());"
    },
    "Closure-131": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (i == length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-131/src/com/google/javascript/rhino/TokenStream.java\t2022-07-18 23:56:21.926722977 +0200\n+++ /tmp/tmpb5280t8x.java\t2022-07-18 23:56:21.950722829 +0200\n@@ -194,11 +194,11 @@\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+if (i == length) {\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n       }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (i <= length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-131/src/com/google/javascript/rhino/TokenStream.java\t2022-07-18 23:56:25.942697636 +0200\n+++ /tmp/tmppdw52z8j.java\t2022-07-18 23:56:25.942697636 +0200\n@@ -194,11 +194,11 @@\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+if (i <= length) {\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n       }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (length < length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-131/src/com/google/javascript/rhino/TokenStream.java\t2022-07-18 23:56:29.490675242 +0200\n+++ /tmp/tmp2n0lso0_.java\t2022-07-18 23:56:29.490675242 +0200\n@@ -194,11 +194,11 @@\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+if (length < length) {\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n       }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (i < length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-131/src/com/google/javascript/rhino/TokenStream.java\t2022-07-18 23:56:33.090652515 +0200\n+++ /tmp/tmp1go1e53e.java\t2022-07-18 23:56:33.094652487 +0200\n@@ -194,11 +194,11 @@\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+if (i < length) {\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n       }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (i > length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-131/src/com/google/javascript/rhino/TokenStream.java\t2022-07-18 23:56:36.678629854 +0200\n+++ /tmp/tmp_1s6w80w.java\t2022-07-18 23:56:36.682629829 +0200\n@@ -194,11 +194,11 @@\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+if (i > length) {\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n       }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (length == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-131/src/com/google/javascript/rhino/TokenStream.java\t2022-07-18 23:56:40.342606711 +0200\n+++ /tmp/tmpw7a7tdde.java\t2022-07-18 23:56:40.346606683 +0200\n@@ -194,11 +194,11 @@\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+if (length == 0) {\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n       }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (length < 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-131/src/com/google/javascript/rhino/TokenStream.java\t2022-07-18 23:56:43.986583684 +0200\n+++ /tmp/tmpw2hv_ytz.java\t2022-07-18 23:56:43.986583684 +0200\n@@ -194,11 +194,11 @@\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+if (length < 0) {\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n       }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (i > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-131/src/com/google/javascript/rhino/TokenStream.java\t2022-07-18 23:56:47.566561057 +0200\n+++ /tmp/tmp852d95rv.java\t2022-07-18 23:56:47.566561057 +0200\n@@ -194,11 +194,11 @@\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+if (i > 0) {\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n       }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (i!= length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-131/src/com/google/javascript/rhino/TokenStream.java\t2022-07-18 23:56:51.138538475 +0200\n+++ /tmp/tmp3ctl48jl.java\t2022-07-18 23:56:51.142538450 +0200\n@@ -194,11 +194,11 @@\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+if (i!= length) {\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n       }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (length < 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-131/src/com/google/javascript/rhino/TokenStream.java\t2022-07-18 23:56:54.734515736 +0200\n+++ /tmp/tmp7rsc_qia.java\t2022-07-18 23:56:54.734515736 +0200\n@@ -194,11 +194,11 @@\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+if (length < 1) {\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n       }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (",
        "fixed_line": "Character.isIdentifierIgnorable(s.charAt(0)) || !Character.isJavaIdentifierStart(s.charAt(0))) { return false; } for (int i = 1; i < length; i++) { if (Character.isIdentifierIgnorable(s.charAt(i)) ||"
    },
    "Math-41": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int i = 0; i < weights.length; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-41/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\t2022-07-18 23:56:58.502491905 +0200\n+++ /tmp/tmphxyk0xak.java\t2022-07-18 23:56:58.606491247 +0200\n@@ -515,11 +515,11 @@\n                     accum += weights[i] * (dev * dev);\n                     accum2 += weights[i] * dev;\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+for (int i = 0; i < weights.length; i++) {\n                     sumWts += weights[i];\n                 }\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = 0; i < weights.length; i++) { // yup, skip for (int i = 0; i < weights.length; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-41/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\t2022-07-18 23:57:19.534358760 +0200\n+++ /tmp/tmpev7rlzqf.java\t2022-07-18 23:57:19.534358760 +0200\n@@ -515,11 +515,11 @@\n                     accum += weights[i] * (dev * dev);\n                     accum2 += weights[i] * dev;\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+for (int i = 0; i < weights.length; i++) { // yup, skip for (int i = 0; i < weights.length; i++) {\n                     sumWts += weights[i];\n                 }\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0; i < weights.length; i++) { // weights[i] = sumWts[i]; if (int i = weights.length; i < weights.length; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-41/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\t2022-07-18 23:57:37.162247015 +0200\n+++ /tmp/tmpqn3ku95s.java\t2022-07-18 23:57:37.162247015 +0200\n@@ -515,11 +515,11 @@\n                     accum += weights[i] * (dev * dev);\n                     accum2 += weights[i] * dev;\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+for (int i = 0; i < weights.length; i++) { // weights[i] = sumWts[i]; if (int i = weights.length; i < weights.length; i++) {\n                     sumWts += weights[i];\n                 }\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = 0; i < weights.length; i++) { // weights[i] = weights[i]; if (int i = weights.length; i < weights.length; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-41/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\t2022-07-18 23:57:54.150139209 +0200\n+++ /tmp/tmp_funvxhv.java\t2022-07-18 23:57:54.150139209 +0200\n@@ -515,11 +515,11 @@\n                     accum += weights[i] * (dev * dev);\n                     accum2 += weights[i] * dev;\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+for (int i = 0; i < weights.length; i++) { // weights[i] = weights[i]; if (int i = weights.length; i < weights.length; i++) {\n                     sumWts += weights[i];\n                 }\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = 1; i < weights.length; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-41/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\t2022-07-18 23:58:11.290030324 +0200\n+++ /tmp/tmpa8ylkj99.java\t2022-07-18 23:58:11.290030324 +0200\n@@ -515,11 +515,11 @@\n                     accum += weights[i] * (dev * dev);\n                     accum2 += weights[i] * dev;\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+for (int i = 1; i < weights.length; i++) {\n                     sumWts += weights[i];\n                 }\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = 0; i < weights.length; i++) { // weights[i] = sumWts[i]; if (int i = weights.length; i = weights.length; i < weights.length; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-41/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\t2022-07-18 23:58:28.365921727 +0200\n+++ /tmp/tmp03cv0ppc.java\t2022-07-18 23:58:28.365921727 +0200\n@@ -515,11 +515,11 @@\n                     accum += weights[i] * (dev * dev);\n                     accum2 += weights[i] * dev;\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+for (int i = 0; i < weights.length; i++) { // weights[i] = sumWts[i]; if (int i = weights.length; i = weights.length; i < weights.length; i++) {\n                     sumWts += weights[i];\n                 }\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = 0; i < weights.length; i++) { // weights[i] = weights[i] / (int i = weights.length; i = weights.length; i = weights.length; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-41/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\t2022-07-18 23:58:46.441806656 +0200\n+++ /tmp/tmp3k6swpyt.java\t2022-07-18 23:58:46.441806656 +0200\n@@ -515,11 +515,11 @@\n                     accum += weights[i] * (dev * dev);\n                     accum2 += weights[i] * dev;\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+for (int i = 0; i < weights.length; i++) { // weights[i] = weights[i] / (int i = weights.length; i = weights.length; i = weights.length; i++) {\n                     sumWts += weights[i];\n                 }\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = 0; i < weights.length; i++) { // weights[i] = weights[i] / (int i = weights.length; i = weights.length; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-41/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\t2022-07-18 23:59:03.969694962 +0200\n+++ /tmp/tmp7pvfxi1g.java\t2022-07-18 23:59:03.973694935 +0200\n@@ -515,11 +515,11 @@\n                     accum += weights[i] * (dev * dev);\n                     accum2 += weights[i] * dev;\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+for (int i = 0; i < weights.length; i++) { // weights[i] = weights[i] / (int i = weights.length; i = weights.length; i++) {\n                     sumWts += weights[i];\n                 }\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for(int i = 0; i < weights.length; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-41/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\t2022-07-18 23:59:21.041586069 +0200\n+++ /tmp/tmpux63ybvh.java\t2022-07-18 23:59:21.045586042 +0200\n@@ -515,11 +515,11 @@\n                     accum += weights[i] * (dev * dev);\n                     accum2 += weights[i] * dev;\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+for(int i = 0; i < weights.length; i++) {\n                     sumWts += weights[i];\n                 }\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = 0; i < weights.length; i++) { // weights[i] = weights[i]; if (int i = weights.length == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-41/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\t2022-07-18 23:59:37.373481805 +0200\n+++ /tmp/tmpjbnlqbq9.java\t2022-07-18 23:59:37.373481805 +0200\n@@ -515,11 +515,11 @@\n                     accum += weights[i] * (dev * dev);\n                     accum2 += weights[i] * dev;\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+for (int i = 0; i < weights.length; i++) { // weights[i] = weights[i]; if (int i = weights.length == 0) {\n                     sumWts += weights[i];\n                 }\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "for (int i = 0; i < weights.length; i++) {",
        "fixed_line": "for (int i = begin; i < begin + length; i++) {"
    },
    "Closure-133": {
        "fixes": [
            {
                "k": 1,
                "patch": "private String getRemainingJSDocLine() { result = stream.getRemainingJSDocLine(); return result; }",
                "patch_diff": "private String getRemainingJSDocLine() { result = stream.getRemainingJSDocLine(); return result; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "private String getRemainingJSDocLine() { String result = stream.getRemainingJSDocLine(); return result; }",
                "patch_diff": "private String getRemainingJSDocLine() { String result = stream.getRemainingJSDocLine(); return result; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "String getRemainingJSDocLine() { String result = stream.getRemainingJSDocLine(); return result; }",
                "patch_diff": "String getRemainingJSDocLine() { String result = stream.getRemainingJSDocLine(); return result; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// String getRemainingJSDocLine() { String result = stream.getRemainingJSDocLine(); return result; }",
                "patch_diff": "// String getRemainingJSDocLine() { String result = stream.getRemainingJSDocLine(); return result; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// String getRemainingJSDocLine() { result = stream.getRemainingJSDocLine(); return result; }",
                "patch_diff": "// String getRemainingJSDocLine() { result = stream.getRemainingJSDocLine(); return result; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "String getRemainingJSDocLine() { result = stream.getRemainingJSDocLine(); return result; }",
                "patch_diff": "String getRemainingJSDocLine() { result = stream.getRemainingJSDocLine(); return result; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return result.getRemainingJSDocLine(); return result; }",
                "patch_diff": "return result.getRemainingJSDocLine(); return result; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "private String getRemainingJSDocLine() { result = stream.getRemainingJSDocLine(); }",
                "patch_diff": "private String getRemainingJSDocLine() { result = stream.getRemainingJSDocLine(); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private String getRemainingJSDocLine() { String result = stream.getRemainingJSDocLine(); }",
                "patch_diff": "private String getRemainingJSDocLine() { String result = stream.getRemainingJSDocLine(); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// return result = stream.getRemainingJSDocLine(); return result; }",
                "patch_diff": "// return result = stream.getRemainingJSDocLine(); return result; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "unreadToken = NO_UNREAD_TOKEN;"
    },
    "JacksonDatabind-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "return _valueTypeDeserializer!= null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-12/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\t2022-07-18 23:59:56.261361113 +0200\n+++ /tmp/tmpfjacorop.java\t2022-07-18 23:59:56.373360397 +0200\n@@ -298,11 +298,11 @@\n     @Override\n     public boolean isCachable() {\n         /* As per [databind#735], existence of value or key deserializer (only passed\n          * if annotated to use non-standard one) should also prevent caching.\n          */\n-        return (_valueTypeDeserializer == null)\n+return _valueTypeDeserializer!= null)\n                 && (_ignorableProperties == null);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return (_valueTypeDeserializer!= null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-12/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\t2022-07-18 23:59:57.937350400 +0200\n+++ /tmp/tmpka72gxhe.java\t2022-07-18 23:59:57.937350400 +0200\n@@ -298,11 +298,11 @@\n     @Override\n     public boolean isCachable() {\n         /* As per [databind#735], existence of value or key deserializer (only passed\n          * if annotated to use non-standard one) should also prevent caching.\n          */\n-        return (_valueTypeDeserializer == null)\n+return (_valueTypeDeserializer!= null)\n                 && (_ignorableProperties == null);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 3,
                "patch": "return _valueTypeDeserializer!= null && _valueTypeDeserializer!= null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-12/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\t2022-07-19 00:00:28.553154520 +0200\n+++ /tmp/tmpgber6ud3.java\t2022-07-19 00:00:28.553154520 +0200\n@@ -298,11 +298,11 @@\n     @Override\n     public boolean isCachable() {\n         /* As per [databind#735], existence of value or key deserializer (only passed\n          * if annotated to use non-standard one) should also prevent caching.\n          */\n-        return (_valueTypeDeserializer == null)\n+return _valueTypeDeserializer!= null && _valueTypeDeserializer!= null)\n                 && (_ignorableProperties == null);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return _valueTypeDeserializer!= null && (_valueTypeDeserializer!= null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-12/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\t2022-07-19 00:00:30.293143378 +0200\n+++ /tmp/tmp8m2u7blw.java\t2022-07-19 00:00:30.293143378 +0200\n@@ -298,11 +298,11 @@\n     @Override\n     public boolean isCachable() {\n         /* As per [databind#735], existence of value or key deserializer (only passed\n          * if annotated to use non-standard one) should also prevent caching.\n          */\n-        return (_valueTypeDeserializer == null)\n+return _valueTypeDeserializer!= null && (_valueTypeDeserializer!= null)\n                 && (_ignorableProperties == null);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 5,
                "patch": "return _valueTypeDeserializer!= null &&",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-12/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\t2022-07-19 00:00:58.884960182 +0200\n+++ /tmp/tmpegd_dnsj.java\t2022-07-19 00:00:58.884960182 +0200\n@@ -298,11 +298,11 @@\n     @Override\n     public boolean isCachable() {\n         /* As per [databind#735], existence of value or key deserializer (only passed\n          * if annotated to use non-standard one) should also prevent caching.\n          */\n-        return (_valueTypeDeserializer == null)\n+return _valueTypeDeserializer!= null &&\n                 && (_ignorableProperties == null);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return (_valueTypeDeserializer!= null && _valueTypeDeserializer!= null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-12/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\t2022-07-19 00:01:00.744948255 +0200\n+++ /tmp/tmpqr12zd0w.java\t2022-07-19 00:01:00.764948129 +0200\n@@ -298,11 +298,11 @@\n     @Override\n     public boolean isCachable() {\n         /* As per [databind#735], existence of value or key deserializer (only passed\n          * if annotated to use non-standard one) should also prevent caching.\n          */\n-        return (_valueTypeDeserializer == null)\n+return (_valueTypeDeserializer!= null && _valueTypeDeserializer!= null)\n                 && (_ignorableProperties == null);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 7,
                "patch": "return _valueTypeDeserializer!= null && _valueTypeDeserializer == null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-12/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\t2022-07-19 00:01:29.292765101 +0200\n+++ /tmp/tmprct4ms_w.java\t2022-07-19 00:01:29.292765101 +0200\n@@ -298,11 +298,11 @@\n     @Override\n     public boolean isCachable() {\n         /* As per [databind#735], existence of value or key deserializer (only passed\n          * if annotated to use non-standard one) should also prevent caching.\n          */\n-        return (_valueTypeDeserializer == null)\n+return _valueTypeDeserializer!= null && _valueTypeDeserializer == null)\n                 && (_ignorableProperties == null);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return _valueTypeDeserializer!= null && _valueTypeDeserializer.isCachable()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-12/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\t2022-07-19 00:01:30.776755573 +0200\n+++ /tmp/tmpbfd9iw4q.java\t2022-07-19 00:01:30.796755446 +0200\n@@ -298,11 +298,11 @@\n     @Override\n     public boolean isCachable() {\n         /* As per [databind#735], existence of value or key deserializer (only passed\n          * if annotated to use non-standard one) should also prevent caching.\n          */\n-        return (_valueTypeDeserializer == null)\n+return _valueTypeDeserializer!= null && _valueTypeDeserializer.isCachable()) {\n                 && (_ignorableProperties == null);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return _valueTypeDeserializer!= null && _valueTypeDeserializer.equals(keyType));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-12/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\t2022-07-19 00:01:32.652743529 +0200\n+++ /tmp/tmpmcan93iz.java\t2022-07-19 00:01:32.656743505 +0200\n@@ -298,11 +298,11 @@\n     @Override\n     public boolean isCachable() {\n         /* As per [databind#735], existence of value or key deserializer (only passed\n          * if annotated to use non-standard one) should also prevent caching.\n          */\n-        return (_valueTypeDeserializer == null)\n+return _valueTypeDeserializer!= null && _valueTypeDeserializer.equals(keyType));\n                 && (_ignorableProperties == null);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return _valueTypeDeserializer!= null && _valueTypeDeserializer.isCachable())",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-12/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\t2022-07-19 00:01:34.332732743 +0200\n+++ /tmp/tmps0u66xyr.java\t2022-07-19 00:01:34.332732743 +0200\n@@ -298,11 +298,11 @@\n     @Override\n     public boolean isCachable() {\n         /* As per [databind#735], existence of value or key deserializer (only passed\n          * if annotated to use non-standard one) should also prevent caching.\n          */\n-        return (_valueTypeDeserializer == null)\n+return _valueTypeDeserializer!= null && _valueTypeDeserializer.isCachable())\n                 && (_ignorableProperties == null);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return (_valueTypeDeserializer == null)",
        "fixed_line": "return (_valueDeserializer == null) && (_keyDeserializer == null) && (_valueTypeDeserializer == null)"
    },
    "Closure-107": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if it.getMsg(); // so we might be null!",
                "patch_diff": "// if it.getMsg(); // so we might be null!",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// if it.getMsg(), mode, // so we might be null!",
                "patch_diff": "// if it.getMsg(), mode, // so we might be null!",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if it.getMsg(), mode, // so we might be negative",
                "patch_diff": "// if it.getMsg(), mode, // so we might be negative",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// if it.getMsg(); // so we might be null or EMPTY",
                "patch_diff": "// if it.getMsg(); // so we might be null or EMPTY",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// if it.getMsg(); // so we might be negative",
                "patch_diff": "// if it.getMsg(); // so we might be negative",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if it.getMsg(); // so we might be valid (e if it.",
                "patch_diff": "// if it.getMsg(); // so we might be valid (e if it.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// if it.getMsg(), mode, // so we might be null",
                "patch_diff": "// if it.getMsg(), mode, // so we might be null",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// if it.getMsg(), mode, // so we might be null or EMPTY",
                "patch_diff": "// if it.getMsg(), mode, // so we might be null or EMPTY",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// if it.getMsg(); // so we might be null",
                "patch_diff": "// if it.getMsg(); // so we might be null",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if it.getMsg(), mode, // so we might be removed.",
                "patch_diff": "// if it.getMsg(), mode, // so we might be removed.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "options.setWarningLevel(JsMessageVisitor.MSG_CONVENTIONS, CheckLevel.OFF);"
    },
    "Jsoup-19": {
        "fixes": [
            {
                "k": 1,
                "patch": "// object (el.getKey()); // as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < v.length; i++) {",
                "patch_diff": "// object (el.getKey()); // as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < v.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// object (el.getKey()); // as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < v.length; ++i) {",
                "patch_diff": "// object (el.getKey()); // as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < v.length; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// object (el.getKey()); // as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < v.length; ++k) {",
                "patch_diff": "// object (el.getKey()); // as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < v.length; ++k) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// object (el.getKey()); // as per [JACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "// object (el.getKey()); // as per [JACKSON-notnotnotnotnotnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// object (el.getKey()); // as per [JACKSON-notnotnotnotnotnotnotnot real number",
                "patch_diff": "// object (el.getKey()); // as per [JACKSON-notnotnotnotnotnotnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// object (el.getKey()); // as per [JACKSON-notnotnotnotnotnot real number",
                "patch_diff": "// object (el.getKey()); // as per [JACKSON-notnotnotnotnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// object (el.getKey()); // as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < el.length; ++i) {",
                "patch_diff": "// object (el.getKey()); // as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < el.length; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// object (el.getKey()); // as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < el.length; i++) {",
                "patch_diff": "// object (el.getKey()); // as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < el.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// object (el.getKey()); // as per [JACKSON-notnotnotnotnotnotnotnotnot real number",
                "patch_diff": "// object (el.getKey()); // as per [JACKSON-notnotnotnotnotnotnotnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// object (el.getKey()); // as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < v.size(); ++k) {",
                "patch_diff": "// object (el.getKey()); // as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < v.size(); ++k) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (value.length() == 0) value = attr.getValue(); // if it could not be made abs, run as-is to allow custom unknown protocols"
    },
    "Gson-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "// When timezone } else if ((offset < SHORT_NAME) || timezone == 'D') { // 18-JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "// When timezone } else if ((offset < SHORT_NAME) || timezone == 'D') { // 18-JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// When timezone } else if ((offset < SHORT_NAME) || timezone.equals(timezone)) == 'D') || (timezoneIndicator == 'J') {",
                "patch_diff": "// When timezone } else if ((offset < SHORT_NAME) || timezone.equals(timezone)) == 'D') || (timezoneIndicator == 'J') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// When timezone } else if ((offset < SHORT_NAME) || timezone == 'D') { // 18-JACKSON-407] -- allow disabling wrapping for (int i = 0; i < v.length; i++) {",
                "patch_diff": "// When timezone } else if ((offset < SHORT_NAME) || timezone == 'D') { // 18-JACKSON-407] -- allow disabling wrapping for (int i = 0; i < v.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// When timezone } else if ((offset < SHORT_NAME) || timezone == 'D') { // 18-JACKSON-407] -- allow disabling wrapping for (int i = 0; i < qOffset; i++) {",
                "patch_diff": "// When timezone } else if ((offset < SHORT_NAME) || timezone == 'D') { // 18-JACKSON-407] -- allow disabling wrapping for (int i = 0; i < qOffset; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// When timezone } else if ((offset < SHORT_NAME) || timezone.equals(timezoneName)) == 'D') || (timezoneIndicator == 'J') {",
                "patch_diff": "// When timezone } else if ((offset < SHORT_NAME) || timezone.equals(timezoneName)) == 'D') || (timezoneIndicator == 'J') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// When timezone } else if ((offset < SHORT_NAME) || timezone == 'D') || (timezoneIndicator == 'J') {",
                "patch_diff": "// When timezone } else if ((offset < SHORT_NAME) || timezone == 'D') || (timezoneIndicator == 'J') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// When timezone } else if ((offset < SHORT_NAME) || timezone == 'D') { // 18-JACKSON-407] -- allow disabling wrapping for (int i = 0; i < length; i++) {",
                "patch_diff": "// When timezone } else if ((offset < SHORT_NAME) || timezone == 'D') { // 18-JACKSON-407] -- allow disabling wrapping for (int i = 0; i < length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// When timezone } else if ((offset < SHORT_NAME) || timezone.equals(timezone)) == 'D' || timezone == 'J') {",
                "patch_diff": "// When timezone } else if ((offset < SHORT_NAME) || timezone.equals(timezone)) == 'D' || timezone == 'J') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// When timezone } else if ((offset < SHORT_NAME) || timezone == 'D') { // 18-JACKSON-407] -- allow disabling wrapping for \"",
                "patch_diff": "// When timezone } else if ((offset < SHORT_NAME) || timezone == 'D') { // 18-JACKSON-407] -- allow disabling wrapping for \"",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// When timezone } else if ((offset < SHORT_NAME) || timezone == 'D') { // 18-JACKSON-407] -- allow disabling wrapping for mode",
                "patch_diff": "// When timezone } else if ((offset < SHORT_NAME) || timezone == 'D') { // 18-JACKSON-407] -- allow disabling wrapping for mode",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "timezoneOffset = timezoneOffset.length() >= 5 ? timezoneOffset : timezoneOffset + \"00\";"
    },
    "Math-67": {
        "fixes": [
            {
                "k": 1,
                "patch": "return optimizer.getFunctionValue(); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-67/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\t2022-07-19 00:01:41.884684246 +0200\n+++ /tmp/tmp7bw_6iq3.java\t2022-07-19 00:01:42.016683399 +0200\n@@ -87,16 +87,11 @@\n         setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getResult() {\n-        return optimizer.getResult();\n+return optimizer.getFunctionValue(); }\n     }\n \n     /** {@inheritDoc} */\n     public double getAbsoluteAccuracy() {\n         return optimizer.getAbsoluteAccuracy();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return optimizer.getFunctionValue(); } /** {@inheritDoc} */ public double getResult() { return optimizer.getResult();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-67/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\t2022-07-19 00:01:44.348668420 +0200\n+++ /tmp/tmpq8iyejqu.java\t2022-07-19 00:01:44.348668420 +0200\n@@ -87,16 +87,11 @@\n         setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getResult() {\n-        return optimizer.getResult();\n+return optimizer.getFunctionValue(); } /** {@inheritDoc} */ public double getResult() { return optimizer.getResult();\n     }\n \n     /** {@inheritDoc} */\n     public double getAbsoluteAccuracy() {\n         return optimizer.getAbsoluteAccuracy();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return optimizer.getFunctionValue(); } else if (inheritinheritDoc} */ public double getResult() { return optimizer.getResult();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-67/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\t2022-07-19 00:01:54.576602708 +0200\n+++ /tmp/tmpzr_hp102.java\t2022-07-19 00:01:54.580602681 +0200\n@@ -87,16 +87,11 @@\n         setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getResult() {\n-        return optimizer.getResult();\n+return optimizer.getFunctionValue(); } else if (inheritinheritDoc} */ public double getResult() { return optimizer.getResult();\n     }\n \n     /** {@inheritDoc} */\n     public double getAbsoluteAccuracy() {\n         return optimizer.getAbsoluteAccuracy();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return optimizer.getFunctionValue(); } // {@inheritDoc} */ public double getResult() { return optimizer.getResult();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-67/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\t2022-07-19 00:01:56.756588698 +0200\n+++ /tmp/tmprg8cye4j.java\t2022-07-19 00:01:56.756588698 +0200\n@@ -87,16 +87,11 @@\n         setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getResult() {\n-        return optimizer.getResult();\n+return optimizer.getFunctionValue(); } // {@inheritDoc} */ public double getResult() { return optimizer.getResult();\n     }\n \n     /** {@inheritDoc} */\n     public double getAbsoluteAccuracy() {\n         return optimizer.getAbsoluteAccuracy();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return optimizer.getFunctionValue(); } this {@inheritDoc} */ public double getResult() { return optimizer.getResult();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-67/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\t2022-07-19 00:01:58.940574661 +0200\n+++ /tmp/tmp0q7ymn6s.java\t2022-07-19 00:01:58.940574661 +0200\n@@ -87,16 +87,11 @@\n         setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getResult() {\n-        return optimizer.getResult();\n+return optimizer.getFunctionValue(); } this {@inheritDoc} */ public double getResult() { return optimizer.getResult();\n     }\n \n     /** {@inheritDoc} */\n     public double getAbsoluteAccuracy() {\n         return optimizer.getAbsoluteAccuracy();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return optimizer.getFunctionValue(); } if (inheritinheritDoc} */ public double getResult() { return optimizer.getResult();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-67/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\t2022-07-19 00:02:01.092560829 +0200\n+++ /tmp/tmp6wbk1rrn.java\t2022-07-19 00:02:01.092560829 +0200\n@@ -87,16 +87,11 @@\n         setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getResult() {\n-        return optimizer.getResult();\n+return optimizer.getFunctionValue(); } if (inheritinheritDoc} */ public double getResult() { return optimizer.getResult();\n     }\n \n     /** {@inheritDoc} */\n     public double getAbsoluteAccuracy() {\n         return optimizer.getAbsoluteAccuracy();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return optimizer.getFunctionValue(); } /**FinheritDoc} */ public double getResult() { return optimizer.getResult();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-67/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\t2022-07-19 00:02:03.228547099 +0200\n+++ /tmp/tmp0rwtgh5z.java\t2022-07-19 00:02:03.228547099 +0200\n@@ -87,16 +87,11 @@\n         setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getResult() {\n-        return optimizer.getResult();\n+return optimizer.getFunctionValue(); } /**FinheritDoc} */ public double getResult() { return optimizer.getResult();\n     }\n \n     /** {@inheritDoc} */\n     public double getAbsoluteAccuracy() {\n         return optimizer.getAbsoluteAccuracy();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return optimizer.getFunctionValue(); } /** {@inheritinheritDoc} */ public double getResult() { return optimizer.getResult();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-67/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\t2022-07-19 00:02:10.812498341 +0200\n+++ /tmp/tmpmax30b4e.java\t2022-07-19 00:02:10.812498341 +0200\n@@ -87,16 +87,11 @@\n         setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getResult() {\n-        return optimizer.getResult();\n+return optimizer.getFunctionValue(); } /** {@inheritinheritDoc} */ public double getResult() { return optimizer.getResult();\n     }\n \n     /** {@inheritDoc} */\n     public double getAbsoluteAccuracy() {\n         return optimizer.getAbsoluteAccuracy();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return optimizer.getFunctionValue(); } /** {@inheritDoc} */ public double getResult() { return mappings.getResult();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-67/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\t2022-07-19 00:02:18.372449726 +0200\n+++ /tmp/tmpgrwyrslw.java\t2022-07-19 00:02:18.372449726 +0200\n@@ -87,16 +87,11 @@\n         setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getResult() {\n-        return optimizer.getResult();\n+return optimizer.getFunctionValue(); } /** {@inheritDoc} */ public double getResult() { return mappings.getResult();\n     }\n \n     /** {@inheritDoc} */\n     public double getAbsoluteAccuracy() {\n         return optimizer.getAbsoluteAccuracy();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return optimizer.getFunctionValue(); } else { // double getResult() { return optimizer.getResult();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-67/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\t2022-07-19 00:02:20.680434879 +0200\n+++ /tmp/tmpd30k8n60.java\t2022-07-19 00:02:20.680434879 +0200\n@@ -87,16 +87,11 @@\n         setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getResult() {\n-        return optimizer.getResult();\n+return optimizer.getFunctionValue(); } else { // double getResult() { return optimizer.getResult();\n     }\n \n     /** {@inheritDoc} */\n     public double getAbsoluteAccuracy() {\n         return optimizer.getAbsoluteAccuracy();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return optimizer.getFunctionValue(); } /** {@inheritDoc} */ public double getResult() { return optimizer.getResult();",
        "fixed_line": "return optimaValues[0]; } /** {@inheritDoc} */ public double getResult() { return optima[0];"
    },
    "Mockito-18": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (type == Collection.class) { return Primitives.class; } else if (type == Type.class) {",
                "patch_diff": "if (type == Collection.class) { return Primitives.class; } else if (type == Type.class) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (type == Collection.class) { return Primitives.class; } else if (type == int.class) {",
                "patch_diff": "if (type == Collection.class) { return Primitives.class; } else if (type == int.class) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (type == Collection.class) { return Primitives.class; } else if (type == Type.class) { return Primitives.class; } else if (type == Type.class) {",
                "patch_diff": "if (type == Collection.class) { return Primitives.class; } else if (type == Type.class) { return Primitives.class; } else if (type == Type.class) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (type == Collection.class) { return Primitives.class; } else if (type == Collection.class) {",
                "patch_diff": "if (type == Collection.class) { return Primitives.class; } else if (type == Collection.class) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (type == Collection.class) { return Primitives.class; } else if (type == int.class) { return Primitives.class; } else if (type == int.class) { return Primitives.class; } else if (type == Type.class) {",
                "patch_diff": "if (type == Collection.class) { return Primitives.class; } else if (type == int.class) { return Primitives.class; } else if (type == int.class) { return Primitives.class; } else if (type == Type.class) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (type == Collection.class) { return Primitives.class; } else if (type == int.class) { return Primitives.class; } else if (type == int.class) { return Primitives.class; } else if (type == Collection.class) {",
                "patch_diff": "if (type == Collection.class) { return Primitives.class; } else if (type == int.class) { return Primitives.class; } else if (type == int.class) { return Primitives.class; } else if (type == Collection.class) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (type == Collection.class) { // as per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "if (type == Collection.class) { // as per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (type == Collection.class) { return Primitives.class; } else if (type == int.class) { return Primitives.class; } else if (type == int.class) { return Primitives.class; } else if (type == Collection.class) { return Primitives.class; } else if (type == Type.class) {",
                "patch_diff": "if (type == Collection.class) { return Primitives.class; } else if (type == int.class) { return Primitives.class; } else if (type == int.class) { return Primitives.class; } else if (type == Collection.class) { return Primitives.class; } else if (type == Type.class) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (type == Collection.class) { return Primitives.class; }",
                "patch_diff": "if (type == Collection.class) { return Primitives.class; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (type == Collection.class) { return Primitives.class; } else if (type == int.class) { return Primitives.class; } else if (type == int.class) { return Primitives.class) {",
                "patch_diff": "if (type == Collection.class) { return Primitives.class; } else if (type == int.class) { return Primitives.class; } else if (type == int.class) { return Primitives.class) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "} else if (type == Iterable.class) { return new ArrayList<Object>(0);"
    },
    "Math-17": {
        "fixes": [
            {
                "k": 1,
                "patch": "this(x);",
                "patch_diff": "this(x);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// Dfp in this.\");radix.size() > 1) {",
                "patch_diff": "// Dfp in this.\");radix.size() > 1) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "this(x); } else if (x < x multiplicand) {",
                "patch_diff": "this(x); } else if (x < x multiplicand) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "this(x); } else if (x < x multiplicand == x) {",
                "patch_diff": "this(x); } else if (x < x multiplicand == x) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "this(x); } else if (x < 0) {",
                "patch_diff": "this(x); } else if (x < 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "this(x = a;radix. * @ @[i]);",
                "patch_diff": "this(x = a;radix. * @ @[i]);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "this(x = a;radix. * @ @[i];",
                "patch_diff": "this(x = a;radix. * @ @[i];",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "this(x = a;radix. * @ @\")",
                "patch_diff": "this(x = a;radix. * @ @\")",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "this(x); }",
                "patch_diff": "this(x); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "this(x&dataset = x;radix. * @ @[i]);",
                "patch_diff": "this(x&dataset = x;radix. * @ @[i]);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (x >= 0 && x < RADIX) { return multiplyFast(x); } else { return multiply(newInstance(x)); }"
    },
    "JacksonDatabind-100": {
        "fixes": [
            {
                "k": 1,
                "patch": "byte[] data = n.binaryValue(); if (data!= null) { return null; } if (n.isPojo()) { return (byte[]) ob; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-100/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\t2022-07-19 00:02:27.132393373 +0200\n+++ /tmp/tmpt9ju2n7x.java\t2022-07-19 00:02:27.172393118 +0200\n@@ -358,19 +358,11 @@\n         // Multiple possibilities...\n         JsonNode n = currentNode();\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            byte[] data = n.binaryValue();\n-            if (data != null) {\n-                return data;\n-            }\n-            if (n.isPojo()) {\n-                Object ob = ((POJONode) n).getPojo();\n-                if (ob instanceof byte[]) {\n-                    return (byte[]) ob;\n-                }\n+byte[] data = n.binaryValue(); if (data!= null) { return null; } if (n.isPojo()) { return (byte[]) ob; }\n             }\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "byte[] data = n.binaryValue(); if (data == null) { return this; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-100/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\t2022-07-19 00:02:28.792382694 +0200\n+++ /tmp/tmp1zkzixkd.java\t2022-07-19 00:02:28.792382694 +0200\n@@ -358,19 +358,11 @@\n         // Multiple possibilities...\n         JsonNode n = currentNode();\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            byte[] data = n.binaryValue();\n-            if (data != null) {\n-                return data;\n-            }\n-            if (n.isPojo()) {\n-                Object ob = ((POJONode) n).getPojo();\n-                if (ob instanceof byte[]) {\n-                    return (byte[]) ob;\n-                }\n+byte[] data = n.binaryValue(); if (data == null) { return this; }\n             }\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "byte[] data = this.binaryValue(); if (data!= null) { return null; } if (n.isPojo()) { return (byte[]) ob; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-100/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\t2022-07-19 00:02:30.556371344 +0200\n+++ /tmp/tmpxzeldp0s.java\t2022-07-19 00:02:30.556371344 +0200\n@@ -358,19 +358,11 @@\n         // Multiple possibilities...\n         JsonNode n = currentNode();\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            byte[] data = n.binaryValue();\n-            if (data != null) {\n-                return data;\n-            }\n-            if (n.isPojo()) {\n-                Object ob = ((POJONode) n).getPojo();\n-                if (ob instanceof byte[]) {\n-                    return (byte[]) ob;\n-                }\n+byte[] data = this.binaryValue(); if (data!= null) { return null; } if (n.isPojo()) { return (byte[]) ob; }\n             }\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "byte[] data = n.binaryValue(); if (data!= null) { return null; } if (n.isPojo()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-100/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\t2022-07-19 00:02:32.232360559 +0200\n+++ /tmp/tmphgw669ao.java\t2022-07-19 00:02:32.232360559 +0200\n@@ -358,19 +358,11 @@\n         // Multiple possibilities...\n         JsonNode n = currentNode();\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            byte[] data = n.binaryValue();\n-            if (data != null) {\n-                return data;\n-            }\n-            if (n.isPojo()) {\n-                Object ob = ((POJONode) n).getPojo();\n-                if (ob instanceof byte[]) {\n-                    return (byte[]) ob;\n-                }\n+byte[] data = n.binaryValue(); if (data!= null) { return null; } if (n.isPojo()) {\n             }\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "byte[] data = n.binaryValue(); if (data!= null) { return null; } if (n.isPojo()) { return (byte[]) n; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-100/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\t2022-07-19 00:03:29.915988988 +0200\n+++ /tmp/tmpspteorfx.java\t2022-07-19 00:03:29.919988964 +0200\n@@ -358,19 +358,11 @@\n         // Multiple possibilities...\n         JsonNode n = currentNode();\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            byte[] data = n.binaryValue();\n-            if (data != null) {\n-                return data;\n-            }\n-            if (n.isPojo()) {\n-                Object ob = ((POJONode) n).getPojo();\n-                if (ob instanceof byte[]) {\n-                    return (byte[]) ob;\n-                }\n+byte[] data = n.binaryValue(); if (data!= null) { return null; } if (n.isPojo()) { return (byte[]) n; }\n             }\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "byte[] data = n.binaryValue(); if (data == null) { return null; } if (n.isPojo()) { return (byte[]) ob; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-100/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\t2022-07-19 00:03:31.807976788 +0200\n+++ /tmp/tmp_hf46my1.java\t2022-07-19 00:03:31.807976788 +0200\n@@ -358,19 +358,11 @@\n         // Multiple possibilities...\n         JsonNode n = currentNode();\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            byte[] data = n.binaryValue();\n-            if (data != null) {\n-                return data;\n-            }\n-            if (n.isPojo()) {\n-                Object ob = ((POJONode) n).getPojo();\n-                if (ob instanceof byte[]) {\n-                    return (byte[]) ob;\n-                }\n+byte[] data = n.binaryValue(); if (data == null) { return null; } if (n.isPojo()) { return (byte[]) ob; }\n             }\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "byte[] data = n.binaryValue(); if (data!= null) { return null; } if (n instanceof byte[]) { return (byte[]) ob; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-100/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\t2022-07-19 00:03:33.731964384 +0200\n+++ /tmp/tmpnsqgjfp7.java\t2022-07-19 00:03:33.731964384 +0200\n@@ -358,19 +358,11 @@\n         // Multiple possibilities...\n         JsonNode n = currentNode();\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            byte[] data = n.binaryValue();\n-            if (data != null) {\n-                return data;\n-            }\n-            if (n.isPojo()) {\n-                Object ob = ((POJONode) n).getPojo();\n-                if (ob instanceof byte[]) {\n-                    return (byte[]) ob;\n-                }\n+byte[] data = n.binaryValue(); if (data!= null) { return null; } if (n instanceof byte[]) { return (byte[]) ob; }\n             }\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "byte[] data = n.binaryValue(); if (data == null) { return this; } if (n instanceof byte[]) { return (byte[]) ob; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-100/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\t2022-07-19 00:03:35.363953858 +0200\n+++ /tmp/tmpapp83ifq.java\t2022-07-19 00:03:35.367953834 +0200\n@@ -358,19 +358,11 @@\n         // Multiple possibilities...\n         JsonNode n = currentNode();\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            byte[] data = n.binaryValue();\n-            if (data != null) {\n-                return data;\n-            }\n-            if (n.isPojo()) {\n-                Object ob = ((POJONode) n).getPojo();\n-                if (ob instanceof byte[]) {\n-                    return (byte[]) ob;\n-                }\n+byte[] data = n.binaryValue(); if (data == null) { return this; } if (n instanceof byte[]) { return (byte[]) ob; }\n             }\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "byte[] data = n.binaryValue(); if (data == null) { return null; } if (n instanceof byte[]) { return (byte[]) ob; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-100/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\t2022-07-19 00:03:37.211941942 +0200\n+++ /tmp/tmp3uy0zd6m.java\t2022-07-19 00:03:37.211941942 +0200\n@@ -358,19 +358,11 @@\n         // Multiple possibilities...\n         JsonNode n = currentNode();\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            byte[] data = n.binaryValue();\n-            if (data != null) {\n-                return data;\n-            }\n-            if (n.isPojo()) {\n-                Object ob = ((POJONode) n).getPojo();\n-                if (ob instanceof byte[]) {\n-                    return (byte[]) ob;\n-                }\n+byte[] data = n.binaryValue(); if (data == null) { return null; } if (n instanceof byte[]) { return (byte[]) ob; }\n             }\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "byte[] data = n.binaryValue(); if (data == null) { return null; } if (n.isPojo()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-100/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\t2022-07-19 00:03:38.755931983 +0200\n+++ /tmp/tmpgqcl20jh.java\t2022-07-19 00:03:38.755931983 +0200\n@@ -358,19 +358,11 @@\n         // Multiple possibilities...\n         JsonNode n = currentNode();\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            byte[] data = n.binaryValue();\n-            if (data != null) {\n-                return data;\n-            }\n-            if (n.isPojo()) {\n-                Object ob = ((POJONode) n).getPojo();\n-                if (ob instanceof byte[]) {\n-                    return (byte[]) ob;\n-                }\n+byte[] data = n.binaryValue(); if (data == null) { return null; } if (n.isPojo()) {\n             }\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "byte[] data = n.binaryValue(); if (data != null) { return data; } if (n.isPojo()) { Object ob = ((POJONode) n).getPojo(); if (ob instanceof byte[]) { return (byte[]) ob; }",
        "fixed_line": "if (n instanceof TextNode) { return ((TextNode) n).getBinaryValue(b64variant); } return n.binaryValue();"
    },
    "Time-7": {
        "fixes": [
            {
                "k": 1,
                "patch": "int defaultYear = chrono.year().get(instantLocal);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-7/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 00:04:33.959575649 +0200\n+++ /tmp/tmpvt2id3o2.java\t2022-07-19 00:04:34.015575285 +0200\n@@ -705,11 +705,11 @@\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+int defaultYear = chrono.year().get(instantLocal);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int defaultYear = chrono.year().get(instantLocal - 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-7/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 00:04:54.915440229 +0200\n+++ /tmp/tmp2c6gtp_g.java\t2022-07-19 00:04:54.915440229 +0200\n@@ -705,11 +705,11 @@\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+int defaultYear = chrono.year().get(instantLocal - 1);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int defaultYear = chrono.year().get(instantLocal = chrono);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-7/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 00:05:07.871356470 +0200\n+++ /tmp/tmpyyqx48ps.java\t2022-07-19 00:05:07.871356470 +0200\n@@ -705,11 +705,11 @@\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+int defaultYear = chrono.year().get(instantLocal = chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int defaultYear = chrono.year().get(instantLocal); // standardOffset = chrono.nextLocal = chrono.year().get(instantLocal);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-7/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 00:05:10.819337408 +0200\n+++ /tmp/tmpebvtkjds.java\t2022-07-19 00:05:10.819337408 +0200\n@@ -705,11 +705,11 @@\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+int defaultYear = chrono.year().get(instantLocal); // standardOffset = chrono.nextLocal = chrono.year().get(instantLocal);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int defaultYear = chrono.year().get(instantLocal); // standardOffset = chrono.year().get(instantLocal);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-7/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 00:05:21.807266342 +0200\n+++ /tmp/tmp16t9tlq6.java\t2022-07-19 00:05:21.807266342 +0200\n@@ -705,11 +705,11 @@\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+int defaultYear = chrono.year().get(instantLocal); // standardOffset = chrono.year().get(instantLocal);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int defaultYear = chrono.year().get(instantLocal); // standardOffset = chrono.nextLocal = chrono.get(instantLocal);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-7/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 00:05:35.603177088 +0200\n+++ /tmp/tmpz4nprxx2.java\t2022-07-19 00:05:35.603177088 +0200\n@@ -705,11 +705,11 @@\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+int defaultYear = chrono.year().get(instantLocal); // standardOffset = chrono.nextLocal = chrono.get(instantLocal);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int defaultYear = chrono.year().get(instantLocal));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-7/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 00:05:46.635105693 +0200\n+++ /tmp/tmp6ldf_6v9.java\t2022-07-19 00:05:46.635105693 +0200\n@@ -705,11 +705,11 @@\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+int defaultYear = chrono.year().get(instantLocal));\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int defaultYear = chrono.year().get(instantLocal!= chrono);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-7/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 00:05:49.347088139 +0200\n+++ /tmp/tmpasmos7qn.java\t2022-07-19 00:05:49.347088139 +0200\n@@ -705,11 +705,11 @@\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+int defaultYear = chrono.year().get(instantLocal!= chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int defaultYear = chrono.year().get(instantLocal); // standardOffset (chrono.nextLocal = chrono.get(instantLocal);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-7/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 00:05:52.339068769 +0200\n+++ /tmp/tmpgs20_olx.java\t2022-07-19 00:05:52.343068746 +0200\n@@ -705,11 +705,11 @@\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+int defaultYear = chrono.year().get(instantLocal); // standardOffset (chrono.nextLocal = chrono.get(instantLocal);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int defaultYear = chrono.year().get(instantLocal = chrono.get(instantLocal);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-7/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 00:06:03.130998901 +0200\n+++ /tmp/tmpvn3yz9jz.java\t2022-07-19 00:06:03.134998874 +0200\n@@ -705,11 +705,11 @@\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+int defaultYear = chrono.year().get(instantLocal = chrono.get(instantLocal);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "int defaultYear = chrono.year().get(instantLocal);",
        "fixed_line": "int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);"
    },
    "Cli-24": {
        "fixes": [
            {
                "k": 1,
                "patch": "throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"- no room for the description\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-24/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 00:06:06.054979966 +0200\n+++ /tmp/tmpphnb0w7c.java\t2022-07-19 00:06:06.110979605 +0200\n@@ -820,12 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n-                                            \"- no room for the description\");\n+throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"- no room for the description\");\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "throw new IllegalStateException(\"Total width is less than the height of the argument and indent \" + \"- no room for the description\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-24/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 00:06:08.598963494 +0200\n+++ /tmp/tmpbk2yauyf.java\t2022-07-19 00:06:08.598963494 +0200\n@@ -820,12 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n-                                            \"- no room for the description\");\n+throw new IllegalStateException(\"Total width is less than the height of the argument and indent \" + \"- no room for the description\");\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "throw new IllegalStateException(\"Total width is less than the width of the argument argument and indent \" + \"- no room for the description\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-24/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 00:06:11.230946449 +0200\n+++ /tmp/tmpxj46se4y.java\t2022-07-19 00:06:11.230946449 +0200\n@@ -820,12 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n-                                            \"- no room for the description\");\n+throw new IllegalStateException(\"Total width is less than the width of the argument argument and indent \" + \"- no room for the description\");\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new IllegalStateException(\"Total width is less than the record of the argument and indent \" + \"- no room for the description\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-24/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 00:06:13.714930361 +0200\n+++ /tmp/tmp20tjjjw_.java\t2022-07-19 00:06:13.718930333 +0200\n@@ -820,12 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n-                                            \"- no room for the description\");\n+throw new IllegalStateException(\"Total width is less than the record of the argument and indent \" + \"- no room for the description\");\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "throw new IllegalStateException(\"Total width is less than the source of the argument and indent \" + \"- no room for the description\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-24/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 00:06:16.110914841 +0200\n+++ /tmp/tmprwxzvg99.java\t2022-07-19 00:06:16.114914817 +0200\n@@ -820,12 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n-                                            \"- no room for the description\");\n+throw new IllegalStateException(\"Total width is less than the source of the argument and indent \" + \"- no room for the description\");\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "throw new IllegalStateException(\"Total width is less than the size of the argument and indent \" + \"- no room for the description\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-24/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 00:06:18.642898440 +0200\n+++ /tmp/tmp27edamyg.java\t2022-07-19 00:06:18.642898440 +0200\n@@ -820,12 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n-                                            \"- no room for the description\");\n+throw new IllegalStateException(\"Total width is less than the size of the argument and indent \" + \"- no room for the description\");\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "throw new IllegalStateException(\"Total width is less than the the argument and indent \" + \"- no room for the description\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-24/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 00:06:21.038882922 +0200\n+++ /tmp/tmp6s3bzj3_.java\t2022-07-19 00:06:21.038882922 +0200\n@@ -820,12 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n-                                            \"- no room for the description\");\n+throw new IllegalStateException(\"Total width is less than the the argument and indent \" + \"- no room for the description\");\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "throw new IllegalStateException(\"Total width is less than the argument and indent \" + \"- no room for the description\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-24/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 00:06:23.534866751 +0200\n+++ /tmp/tmpj_k2gz9a.java\t2022-07-19 00:06:23.538866727 +0200\n@@ -820,12 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n-                                            \"- no room for the description\");\n+throw new IllegalStateException(\"Total width is less than the argument and indent \" + \"- no room for the description\");\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "throw new IllegalStateException(\"Total width is less than the width of the argument a \" + \"- no room for the description\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-24/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 00:06:26.134849909 +0200\n+++ /tmp/tmpe0vqkien.java\t2022-07-19 00:06:26.134849909 +0200\n@@ -820,12 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n-                                            \"- no room for the description\");\n+throw new IllegalStateException(\"Total width is less than the width of the argument a \" + \"- no room for the description\");\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "throw new IllegalStateException(\"Total width is less than the width of the argumentbase \" + \"- no room for the description\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-24/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 00:06:28.666833505 +0200\n+++ /tmp/tmpaheo4kab.java\t2022-07-19 00:06:28.666833505 +0200\n@@ -820,12 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n-                                            \"- no room for the description\");\n+throw new IllegalStateException(\"Total width is less than the width of the argumentbase \" + \"- no room for the description\");\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"- no room for the description\");",
        "fixed_line": "nextLineTabStop = width - 1;"
    },
    "Lang-48": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (lhsClass.getClass()!= rhs.getClass()) {",
                "patch_diff": "if (lhsClass.getClass()!= rhs.getClass()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "we compare different dimensions = lhs.getClass(); if (lhsClass == rhs.getClass()) {",
                "patch_diff": "we compare different dimensions = lhs.getClass(); if (lhsClass == rhs.getClass()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "we compare different dimensions = lhs.getClass(); if (lhsClass!= rhs.getClass()) {",
                "patch_diff": "we compare different dimensions = lhs.getClass(); if (lhsClass!= rhs.getClass()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "we compare different dimensions = lhs.getClass(); } // 'Switch' on type of array",
                "patch_diff": "we compare different dimensions = lhs.getClass(); } // 'Switch' on type of array",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "we compare different dimensions = lhs.getClass(); } // 'Switch' on type of array, not an array",
                "patch_diff": "we compare different dimensions = lhs.getClass(); } // 'Switch' on type of array, not an array",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "we compare different dimensions = lhs.getClass(); if (lhsClass!= null) {",
                "patch_diff": "we compare different dimensions = lhs.getClass(); if (lhsClass!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "we compare different dimensions = lhs.getClass(); // 'e' on type of array, not an array",
                "patch_diff": "we compare different dimensions = lhs.getClass(); // 'e' on type of array, not an array",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "we compare different dimensions = lhs.getClass(); } // 'Switch' on type of array,",
                "patch_diff": "we compare different dimensions = lhs.getClass(); } // 'Switch' on type of array,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "we compare different dimensions = lhs.getClass(); // 'e' on type of array",
                "patch_diff": "we compare different dimensions = lhs.getClass(); // 'e' on type of array",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (lhsClass.getClass()!= rhs.getClass) {",
                "patch_diff": "if (lhsClass.getClass()!= rhs.getClass) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (lhs instanceof java.math.BigDecimal) { isEquals = (((java.math.BigDecimal)lhs).compareTo(rhs) == 0); } else { // The simple case, not an array, just test the element isEquals = lhs.equals(rhs); }"
    },
    "Closure-39": {
        "fixes": [
            {
                "k": 1,
                "patch": "sb.append(getPropertyType(property).toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-39/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2022-07-19 00:06:33.442802560 +0200\n+++ /tmp/tmp6undfb64.java\t2022-07-19 00:06:33.566801757 +0200\n@@ -375,25 +375,11 @@\n           sb.append(\", \");\n         }\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n-\n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n-      }\n-\n-      sb.append(\"}\");\n-\n-      prettyPrint = true;\n-      return sb.toString();\n-    } else {\n-      return \"{...}\";\n+sb.append(getPropertyType(property).toString());\n     }\n   }\n \n   void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "sb.append(getPropertyType.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-39/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2022-07-19 00:06:37.150778534 +0200\n+++ /tmp/tmpth03uyjt.java\t2022-07-19 00:06:37.150778534 +0200\n@@ -375,25 +375,11 @@\n           sb.append(\", \");\n         }\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n-\n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n-      }\n-\n-      sb.append(\"}\");\n-\n-      prettyPrint = true;\n-      return sb.toString();\n-    } else {\n-      return \"{...}\";\n+sb.append(getPropertyType.toString());\n     }\n   }\n \n   void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "sb.append(getPropertyType(); ++i; if (i == MAX_PRETTY_PRINTED_TYPE) { sb.append(\",\"); prettyPrint = false; return sb.toString();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-39/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2022-07-19 00:06:40.730755334 +0200\n+++ /tmp/tmptrr528kb.java\t2022-07-19 00:06:40.730755334 +0200\n@@ -375,25 +375,11 @@\n           sb.append(\", \");\n         }\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n-\n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n-      }\n-\n-      sb.append(\"}\");\n-\n-      prettyPrint = true;\n-      return sb.toString();\n-    } else {\n-      return \"{...}\";\n+sb.append(getPropertyType(); ++i; if (i == MAX_PRETTY_PRINTED_TYPE) { sb.append(\",\"); prettyPrint = false; return sb.toString();\n     }\n   }\n \n   void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "sb.append(getPropertyType(); ++i; if (i == MAX_PRETTY_PRINTED_TYPE) { sb.append(\",...\"); prettyPrint = false; return sb.toString();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-39/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2022-07-19 00:06:44.262732443 +0200\n+++ /tmp/tmpqkfkba36.java\t2022-07-19 00:06:44.262732443 +0200\n@@ -375,25 +375,11 @@\n           sb.append(\", \");\n         }\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n-\n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n-      }\n-\n-      sb.append(\"}\");\n-\n-      prettyPrint = true;\n-      return sb.toString();\n-    } else {\n-      return \"{...}\";\n+sb.append(getPropertyType(); ++i; if (i == MAX_PRETTY_PRINTED_TYPE) { sb.append(\",...\"); prettyPrint = false; return sb.toString();\n     }\n   }\n \n   void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "sb.append(getPropertyType(); ++i; if (i == MAX_PRETTY_PRINTED_TYPE) { sb.append(\",...\"); prettyPrint = true; return sb.toString();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-39/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2022-07-19 00:06:47.842709238 +0200\n+++ /tmp/tmpgbksxx_x.java\t2022-07-19 00:06:47.842709238 +0200\n@@ -375,25 +375,11 @@\n           sb.append(\", \");\n         }\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n-\n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n-      }\n-\n-      sb.append(\"}\");\n-\n-      prettyPrint = true;\n-      return sb.toString();\n-    } else {\n-      return \"{...}\";\n+sb.append(getPropertyType(); ++i; if (i == MAX_PRETTY_PRINTED_TYPE) { sb.append(\",...\"); prettyPrint = true; return sb.toString();\n     }\n   }\n \n   void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "sb.append(getPropertyType(); ++i; if (i == MAX_PRETTY_PRINTED_TYPE) { sb.append(\",\"); prettyPrint = false; } else { return \"{...}\";",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-39/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2022-07-19 00:06:51.530685335 +0200\n+++ /tmp/tmpodhc37ok.java\t2022-07-19 00:06:51.530685335 +0200\n@@ -375,25 +375,11 @@\n           sb.append(\", \");\n         }\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n-\n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n-      }\n-\n-      sb.append(\"}\");\n-\n-      prettyPrint = true;\n-      return sb.toString();\n-    } else {\n-      return \"{...}\";\n+sb.append(getPropertyType(); ++i; if (i == MAX_PRETTY_PRINTED_TYPE) { sb.append(\",\"); prettyPrint = false; } else { return \"{...}\";\n     }\n   }\n \n   void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "sb.append(getPropertyType(); ++i; if (i == MAX_PRETTY_PRINTED_TYPE) { sb.append(\",...\"); prettyPrint = false; } else { return \"{...}\";",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-39/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2022-07-19 00:06:55.226661373 +0200\n+++ /tmp/tmprmuj3mef.java\t2022-07-19 00:06:55.226661373 +0200\n@@ -375,25 +375,11 @@\n           sb.append(\", \");\n         }\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n-\n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n-      }\n-\n-      sb.append(\"}\");\n-\n-      prettyPrint = true;\n-      return sb.toString();\n-    } else {\n-      return \"{...}\";\n+sb.append(getPropertyType(); ++i; if (i == MAX_PRETTY_PRINTED_TYPE) { sb.append(\",...\"); prettyPrint = false; } else { return \"{...}\";\n     }\n   }\n \n   void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "sb.append(getPropertyType(); ++i; if (i == MAX_PRETTY_PRINTED_TYPE) { sb.append(\",\"); prettyPrint = false; return sb.toString(); } else { return \"{...}\";",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-39/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2022-07-19 00:06:58.978637052 +0200\n+++ /tmp/tmpt5yu1dhx.java\t2022-07-19 00:06:58.982637026 +0200\n@@ -375,25 +375,11 @@\n           sb.append(\", \");\n         }\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n-\n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n-      }\n-\n-      sb.append(\"}\");\n-\n-      prettyPrint = true;\n-      return sb.toString();\n-    } else {\n-      return \"{...}\";\n+sb.append(getPropertyType(); ++i; if (i == MAX_PRETTY_PRINTED_TYPE) { sb.append(\",\"); prettyPrint = false; return sb.toString(); } else { return \"{...}\";\n     }\n   }\n \n   void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "sb.append(getPropertyType(); ++i; if (i == MAX_PRETTY_PRINTED_TYPE) { sb.append(\",...\"); prettyPrint = false; return sb.toString(); } else { return \"{...}\";",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-39/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2022-07-19 00:07:02.550613893 +0200\n+++ /tmp/tmpnn1wcrb1.java\t2022-07-19 00:07:02.550613893 +0200\n@@ -375,25 +375,11 @@\n           sb.append(\", \");\n         }\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n-\n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n-      }\n-\n-      sb.append(\"}\");\n-\n-      prettyPrint = true;\n-      return sb.toString();\n-    } else {\n-      return \"{...}\";\n+sb.append(getPropertyType(); ++i; if (i == MAX_PRETTY_PRINTED_TYPE) { sb.append(\",...\"); prettyPrint = false; return sb.toString(); } else { return \"{...}\";\n     }\n   }\n \n   void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "sb.append(getPropertyType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-39/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2022-07-19 00:07:06.322589434 +0200\n+++ /tmp/tmpmlqj40mv.java\t2022-07-19 00:07:06.326589410 +0200\n@@ -375,25 +375,11 @@\n           sb.append(\", \");\n         }\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n-\n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n-      }\n-\n-      sb.append(\"}\");\n-\n-      prettyPrint = true;\n-      return sb.toString();\n-    } else {\n-      return \"{...}\";\n+sb.append(getPropertyType);\n     }\n   }\n \n   void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "sb.append(getPropertyType(property).toString()); ++i; if (i == MAX_PRETTY_PRINTED_PROPERTIES) { sb.append(\", ...\"); break; } } sb.append(\"}\"); prettyPrint = true; return sb.toString(); } else { return \"{...}\";",
        "fixed_line": "sb.append(getPropertyType(property).toStringHelper(forAnnotations)); ++i; if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) { sb.append(\", ...\"); break; } } sb.append(\"}\"); prettyPrint = true; return sb.toString(); } else { return forAnnotations ? \"?\" : \"{...}\";"
    },
    "Math-25": {
        "fixes": [
            {
                "k": 1,
                "patch": "// In some ill-condition = 0.5 * (c1 / c2); } else if (c1!= null) {",
                "patch_diff": "// In some ill-condition = 0.5 * (c1 / c2); } else if (c1!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// In some ill.sqrt(c1 /",
                "patch_diff": "// In some ill.sqrt(c1 /",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// In some ill.sqrt(c1 / d * (c1 > 0.0) {",
                "patch_diff": "// In some ill.sqrt(c1 / d * (c1 > 0.0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// In some ill.sqrt(c1);",
                "patch_diff": "// In some ill.sqrt(c1);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// In some ill-condition = 0.5 * (c1 / c2); } else {",
                "patch_diff": "// In some ill-condition = 0.5 * (c1 / c2); } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// In some ill.sqrt(c1 / c1); } else {",
                "patch_diff": "// In some ill.sqrt(c1 / c1); } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// In some ill-condition = 0.5 * (c1 /",
                "patch_diff": "// In some ill-condition = 0.5 * (c1 /",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// In some ill-condition = 0.5 * (c1 / c2); }",
                "patch_diff": "// In some ill-condition = 0.5 * (c1 / c2); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// In some ill.sqrt(c1 / c2); } else {",
                "patch_diff": "// In some ill.sqrt(c1 / c2); } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "//_ some ill.sqrt(c1 / d * (c1 > 0.0) {",
                "patch_diff": "//_ some ill.sqrt(c1 / d * (c1 > 0.0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (c2 == 0) { // In some ill-conditioned cases (cf. MATH-844), the guesser // procedure cannot produce sensible results. throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR); }"
    },
    "Math-2": {
        "fixes": [
            {
                "k": 1,
                "patch": "return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-2/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\t2022-07-19 00:07:11.782554030 +0200\n+++ /tmp/tmpd3ju3x0o.java\t2022-07-19 00:07:11.830553722 +0200\n@@ -263,11 +263,11 @@\n      *\n      * For population size {@code N}, number of successes {@code m}, and sample\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return (double)(getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-2/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\t2022-07-19 00:07:51.274297824 +0200\n+++ /tmp/tmpjef7s6__.java\t2022-07-19 00:07:51.290297722 +0200\n@@ -263,11 +263,11 @@\n      *\n      * For population size {@code N}, number of successes {@code m}, and sample\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+return (double)(getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return(double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-2/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\t2022-07-19 00:08:29.234051378 +0200\n+++ /tmp/tmpvwfd7apb.java\t2022-07-19 00:08:29.234051378 +0200\n@@ -263,11 +263,11 @@\n      *\n      * For population size {@code N}, number of successes {@code m}, and sample\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+return(double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize(); if (double) getPopulationSize();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-2/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\t2022-07-19 00:09:07.621801983 +0200\n+++ /tmp/tmpfb2dnznp.java\t2022-07-19 00:09:07.633801905 +0200\n@@ -263,11 +263,11 @@\n      *\n      * For population size {@code N}, number of successes {@code m}, and sample\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize(); if (double) getPopulationSize();\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return (double) (getSampleSize() * getNumberOfSuccesses()) /(double) getPopulationSize();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-2/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\t2022-07-19 00:09:09.733788258 +0200\n+++ /tmp/tmp7i_553se.java\t2022-07-19 00:09:09.733788258 +0200\n@@ -263,11 +263,11 @@\n      *\n      * For population size {@code N}, number of successes {@code m}, and sample\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+return (double) (getSampleSize() * getNumberOfSuccesses()) /(double) getPopulationSize();\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return (double[]) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-2/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\t2022-07-19 00:09:47.149545016 +0200\n+++ /tmp/tmp61xp0hf_.java\t2022-07-19 00:09:47.149545016 +0200\n@@ -263,11 +263,11 @@\n      *\n      * For population size {@code N}, number of successes {@code m}, and sample\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+return (double[]) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return (double) (getSampleSize() / getNumberOfSuccesses()) / (double) getPopulationSize();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-2/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\t2022-07-19 00:09:49.489529800 +0200\n+++ /tmp/tmp2u2i1_m8.java\t2022-07-19 00:09:49.489529800 +0200\n@@ -263,11 +263,11 @@\n      *\n      * For population size {@code N}, number of successes {@code m}, and sample\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+return (double) (getSampleSize() / getNumberOfSuccesses()) / (double) getPopulationSize();\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize(); else if (double) getPopulationSize();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-2/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\t2022-07-19 00:10:26.781287220 +0200\n+++ /tmp/tmpum4duxs3.java\t2022-07-19 00:10:26.781287220 +0200\n@@ -263,11 +263,11 @@\n      *\n      * For population size {@code N}, number of successes {@code m}, and sample\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize(); else if (double) getPopulationSize();\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return (_double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-2/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\t2022-07-19 00:10:29.249271160 +0200\n+++ /tmp/tmp4_jstd42.java\t2022-07-19 00:10:29.249271160 +0200\n@@ -263,11 +263,11 @@\n      *\n      * For population size {@code N}, number of successes {@code m}, and sample\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+return (_double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return (double)((getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-2/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\t2022-07-19 00:10:31.549256195 +0200\n+++ /tmp/tmp3pjz2rb1.java\t2022-07-19 00:10:31.549256195 +0200\n@@ -263,11 +263,11 @@\n      *\n      * For population size {@code N}, number of successes {@code m}, and sample\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+return (double)((getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();",
        "fixed_line": "return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize());"
    },
    "Gson-13": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (first == NUMBER_CHAR_DIG || arguments == Long.MIN_VALUE || (value!= Long.MIN_VALUE || negative)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-13/gson/src/main/java/com/google/gson/stream/JsonReader.java\t2022-07-19 00:10:33.909240836 +0200\n+++ /tmp/tmplgclddng.java\t2022-07-19 00:10:33.933240682 +0200\n@@ -726,11 +726,11 @@\n         }\n       }\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+if (first == NUMBER_CHAR_DIG || arguments == Long.MIN_VALUE || (value!= Long.MIN_VALUE || negative)) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n         || last == NUMBER_CHAR_EXP_DIGIT) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (first == NUMBER_CHAR_DIG && fitsInLong || (value!= Long.MIN_VALUE || negative)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-13/gson/src/main/java/com/google/gson/stream/JsonReader.java\t2022-07-19 00:10:35.817228422 +0200\n+++ /tmp/tmp5bh7s3m0.java\t2022-07-19 00:10:35.817228422 +0200\n@@ -726,11 +726,11 @@\n         }\n       }\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+if (first == NUMBER_CHAR_DIG && fitsInLong || (value!= Long.MIN_VALUE || negative)) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n         || last == NUMBER_CHAR_EXP_DIGIT) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (first == NUMBER_CHAR_DIG || current == Long.MIN_VALUE || (value!= Long.MIN_VALUE || negative)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-13/gson/src/main/java/com/google/gson/stream/JsonReader.java\t2022-07-19 00:10:37.593220438 +0200\n+++ /tmp/tmpb99t46b6.java\t2022-07-19 00:10:37.593220438 +0200\n@@ -726,11 +726,11 @@\n         }\n       }\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+if (first == NUMBER_CHAR_DIG || current == Long.MIN_VALUE || (value!= Long.MIN_VALUE || negative)) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n         || last == NUMBER_CHAR_EXP_DIGIT) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (first == NUMBER_CHAR_DIG || current == Long.MIN_VALUE || negative == Long.MIN_VALUE || negative)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-13/gson/src/main/java/com/google/gson/stream/JsonReader.java\t2022-07-19 00:10:39.481218965 +0200\n+++ /tmp/tmpmnp_1iwk.java\t2022-07-19 00:10:39.481218965 +0200\n@@ -726,11 +726,11 @@\n         }\n       }\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+if (first == NUMBER_CHAR_DIG || current == Long.MIN_VALUE || negative == Long.MIN_VALUE || negative)) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n         || last == NUMBER_CHAR_EXP_DIGIT) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (first == NUMBER_CHAR_DIG && fitsInLong || (value instanceof Long.MIN_VALUE || negative)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-13/gson/src/main/java/com/google/gson/stream/JsonReader.java\t2022-07-19 00:10:40.981217770 +0200\n+++ /tmp/tmphu3cgzur.java\t2022-07-19 00:10:40.981217770 +0200\n@@ -726,11 +726,11 @@\n         }\n       }\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+if (first == NUMBER_CHAR_DIG && fitsInLong || (value instanceof Long.MIN_VALUE || negative)) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n         || last == NUMBER_CHAR_EXP_DIGIT) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (first == NUMBER_CHAR_DIG || base == Long.MIN_VALUE || (value!= Long.MIN_VALUE || negative)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-13/gson/src/main/java/com/google/gson/stream/JsonReader.java\t2022-07-19 00:10:42.805216284 +0200\n+++ /tmp/tmpwc9fvmqx.java\t2022-07-19 00:10:42.805216284 +0200\n@@ -726,11 +726,11 @@\n         }\n       }\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+if (first == NUMBER_CHAR_DIG || base == Long.MIN_VALUE || (value!= Long.MIN_VALUE || negative)) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n         || last == NUMBER_CHAR_EXP_DIGIT) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (first == NUMBER_CHAR_DIG && fitsInLong && (value!= Long.MIN_VALUE || negative)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-13/gson/src/main/java/com/google/gson/stream/JsonReader.java\t2022-07-19 00:10:44.629214765 +0200\n+++ /tmp/tmpqz5exg5y.java\t2022-07-19 00:10:44.629214765 +0200\n@@ -726,11 +726,11 @@\n         }\n       }\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+if (first == NUMBER_CHAR_DIG && fitsInLong && (value!= Long.MIN_VALUE || negative)) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n         || last == NUMBER_CHAR_EXP_DIGIT) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (first == NUMBER_CHAR_DIG || fitsInLong || (value!= Long.MIN_VALUE || negative)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-13/gson/src/main/java/com/google/gson/stream/JsonReader.java\t2022-07-19 00:10:46.513213165 +0200\n+++ /tmp/tmps2vwf7la.java\t2022-07-19 00:10:46.513213165 +0200\n@@ -726,11 +726,11 @@\n         }\n       }\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+if (first == NUMBER_CHAR_DIG || fitsInLong || (value!= Long.MIN_VALUE || negative)) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n         || last == NUMBER_CHAR_EXP_DIGIT) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (first == NUMBER_CHAR_DIG || arguments == Long.MIN_VALUE || (value!= Long.MIN_VALUE) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-13/gson/src/main/java/com/google/gson/stream/JsonReader.java\t2022-07-19 00:10:48.481211453 +0200\n+++ /tmp/tmpd4bnxkvk.java\t2022-07-19 00:10:48.481211453 +0200\n@@ -726,11 +726,11 @@\n         }\n       }\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+if (first == NUMBER_CHAR_DIG || arguments == Long.MIN_VALUE || (value!= Long.MIN_VALUE) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n         || last == NUMBER_CHAR_EXP_DIGIT) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (first == NUMBER_CHAR_DIG || arguments == Long.MIN_VALUE || (value instanceof Long) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-13/gson/src/main/java/com/google/gson/stream/JsonReader.java\t2022-07-19 00:10:49.965210137 +0200\n+++ /tmp/tmpwrwbzmh1.java\t2022-07-19 00:10:49.965210137 +0200\n@@ -726,11 +726,11 @@\n         }\n       }\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+if (first == NUMBER_CHAR_DIG || arguments == Long.MIN_VALUE || (value instanceof Long) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n         || last == NUMBER_CHAR_EXP_DIGIT) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {",
        "fixed_line": "if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) {"
    },
    "Math-7": {
        "fixes": [
            {
                "k": 1,
                "patch": "currentEvent.stepAccepted(event, eventY);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-7/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\t2022-07-19 00:10:51.953208341 +0200\n+++ /tmp/tmpkbka23kp.java\t2022-07-19 00:10:51.977208320 +0200\n@@ -341,37 +341,11 @@\n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n-\n-                if (isLastStep) {\n-                    // the event asked to stop integration\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n-                    return eventT;\n-                }\n-\n-                boolean needReset = currentEvent.reset(eventT, eventY);\n-                if (needReset) {\n-                    // some event handler has triggered changes that\n-                    // invalidate the derivatives, we need to recompute them\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    computeDerivatives(eventT, y, yDot);\n-                    resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n+currentEvent.stepAccepted(event, eventY);\n                     return eventT;\n                 }\n \n                 // prepare handling of the remaining part of the step\n                 previousT = eventT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "currentEvent.stepAccepted(event.stepAccepted",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-7/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\t2022-07-19 00:10:54.161206302 +0200\n+++ /tmp/tmpr0ppcsi7.java\t2022-07-19 00:10:54.165206296 +0200\n@@ -341,37 +341,11 @@\n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n-\n-                if (isLastStep) {\n-                    // the event asked to stop integration\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n-                    return eventT;\n-                }\n-\n-                boolean needReset = currentEvent.reset(eventT, eventY);\n-                if (needReset) {\n-                    // some event handler has triggered changes that\n-                    // invalidate the derivatives, we need to recompute them\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    computeDerivatives(eventT, y, yDot);\n-                    resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n+currentEvent.stepAccepted(event.stepAccepted\n                     return eventT;\n                 }\n \n                 // prepare handling of the remaining part of the step\n                 previousT = eventT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "currentEvent.stepAccepted(event.stepAccepted()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-7/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\t2022-07-19 00:10:56.353204228 +0200\n+++ /tmp/tmp6jbe3n1x.java\t2022-07-19 00:10:56.357204224 +0200\n@@ -341,37 +341,11 @@\n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n-\n-                if (isLastStep) {\n-                    // the event asked to stop integration\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n-                    return eventT;\n-                }\n-\n-                boolean needReset = currentEvent.reset(eventT, eventY);\n-                if (needReset) {\n-                    // some event handler has triggered changes that\n-                    // invalidate the derivatives, we need to recompute them\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    computeDerivatives(eventT, y, yDot);\n-                    resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n+currentEvent.stepAccepted(event.stepAccepted()) {\n                     return eventT;\n                 }\n \n                 // prepare handling of the remaining part of the step\n                 previousT = eventT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "currentEvent.stepAccepted",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-7/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\t2022-07-19 00:10:58.385202265 +0200\n+++ /tmp/tmpy7e4dr6u.java\t2022-07-19 00:10:58.385202265 +0200\n@@ -341,37 +341,11 @@\n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n-\n-                if (isLastStep) {\n-                    // the event asked to stop integration\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n-                    return eventT;\n-                }\n-\n-                boolean needReset = currentEvent.reset(eventT, eventY);\n-                if (needReset) {\n-                    // some event handler has triggered changes that\n-                    // invalidate the derivatives, we need to recompute them\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    computeDerivatives(eventT, y, yDot);\n-                    resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n+currentEvent.stepAccepted\n                     return eventT;\n                 }\n \n                 // prepare handling of the remaining part of the step\n                 previousT = eventT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "currentEvent.stepAccepted(event, eventY); }Accepted",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-7/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\t2022-07-19 00:11:00.573200109 +0200\n+++ /tmp/tmpa0vm4bwy.java\t2022-07-19 00:11:00.573200109 +0200\n@@ -341,37 +341,11 @@\n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n-\n-                if (isLastStep) {\n-                    // the event asked to stop integration\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n-                    return eventT;\n-                }\n-\n-                boolean needReset = currentEvent.reset(eventT, eventY);\n-                if (needReset) {\n-                    // some event handler has triggered changes that\n-                    // invalidate the derivatives, we need to recompute them\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    computeDerivatives(eventT, y, yDot);\n-                    resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n+currentEvent.stepAccepted(event, eventY); }Accepted\n                     return eventT;\n                 }\n \n                 // prepare handling of the remaining part of the step\n                 previousT = eventT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "currentEvent.stepAccepted(event, eventY); // TODOAccepted",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-7/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\t2022-07-19 00:11:02.605198062 +0200\n+++ /tmp/tmph3fctlzo.java\t2022-07-19 00:11:02.605198062 +0200\n@@ -341,37 +341,11 @@\n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n-\n-                if (isLastStep) {\n-                    // the event asked to stop integration\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n-                    return eventT;\n-                }\n-\n-                boolean needReset = currentEvent.reset(eventT, eventY);\n-                if (needReset) {\n-                    // some event handler has triggered changes that\n-                    // invalidate the derivatives, we need to recompute them\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    computeDerivatives(eventT, y, yDot);\n-                    resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n+currentEvent.stepAccepted(event, eventY); // TODOAccepted\n                     return eventT;\n                 }\n \n                 // prepare handling of the remaining part of the step\n                 previousT = eventT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "currentEvent.stepAccepted(event, eventY); } else {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-7/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\t2022-07-19 00:11:04.769195843 +0200\n+++ /tmp/tmp_ils9gdo.java\t2022-07-19 00:11:04.769195843 +0200\n@@ -341,37 +341,11 @@\n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n-\n-                if (isLastStep) {\n-                    // the event asked to stop integration\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n-                    return eventT;\n-                }\n-\n-                boolean needReset = currentEvent.reset(eventT, eventY);\n-                if (needReset) {\n-                    // some event handler has triggered changes that\n-                    // invalidate the derivatives, we need to recompute them\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    computeDerivatives(eventT, y, yDot);\n-                    resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n+currentEvent.stepAccepted(event, eventY); } else {\n                     return eventT;\n                 }\n \n                 // prepare handling of the remaining part of the step\n                 previousT = eventT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "currentEvent.stepAccepted(event, eventY); } else if (event.length == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-7/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\t2022-07-19 00:11:06.817193698 +0200\n+++ /tmp/tmp28jc_z2b.java\t2022-07-19 00:11:06.817193698 +0200\n@@ -341,37 +341,11 @@\n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n-\n-                if (isLastStep) {\n-                    // the event asked to stop integration\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n-                    return eventT;\n-                }\n-\n-                boolean needReset = currentEvent.reset(eventT, eventY);\n-                if (needReset) {\n-                    // some event handler has triggered changes that\n-                    // invalidate the derivatives, we need to recompute them\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    computeDerivatives(eventT, y, yDot);\n-                    resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n+currentEvent.stepAccepted(event, eventY); } else if (event.length == 0) {\n                     return eventT;\n                 }\n \n                 // prepare handling of the remaining part of the step\n                 previousT = eventT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "currentEvent.stepAccepted(event, eventY); isLast.stepAccepted",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-7/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\t2022-07-19 00:11:08.877191502 +0200\n+++ /tmp/tmpl8wg7rm3.java\t2022-07-19 00:11:08.877191502 +0200\n@@ -341,37 +341,11 @@\n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n-\n-                if (isLastStep) {\n-                    // the event asked to stop integration\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n-                    return eventT;\n-                }\n-\n-                boolean needReset = currentEvent.reset(eventT, eventY);\n-                if (needReset) {\n-                    // some event handler has triggered changes that\n-                    // invalidate the derivatives, we need to recompute them\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    computeDerivatives(eventT, y, yDot);\n-                    resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n+currentEvent.stepAccepted(event, eventY); isLast.stepAccepted\n                     return eventT;\n                 }\n \n                 // prepare handling of the remaining part of the step\n                 previousT = eventT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "currentEvent.stepAccepted(event, eventY); } else if (event.isArg()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-7/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\t2022-07-19 00:11:11.049189145 +0200\n+++ /tmp/tmpv4foudjq.java\t2022-07-19 00:11:11.049189145 +0200\n@@ -341,37 +341,11 @@\n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n-\n-                if (isLastStep) {\n-                    // the event asked to stop integration\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n-                    return eventT;\n-                }\n-\n-                boolean needReset = currentEvent.reset(eventT, eventY);\n-                if (needReset) {\n-                    // some event handler has triggered changes that\n-                    // invalidate the derivatives, we need to recompute them\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    computeDerivatives(eventT, y, yDot);\n-                    resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n+currentEvent.stepAccepted(event, eventY); } else if (event.isArg()) {\n                     return eventT;\n                 }\n \n                 // prepare handling of the remaining part of the step\n                 previousT = eventT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "currentEvent.stepAccepted(eventT, eventY); isLastStep = currentEvent.stop(); // handle the first part of the step, up to the event for (final StepHandler handler : stepHandlers) { handler.handleStep(interpolator, isLastStep); } if (isLastStep) { // the event asked to stop integration System.arraycopy(eventY, 0, y, 0, y.length); for (final EventState remaining : occuringEvents) { remaining.stepAccepted(eventT, eventY); } return eventT; } boolean needReset = currentEvent.reset(eventT, eventY); if (needReset) { // some event handler has triggered changes that // invalidate the derivatives, we need to recompute them System.arraycopy(eventY, 0, y, 0, y.length); computeDerivatives(eventT, y, yDot); resetOccurred = true; for (final EventState remaining : occuringEvents) { remaining.stepAccepted(eventT, eventY); }",
        "fixed_line": "for (final EventState state : eventsStates) { state.stepAccepted(eventT, eventY); isLastStep = isLastStep || state.stop(); } // handle the first part of the step, up to the event for (final StepHandler handler : stepHandlers) { handler.handleStep(interpolator, isLastStep); } if (isLastStep) { // the event asked to stop integration System.arraycopy(eventY, 0, y, 0, y.length); return eventT; } boolean needReset = false; for (final EventState state : eventsStates) { needReset = needReset || state.reset(eventT, eventY); }"
    },
    "Lang-43": {
        "fixes": [
            {
                "k": 1,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = start; i < v.length; i++) {",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = start; i < v.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = start; i < count; ++i) {",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = start; i < count; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = start; i < len; ++i) {",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = start; i < len; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = start; i < count; i++) {",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = start; i < count; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = start; i < end; ++i) {",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = start; i < end; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = start; i < v.length; ++i) {",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = start; i < v.length; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (c == null? null : format.getIndex();",
                "patch_diff": "if (c == null? null : format.getIndex();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = start; i < end; i++) {",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = start; i < end; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = start; i < len; i++) {",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = start; i < len; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = start; i < as per [JACKSON-407] -- allow disabling wrapping for (int i = start; i++) {",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = start; i < as per [JACKSON-407] -- allow disabling wrapping for (int i = start; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "next(pos);"
    },
    "Cli-28": {
        "fixes": [
            {
                "k": 1,
                "patch": "break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-28/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 00:11:15.197184517 +0200\n+++ /tmp/tmpui60_fft.java\t2022-07-19 00:11:15.229184479 +0200\n@@ -285,11 +285,11 @@\n                         || \"true\".equalsIgnoreCase(value)\n                         || \"1\".equalsIgnoreCase(value)))\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+break;\n                 }\n \n                 cmd.addOption(opt);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "break; // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-28/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 00:11:17.829181497 +0200\n+++ /tmp/tmpi74wha38.java\t2022-07-19 00:11:17.833181491 +0200\n@@ -285,11 +285,11 @@\n                         || \"true\".equalsIgnoreCase(value)\n                         || \"1\".equalsIgnoreCase(value)))\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+break; // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n                 }\n \n                 cmd.addOption(opt);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "break; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-28/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 00:11:20.393178491 +0200\n+++ /tmp/tmp7fh872__.java\t2022-07-19 00:11:20.393178491 +0200\n@@ -285,11 +285,11 @@\n                         || \"true\".equalsIgnoreCase(value)\n                         || \"1\".equalsIgnoreCase(value)))\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+break; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n                 }\n \n                 cmd.addOption(opt);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "break; // we didn't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-28/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 00:11:22.973175408 +0200\n+++ /tmp/tmp3k_rv_2u.java\t2022-07-19 00:11:22.973175408 +0200\n@@ -285,11 +285,11 @@\n                         || \"true\".equalsIgnoreCase(value)\n                         || \"1\".equalsIgnoreCase(value)))\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+break; // we didn't really modify it's totalGJACKSON-notnotnotnot real number\n                 }\n \n                 cmd.addOption(opt);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "break; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-28/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 00:11:25.437172406 +0200\n+++ /tmp/tmptolm4mda.java\t2022-07-19 00:11:25.437172406 +0200\n@@ -285,11 +285,11 @@\n                         || \"true\".equalsIgnoreCase(value)\n                         || \"1\".equalsIgnoreCase(value)))\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+break; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n                 }\n \n                 cmd.addOption(opt);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "break; // we didn't really modify it's totalGJACKSON-407] -- allow disabling wrapping for (;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-28/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 00:11:28.153169032 +0200\n+++ /tmp/tmpsflian3q.java\t2022-07-19 00:11:28.153169032 +0200\n@@ -285,11 +285,11 @@\n                         || \"true\".equalsIgnoreCase(value)\n                         || \"1\".equalsIgnoreCase(value)))\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+break; // we didn't really modify it's totalGJACKSON-407] -- allow disabling wrapping for (;\n                 }\n \n                 cmd.addOption(opt);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "break; // we didn't really modify it's totalGJACKSON-407] -- allow use a digit after the",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-28/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 00:11:30.597165938 +0200\n+++ /tmp/tmpyymjekfj.java\t2022-07-19 00:11:30.597165938 +0200\n@@ -285,11 +285,11 @@\n                         || \"true\".equalsIgnoreCase(value)\n                         || \"1\".equalsIgnoreCase(value)))\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+break; // we didn't really modify it's totalGJACKSON-407] -- allow use a digit after the\n                 }\n \n                 cmd.addOption(opt);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "break; // we didn't really modify it was non-literal characters that might be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-28/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 00:11:33.277162484 +0200\n+++ /tmp/tmpyhljkpd6.java\t2022-07-19 00:11:33.277162484 +0200\n@@ -285,11 +285,11 @@\n                         || \"true\".equalsIgnoreCase(value)\n                         || \"1\".equalsIgnoreCase(value)))\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+break; // we didn't really modify it was non-literal characters that might be null!\n                 }\n \n                 cmd.addOption(opt);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "break; // we need to check whether a digit after the E",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-28/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 00:11:35.897159046 +0200\n+++ /tmp/tmp3azvgb3h.java\t2022-07-19 00:11:35.897159046 +0200\n@@ -285,11 +285,11 @@\n                         || \"true\".equalsIgnoreCase(value)\n                         || \"1\".equalsIgnoreCase(value)))\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+break; // we need to check whether a digit after the E\n                 }\n \n                 cmd.addOption(opt);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "break; // we didn't really modify it's totalGJACKSON-notnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-28/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 00:11:38.373155735 +0200\n+++ /tmp/tmp2y4twifa.java\t2022-07-19 00:11:38.373155735 +0200\n@@ -285,11 +285,11 @@\n                         || \"true\".equalsIgnoreCase(value)\n                         || \"1\".equalsIgnoreCase(value)))\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+break; // we didn't really modify it's totalGJACKSON-notnotnot real number\n                 }\n \n                 cmd.addOption(opt);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "break;",
        "fixed_line": "continue;"
    },
    "JacksonCore-6": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int i = 0; i < len; ++i) { char c = str.charAt(i);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-6/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 00:11:41.165151942 +0200\n+++ /tmp/tmpbqhs05ox.java\t2022-07-19 00:11:41.241151837 +0200\n@@ -188,12 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         // [core#176]: no leading zeroes allowed\n-        for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i);\n+for (int i = 0; i < len; ++i) { char c = str.charAt(i);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = 0; i < len; ++i; ++i) { char c = str.charAt(i);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-6/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 00:11:46.429144599 +0200\n+++ /tmp/tmpara307x1.java\t2022-07-19 00:11:46.433144591 +0200\n@@ -188,12 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         // [core#176]: no leading zeroes allowed\n-        for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i);\n+for (int i = 0; i < len; ++i; ++i) { char c = str.charAt(i);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for(int i = 0; i < len; ++i) { char c = str.charAt(i);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-6/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 00:11:47.957142421 +0200\n+++ /tmp/tmpbo3bo5u2.java\t2022-07-19 00:11:47.957142421 +0200\n@@ -188,12 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         // [core#176]: no leading zeroes allowed\n-        for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i);\n+for(int i = 0; i < len; ++i) { char c = str.charAt(i);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = 0; i < len; ++i) { char c = str.charAt(i));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-6/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 00:11:52.533135778 +0200\n+++ /tmp/tmpnj7avgyr.java\t2022-07-19 00:11:52.533135778 +0200\n@@ -188,12 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         // [core#176]: no leading zeroes allowed\n-        for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i);\n+for (int i = 0; i < len; ++i) { char c = str.charAt(i));\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = 0; i!= len; ++i) { char c = str.charAt(i);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-6/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 00:11:54.013133592 +0200\n+++ /tmp/tmpiluyugz0.java\t2022-07-19 00:11:54.013133592 +0200\n@@ -188,12 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         // [core#176]: no leading zeroes allowed\n-        for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i);\n+for (int i = 0; i!= len; ++i) { char c = str.charAt(i);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = 1; i < len; ++i) { char c = str.charAt(i);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-6/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 00:11:58.769126436 +0200\n+++ /tmp/tmpkpjj2w2y.java\t2022-07-19 00:11:58.769126436 +0200\n@@ -188,12 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         // [core#176]: no leading zeroes allowed\n-        for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i);\n+for (int i = 1; i < len; ++i) { char c = str.charAt(i);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = 0; i < len; ++i) { char c -= str.charAt(i);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-6/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 00:12:03.537119069 +0200\n+++ /tmp/tmpnv_g8taj.java\t2022-07-19 00:12:03.537119069 +0200\n@@ -188,12 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         // [core#176]: no leading zeroes allowed\n-        for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i);\n+for (int i = 0; i < len; ++i) { char c -= str.charAt(i);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = 0; i < len; ++i)) { char c = str.charAt(i);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-6/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 00:12:05.073116654 +0200\n+++ /tmp/tmp_znrditz.java\t2022-07-19 00:12:05.073116654 +0200\n@@ -188,12 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         // [core#176]: no leading zeroes allowed\n-        for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i);\n+for (int i = 0; i < len; ++i)) { char c = str.charAt(i);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int i -= 0; i < len; ++i) { char c = str.charAt(i);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-6/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 00:12:06.597114236 +0200\n+++ /tmp/tmpd94pztdt.java\t2022-07-19 00:12:06.597114236 +0200\n@@ -188,12 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         // [core#176]: no leading zeroes allowed\n-        for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i);\n+for (int i -= 0; i < len; ++i) { char c = str.charAt(i);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = 0; i < len; ++i) { char c = str.charAt(i]);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-6/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 00:12:08.165111730 +0200\n+++ /tmp/tmpykgxx497.java\t2022-07-19 00:12:08.165111730 +0200\n@@ -188,12 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         // [core#176]: no leading zeroes allowed\n-        for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i);\n+for (int i = 0; i < len; ++i) { char c = str.charAt(i]);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "for (int i = 0; i < len; ++i) { char c = str.charAt(i);",
        "fixed_line": "char c = str.charAt(0); if (c <= '0') { return (len == 1 && c == '0') ? 0 : -1; } if (c > '9') { return -1; } for (int i = 1; i < len; ++i) { c = str.charAt(i);"
    },
    "Closure-170": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (n.isName() && n.getString().equals(varName)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-170/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2022-07-19 00:12:10.041108706 +0200\n+++ /tmp/tmp2243ol73.java\t2022-07-19 00:12:10.093108621 +0200\n@@ -477,18 +477,11 @@\n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (n.isName() && n.getString().equals(varName) &&\n-            // We make a special exception when the entire cfgNode is a chain\n-            // of assignments, since in that case the assignment statements\n-            // will happen after the inlining of the right hand side.\n-            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n-            //   and remove this special case.\n-              !(parent.isAssign() &&\n-               (parent.getFirstChild() == n))) {\n+if (n.isName() && n.getString().equals(varName)) {\n               // Don't count lhs of top-level assignment chain\n               numUsesWithinCfgNode++;\n           }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (n.isName() && n.getString().equals(varName) == n))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-170/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2022-07-19 00:12:59.569018470 +0200\n+++ /tmp/tmpspy62zbm.java\t2022-07-19 00:12:59.569018470 +0200\n@@ -477,18 +477,11 @@\n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (n.isName() && n.getString().equals(varName) &&\n-            // We make a special exception when the entire cfgNode is a chain\n-            // of assignments, since in that case the assignment statements\n-            // will happen after the inlining of the right hand side.\n-            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n-            //   and remove this special case.\n-              !(parent.isAssign() &&\n-               (parent.getFirstChild() == n))) {\n+if (n.isName() && n.getString().equals(varName) == n))) {\n               // Don't count lhs of top-level assignment chain\n               numUsesWithinCfgNode++;\n           }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (n.isName() && n.getString().equals(varName) && // We make a prototype, as per RFC 46 property name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-170/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2022-07-19 00:13:03.053011397 +0200\n+++ /tmp/tmp_k32j_lq.java\t2022-07-19 00:13:03.053011397 +0200\n@@ -477,18 +477,11 @@\n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (n.isName() && n.getString().equals(varName) &&\n-            // We make a special exception when the entire cfgNode is a chain\n-            // of assignments, since in that case the assignment statements\n-            // will happen after the inlining of the right hand side.\n-            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n-            //   and remove this special case.\n-              !(parent.isAssign() &&\n-               (parent.getFirstChild() == n))) {\n+if (n.isName() && n.getString().equals(varName) && // We make a prototype, as per RFC 46 property name;\n               // Don't count lhs of top-level assignment chain\n               numUsesWithinCfgNode++;\n           }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (n.isName() && n.getString().equals(varName) && // We make a prototype,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-170/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2022-07-19 00:13:06.565004175 +0200\n+++ /tmp/tmpm8gav2_3.java\t2022-07-19 00:13:06.565004175 +0200\n@@ -477,18 +477,11 @@\n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (n.isName() && n.getString().equals(varName) &&\n-            // We make a special exception when the entire cfgNode is a chain\n-            // of assignments, since in that case the assignment statements\n-            // will happen after the inlining of the right hand side.\n-            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n-            //   and remove this special case.\n-              !(parent.isAssign() &&\n-               (parent.getFirstChild() == n))) {\n+if (n.isName() && n.getString().equals(varName) && // We make a prototype,\n               // Don't count lhs of top-level assignment chain\n               numUsesWithinCfgNode++;\n           }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (n.isName() && n.getString().equals(varName) && // We make a prototype, as per [JACKSON-407] -- allow disabling wrapping for a prototype,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-170/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2022-07-19 00:13:09.812997415 +0200\n+++ /tmp/tmpqwz8imnf.java\t2022-07-19 00:13:09.812997415 +0200\n@@ -477,18 +477,11 @@\n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (n.isName() && n.getString().equals(varName) &&\n-            // We make a special exception when the entire cfgNode is a chain\n-            // of assignments, since in that case the assignment statements\n-            // will happen after the inlining of the right hand side.\n-            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n-            //   and remove this special case.\n-              !(parent.isAssign() &&\n-               (parent.getFirstChild() == n))) {\n+if (n.isName() && n.getString().equals(varName) && // We make a prototype, as per [JACKSON-407] -- allow disabling wrapping for a prototype,\n               // Don't count lhs of top-level assignment chain\n               numUsesWithinCfgNode++;\n           }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (n.isName() && n.getString().equals(varName) == n)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-170/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2022-07-19 00:13:13.252990167 +0200\n+++ /tmp/tmpjwrm0hf4.java\t2022-07-19 00:13:13.252990167 +0200\n@@ -477,18 +477,11 @@\n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (n.isName() && n.getString().equals(varName) &&\n-            // We make a special exception when the entire cfgNode is a chain\n-            // of assignments, since in that case the assignment statements\n-            // will happen after the inlining of the right hand side.\n-            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n-            //   and remove this special case.\n-              !(parent.isAssign() &&\n-               (parent.getFirstChild() == n))) {\n+if (n.isName() && n.getString().equals(varName) == n)) {\n               // Don't count lhs of top-level assignment chain\n               numUsesWithinCfgNode++;\n           }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (n.isName() && n.getString().equals(varName) && // We make a prototype, as per [JACKSON-407] --raw == n))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-170/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2022-07-19 00:13:16.864982463 +0200\n+++ /tmp/tmpl0a90ijs.java\t2022-07-19 00:13:16.864982463 +0200\n@@ -477,18 +477,11 @@\n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (n.isName() && n.getString().equals(varName) &&\n-            // We make a special exception when the entire cfgNode is a chain\n-            // of assignments, since in that case the assignment statements\n-            // will happen after the inlining of the right hand side.\n-            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n-            //   and remove this special case.\n-              !(parent.isAssign() &&\n-               (parent.getFirstChild() == n))) {\n+if (n.isName() && n.getString().equals(varName) && // We make a prototype, as per [JACKSON-407] --raw == n))) {\n               // Don't count lhs of top-level assignment chain\n               numUsesWithinCfgNode++;\n           }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (n.isName() && n.getString().equals(varName) && // We make a prototype, as per [JACKSON-407] --raw) == n))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-170/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2022-07-19 00:13:20.356974924 +0200\n+++ /tmp/tmpxp_p4cy9.java\t2022-07-19 00:13:20.356974924 +0200\n@@ -477,18 +477,11 @@\n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (n.isName() && n.getString().equals(varName) &&\n-            // We make a special exception when the entire cfgNode is a chain\n-            // of assignments, since in that case the assignment statements\n-            // will happen after the inlining of the right hand side.\n-            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n-            //   and remove this special case.\n-              !(parent.isAssign() &&\n-               (parent.getFirstChild() == n))) {\n+if (n.isName() && n.getString().equals(varName) && // We make a prototype, as per [JACKSON-407] --raw) == n))) {\n               // Don't count lhs of top-level assignment chain\n               numUsesWithinCfgNode++;\n           }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (n.isName() || n.getString().equals(varName) == n))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-170/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2022-07-19 00:13:23.912967157 +0200\n+++ /tmp/tmp07osnn_s.java\t2022-07-19 00:13:23.912967157 +0200\n@@ -477,18 +477,11 @@\n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (n.isName() && n.getString().equals(varName) &&\n-            // We make a special exception when the entire cfgNode is a chain\n-            // of assignments, since in that case the assignment statements\n-            // will happen after the inlining of the right hand side.\n-            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n-            //   and remove this special case.\n-              !(parent.isAssign() &&\n-               (parent.getFirstChild() == n))) {\n+if (n.isName() || n.getString().equals(varName) == n))) {\n               // Don't count lhs of top-level assignment chain\n               numUsesWithinCfgNode++;\n           }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (n.isName() == n.getString().equals(varName) && // We make a prototype, as per RFC 46 property name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-170/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2022-07-19 00:13:27.424959390 +0200\n+++ /tmp/tmpy0f16l0k.java\t2022-07-19 00:13:27.428959381 +0200\n@@ -477,18 +477,11 @@\n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (n.isName() && n.getString().equals(varName) &&\n-            // We make a special exception when the entire cfgNode is a chain\n-            // of assignments, since in that case the assignment statements\n-            // will happen after the inlining of the right hand side.\n-            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n-            //   and remove this special case.\n-              !(parent.isAssign() &&\n-               (parent.getFirstChild() == n))) {\n+if (n.isName() == n.getString().equals(varName) && // We make a prototype, as per RFC 46 property name;\n               // Don't count lhs of top-level assignment chain\n               numUsesWithinCfgNode++;\n           }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (n.isName() && n.getString().equals(varName) && // We make a special exception when the entire cfgNode is a chain // of assignments, since in that case the assignment statements // will happen after the inlining of the right hand side. // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact // and remove this special case. !(parent.isAssign() && (parent.getFirstChild() == n))) {",
        "fixed_line": "if (n.isName() && n.getString().equals(varName)) { // We make a special exception when the entire cfgNode is a chain // of assignments, since in that case the assignment statements // will happen after the inlining of the right hand side. // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact // and remove this special case. if (parent.isAssign() && (parent.getFirstChild() == n) && isAssignChain(parent, cfgNode)) { // Don't count lhs of top-level assignment chain return; } else { numUsesWithinCfgNode++; } } } private boolean isAssignChain(Node child, Node ancestor) { for (Node n = child; n != ancestor; n = n.getParent()) { if (!n.isAssign()) { return false; } } return true; }"
    },
    "Math-95": {
        "fixes": [
            {
                "k": 1,
                "patch": "double ret = p;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2022-07-19 00:13:31.248950836 +0200\n+++ /tmp/tmplw6lulih.java\t2022-07-19 00:13:31.372950555 +0200\n@@ -139,11 +139,11 @@\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+double ret = p;\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "double ret = p; // we didn't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2022-07-19 00:13:38.248934907 +0200\n+++ /tmp/tmpvpdc1z1r.java\t2022-07-19 00:13:38.248934907 +0200\n@@ -139,11 +139,11 @@\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+double ret = p; // we didn't really modify it's totalGJACKSON-notnotnotnot real number\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "double ret = p; // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2022-07-19 00:13:44.760919780 +0200\n+++ /tmp/tmpn6lxqpd5.java\t2022-07-19 00:13:44.760919780 +0200\n@@ -139,11 +139,11 @@\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+double ret = p; // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "double ret = p; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2022-07-19 00:13:51.364904136 +0200\n+++ /tmp/tmpqfusdz_v.java\t2022-07-19 00:13:51.364904136 +0200\n@@ -139,11 +139,11 @@\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+double ret = p; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "double ret = p; // we didn't really modify it's totalGJACKSON-notnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2022-07-19 00:13:58.012888087 +0200\n+++ /tmp/tmpi019syh4.java\t2022-07-19 00:13:58.012888087 +0200\n@@ -139,11 +139,11 @@\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+double ret = p; // we didn't really modify it's totalGJACKSON-notnotnot real number\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "double ret = p; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2022-07-19 00:14:04.776871445 +0200\n+++ /tmp/tmplotq2ayf.java\t2022-07-19 00:14:04.776871445 +0200\n@@ -139,11 +139,11 @@\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+double ret = p; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "double ret = p; // we didn't really modify it's totalGJACKSON-notnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2022-07-19 00:14:11.492854621 +0200\n+++ /tmp/tmpgr4gft4y.java\t2022-07-19 00:14:11.496854611 +0200\n@@ -139,11 +139,11 @@\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+double ret = p; // we didn't really modify it's totalGJACKSON-notnot real number\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "double ret = p; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2022-07-19 00:14:18.296837271 +0200\n+++ /tmp/tmp4ju3lswt.java\t2022-07-19 00:14:18.316837220 +0200\n@@ -139,11 +139,11 @@\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+double ret = p; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "double ret;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2022-07-19 00:14:25.436818740 +0200\n+++ /tmp/tmpu15yu8z7.java\t2022-07-19 00:14:25.436818740 +0200\n@@ -139,11 +139,11 @@\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+double ret;\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "double ret = p; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2022-07-19 00:14:31.976801478 +0200\n+++ /tmp/tmplamp9nmr.java\t2022-07-19 00:14:31.976801478 +0200\n@@ -139,11 +139,11 @@\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+double ret = p; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "double ret;",
        "fixed_line": "double ret = 1.0; double d = getDenominatorDegreesOfFreedom(); if (d > 2.0) { // use mean ret = d / (d - 2.0); }"
    },
    "Cli-14": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (validate) { option.validate(commandLine); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-14/src/java/org/apache/commons/cli2/option/GroupImpl.java\t2022-07-19 00:14:38.636783618 +0200\n+++ /tmp/tmpennxbpk3.java\t2022-07-19 00:14:38.660783551 +0200\n@@ -245,13 +245,11 @@\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n \n             // needs validation?\n             boolean validate = option.isRequired() || option instanceof Group;\n-            if (validate) {\n-                option.validate(commandLine);\n-            }\n+if (validate) { option.validate(commandLine); }\n \n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n                 if (++present > maximum) {\n                     unexpected = option;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (option.validate(commandLine); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-14/src/java/org/apache/commons/cli2/option/GroupImpl.java\t2022-07-19 00:14:41.884774808 +0200\n+++ /tmp/tmpv7bys5oe.java\t2022-07-19 00:14:41.884774808 +0200\n@@ -245,13 +245,11 @@\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n \n             // needs validation?\n             boolean validate = option.isRequired() || option instanceof Group;\n-            if (validate) {\n-                option.validate(commandLine);\n-            }\n+if (option.validate(commandLine); }\n \n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n                 if (++present > maximum) {\n                     unexpected = option;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (option ==validate) { option.validate(commandLine); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-14/src/java/org/apache/commons/cli2/option/GroupImpl.java\t2022-07-19 00:14:43.452770531 +0200\n+++ /tmp/tmp0yhuop34.java\t2022-07-19 00:14:43.452770531 +0200\n@@ -245,13 +245,11 @@\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n \n             // needs validation?\n             boolean validate = option.isRequired() || option instanceof Group;\n-            if (validate) {\n-                option.validate(commandLine);\n-            }\n+if (option ==validate) { option.validate(commandLine); }\n \n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n                 if (++present > maximum) {\n                     unexpected = option;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (option) { option.validate(commandLine); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-14/src/java/org/apache/commons/cli2/option/GroupImpl.java\t2022-07-19 00:14:45.120765965 +0200\n+++ /tmp/tmpz__bo71l.java\t2022-07-19 00:14:45.120765965 +0200\n@@ -245,13 +245,11 @@\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n \n             // needs validation?\n             boolean validate = option.isRequired() || option instanceof Group;\n-            if (validate) {\n-                option.validate(commandLine);\n-            }\n+if (option) { option.validate(commandLine); }\n \n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n                 if (++present > maximum) {\n                     unexpected = option;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (validate ) { option.validate(commandLine); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-14/src/java/org/apache/commons/cli2/option/GroupImpl.java\t2022-07-19 00:14:46.832761260 +0200\n+++ /tmp/tmp221uc104.java\t2022-07-19 00:14:46.832761260 +0200\n@@ -245,13 +245,11 @@\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n \n             // needs validation?\n             boolean validate = option.isRequired() || option instanceof Group;\n-            if (validate) {\n-                option.validate(commandLine);\n-            }\n+if (validate ) { option.validate(commandLine); }\n \n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n                 if (++present > maximum) {\n                     unexpected = option;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (skip.validate(commandLine); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-14/src/java/org/apache/commons/cli2/option/GroupImpl.java\t2022-07-19 00:14:49.764753160 +0200\n+++ /tmp/tmp5sp6pwh4.java\t2022-07-19 00:14:49.768753150 +0200\n@@ -245,13 +245,11 @@\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n \n             // needs validation?\n             boolean validate = option.isRequired() || option instanceof Group;\n-            if (validate) {\n-                option.validate(commandLine);\n-            }\n+if (skip.validate(commandLine); }\n \n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n                 if (++present > maximum) {\n                     unexpected = option;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (defaultNewLine) { option.validate(commandLine); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-14/src/java/org/apache/commons/cli2/option/GroupImpl.java\t2022-07-19 00:14:51.356748741 +0200\n+++ /tmp/tmp0w5drscj.java\t2022-07-19 00:14:51.356748741 +0200\n@@ -245,13 +245,11 @@\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n \n             // needs validation?\n             boolean validate = option.isRequired() || option instanceof Group;\n-            if (validate) {\n-                option.validate(commandLine);\n-            }\n+if (defaultNewLine) { option.validate(commandLine); }\n \n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n                 if (++present > maximum) {\n                     unexpected = option;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (validate) { option.validate(command); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-14/src/java/org/apache/commons/cli2/option/GroupImpl.java\t2022-07-19 00:14:53.176743670 +0200\n+++ /tmp/tmpiuyuobb8.java\t2022-07-19 00:14:53.176743670 +0200\n@@ -245,13 +245,11 @@\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n \n             // needs validation?\n             boolean validate = option.isRequired() || option instanceof Group;\n-            if (validate) {\n-                option.validate(commandLine);\n-            }\n+if (validate) { option.validate(command); }\n \n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n                 if (++present > maximum) {\n                     unexpected = option;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (validate) { option.validate(commandLine); } else {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-14/src/java/org/apache/commons/cli2/option/GroupImpl.java\t2022-07-19 00:14:54.892738870 +0200\n+++ /tmp/tmpk5a3aiiu.java\t2022-07-19 00:14:54.896738857 +0200\n@@ -245,13 +245,11 @@\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n \n             // needs validation?\n             boolean validate = option.isRequired() || option instanceof Group;\n-            if (validate) {\n-                option.validate(commandLine);\n-            }\n+if (validate) { option.validate(commandLine); } else {\n \n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n                 if (++present > maximum) {\n                     unexpected = option;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (group.validate(commandLine); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-14/src/java/org/apache/commons/cli2/option/GroupImpl.java\t2022-07-19 00:14:56.472734433 +0200\n+++ /tmp/tmpy01vhlja.java\t2022-07-19 00:14:56.476734420 +0200\n@@ -245,13 +245,11 @@\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n \n             // needs validation?\n             boolean validate = option.isRequired() || option instanceof Group;\n-            if (validate) {\n-                option.validate(commandLine);\n-            }\n+if (group.validate(commandLine); }\n \n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n                 if (++present > maximum) {\n                     unexpected = option;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (validate) { option.validate(commandLine); }",
        "fixed_line": "validate = true; } if (validate) {"
    },
    "Cli-4": {
        "fixes": [
            {
                "k": 1,
                "patch": "StringBuffer buff = new StringBuffer();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-4/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 00:14:58.428728922 +0200\n+++ /tmp/tmp0r37a6oc.java\t2022-07-19 00:14:58.488728749 +0200\n@@ -293,11 +293,11 @@\n         // if there are required options that have not been\n         // processsed\n         if (requiredOptions.size() > 0)\n         {\n             Iterator iter = requiredOptions.iterator();\n-            StringBuffer buff = new StringBuffer();\n+StringBuffer buff = new StringBuffer();\n \n \n             // loop through the required options\n             while (iter.hasNext())\n             {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "StringBuffer buff = new StringBuffer(); // we didn't really modify it's totalGJACKSON-notnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-4/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 00:15:01.444720376 +0200\n+++ /tmp/tmp7gevfrrs.java\t2022-07-19 00:15:01.444720376 +0200\n@@ -293,11 +293,11 @@\n         // if there are required options that have not been\n         // processsed\n         if (requiredOptions.size() > 0)\n         {\n             Iterator iter = requiredOptions.iterator();\n-            StringBuffer buff = new StringBuffer();\n+StringBuffer buff = new StringBuffer(); // we didn't really modify it's totalGJACKSON-notnotnot real number\n \n \n             // loop through the required options\n             while (iter.hasNext())\n             {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "StringBuffer buff = new StringBuffer(); // we didn't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-4/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 00:15:03.880713434 +0200\n+++ /tmp/tmp_mtlb5n8.java\t2022-07-19 00:15:03.880713434 +0200\n@@ -293,11 +293,11 @@\n         // if there are required options that have not been\n         // processsed\n         if (requiredOptions.size() > 0)\n         {\n             Iterator iter = requiredOptions.iterator();\n-            StringBuffer buff = new StringBuffer();\n+StringBuffer buff = new StringBuffer(); // we didn't really modify it's totalGJACKSON-notnotnotnot real number\n \n \n             // loop through the required options\n             while (iter.hasNext())\n             {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "StringBuffer buff = new StringBuffer(); // we didn't really modify it's totalGJACKSON-notnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-4/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 00:15:06.060707192 +0200\n+++ /tmp/tmp_n6dfz0y.java\t2022-07-19 00:15:06.064707182 +0200\n@@ -293,11 +293,11 @@\n         // if there are required options that have not been\n         // processsed\n         if (requiredOptions.size() > 0)\n         {\n             Iterator iter = requiredOptions.iterator();\n-            StringBuffer buff = new StringBuffer();\n+StringBuffer buff = new StringBuffer(); // we didn't really modify it's totalGJACKSON-notnot real number\n \n \n             // loop through the required options\n             while (iter.hasNext())\n             {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "StringBuffer buff = new StringBuffer(); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-4/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 00:15:08.488700206 +0200\n+++ /tmp/tmpp33uut2k.java\t2022-07-19 00:15:08.488700206 +0200\n@@ -293,11 +293,11 @@\n         // if there are required options that have not been\n         // processsed\n         if (requiredOptions.size() > 0)\n         {\n             Iterator iter = requiredOptions.iterator();\n-            StringBuffer buff = new StringBuffer();\n+StringBuffer buff = new StringBuffer(); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n \n \n             // loop through the required options\n             while (iter.hasNext())\n             {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "StringBuffer buff = new StringBuffer(); // can't really modify it's totalGJACKSON-notnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-4/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 00:15:10.776693592 +0200\n+++ /tmp/tmp05gkusx0.java\t2022-07-19 00:15:10.776693592 +0200\n@@ -293,11 +293,11 @@\n         // if there are required options that have not been\n         // processsed\n         if (requiredOptions.size() > 0)\n         {\n             Iterator iter = requiredOptions.iterator();\n-            StringBuffer buff = new StringBuffer();\n+StringBuffer buff = new StringBuffer(); // can't really modify it's totalGJACKSON-notnotnot real number\n \n \n             // loop through the required options\n             while (iter.hasNext())\n             {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "StringBuffer buff = new StringBuffer(); // can't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-4/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 00:15:13.096686854 +0200\n+++ /tmp/tmpqze5rj2t.java\t2022-07-19 00:15:13.128686763 +0200\n@@ -293,11 +293,11 @@\n         // if there are required options that have not been\n         // processsed\n         if (requiredOptions.size() > 0)\n         {\n             Iterator iter = requiredOptions.iterator();\n-            StringBuffer buff = new StringBuffer();\n+StringBuffer buff = new StringBuffer(); // can't really modify it's totalGJACKSON-notnotnotnot real number\n \n \n             // loop through the required options\n             while (iter.hasNext())\n             {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "StringBuffer buff = new StringBuffer(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-4/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 00:15:15.848678819 +0200\n+++ /tmp/tmpy1x3gtx2.java\t2022-07-19 00:15:15.852678809 +0200\n@@ -293,11 +293,11 @@\n         // if there are required options that have not been\n         // processsed\n         if (requiredOptions.size() > 0)\n         {\n             Iterator iter = requiredOptions.iterator();\n-            StringBuffer buff = new StringBuffer();\n+StringBuffer buff = new StringBuffer(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n \n \n             // loop through the required options\n             while (iter.hasNext())\n             {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "StringBuffer buff = new StringBuffer(); // can't really modify it's totalGJACKSON-notnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-4/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 00:15:18.324671552 +0200\n+++ /tmp/tmp8kft_a9t.java\t2022-07-19 00:15:18.324671552 +0200\n@@ -293,11 +293,11 @@\n         // if there are required options that have not been\n         // processsed\n         if (requiredOptions.size() > 0)\n         {\n             Iterator iter = requiredOptions.iterator();\n-            StringBuffer buff = new StringBuffer();\n+StringBuffer buff = new StringBuffer(); // can't really modify it's totalGJACKSON-notnot real number\n \n \n             // loop through the required options\n             while (iter.hasNext())\n             {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "StringBuffer buff = new StringBuffer(); // can't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-4/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 00:15:20.596664853 +0200\n+++ /tmp/tmpxka8tmvp.java\t2022-07-19 00:15:20.600664843 +0200\n@@ -293,11 +293,11 @@\n         // if there are required options that have not been\n         // processsed\n         if (requiredOptions.size() > 0)\n         {\n             Iterator iter = requiredOptions.iterator();\n-            StringBuffer buff = new StringBuffer();\n+StringBuffer buff = new StringBuffer(); // can't really modify it's totalGJACKSON-notnotnotnotnot real number\n \n \n             // loop through the required options\n             while (iter.hasNext())\n             {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "StringBuffer buff = new StringBuffer();",
        "fixed_line": "StringBuffer buff = new StringBuffer(\"Missing required option\"); buff.append(requiredOptions.size() == 1 ? \"\" : \"s\"); buff.append(\": \");"
    },
    "Lang-22": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (Math.abs(u) < 1 || Math.abs(v) <= 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-22/src/main/java/org/apache/commons/lang3/math/Fraction.java\t2022-07-19 00:15:23.308656821 +0200\n+++ /tmp/tmplup9f28d.java\t2022-07-19 00:15:23.352656687 +0200\n@@ -579,11 +579,11 @@\n      * @return the greatest common divisor, never zero\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+if (Math.abs(u) < 1 || Math.abs(v) <= 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (Math.abs(u) < 1 || Math.abs(v) == 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-22/src/main/java/org/apache/commons/lang3/math/Fraction.java\t2022-07-19 00:15:33.184627202 +0200\n+++ /tmp/tmp_8ms6yb8.java\t2022-07-19 00:15:33.184627202 +0200\n@@ -579,11 +579,11 @@\n      * @return the greatest common divisor, never zero\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+if (Math.abs(u) < 1 || Math.abs(v) == 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (Math.abs(u) <= 0 || Math.abs(v) <= 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-22/src/main/java/org/apache/commons/lang3/math/Fraction.java\t2022-07-19 00:15:42.732598045 +0200\n+++ /tmp/tmpxbvx6kos.java\t2022-07-19 00:15:42.732598045 +0200\n@@ -579,11 +579,11 @@\n      * @return the greatest common divisor, never zero\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+if (Math.abs(u) <= 0 || Math.abs(v) <= 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (Math.abs(u) <= 1 || Math.abs(v) == 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-22/src/main/java/org/apache/commons/lang3/math/Fraction.java\t2022-07-19 00:15:52.212568596 +0200\n+++ /tmp/tmpqr_etl_q.java\t2022-07-19 00:15:52.212568596 +0200\n@@ -579,11 +579,11 @@\n      * @return the greatest common divisor, never zero\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+if (Math.abs(u) <= 1 || Math.abs(v) == 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-22/src/main/java/org/apache/commons/lang3/math/Fraction.java\t2022-07-19 00:16:01.824538241 +0200\n+++ /tmp/tmpjlsty116.java\t2022-07-19 00:16:01.828538227 +0200\n@@ -579,11 +579,11 @@\n      * @return the greatest common divisor, never zero\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (Math.abs(u) < 1 || Math.abs(v) < 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-22/src/main/java/org/apache/commons/lang3/math/Fraction.java\t2022-07-19 00:16:11.364507623 +0200\n+++ /tmp/tmpcsr8nlbs.java\t2022-07-19 00:16:11.380507572 +0200\n@@ -579,11 +579,11 @@\n      * @return the greatest common divisor, never zero\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+if (Math.abs(u) < 1 || Math.abs(v) < 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (Math.abs(u) <= 0 || Math.abs(v) < 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-22/src/main/java/org/apache/commons/lang3/math/Fraction.java\t2022-07-19 00:16:20.968476322 +0200\n+++ /tmp/tmp838218mj.java\t2022-07-19 00:16:20.968476322 +0200\n@@ -579,11 +579,11 @@\n      * @return the greatest common divisor, never zero\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+if (Math.abs(u) <= 0 || Math.abs(v) < 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (Math.abs(u) <= 0 && Math.abs(v) <= 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-22/src/main/java/org/apache/commons/lang3/math/Fraction.java\t2022-07-19 00:16:30.540444652 +0200\n+++ /tmp/tmpdx2mssxe.java\t2022-07-19 00:16:30.544444640 +0200\n@@ -579,11 +579,11 @@\n      * @return the greatest common divisor, never zero\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+if (Math.abs(u) <= 0 && Math.abs(v) <= 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 9,
                "patch": "if (Math.abs(u) <= 1 || Math.abs(v) < 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-22/src/main/java/org/apache/commons/lang3/math/Fraction.java\t2022-07-19 00:16:39.972412997 +0200\n+++ /tmp/tmpjo7pxoix.java\t2022-07-19 00:16:39.988412942 +0200\n@@ -579,11 +579,11 @@\n      * @return the greatest common divisor, never zero\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+if (Math.abs(u) <= 1 || Math.abs(v) < 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (Math.abs(u) <= 0 || Math.abs(v) == 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-22/src/main/java/org/apache/commons/lang3/math/Fraction.java\t2022-07-19 00:16:49.516380513 +0200\n+++ /tmp/tmp6mqwxpau.java\t2022-07-19 00:16:49.516380513 +0200\n@@ -579,11 +579,11 @@\n      * @return the greatest common divisor, never zero\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+if (Math.abs(u) <= 0 || Math.abs(v) == 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {",
        "fixed_line": "if ((u == 0) || (v == 0)) { if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) { throw new ArithmeticException(\"overflow: gcd is 2^31\"); } return Math.abs(u) + Math.abs(v); } //if either operand is abs 1, return 1: if (Math.abs(u) == 1 || Math.abs(v) == 1) {"
    },
    "Closure-69": {
        "fixes": [
            {
                "k": 1,
                "patch": "// Functions with explcit, n, CONSTRUCTOR_NOT_CALLABLE, childType.getReturnType());",
                "patch_diff": "// Functions with explcit, n, CONSTRUCTOR_NOT_CALLABLE, childType.getReturnType());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// Functions with explcit, n, CONSTRUCTOR_NOT_CALLABLE, childType.getReturnType()); }",
                "patch_diff": "// Functions with explcit, n, CONSTRUCTOR_NOT_CALLABLE, childType.getReturnType()); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// Functions with explcit, n, CONSTRUCTOR_NOT_CALLABLE, childType.getReturnType()); ensureTyped(t, n, functionType);",
                "patch_diff": "// Functions with explcit, n, CONSTRUCTOR_NOT_CALLABLE, childType.getReturnType()); ensureTyped(t, n, functionType);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// Functions with explcit, n, CONSTRUCTOR_NOT_CALLABLE, childType.getReturnType()); } else {",
                "patch_diff": "// Functions with explcit, n, CONSTRUCTOR_NOT_CALLABLE, childType.getReturnType()); } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// Functions with explcitChild(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.getReturnType());",
                "patch_diff": "// Functions with explcitChild(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.getReturnType());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// Functions with explcit, n, CONSTRUCTOR_NOT_CALLABLE, childType.getReturnType()); ensureTyped(t, n);",
                "patch_diff": "// Functions with explcit, n, CONSTRUCTOR_NOT_CALLABLE, childType.getReturnType()); ensureTyped(t, n);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// Functions with explcit, n, CONSTRUCTOR_NOT_CALLABLE, childType.getReturnType()); return;",
                "patch_diff": "// Functions with explcit, n, CONSTRUCTOR_NOT_CALLABLE, childType.getReturnType()); return;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// Functions with explcit, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());",
                "patch_diff": "// Functions with explcit, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// Functions with explcit, n, CONSTRUCTOR_NOT_CALLABLE, childType);",
                "patch_diff": "// Functions with explcit, n, CONSTRUCTOR_NOT_CALLABLE, childType);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// Functions with explcitChild(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.getReturnType()); ensureTyped(t, n, functionType);",
                "patch_diff": "// Functions with explcitChild(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.getReturnType()); ensureTyped(t, n, functionType);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (functionType.isOrdinaryFunction() && !functionType.getTypeOfThis().isUnknownType() && !functionType.getTypeOfThis().isNativeObjectType() && !(child.getType() == Token.GETELEM || child.getType() == Token.GETPROP)) { report(t, n, EXPECTED_THIS_TYPE, functionType.toString()); }"
    },
    "Jsoup-6": {
        "fixes": [
            {
                "k": 1,
                "patch": "m.appendReplacement(accum, c); } else { m.appendReplacement(accum, m.group(0));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-6/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 00:17:01.072340593 +0200\n+++ /tmp/tmpfbb3kwa4.java\t2022-07-19 00:17:01.120340426 +0200\n@@ -65,13 +65,11 @@\n                     charval = full.get(name);\n             }\n \n             if (charval != -1 || charval > 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, c);\n-            } else {\n-                m.appendReplacement(accum, m.group(0));\n+m.appendReplacement(accum, c); } else { m.appendReplacement(accum, m.group(0));\n             }\n         }\n         m.appendTail(accum);\n         return accum.toString();\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "m.appendReplacement(accum, c); } else {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-6/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 00:17:04.568328389 +0200\n+++ /tmp/tmpy3etbtj1.java\t2022-07-19 00:17:04.592328305 +0200\n@@ -65,13 +65,11 @@\n                     charval = full.get(name);\n             }\n \n             if (charval != -1 || charval > 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, c);\n-            } else {\n-                m.appendReplacement(accum, m.group(0));\n+m.appendReplacement(accum, c); } else {\n             }\n         }\n         m.appendTail(accum);\n         return accum.toString();\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "m.appendReplacement(accum, c); } else if (m.appendReplacement(accum, m.group(0));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-6/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 00:17:07.452318280 +0200\n+++ /tmp/tmpqxip6t09.java\t2022-07-19 00:17:07.456318265 +0200\n@@ -65,13 +65,11 @@\n                     charval = full.get(name);\n             }\n \n             if (charval != -1 || charval > 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, c);\n-            } else {\n-                m.appendReplacement(accum, m.group(0));\n+m.appendReplacement(accum, c); } else if (m.appendReplacement(accum, m.group(0));\n             }\n         }\n         m.appendTail(accum);\n         return accum.toString();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "m.appendReplacement(accum, c); } else { m.appendReplacement(c, m.group(0));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-6/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 00:17:08.956312992 +0200\n+++ /tmp/tmpe7lgmvl5.java\t2022-07-19 00:17:08.960312978 +0200\n@@ -65,13 +65,11 @@\n                     charval = full.get(name);\n             }\n \n             if (charval != -1 || charval > 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, c);\n-            } else {\n-                m.appendReplacement(accum, m.group(0));\n+m.appendReplacement(accum, c); } else { m.appendReplacement(c, m.group(0));\n             }\n         }\n         m.appendTail(accum);\n         return accum.toString();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "m.appendReplacement(accum, c); } else { if (m.appendReplacement(accum, m.group(0));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-6/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 00:17:10.724306762 +0200\n+++ /tmp/tmpbfh9b8nc.java\t2022-07-19 00:17:10.728306748 +0200\n@@ -65,13 +65,11 @@\n                     charval = full.get(name);\n             }\n \n             if (charval != -1 || charval > 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, c);\n-            } else {\n-                m.appendReplacement(accum, m.group(0));\n+m.appendReplacement(accum, c); } else { if (m.appendReplacement(accum, m.group(0));\n             }\n         }\n         m.appendTail(accum);\n         return accum.toString();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "m.appendReplacement(accum, c); else { m.appendReplacement(accum, m.group(0));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-6/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 00:17:12.216301492 +0200\n+++ /tmp/tmpdvcn_dv0.java\t2022-07-19 00:17:12.220301478 +0200\n@@ -65,13 +65,11 @@\n                     charval = full.get(name);\n             }\n \n             if (charval != -1 || charval > 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, c);\n-            } else {\n-                m.appendReplacement(accum, m.group(0));\n+m.appendReplacement(accum, c); else { m.appendReplacement(accum, m.group(0));\n             }\n         }\n         m.appendTail(accum);\n         return accum.toString();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "m.appendReplacement(accum, x); } else { m.appendReplacement(accum, m.group(0));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-6/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 00:17:13.820295817 +0200\n+++ /tmp/tmpcpif84zt.java\t2022-07-19 00:17:13.824295803 +0200\n@@ -65,13 +65,11 @@\n                     charval = full.get(name);\n             }\n \n             if (charval != -1 || charval > 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, c);\n-            } else {\n-                m.appendReplacement(accum, m.group(0));\n+m.appendReplacement(accum, x); } else { m.appendReplacement(accum, m.group(0));\n             }\n         }\n         m.appendTail(accum);\n         return accum.toString();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "m.appendReplacement(accum, c); } else { m.appendReplacement(get, m.group(0));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-6/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 00:17:15.568289618 +0200\n+++ /tmp/tmp7cbftnjw.java\t2022-07-19 00:17:15.568289618 +0200\n@@ -65,13 +65,11 @@\n                     charval = full.get(name);\n             }\n \n             if (charval != -1 || charval > 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, c);\n-            } else {\n-                m.appendReplacement(accum, m.group(0));\n+m.appendReplacement(accum, c); } else { m.appendReplacement(get, m.group(0));\n             }\n         }\n         m.appendTail(accum);\n         return accum.toString();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "m.appendReplacement(accum, c); } else { m.appendReplacement(base, m.group(0));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-6/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 00:17:17.420283036 +0200\n+++ /tmp/tmp5k7hmdwy.java\t2022-07-19 00:17:17.420283036 +0200\n@@ -65,13 +65,11 @@\n                     charval = full.get(name);\n             }\n \n             if (charval != -1 || charval > 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, c);\n-            } else {\n-                m.appendReplacement(accum, m.group(0));\n+m.appendReplacement(accum, c); } else { m.appendReplacement(base, m.group(0));\n             }\n         }\n         m.appendTail(accum);\n         return accum.toString();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "m.appendReplacement(accum, c); } else { m.appendReplacement(accum, m.double(0));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-6/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 00:17:19.220276622 +0200\n+++ /tmp/tmpmvp2s8cj.java\t2022-07-19 00:17:19.220276622 +0200\n@@ -65,13 +65,11 @@\n                     charval = full.get(name);\n             }\n \n             if (charval != -1 || charval > 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, c);\n-            } else {\n-                m.appendReplacement(accum, m.group(0));\n+m.appendReplacement(accum, c); } else { m.appendReplacement(accum, m.double(0));\n             }\n         }\n         m.appendTail(accum);\n         return accum.toString();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "m.appendReplacement(accum, c); } else { m.appendReplacement(accum, m.group(0));",
        "fixed_line": "m.appendReplacement(accum, Matcher.quoteReplacement(c)); } else { m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); // replace with original string"
    },
    "Math-101": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (startIndex < 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-101/src/java/org/apache/commons/math/complex/ComplexFormat.java\t2022-07-19 00:17:20.876270710 +0200\n+++ /tmp/tmpyzarnzch.java\t2022-07-19 00:17:20.988270310 +0200\n@@ -372,11 +372,11 @@\n \n         // parse imaginary character\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+if (startIndex < 0) {\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n             // character examined.\n             pos.setIndex(initialIndex);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (endIndex < 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-101/src/java/org/apache/commons/math/complex/ComplexFormat.java\t2022-07-19 00:17:24.100259162 +0200\n+++ /tmp/tmp22rmfrbr.java\t2022-07-19 00:17:24.100259162 +0200\n@@ -372,11 +372,11 @@\n \n         // parse imaginary character\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+if (endIndex < 0) {\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n             // character examined.\n             pos.setIndex(initialIndex);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (startIndex < 0) { // end period is not in the source",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-101/src/java/org/apache/commons/math/complex/ComplexFormat.java\t2022-07-19 00:17:27.268247770 +0200\n+++ /tmp/tmprxpi6z1r.java\t2022-07-19 00:17:27.268247770 +0200\n@@ -372,11 +372,11 @@\n \n         // parse imaginary character\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+if (startIndex < 0) { // end period is not in the source\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n             // character examined.\n             pos.setIndex(initialIndex);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (startIndex < 0) { // end period is not in original series",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-101/src/java/org/apache/commons/math/complex/ComplexFormat.java\t2022-07-19 00:17:30.464236230 +0200\n+++ /tmp/tmp19p6riyu.java\t2022-07-19 00:17:30.464236230 +0200\n@@ -372,11 +372,11 @@\n \n         // parse imaginary character\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+if (startIndex < 0) { // end period is not in original series\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n             // character examined.\n             pos.setIndex(initialIndex);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (startIndex < 0) { // end period is not in the",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-101/src/java/org/apache/commons/math/complex/ComplexFormat.java\t2022-07-19 00:17:33.608224832 +0200\n+++ /tmp/tmp5ljkiyib.java\t2022-07-19 00:17:33.608224832 +0200\n@@ -372,11 +372,11 @@\n \n         // parse imaginary character\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+if (startIndex < 0) { // end period is not in the\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n             // character examined.\n             pos.setIndex(initialIndex);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (endIndex < 0) { // end period is negative",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-101/src/java/org/apache/commons/math/complex/ComplexFormat.java\t2022-07-19 00:17:36.656213742 +0200\n+++ /tmp/tmpokeb045g.java\t2022-07-19 00:17:36.656213742 +0200\n@@ -372,11 +372,11 @@\n \n         // parse imaginary character\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+if (endIndex < 0) { // end period is negative\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n             // character examined.\n             pos.setIndex(initialIndex);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (startIndex < 0) { // end period is not in the end",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-101/src/java/org/apache/commons/math/complex/ComplexFormat.java\t2022-07-19 00:17:39.672202727 +0200\n+++ /tmp/tmpv2op8bzv.java\t2022-07-19 00:17:39.672202727 +0200\n@@ -372,11 +372,11 @@\n \n         // parse imaginary character\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+if (startIndex < 0) { // end period is not in the end\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n             // character examined.\n             pos.setIndex(initialIndex);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (endIndex < 0) { // start is not in the end",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-101/src/java/org/apache/commons/math/complex/ComplexFormat.java\t2022-07-19 00:17:42.740191480 +0200\n+++ /tmp/tmp82w7fs6e.java\t2022-07-19 00:17:42.740191480 +0200\n@@ -372,11 +372,11 @@\n \n         // parse imaginary character\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+if (endIndex < 0) { // start is not in the end\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n             // character examined.\n             pos.setIndex(initialIndex);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (endIndex < 0) { // start is not in the source",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-101/src/java/org/apache/commons/math/complex/ComplexFormat.java\t2022-07-19 00:17:45.800180226 +0200\n+++ /tmp/tmp4yeblh9f.java\t2022-07-19 00:17:45.800180226 +0200\n@@ -372,11 +372,11 @@\n \n         // parse imaginary character\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+if (endIndex < 0) { // start is not in the source\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n             // character examined.\n             pos.setIndex(initialIndex);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (startIndex < 0) { // end period is not in the start",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-101/src/java/org/apache/commons/math/complex/ComplexFormat.java\t2022-07-19 00:17:48.812169103 +0200\n+++ /tmp/tmp09hkqmmh.java\t2022-07-19 00:17:48.812169103 +0200\n@@ -372,11 +372,11 @@\n \n         // parse imaginary character\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+if (startIndex < 0) { // end period is not in the start\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n             // character examined.\n             pos.setIndex(initialIndex);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (",
        "fixed_line": "if ((startIndex >= source.length()) || (endIndex > source.length()) ||"
    },
    "Chart-10": {
        "fixes": [
            {
                "k": 1,
                "patch": "return \" title=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\";",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-10/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\t2022-07-19 00:17:51.980157364 +0200\n+++ /tmp/tmp0d8iys7i.java\t2022-07-19 00:17:52.004157277 +0200\n@@ -60,10 +60,10 @@\n      * @param toolTipText  the tooltip.\n      * \n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + toolTipText\n+return \" title=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\";\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return \" title=\\\"\" + toolTipText;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-10/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\t2022-07-19 00:17:53.608151315 +0200\n+++ /tmp/tmp9pp6rwm9.java\t2022-07-19 00:17:53.612151301 +0200\n@@ -60,10 +60,10 @@\n      * @param toolTipText  the tooltip.\n      * \n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + toolTipText\n+return \" title=\\\"\" + toolTipText;\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return \" title=\\\"\" + toolTipText);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-10/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\t2022-07-19 00:17:55.124145671 +0200\n+++ /tmp/tmp5tzcyjv_.java\t2022-07-19 00:17:55.124145671 +0200\n@@ -60,10 +60,10 @@\n      * @param toolTipText  the tooltip.\n      * \n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + toolTipText\n+return \" title=\\\"\" + toolTipText);\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return \" title=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\"; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-10/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\t2022-07-19 00:17:56.768139540 +0200\n+++ /tmp/tmpgpplbrzq.java\t2022-07-19 00:17:56.768139540 +0200\n@@ -60,10 +60,10 @@\n      * @param toolTipText  the tooltip.\n      * \n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + toolTipText\n+return \" title=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\"; }\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return \" title=\\\"\" + toolTipText",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-10/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\t2022-07-19 00:17:58.384133504 +0200\n+++ /tmp/tmp15mlsqa7.java\t2022-07-19 00:17:58.384133504 +0200\n@@ -60,10 +60,10 @@\n      * @param toolTipText  the tooltip.\n      * \n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + toolTipText\n+return \" title=\\\"\" + toolTipText\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return \" title=\\\"\" + toolTipText, urlText);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-10/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\t2022-07-19 00:18:07.188100417 +0200\n+++ /tmp/tmpodywpk0i.java\t2022-07-19 00:18:07.188100417 +0200\n@@ -60,10 +60,10 @@\n      * @param toolTipText  the tooltip.\n      * \n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + toolTipText\n+return \" title=\\\"\" + toolTipText, urlText);\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return \" title=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\"; } else {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-10/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\t2022-07-19 00:18:08.776094415 +0200\n+++ /tmp/tmpqn_znh3f.java\t2022-07-19 00:18:08.776094415 +0200\n@@ -60,10 +60,10 @@\n      * @param toolTipText  the tooltip.\n      * \n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + toolTipText\n+return \" title=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\"; } else {\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return \" title=\\\"\" + toolTipText() + \"\\\" alt=\\\"\\\"\";",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-10/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\t2022-07-19 00:18:10.368088384 +0200\n+++ /tmp/tmptyi4cjpw.java\t2022-07-19 00:18:10.368088384 +0200\n@@ -60,10 +60,10 @@\n      * @param toolTipText  the tooltip.\n      * \n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + toolTipText\n+return \" title=\\\"\" + toolTipText() + \"\\\" alt=\\\"\\\"\";\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return \" title=\\\"\" + toolTipText = \" + toolTipText + \"\\\" alt=\\\"\\\"\";",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-10/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\t2022-07-19 00:18:11.936082437 +0200\n+++ /tmp/tmp08kak2_h.java\t2022-07-19 00:18:11.940082424 +0200\n@@ -60,10 +60,10 @@\n      * @param toolTipText  the tooltip.\n      * \n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + toolTipText\n+return \" title=\\\"\" + toolTipText = \" + toolTipText + \"\\\" alt=\\\"\\\"\";\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return \" title=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\"; } }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-10/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\t2022-07-19 00:18:13.520076420 +0200\n+++ /tmp/tmpst5id1fv.java\t2022-07-19 00:18:13.520076420 +0200\n@@ -60,10 +60,10 @@\n      * @param toolTipText  the tooltip.\n      * \n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + toolTipText\n+return \" title=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\"; } }\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return \" title=\\\"\" + toolTipText",
        "fixed_line": "return \" title=\\\"\" + ImageMapUtilities.htmlEscape(toolTipText)"
    },
    "JacksonDatabind-41": {
        "fixes": [
            {
                "k": 1,
                "patch": "return constructType(type, constructType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-41/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 00:18:15.340069492 +0200\n+++ /tmp/tmpi_r0jp_c.java\t2022-07-19 00:18:15.372069370 +0200\n@@ -597,19 +597,11 @@\n     /**\n      * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n      */\n     @Deprecated\n     public JavaType constructType(Type type, Class<?> contextClass) {\n-        return constructType(type, constructType(contextClass));\n-    }\n-\n-    /**\n-     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n-     */\n-    @Deprecated\n-    public JavaType constructType(Type type, JavaType contextType) {\n-        return _fromAny(null, type, contextType.getBindings());\n+return constructType(type, constructType);\n     }\n \n     /*\n     /**********************************************************\n     /* Direct factory methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return constructType(type, constructType(contextClass));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-41/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 00:18:17.252062199 +0200\n+++ /tmp/tmpx4i7fr2x.java\t2022-07-19 00:18:17.256062182 +0200\n@@ -597,19 +597,11 @@\n     /**\n      * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n      */\n     @Deprecated\n     public JavaType constructType(Type type, Class<?> contextClass) {\n-        return constructType(type, constructType(contextClass));\n-    }\n-\n-    /**\n-     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n-     */\n-    @Deprecated\n-    public JavaType constructType(Type type, JavaType contextType) {\n-        return _fromAny(null, type, contextType.getBindings());\n+return constructType(type, constructType(contextClass));\n     }\n \n     /*\n     /**********************************************************\n     /* Direct factory methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return constructType(type, constructType); } catch (accidentally removed in 2.7.0Type.getBindings());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-41/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 00:18:19.016055457 +0200\n+++ /tmp/tmpw0zcaefc.java\t2022-07-19 00:18:19.016055457 +0200\n@@ -597,19 +597,11 @@\n     /**\n      * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n      */\n     @Deprecated\n     public JavaType constructType(Type type, Class<?> contextClass) {\n-        return constructType(type, constructType(contextClass));\n-    }\n-\n-    /**\n-     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n-     */\n-    @Deprecated\n-    public JavaType constructType(Type type, JavaType contextType) {\n-        return _fromAny(null, type, contextType.getBindings());\n+return constructType(type, constructType); } catch (accidentally removed in 2.7.0Type.getBindings());\n     }\n \n     /*\n     /**********************************************************\n     /* Direct factory methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return constructType(type, constructType(contextClass)); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-41/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 00:18:20.612049346 +0200\n+++ /tmp/tmpyoamvi3z.java\t2022-07-19 00:18:20.616049330 +0200\n@@ -597,19 +597,11 @@\n     /**\n      * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n      */\n     @Deprecated\n     public JavaType constructType(Type type, Class<?> contextClass) {\n-        return constructType(type, constructType(contextClass));\n-    }\n-\n-    /**\n-     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n-     */\n-    @Deprecated\n-    public JavaType constructType(Type type, JavaType contextType) {\n-        return _fromAny(null, type, contextType.getBindings());\n+return constructType(type, constructType(contextClass)); }\n     }\n \n     /*\n     /**********************************************************\n     /* Direct factory methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return constructType(type, constructType)); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-41/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 00:18:22.220043179 +0200\n+++ /tmp/tmpo8z7kdkk.java\t2022-07-19 00:18:22.220043179 +0200\n@@ -597,19 +597,11 @@\n     /**\n      * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n      */\n     @Deprecated\n     public JavaType constructType(Type type, Class<?> contextClass) {\n-        return constructType(type, constructType(contextClass));\n-    }\n-\n-    /**\n-     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n-     */\n-    @Deprecated\n-    public JavaType constructType(Type type, JavaType contextType) {\n-        return _fromAny(null, type, contextType.getBindings());\n+return constructType(type, constructType)); }\n     }\n \n     /*\n     /**********************************************************\n     /* Direct factory methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return constructType(type, constructType));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-41/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 00:18:23.868036846 +0200\n+++ /tmp/tmpync5t7q3.java\t2022-07-19 00:18:23.868036846 +0200\n@@ -597,19 +597,11 @@\n     /**\n      * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n      */\n     @Deprecated\n     public JavaType constructType(Type type, Class<?> contextClass) {\n-        return constructType(type, constructType(contextClass));\n-    }\n-\n-    /**\n-     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n-     */\n-    @Deprecated\n-    public JavaType constructType(Type type, JavaType contextType) {\n-        return _fromAny(null, type, contextType.getBindings());\n+return constructType(type, constructType));\n     }\n \n     /*\n     /**********************************************************\n     /* Direct factory methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return constructType(type, constructType); } else if (accidentally removed in 2.7.0Type.getBindings());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-41/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 00:18:25.500030567 +0200\n+++ /tmp/tmpyovluf7x.java\t2022-07-19 00:18:25.504030551 +0200\n@@ -597,19 +597,11 @@\n     /**\n      * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n      */\n     @Deprecated\n     public JavaType constructType(Type type, Class<?> contextClass) {\n-        return constructType(type, constructType(contextClass));\n-    }\n-\n-    /**\n-     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n-     */\n-    @Deprecated\n-    public JavaType constructType(Type type, JavaType contextType) {\n-        return _fromAny(null, type, contextType.getBindings());\n+return constructType(type, constructType); } else if (accidentally removed in 2.7.0Type.getBindings());\n     }\n \n     /*\n     /**********************************************************\n     /* Direct factory methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return constructType(type, constructType(contextClass)); } else if (type.getBindings());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-41/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 00:18:27.128024289 +0200\n+++ /tmp/tmpole5xmqt.java\t2022-07-19 00:18:27.128024289 +0200\n@@ -597,19 +597,11 @@\n     /**\n      * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n      */\n     @Deprecated\n     public JavaType constructType(Type type, Class<?> contextClass) {\n-        return constructType(type, constructType(contextClass));\n-    }\n-\n-    /**\n-     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n-     */\n-    @Deprecated\n-    public JavaType constructType(Type type, JavaType contextType) {\n-        return _fromAny(null, type, contextType.getBindings());\n+return constructType(type, constructType(contextClass)); } else if (type.getBindings());\n     }\n \n     /*\n     /**********************************************************\n     /* Direct factory methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return constructType(type, constructType); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-41/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 00:18:28.740018066 +0200\n+++ /tmp/tmppp3ozvgh.java\t2022-07-19 00:18:28.740018066 +0200\n@@ -597,19 +597,11 @@\n     /**\n      * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n      */\n     @Deprecated\n     public JavaType constructType(Type type, Class<?> contextClass) {\n-        return constructType(type, constructType(contextClass));\n-    }\n-\n-    /**\n-     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n-     */\n-    @Deprecated\n-    public JavaType constructType(Type type, JavaType contextType) {\n-        return _fromAny(null, type, contextType.getBindings());\n+return constructType(type, constructType); }\n     }\n \n     /*\n     /**********************************************************\n     /* Direct factory methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return constructType(type, constructType(contextClass)); } catch (accidentally removed in 2.7.0Type.getBindings());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-41/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 00:18:30.352011829 +0200\n+++ /tmp/tmpskzmkp_z.java\t2022-07-19 00:18:30.352011829 +0200\n@@ -597,19 +597,11 @@\n     /**\n      * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n      */\n     @Deprecated\n     public JavaType constructType(Type type, Class<?> contextClass) {\n-        return constructType(type, constructType(contextClass));\n-    }\n-\n-    /**\n-     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n-     */\n-    @Deprecated\n-    public JavaType constructType(Type type, JavaType contextType) {\n-        return _fromAny(null, type, contextType.getBindings());\n+return constructType(type, constructType(contextClass)); } catch (accidentally removed in 2.7.0Type.getBindings());\n     }\n \n     /*\n     /**********************************************************\n     /* Direct factory methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return constructType(type, constructType(contextClass)); } /** * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1) */ @Deprecated public JavaType constructType(Type type, JavaType contextType) { return _fromAny(null, type, contextType.getBindings());",
        "fixed_line": "TypeBindings bindings = (contextClass == null) ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings(); return _fromAny(null, type, bindings); } /** * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1) */ @Deprecated public JavaType constructType(Type type, JavaType contextType) { TypeBindings bindings = (contextType == null) ? TypeBindings.emptyBindings() : contextType.getBindings(); return _fromAny(null, type, bindings);"
    },
    "Closure-61": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&",
                "patch_diff": "if (nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (nameNode.getFirstChild().getType()!= Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&",
                "patch_diff": "if (nameNode.getFirstChild().getType()!= Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&",
                "patch_diff": "if (nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (n.getFirstChild().getType()!= Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&",
                "patch_diff": "if (n.getFirstChild().getType()!= Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP && // no property nameNode.getFirstChild().getType() == Token.REGEXP &&",
                "patch_diff": "if (nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP && // no property nameNode.getFirstChild().getType() == Token.REGEXP &&",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (nameNode.getFirstP &&!compiler.getFirstChild().getType() == Token.REGEXP &&",
                "patch_diff": "if (nameNode.getFirstP &&!compiler.getFirstChild().getType() == Token.REGEXP &&",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getString()) {",
                "patch_diff": "if (nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getString()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP && // no property nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&",
                "patch_diff": "if (nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP && // no property nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP && // nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&",
                "patch_diff": "if (nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP && // nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (n.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&",
                "patch_diff": "if (n.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (nameNode.getFirstChild().getType() == Token.NAME) { String namespaceName = nameNode.getFirstChild().getString(); if (namespaceName.equals(\"Math\")) { return false; } }"
    },
    "Cli-27": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (selected == null || selected.equals(option.getOpt())) { selected = option.getOpt();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-27/src/java/org/apache/commons/cli/OptionGroup.java\t2022-07-19 00:18:34.099997295 +0200\n+++ /tmp/tmpn7qu5p47.java\t2022-07-19 00:18:34.163997045 +0200\n@@ -93,13 +93,11 @@\n         }\n         \n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if (selected == null || selected.equals(option.getOpt()))\n-        {\n-            selected = option.getOpt();\n+if (selected == null || selected.equals(option.getOpt())) { selected = option.getOpt();\n         }\n         else\n         {\n             throw new AlreadySelectedException(this, option);\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (selected == null || selected.equals(option.getOpt())) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-27/src/java/org/apache/commons/cli/OptionGroup.java\t2022-07-19 00:18:36.603987550 +0200\n+++ /tmp/tmpbr_46nmk.java\t2022-07-19 00:18:36.603987550 +0200\n@@ -93,13 +93,11 @@\n         }\n         \n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if (selected == null || selected.equals(option.getOpt()))\n-        {\n-            selected = option.getOpt();\n+if (selected == null || selected.equals(option.getOpt())) {\n         }\n         else\n         {\n             throw new AlreadySelectedException(this, option);\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (selected == null ||selected.equals(option.getOpt())) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-27/src/java/org/apache/commons/cli/OptionGroup.java\t2022-07-19 00:18:39.015978142 +0200\n+++ /tmp/tmpyhhm_z4v.java\t2022-07-19 00:18:39.015978142 +0200\n@@ -93,13 +93,11 @@\n         }\n         \n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if (selected == null || selected.equals(option.getOpt()))\n-        {\n-            selected = option.getOpt();\n+if (selected == null ||selected.equals(option.getOpt())) {\n         }\n         else\n         {\n             throw new AlreadySelectedException(this, option);\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (this.selected == null || selected.equals(option.getOpt())) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-27/src/java/org/apache/commons/cli/OptionGroup.java\t2022-07-19 00:18:41.415968758 +0200\n+++ /tmp/tmpmtojwln7.java\t2022-07-19 00:18:41.415968758 +0200\n@@ -93,13 +93,11 @@\n         }\n         \n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if (selected == null || selected.equals(option.getOpt()))\n-        {\n-            selected = option.getOpt();\n+if (this.selected == null || selected.equals(option.getOpt())) {\n         }\n         else\n         {\n             throw new AlreadySelectedException(this, option);\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (this.selected == null || selected.equals(option.getOpt())) { selected = option.getOpt();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-27/src/java/org/apache/commons/cli/OptionGroup.java\t2022-07-19 00:18:43.763959555 +0200\n+++ /tmp/tmpnjci9y60.java\t2022-07-19 00:18:43.763959555 +0200\n@@ -93,13 +93,11 @@\n         }\n         \n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if (selected == null || selected.equals(option.getOpt()))\n-        {\n-            selected = option.getOpt();\n+if (this.selected == null || selected.equals(option.getOpt())) { selected = option.getOpt();\n         }\n         else\n         {\n             throw new AlreadySelectedException(this, option);\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (selected == null ||selected.equals(option.getOpt())) { selected = option.getOpt();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-27/src/java/org/apache/commons/cli/OptionGroup.java\t2022-07-19 00:18:46.087950425 +0200\n+++ /tmp/tmpqhjb6w2u.java\t2022-07-19 00:18:46.087950425 +0200\n@@ -93,13 +93,11 @@\n         }\n         \n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if (selected == null || selected.equals(option.getOpt()))\n-        {\n-            selected = option.getOpt();\n+if (selected == null ||selected.equals(option.getOpt())) { selected = option.getOpt();\n         }\n         else\n         {\n             throw new AlreadySelectedException(this, option);\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if(selected == null || selected.equals(option.getOpt())) { selected = option.getOpt();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-27/src/java/org/apache/commons/cli/OptionGroup.java\t2022-07-19 00:18:48.523940833 +0200\n+++ /tmp/tmp7w030tw6.java\t2022-07-19 00:18:48.523940833 +0200\n@@ -93,13 +93,11 @@\n         }\n         \n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if (selected == null || selected.equals(option.getOpt()))\n-        {\n-            selected = option.getOpt();\n+if(selected == null || selected.equals(option.getOpt())) { selected = option.getOpt();\n         }\n         else\n         {\n             throw new AlreadySelectedException(this, option);\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (this.selected == null ||selected.equals(option.getOpt())) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-27/src/java/org/apache/commons/cli/OptionGroup.java\t2022-07-19 00:18:50.915931392 +0200\n+++ /tmp/tmp_6cs36j5.java\t2022-07-19 00:18:50.915931392 +0200\n@@ -93,13 +93,11 @@\n         }\n         \n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if (selected == null || selected.equals(option.getOpt()))\n-        {\n-            selected = option.getOpt();\n+if (this.selected == null ||selected.equals(option.getOpt())) {\n         }\n         else\n         {\n             throw new AlreadySelectedException(this, option);\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (selected == null || selected.equals(option.getOpt())) {selected = option.getOpt();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-27/src/java/org/apache/commons/cli/OptionGroup.java\t2022-07-19 00:18:53.259922119 +0200\n+++ /tmp/tmprd1d7rkb.java\t2022-07-19 00:18:53.259922119 +0200\n@@ -93,13 +93,11 @@\n         }\n         \n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if (selected == null || selected.equals(option.getOpt()))\n-        {\n-            selected = option.getOpt();\n+if (selected == null || selected.equals(option.getOpt())) {selected = option.getOpt();\n         }\n         else\n         {\n             throw new AlreadySelectedException(this, option);\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (selected == null && selected.equals(option.getOpt())) { selected = option.getOpt();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-27/src/java/org/apache/commons/cli/OptionGroup.java\t2022-07-19 00:18:55.507913205 +0200\n+++ /tmp/tmpu5q0nx_c.java\t2022-07-19 00:18:55.511913189 +0200\n@@ -93,13 +93,11 @@\n         }\n         \n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if (selected == null || selected.equals(option.getOpt()))\n-        {\n-            selected = option.getOpt();\n+if (selected == null && selected.equals(option.getOpt())) { selected = option.getOpt();\n         }\n         else\n         {\n             throw new AlreadySelectedException(this, option);\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (selected == null || selected.equals(option.getOpt())) { selected = option.getOpt();",
        "fixed_line": "if (selected == null || selected.equals(option.getKey())) { selected = option.getKey();"
    },
    "Closure-101": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (flags.process_closure_primitives) { options.closurePass = true; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-101/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 00:18:57.967903428 +0200\n+++ /tmp/tmp0lhqnvjm.java\t2022-07-19 00:18:57.991903333 +0200\n@@ -428,13 +428,11 @@\n     WarningLevel wLevel = flags.warning_level;\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n-    }\n+if (flags.process_closure_primitives) { options.closurePass = true; }\n \n     initOptionsFromFlags(options);\n     return options;\n   }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (flags.process_closure_primitives) { options.closurePass = false; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-101/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 00:19:16.739828088 +0200\n+++ /tmp/tmpaq0blq5p.java\t2022-07-19 00:19:16.739828088 +0200\n@@ -428,13 +428,11 @@\n     WarningLevel wLevel = flags.warning_level;\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n-    }\n+if (flags.process_closure_primitives) { options.closurePass = false; }\n \n     initOptionsFromFlags(options);\n     return options;\n   }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (options.process_closure_primitives) { options.closurePass = true; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-101/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 00:19:35.659750858 +0200\n+++ /tmp/tmpe6fh7p1t.java\t2022-07-19 00:19:35.663750839 +0200\n@@ -428,13 +428,11 @@\n     WarningLevel wLevel = flags.warning_level;\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n-    }\n+if (options.process_closure_primitives) { options.closurePass = true; }\n \n     initOptionsFromFlags(options);\n     return options;\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (options.process_closure_primitives) { options.closurePass = false; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-101/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 00:19:37.423743590 +0200\n+++ /tmp/tmpa5_enyz7.java\t2022-07-19 00:19:37.423743590 +0200\n@@ -428,13 +428,11 @@\n     WarningLevel wLevel = flags.warning_level;\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n-    }\n+if (options.process_closure_primitives) { options.closurePass = false; }\n \n     initOptionsFromFlags(options);\n     return options;\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (options.process_closure_primitives) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-101/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 00:19:39.175736363 +0200\n+++ /tmp/tmpyecd97ag.java\t2022-07-19 00:19:39.175736363 +0200\n@@ -428,13 +428,11 @@\n     WarningLevel wLevel = flags.warning_level;\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n-    }\n+if (options.process_closure_primitives) {\n \n     initOptionsFromFlags(options);\n     return options;\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (flags.process_closure_primitives) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-101/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 00:19:40.735729922 +0200\n+++ /tmp/tmprp0hlbyg.java\t2022-07-19 00:19:40.735729922 +0200\n@@ -428,13 +428,11 @@\n     WarningLevel wLevel = flags.warning_level;\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n-    }\n+if (flags.process_closure_primitives) {\n \n     initOptionsFromFlags(options);\n     return options;\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (flags.process_closure_primitives) { options.closurePass = true; return",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-101/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 00:19:42.271723567 +0200\n+++ /tmp/tmpeyoopc3q.java\t2022-07-19 00:19:42.271723567 +0200\n@@ -428,13 +428,11 @@\n     WarningLevel wLevel = flags.warning_level;\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n-    }\n+if (flags.process_closure_primitives) { options.closurePass = true; return\n \n     initOptionsFromFlags(options);\n     return options;\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (flags.process_closure_primitives) { options.closurePass = false; return",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-101/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 00:19:43.807717205 +0200\n+++ /tmp/tmpfstc56mn.java\t2022-07-19 00:19:43.807717205 +0200\n@@ -428,13 +428,11 @@\n     WarningLevel wLevel = flags.warning_level;\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n-    }\n+if (flags.process_closure_primitives) { options.closurePass = false; return\n \n     initOptionsFromFlags(options);\n     return options;\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (options.process_closure_primitives) { options.closurePass = true; return",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-101/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 00:19:45.295711037 +0200\n+++ /tmp/tmpckielj5t.java\t2022-07-19 00:19:45.295711037 +0200\n@@ -428,13 +428,11 @@\n     WarningLevel wLevel = flags.warning_level;\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n-    }\n+if (options.process_closure_primitives) { options.closurePass = true; return\n \n     initOptionsFromFlags(options);\n     return options;\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (flags.process_closure_primitives) { options.closurePass = true; } else {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-101/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 00:19:46.779704874 +0200\n+++ /tmp/tmprmm7l6ek.java\t2022-07-19 00:19:46.779704874 +0200\n@@ -428,13 +428,11 @@\n     WarningLevel wLevel = flags.warning_level;\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n-    }\n+if (flags.process_closure_primitives) { options.closurePass = true; } else {\n \n     initOptionsFromFlags(options);\n     return options;\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (flags.process_closure_primitives) { options.closurePass = true; }",
        "fixed_line": "options.closurePass = flags.process_closure_primitives;"
    },
    "Closure-59": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (options.checkGlobalThisLevel.isOn()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-59/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 00:19:48.543697542 +0200\n+++ /tmp/tmp1d275z9n.java\t2022-07-19 00:19:48.567697443 +0200\n@@ -250,11 +250,11 @@\n           DiagnosticGroup.forType(\n               RhinoErrorReporter.TYPE_PARSE_ERROR),\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+if (options.checkGlobalThisLevel.isOn()) {\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if(options.checkGlobalThisLevel.isOn()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-59/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 00:20:28.171530058 +0200\n+++ /tmp/tmp9lm6p33n.java\t2022-07-19 00:20:28.175530039 +0200\n@@ -250,11 +250,11 @@\n           DiagnosticGroup.forType(\n               RhinoErrorReporter.TYPE_PARSE_ERROR),\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+if(options.checkGlobalThisLevel.isOn()) {\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (options.checkGlobalThisLevel.isOn()) { // should never be null",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-59/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 00:21:04.487372191 +0200\n+++ /tmp/tmpdm_7u9qw.java\t2022-07-19 00:21:04.487372191 +0200\n@@ -250,11 +250,11 @@\n           DiagnosticGroup.forType(\n               RhinoErrorReporter.TYPE_PARSE_ERROR),\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+if (options.checkGlobalThisLevel.isOn()) { // should never be null\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (options.checkGlobalThisLevel.isOn()) { // empty String means 'default'",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-59/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 00:21:41.451207512 +0200\n+++ /tmp/tmpjcp5zuqs.java\t2022-07-19 00:21:41.451207512 +0200\n@@ -250,11 +250,11 @@\n           DiagnosticGroup.forType(\n               RhinoErrorReporter.TYPE_PARSE_ERROR),\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+if (options.checkGlobalThisLevel.isOn()) { // empty String means 'default'\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (options.checkGlobalThisLevel.isOn()) { // empty String means 'default's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-59/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 00:22:18.395039174 +0200\n+++ /tmp/tmp_rf5bav1.java\t2022-07-19 00:22:18.395039174 +0200\n@@ -250,11 +250,11 @@\n           DiagnosticGroup.forType(\n               RhinoErrorReporter.TYPE_PARSE_ERROR),\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+if (options.checkGlobalThisLevel.isOn()) { // empty String means 'default's do implicit re-parse\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (options.checkGlobalThisLevel.isOn()) { // should never be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-59/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 00:22:54.798869888 +0200\n+++ /tmp/tmpu2z6lqjp.java\t2022-07-19 00:22:54.802869867 +0200\n@@ -250,11 +250,11 @@\n           DiagnosticGroup.forType(\n               RhinoErrorReporter.TYPE_PARSE_ERROR),\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+if (options.checkGlobalThisLevel.isOn()) { // should never be null!\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (options.checkGlobalThisLevel.isOn()) { // should never be null or EMPTY",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-59/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 00:23:31.282697065 +0200\n+++ /tmp/tmpdsytv24e.java\t2022-07-19 00:23:31.282697065 +0200\n@@ -250,11 +250,11 @@\n           DiagnosticGroup.forType(\n               RhinoErrorReporter.TYPE_PARSE_ERROR),\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+if (options.checkGlobalThisLevel.isOn()) { // should never be null or EMPTY\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (options.checkGlobalThisLevel.isOn()) { // should never be null if the type in the",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-59/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 00:24:07.738521426 +0200\n+++ /tmp/tmp9mvft_52.java\t2022-07-19 00:24:07.738521426 +0200\n@@ -250,11 +250,11 @@\n           DiagnosticGroup.forType(\n               RhinoErrorReporter.TYPE_PARSE_ERROR),\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+if (options.checkGlobalThisLevel.isOn()) { // should never be null if the type in the\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (options.checkGlobalThisLevel.isOn()) { // should never be null or empty",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-59/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 00:24:44.278342635 +0200\n+++ /tmp/tmppd4c5fea.java\t2022-07-19 00:24:44.282342615 +0200\n@@ -250,11 +250,11 @@\n           DiagnosticGroup.forType(\n               RhinoErrorReporter.TYPE_PARSE_ERROR),\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+if (options.checkGlobalThisLevel.isOn()) { // should never be null or empty\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (options.checkGlobalThisLevel.equals()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-59/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 00:25:20.370163517 +0200\n+++ /tmp/tmpamlar650.java\t2022-07-19 00:25:20.374163497 +0200\n@@ -250,11 +250,11 @@\n           DiagnosticGroup.forType(\n               RhinoErrorReporter.TYPE_PARSE_ERROR),\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+if (options.checkGlobalThisLevel.equals()) {\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (options.checkGlobalThisLevel.isOn()) {",
        "fixed_line": "if (options.checkGlobalThisLevel.isOn() && !options.disables(DiagnosticGroups.GLOBAL_THIS)) {"
    },
    "Time-4": {
        "fixes": [
            {
                "k": 1,
                "patch": "Partial newPartial = new Partial(iChronology, newTypes, newValues);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-4/src/main/java/org/joda/time/Partial.java\t2022-07-19 00:25:24.146144639 +0200\n+++ /tmp/tmp_8igfjq6.java\t2022-07-19 00:25:24.174144499 +0200\n@@ -459,11 +459,11 @@\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+Partial newPartial = new Partial(iChronology, newTypes, newValues);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n         if (value == getValue(index)) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "Partial newPartial = new Partial(iChronology, newTypes, newValues); // remove the newValues);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-4/src/main/java/org/joda/time/Partial.java\t2022-07-19 00:25:38.886070711 +0200\n+++ /tmp/tmpes329rob.java\t2022-07-19 00:25:38.886070711 +0200\n@@ -459,11 +459,11 @@\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+Partial newPartial = new Partial(iChronology, newTypes, newValues); // remove the newValues);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n         if (value == getValue(index)) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "Partial newPartial = new Partial(iChronology, newTypes, newValues); // remove old items if necessary, newValues);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-4/src/main/java/org/joda/time/Partial.java\t2022-07-19 00:25:50.250013458 +0200\n+++ /tmp/tmp2kxta6d9.java\t2022-07-19 00:25:50.250013458 +0200\n@@ -459,11 +459,11 @@\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+Partial newPartial = new Partial(iChronology, newTypes, newValues); // remove old items if necessary, newValues);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n         if (value == getValue(index)) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "Partial newPartial = new Partial(iChronology, newTypes, newValues); // the newValues);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-4/src/main/java/org/joda/time/Partial.java\t2022-07-19 00:25:59.565966360 +0200\n+++ /tmp/tmphsfr71j8.java\t2022-07-19 00:25:59.565966360 +0200\n@@ -459,11 +459,11 @@\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+Partial newPartial = new Partial(iChronology, newTypes, newValues); // the newValues);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n         if (value == getValue(index)) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "Partial newPartial = new Partial(iChronology, newTypes, newValues); // we need to check whether a newValues);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-4/src/main/java/org/joda/time/Partial.java\t2022-07-19 00:26:09.017918429 +0200\n+++ /tmp/tmpcxten8r9.java\t2022-07-19 00:26:09.017918429 +0200\n@@ -459,11 +459,11 @@\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+Partial newPartial = new Partial(iChronology, newTypes, newValues); // we need to check whether a newValues);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n         if (value == getValue(index)) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "Partial newPartial = new Partial(iChronology, newTypes, newValues); // we need to do a newValues);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-4/src/main/java/org/joda/time/Partial.java\t2022-07-19 00:26:18.469870351 +0200\n+++ /tmp/tmp07d8kjir.java\t2022-07-19 00:26:18.469870351 +0200\n@@ -459,11 +459,11 @@\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+Partial newPartial = new Partial(iChronology, newTypes, newValues); // we need to do a newValues);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n         if (value == getValue(index)) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "Partial newPartial = new Partial(iChronology, newTypes, newValues); // remove the newValues = newValues);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-4/src/main/java/org/joda/time/Partial.java\t2022-07-19 00:26:27.985821804 +0200\n+++ /tmp/tmpbn6joxq3.java\t2022-07-19 00:26:27.985821804 +0200\n@@ -459,11 +459,11 @@\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+Partial newPartial = new Partial(iChronology, newTypes, newValues); // remove the newValues = newValues);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n         if (value == getValue(index)) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "Partial newPartial = newPartial(iChronology, newTypes, newValues);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-4/src/main/java/org/joda/time/Partial.java\t2022-07-19 00:26:37.453773361 +0200\n+++ /tmp/tmp4j585nit.java\t2022-07-19 00:26:37.457773340 +0200\n@@ -459,11 +459,11 @@\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+Partial newPartial = newPartial(iChronology, newTypes, newValues);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n         if (value == getValue(index)) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "Partial newPartial = new Partial(0, newTypes, newValues);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-4/src/main/java/org/joda/time/Partial.java\t2022-07-19 00:26:39.201764401 +0200\n+++ /tmp/tmp6fkt_hos.java\t2022-07-19 00:26:39.201764401 +0200\n@@ -459,11 +459,11 @@\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+Partial newPartial = new Partial(0, newTypes, newValues);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n         if (value == getValue(index)) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "Partial newPartial = new Partial(iChronology, newTypes, newValues = newValues);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-4/src/main/java/org/joda/time/Partial.java\t2022-07-19 00:26:40.977755295 +0200\n+++ /tmp/tmpgwmgs3ua.java\t2022-07-19 00:26:40.977755295 +0200\n@@ -459,11 +459,11 @@\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+Partial newPartial = new Partial(iChronology, newTypes, newValues = newValues);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n         if (value == getValue(index)) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "Partial newPartial = new Partial(iChronology, newTypes, newValues);",
        "fixed_line": "Partial newPartial = new Partial(newTypes, newValues, iChronology);"
    },
    "Closure-56": {
        "fixes": [
            {
                "k": 1,
                "patch": "return js.indexOf('\\n', pos);",
                "patch_diff": "return js.indexOf('\\n', pos);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return js.indexOf('\\n', pos); } else {",
                "patch_diff": "return js.indexOf('\\n', pos); } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return js.indexOf('\\n', pos); }",
                "patch_diff": "return js.indexOf('\\n', pos); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return js.indexOf('\\n', pos)); } else {",
                "patch_diff": "return js.indexOf('\\n', pos)); } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos));",
                "patch_diff": "return js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos));",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos)); } else {",
                "patch_diff": "return js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos)); } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos);",
                "patch_diff": "return js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return js.indexOf('\\n', pos)); }",
                "patch_diff": "return js.indexOf('\\n', pos)); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return js.indexOf('\\n', pos));",
                "patch_diff": "return js.indexOf('\\n', pos));",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos < 0) {",
                "patch_diff": "return js.indexOf('\\n', pos); } else if (js.indexOf('\\n', pos < 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (pos >= js.length()) { return null; } else { return js.substring(pos, js.length()); }"
    },
    "JacksonDatabind-70": {
        "fixes": [
            {
                "k": 1,
                "patch": "found = _key.equals(prop.getName());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-70/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\t2022-07-19 00:26:52.333696948 +0200\n+++ /tmp/tmp8hp6g64n.java\t2022-07-19 00:26:52.349696867 +0200\n@@ -435,11 +435,11 @@\n                 continue;\n             }\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+found = _key.equals(prop.getName());\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n                     continue;\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "found = key.equals(prop.getName());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-70/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\t2022-07-19 00:26:54.117687766 +0200\n+++ /tmp/tmpsyucxqi9.java\t2022-07-19 00:26:54.117687766 +0200\n@@ -435,11 +435,11 @@\n                 continue;\n             }\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+found = key.equals(prop.getName());\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n                     continue;\n                 }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "found = _props.equals(prop.getName());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-70/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\t2022-07-19 00:27:34.141480515 +0200\n+++ /tmp/tmpq9m1ki9e.java\t2022-07-19 00:27:34.141480515 +0200\n@@ -435,11 +435,11 @@\n                 continue;\n             }\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+found = _props.equals(prop.getName());\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n                     continue;\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "found = prop.equals(prop.getName());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-70/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\t2022-07-19 00:27:35.857471580 +0200\n+++ /tmp/tmp4ibjl165.java\t2022-07-19 00:27:35.873471495 +0200\n@@ -435,11 +435,11 @@\n                 continue;\n             }\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+found = prop.equals(prop.getName());\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n                     continue;\n                 }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "found = property.equals(prop.getName());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-70/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\t2022-07-19 00:28:15.341264872 +0200\n+++ /tmp/tmpg9hiak6m.java\t2022-07-19 00:28:15.341264872 +0200\n@@ -435,11 +435,11 @@\n                 continue;\n             }\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+found = property.equals(prop.getName());\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n                     continue;\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "found = name.equals(prop.getName());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-70/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\t2022-07-19 00:28:17.045255906 +0200\n+++ /tmp/tmpz5p0_ehq.java\t2022-07-19 00:28:17.045255906 +0200\n@@ -435,11 +435,11 @@\n                 continue;\n             }\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+found = name.equals(prop.getName());\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n                     continue;\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "found = t.equals(prop.getName());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-70/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\t2022-07-19 00:28:18.777246789 +0200\n+++ /tmp/tmpyat14_fn.java\t2022-07-19 00:28:18.781246768 +0200\n@@ -435,11 +435,11 @@\n                 continue;\n             }\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+found = t.equals(prop.getName());\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n                     continue;\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "found = _name.equals(prop.getName());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-70/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\t2022-07-19 00:28:20.453237962 +0200\n+++ /tmp/tmp2z3v41_k.java\t2022-07-19 00:28:20.453237962 +0200\n@@ -435,11 +435,11 @@\n                 continue;\n             }\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+found = _name.equals(prop.getName());\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n                     continue;\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "found = ctor.equals(prop.getName());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-70/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\t2022-07-19 00:28:22.201228753 +0200\n+++ /tmp/tmp67jjewai.java\t2022-07-19 00:28:22.201228753 +0200\n@@ -435,11 +435,11 @@\n                 continue;\n             }\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+found = ctor.equals(prop.getName());\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n                     continue;\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "found = NULL.equals(prop.getName());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-70/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\t2022-07-19 00:28:23.969219434 +0200\n+++ /tmp/tmpuj83inph.java\t2022-07-19 00:28:23.969219434 +0200\n@@ -435,11 +435,11 @@\n                 continue;\n             }\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+found = NULL.equals(prop.getName());\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n                     continue;\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "found = key.equals(prop.getName());",
        "fixed_line": "found = key.equals(_hashArea[i-1]);"
    },
    "Chart-23": {
        "fixes": [
            {
                "k": 1,
                "patch": "this.seriesKeys.length() 1.0.7 = this.shape;",
                "patch_diff": "this.seriesKeys.length() 1.0.7 = this.shape;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "this.area.length() 1.0.7 = this.shape;",
                "patch_diff": "this.area.length() 1.0.7 = this.shape;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// 0.0 0.0 = this.shape;",
                "patch_diff": "// 0.0 0.0 = this.shape;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "this.default.7 = this.shape;",
                "patch_diff": "this.default.7 = this.shape;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "this.seriesKeys.length() 1.0.7 = (this.shape;",
                "patch_diff": "this.seriesKeys.length() 1.0.7 = (this.shape;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "this.seriesKeys.length() 1.0.7 = this.max.7;",
                "patch_diff": "this.seriesKeys.length() 1.0.7 = this.max.7;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "this.seriesKeys.length() 1.0.7 = 0.0;",
                "patch_diff": "this.seriesKeys.length() 1.0.7 = 0.0;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "this.area.length 1.0.7 = this.shape;",
                "patch_diff": "this.area.length 1.0.7 = this.shape;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "this.default.7 = this.area. 1.0.7;",
                "patch_diff": "this.default.7 = this.area. 1.0.7;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "this.seriesKeys.length() 1.0.7 = this.maxValue;",
                "patch_diff": "this.seriesKeys.length() 1.0.7 = this.maxValue;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "public boolean equals(Object obj) { if (obj == this) { return true; } if (!(obj instanceof MinMaxCategoryRenderer)) { return false; } MinMaxCategoryRenderer that = (MinMaxCategoryRenderer) obj; if (this.plotLines != that.plotLines) { return false; } if (!PaintUtilities.equal(this.groupPaint, that.groupPaint)) { return false; } if (!this.groupStroke.equals(that.groupStroke)) { return false; } return super.equals(obj); }"
    },
    "Cli-29": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (str.startsWith(\"\\\"\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-29/src/java/org/apache/commons/cli/Util.java\t2022-07-19 00:28:27.561200490 +0200\n+++ /tmp/tmp8ih11y77.java\t2022-07-19 00:28:27.573200427 +0200\n@@ -60,18 +60,11 @@\n      *\n      * @return The string without the leading and trailing quotes.\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n-        if (str.startsWith(\"\\\"\"))\n-        {\n-            str = str.substring(1, str.length());\n-        }\n-        int length = str.length();\n-        if (str.endsWith(\"\\\"\"))\n-        {\n-            str = str.substring(0, length - 1);\n+if (str.startsWith(\"\\\"\")) {\n         }\n         \n         return str;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (str.startsWith(\"\\\"\")) { int length = str.length()); } int length = str.endsWith(\"\\\"\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-29/src/java/org/apache/commons/cli/Util.java\t2022-07-19 00:28:29.981187718 +0200\n+++ /tmp/tmph9755sx4.java\t2022-07-19 00:28:29.981187718 +0200\n@@ -60,18 +60,11 @@\n      *\n      * @return The string without the leading and trailing quotes.\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n-        if (str.startsWith(\"\\\"\"))\n-        {\n-            str = str.substring(1, str.length());\n-        }\n-        int length = str.length();\n-        if (str.endsWith(\"\\\"\"))\n-        {\n-            str = str.substring(0, length - 1);\n+if (str.startsWith(\"\\\"\")) { int length = str.length()); } int length = str.endsWith(\"\\\"\")) {\n         }\n         \n         return str;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (str.startsWith(\"\\\"\")) { int length = str.length(); } int length = str.length(); if (str.endsWith(\"\\\"\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-29/src/java/org/apache/commons/cli/Util.java\t2022-07-19 00:28:31.473179839 +0200\n+++ /tmp/tmp6x9oa9e3.java\t2022-07-19 00:28:31.473179839 +0200\n@@ -60,18 +60,11 @@\n      *\n      * @return The string without the leading and trailing quotes.\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n-        if (str.startsWith(\"\\\"\"))\n-        {\n-            str = str.substring(1, str.length());\n-        }\n-        int length = str.length();\n-        if (str.endsWith(\"\\\"\"))\n-        {\n-            str = str.substring(0, length - 1);\n+if (str.startsWith(\"\\\"\")) { int length = str.length(); } int length = str.length(); if (str.endsWith(\"\\\"\")) {\n         }\n         \n         return str;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (str.startsWith(\"\\\"\")) { int length = str.length(); } int length = str.endsWith(\"\\\"\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-29/src/java/org/apache/commons/cli/Util.java\t2022-07-19 00:28:33.901167014 +0200\n+++ /tmp/tmpb6208hfu.java\t2022-07-19 00:28:33.901167014 +0200\n@@ -60,18 +60,11 @@\n      *\n      * @return The string without the leading and trailing quotes.\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n-        if (str.startsWith(\"\\\"\"))\n-        {\n-            str = str.substring(1, str.length());\n-        }\n-        int length = str.length();\n-        if (str.endsWith(\"\\\"\"))\n-        {\n-            str = str.substring(0, length - 1);\n+if (str.startsWith(\"\\\"\")) { int length = str.length(); } int length = str.endsWith(\"\\\"\")) {\n         }\n         \n         return str;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (str.startsWith(\"\\\"\")) { int length = str.length()); } int length = str.length(); if (str.endsWith(\"\\\"\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-29/src/java/org/apache/commons/cli/Util.java\t2022-07-19 00:28:35.525158430 +0200\n+++ /tmp/tmpr7scq3s1.java\t2022-07-19 00:28:35.525158430 +0200\n@@ -60,18 +60,11 @@\n      *\n      * @return The string without the leading and trailing quotes.\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n-        if (str.startsWith(\"\\\"\"))\n-        {\n-            str = str.substring(1, str.length());\n-        }\n-        int length = str.length();\n-        if (str.endsWith(\"\\\"\"))\n-        {\n-            str = str.substring(0, length - 1);\n+if (str.startsWith(\"\\\"\")) { int length = str.length()); } int length = str.length(); if (str.endsWith(\"\\\"\")) {\n         }\n         \n         return str;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (str.startsWith(\"\\\"\")) { size = str.substring(1, length); } int length = str.length(); if (str.endsWith(\"\\\"\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-29/src/java/org/apache/commons/cli/Util.java\t2022-07-19 00:28:36.993150669 +0200\n+++ /tmp/tmp8121oinm.java\t2022-07-19 00:28:36.993150669 +0200\n@@ -60,18 +60,11 @@\n      *\n      * @return The string without the leading and trailing quotes.\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n-        if (str.startsWith(\"\\\"\"))\n-        {\n-            str = str.substring(1, str.length());\n-        }\n-        int length = str.length();\n-        if (str.endsWith(\"\\\"\"))\n-        {\n-            str = str.substring(0, length - 1);\n+if (str.startsWith(\"\\\"\")) { size = str.substring(1, length); } int length = str.length(); if (str.endsWith(\"\\\"\")) {\n         }\n         \n         return str;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (str.startsWith(\"\\\"\")) { return str.substring(1, length = str.length(); } int length = str.endsWith(\"\\\"\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-29/src/java/org/apache/commons/cli/Util.java\t2022-07-19 00:28:38.649141911 +0200\n+++ /tmp/tmplb2wlfkh.java\t2022-07-19 00:28:38.649141911 +0200\n@@ -60,18 +60,11 @@\n      *\n      * @return The string without the leading and trailing quotes.\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n-        if (str.startsWith(\"\\\"\"))\n-        {\n-            str = str.substring(1, str.length());\n-        }\n-        int length = str.length();\n-        if (str.endsWith(\"\\\"\"))\n-        {\n-            str = str.substring(0, length - 1);\n+if (str.startsWith(\"\\\"\")) { return str.substring(1, length = str.length(); } int length = str.endsWith(\"\\\"\")) {\n         }\n         \n         return str;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (str.startsWith(\"\\\"\")) { str = str.substring(1, length); } int length = str.length(); if (str.endsWith(\"\\\"\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-29/src/java/org/apache/commons/cli/Util.java\t2022-07-19 00:28:40.073134374 +0200\n+++ /tmp/tmp8d2r6t06.java\t2022-07-19 00:28:40.073134374 +0200\n@@ -60,18 +60,11 @@\n      *\n      * @return The string without the leading and trailing quotes.\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n-        if (str.startsWith(\"\\\"\"))\n-        {\n-            str = str.substring(1, str.length());\n-        }\n-        int length = str.length();\n-        if (str.endsWith(\"\\\"\"))\n-        {\n-            str = str.substring(0, length - 1);\n+if (str.startsWith(\"\\\"\")) { str = str.substring(1, length); } int length = str.length(); if (str.endsWith(\"\\\"\")) {\n         }\n         \n         return str;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (str.startsWith(\"\\\"\")) { return str; } int length = str.length(); if (str.endsWith(\"\\\"\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-29/src/java/org/apache/commons/cli/Util.java\t2022-07-19 00:28:41.661125970 +0200\n+++ /tmp/tmpjlgkuui9.java\t2022-07-19 00:28:41.661125970 +0200\n@@ -60,18 +60,11 @@\n      *\n      * @return The string without the leading and trailing quotes.\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n-        if (str.startsWith(\"\\\"\"))\n-        {\n-            str = str.substring(1, str.length());\n-        }\n-        int length = str.length();\n-        if (str.endsWith(\"\\\"\"))\n-        {\n-            str = str.substring(0, length - 1);\n+if (str.startsWith(\"\\\"\")) { return str; } int length = str.length(); if (str.endsWith(\"\\\"\")) {\n         }\n         \n         return str;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (str.startsWith(\"\\\"\")) { size = str.substring(1, length); } int length = str.endsWith(\"\\\"\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-29/src/java/org/apache/commons/cli/Util.java\t2022-07-19 00:28:44.105113028 +0200\n+++ /tmp/tmpb8jrltyl.java\t2022-07-19 00:28:44.109113007 +0200\n@@ -60,18 +60,11 @@\n      *\n      * @return The string without the leading and trailing quotes.\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n-        if (str.startsWith(\"\\\"\"))\n-        {\n-            str = str.substring(1, str.length());\n-        }\n-        int length = str.length();\n-        if (str.endsWith(\"\\\"\"))\n-        {\n-            str = str.substring(0, length - 1);\n+if (str.startsWith(\"\\\"\")) { size = str.substring(1, length); } int length = str.endsWith(\"\\\"\")) {\n         }\n         \n         return str;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (str.startsWith(\"\\\"\")) { str = str.substring(1, str.length()); } int length = str.length(); if (str.endsWith(\"\\\"\")) { str = str.substring(0, length - 1);",
        "fixed_line": "if (length > 1 && str.startsWith(\"\\\"\") && str.endsWith(\"\\\"\") && str.substring(1, length - 1).indexOf('\"') == -1) { str = str.substring(1, length - 1);"
    },
    "Math-20": {
        "fixes": [
            {
                "k": 1,
                "patch": "return",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-20/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\t2022-07-19 00:28:45.817103960 +0200\n+++ /tmp/tmpa5hzacza.java\t2022-07-19 00:28:45.841103833 +0200\n@@ -916,11 +916,11 @@\n         /**\n          * @param x Normalized objective variables.\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return\n+return\n                 decode(x);\n         }\n \n         /**\n          * @param x Normalized objective variables.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-20/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\t2022-07-19 00:29:21.392914720 +0200\n+++ /tmp/tmp57_5uwyz.java\t2022-07-19 00:29:21.392914720 +0200\n@@ -916,11 +916,11 @@\n         /**\n          * @param x Normalized objective variables.\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return\n+return 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n                 decode(x);\n         }\n \n         /**\n          * @param x Normalized objective variables.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-20/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\t2022-07-19 00:29:23.572903075 +0200\n+++ /tmp/tmpo7wfb7y9.java\t2022-07-19 00:29:23.572903075 +0200\n@@ -916,11 +916,11 @@\n         /**\n          * @param x Normalized objective variables.\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return\n+return 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n                 decode(x);\n         }\n \n         /**\n          * @param x Normalized objective variables.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-20/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\t2022-07-19 00:29:25.756891405 +0200\n+++ /tmp/tmp7m72flal.java\t2022-07-19 00:29:25.760891384 +0200\n@@ -916,11 +916,11 @@\n         /**\n          * @param x Normalized objective variables.\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return\n+return 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n                 decode(x);\n         }\n \n         /**\n          * @param x Normalized objective variables.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return 1; // we didn't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-20/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\t2022-07-19 00:29:27.940879732 +0200\n+++ /tmp/tmpj1zqguz7.java\t2022-07-19 00:29:27.940879732 +0200\n@@ -916,11 +916,11 @@\n         /**\n          * @param x Normalized objective variables.\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return\n+return 1; // we didn't really modify it's totalGJACKSON-notnotnotnot real number\n                 decode(x);\n         }\n \n         /**\n          * @param x Normalized objective variables.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-20/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\t2022-07-19 00:29:30.072868330 +0200\n+++ /tmp/tmpt68mxeek.java\t2022-07-19 00:29:30.072868330 +0200\n@@ -916,11 +916,11 @@\n         /**\n          * @param x Normalized objective variables.\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return\n+return 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number\n                 decode(x);\n         }\n \n         /**\n          * @param x Normalized objective variables.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-20/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\t2022-07-19 00:29:32.296856430 +0200\n+++ /tmp/tmp5tnupqnm.java\t2022-07-19 00:29:32.300856407 +0200\n@@ -916,11 +916,11 @@\n         /**\n          * @param x Normalized objective variables.\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return\n+return 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number\n                 decode(x);\n         }\n \n         /**\n          * @param x Normalized objective variables.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return 1; // we didn't really modify it's totalGJACKSON-notnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-20/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\t2022-07-19 00:29:34.488844696 +0200\n+++ /tmp/tmpo9rnm5vh.java\t2022-07-19 00:29:34.492844675 +0200\n@@ -916,11 +916,11 @@\n         /**\n          * @param x Normalized objective variables.\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return\n+return 1; // we didn't really modify it's totalGJACKSON-notnotnot real number\n                 decode(x);\n         }\n \n         /**\n          * @param x Normalized objective variables.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-20/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\t2022-07-19 00:29:36.728832699 +0200\n+++ /tmp/tmp9jix1c8u.java\t2022-07-19 00:29:36.728832699 +0200\n@@ -916,11 +916,11 @@\n         /**\n          * @param x Normalized objective variables.\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return\n+return 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnot real number\n                 decode(x);\n         }\n \n         /**\n          * @param x Normalized objective variables.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return 1; // we didn't really modify it's totalGJACKSON-notnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-20/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\t2022-07-19 00:29:38.876821191 +0200\n+++ /tmp/tmpf2ia3h6t.java\t2022-07-19 00:29:38.876821191 +0200\n@@ -916,11 +916,11 @@\n         /**\n          * @param x Normalized objective variables.\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return\n+return 1; // we didn't really modify it's totalGJACKSON-notnot real number\n                 decode(x);\n         }\n \n         /**\n          * @param x Normalized objective variables.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return",
        "fixed_line": "return boundaries != null && isRepairMode ? decode(repair(x)) :"
    },
    "Closure-10": {
        "fixes": [
            {
                "k": 1,
                "patch": "return allResultsMatch(n, recurse);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-10/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 00:29:41.228808584 +0200\n+++ /tmp/tmpe1rhte9n.java\t2022-07-19 00:29:41.256808435 +0200\n@@ -1412,11 +1412,11 @@\n     return mayBeString(n, true);\n   }\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+return allResultsMatch(n, recurse);\n     } else {\n       return mayBeStringHelper(n);\n     }\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return allResultsMatch(n, recurse)_AY_PREDICATE);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-10/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 00:29:45.212787217 +0200\n+++ /tmp/tmpunudj_7_.java\t2022-07-19 00:29:45.216787193 +0200\n@@ -1412,11 +1412,11 @@\n     return mayBeString(n, true);\n   }\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+return allResultsMatch(n, recurse)_AY_PREDICATE);\n     } else {\n       return mayBeStringHelper(n);\n     }\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return allResultsMatch(n, recurse)_AY_STRING_PREDICATE);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-10/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 00:29:48.608768989 +0200\n+++ /tmp/tmp8jtrr3wu.java\t2022-07-19 00:29:48.608768989 +0200\n@@ -1412,11 +1412,11 @@\n     return mayBeString(n, true);\n   }\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+return allResultsMatch(n, recurse)_AY_STRING_PREDICATE);\n     } else {\n       return mayBeStringHelper(n);\n     }\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return allResultsMatch(n, recurse,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-10/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 00:29:51.976750897 +0200\n+++ /tmp/tmpbcl85ap8.java\t2022-07-19 00:29:51.980750876 +0200\n@@ -1412,11 +1412,11 @@\n     return mayBeString(n, true);\n   }\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+return allResultsMatch(n, recurse,\n     } else {\n       return mayBeStringHelper(n);\n     }\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return allResultsMatch(n, recurse)_AY_EXTENDED_TYPE);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-10/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 00:29:55.376732624 +0200\n+++ /tmp/tmp_bwvovkf.java\t2022-07-19 00:29:55.380732603 +0200\n@@ -1412,11 +1412,11 @@\n     return mayBeString(n, true);\n   }\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+return allResultsMatch(n, recurse)_AY_EXTENDED_TYPE);\n     } else {\n       return mayBeStringHelper(n);\n     }\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return allResultsMatch(n, recurse)_AY_EXTENDED_TYPE;CATE);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-10/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 00:29:58.692714789 +0200\n+++ /tmp/tmp6q3pm6g9.java\t2022-07-19 00:29:58.692714789 +0200\n@@ -1412,11 +1412,11 @@\n     return mayBeString(n, true);\n   }\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+return allResultsMatch(n, recurse)_AY_EXTENDED_TYPE;CATE);\n     } else {\n       return mayBeStringHelper(n);\n     }\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return allResultsMatch(n, recurse)_AY_CODE);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-10/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 00:30:01.996697010 +0200\n+++ /tmp/tmp4fd6zobv.java\t2022-07-19 00:30:02.000696988 +0200\n@@ -1412,11 +1412,11 @@\n     return mayBeString(n, true);\n   }\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+return allResultsMatch(n, recurse)_AY_CODE);\n     } else {\n       return mayBeStringHelper(n);\n     }\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return allResultsMatch(n, recurse, MAY_PREDICATE);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-10/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 00:30:05.380678787 +0200\n+++ /tmp/tmps2ealy5i.java\t2022-07-19 00:30:05.380678787 +0200\n@@ -1412,11 +1412,11 @@\n     return mayBeString(n, true);\n   }\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+return allResultsMatch(n, recurse, MAY_PREDICATE);\n     } else {\n       return mayBeStringHelper(n);\n     }\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return allResultsMatch(n, recurse)_AY_EXTENDED_TYPE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-10/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 00:30:09.024659150 +0200\n+++ /tmp/tmppl1u48ox.java\t2022-07-19 00:30:09.028659129 +0200\n@@ -1412,11 +1412,11 @@\n     return mayBeString(n, true);\n   }\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+return allResultsMatch(n, recurse)_AY_EXTENDED_TYPE;\n     } else {\n       return mayBeStringHelper(n);\n     }\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return allResultsMatch(n, recurse)_AY_PRODICATE);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-10/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 00:30:12.464640601 +0200\n+++ /tmp/tmplshwzohz.java\t2022-07-19 00:30:12.464640601 +0200\n@@ -1412,11 +1412,11 @@\n     return mayBeString(n, true);\n   }\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+return allResultsMatch(n, recurse)_AY_PRODICATE);\n     } else {\n       return mayBeStringHelper(n);\n     }\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return allResultsMatch(n, MAY_BE_STRING_PREDICATE);",
        "fixed_line": "return anyResultsMatch(n, MAY_BE_STRING_PREDICATE);"
    },
    "Closure-160": {
        "fixes": [
            {
                "k": 1,
                "patch": "(warningsGuard == null ||!warningsGuard.CHECK_VARIABLES))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-160/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 00:30:16.268620075 +0200\n+++ /tmp/tmpx72veq8k.java\t2022-07-19 00:30:16.304619877 +0200\n@@ -270,17 +270,11 @@\n     // variables later so that the compiler doesn't crash. It also\n     // checks the externs file for validity. If you don't want to warn\n     // about missing variable declarations, we shut that specific\n     // error off.\n     if (!options.checkSymbols &&\n-        (warningsGuard == null || !warningsGuard.disables(\n-            DiagnosticGroups.CHECK_VARIABLES))) {\n-      guards.add(new DiagnosticGroupWarningsGuard(\n-          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n-    }\n-\n-    this.warningsGuard = new ComposeWarningsGuard(guards);\n+(warningsGuard == null ||!warningsGuard.CHECK_VARIABLES))) {\n   }\n \n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "(warningsGuard == null ||!warningsGuard.CHECK_VARIABLES))) { guards.CHECK_VARIABLES))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-160/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 00:30:18.860606082 +0200\n+++ /tmp/tmppe8331b_.java\t2022-07-19 00:30:18.860606082 +0200\n@@ -270,17 +270,11 @@\n     // variables later so that the compiler doesn't crash. It also\n     // checks the externs file for validity. If you don't want to warn\n     // about missing variable declarations, we shut that specific\n     // error off.\n     if (!options.checkSymbols &&\n-        (warningsGuard == null || !warningsGuard.disables(\n-            DiagnosticGroups.CHECK_VARIABLES))) {\n-      guards.add(new DiagnosticGroupWarningsGuard(\n-          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n-    }\n-\n-    this.warningsGuard = new ComposeWarningsGuard(guards);\n+(warningsGuard == null ||!warningsGuard.CHECK_VARIABLES))) { guards.CHECK_VARIABLES))) {\n   }\n \n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "(warningsGuard!= null &&!warningsGuard.CHECK_VARIABLES))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-160/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 00:30:21.444592124 +0200\n+++ /tmp/tmpo4t51ivn.java\t2022-07-19 00:30:21.448592101 +0200\n@@ -270,17 +270,11 @@\n     // variables later so that the compiler doesn't crash. It also\n     // checks the externs file for validity. If you don't want to warn\n     // about missing variable declarations, we shut that specific\n     // error off.\n     if (!options.checkSymbols &&\n-        (warningsGuard == null || !warningsGuard.disables(\n-            DiagnosticGroups.CHECK_VARIABLES))) {\n-      guards.add(new DiagnosticGroupWarningsGuard(\n-          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n-    }\n-\n-    this.warningsGuard = new ComposeWarningsGuard(guards);\n+(warningsGuard!= null &&!warningsGuard.CHECK_VARIABLES))) {\n   }\n \n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "(warningsGuard!= null &&!warningsGuard.CHECK_VARIABLES))) { guards.CHECK_VARIABLES))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-160/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 00:30:24.008578266 +0200\n+++ /tmp/tmpy2lcvtrd.java\t2022-07-19 00:30:24.008578266 +0200\n@@ -270,17 +270,11 @@\n     // variables later so that the compiler doesn't crash. It also\n     // checks the externs file for validity. If you don't want to warn\n     // about missing variable declarations, we shut that specific\n     // error off.\n     if (!options.checkSymbols &&\n-        (warningsGuard == null || !warningsGuard.disables(\n-            DiagnosticGroups.CHECK_VARIABLES))) {\n-      guards.add(new DiagnosticGroupWarningsGuard(\n-          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n-    }\n-\n-    this.warningsGuard = new ComposeWarningsGuard(guards);\n+(warningsGuard!= null &&!warningsGuard.CHECK_VARIABLES))) { guards.CHECK_VARIABLES))) {\n   }\n \n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "(warningsGuard!= null &&!warningsGuard.CHECK_VARIABLES))) { guards.CHECK_VARIABLES, CheckLevel.CHECK_VARIABLES); } this.warningsGuard = new ComposeWarningsGuard(guards);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-160/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 00:30:26.556564490 +0200\n+++ /tmp/tmpaebi2jw5.java\t2022-07-19 00:30:26.556564490 +0200\n@@ -270,17 +270,11 @@\n     // variables later so that the compiler doesn't crash. It also\n     // checks the externs file for validity. If you don't want to warn\n     // about missing variable declarations, we shut that specific\n     // error off.\n     if (!options.checkSymbols &&\n-        (warningsGuard == null || !warningsGuard.disables(\n-            DiagnosticGroups.CHECK_VARIABLES))) {\n-      guards.add(new DiagnosticGroupWarningsGuard(\n-          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n-    }\n-\n-    this.warningsGuard = new ComposeWarningsGuard(guards);\n+(warningsGuard!= null &&!warningsGuard.CHECK_VARIABLES))) { guards.CHECK_VARIABLES, CheckLevel.CHECK_VARIABLES); } this.warningsGuard = new ComposeWarningsGuard(guards);\n   }\n \n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "(warningsGuard == null ||!warningsGuard.CHECK_VARIABLES))) { guards.CHECK_VARIABLES))) { throw new ComposeWarningsGuard = new ComposeWarningsGuard(guards);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-160/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 00:30:29.072550880 +0200\n+++ /tmp/tmpajtog04u.java\t2022-07-19 00:30:29.072550880 +0200\n@@ -270,17 +270,11 @@\n     // variables later so that the compiler doesn't crash. It also\n     // checks the externs file for validity. If you don't want to warn\n     // about missing variable declarations, we shut that specific\n     // error off.\n     if (!options.checkSymbols &&\n-        (warningsGuard == null || !warningsGuard.disables(\n-            DiagnosticGroups.CHECK_VARIABLES))) {\n-      guards.add(new DiagnosticGroupWarningsGuard(\n-          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n-    }\n-\n-    this.warningsGuard = new ComposeWarningsGuard(guards);\n+(warningsGuard == null ||!warningsGuard.CHECK_VARIABLES))) { guards.CHECK_VARIABLES))) { throw new ComposeWarningsGuard = new ComposeWarningsGuard(guards);\n   }\n \n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "(warningsGuard!= null &&!warningsGuard.CHECK_VARIABLES))) { guards.CHECK_VARIABLES))) { throw new ComposeWarningsGuard = new ComposeWarningsGuard(guards);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-160/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 00:30:31.636537005 +0200\n+++ /tmp/tmp01wjmhqw.java\t2022-07-19 00:30:31.636537005 +0200\n@@ -270,17 +270,11 @@\n     // variables later so that the compiler doesn't crash. It also\n     // checks the externs file for validity. If you don't want to warn\n     // about missing variable declarations, we shut that specific\n     // error off.\n     if (!options.checkSymbols &&\n-        (warningsGuard == null || !warningsGuard.disables(\n-            DiagnosticGroups.CHECK_VARIABLES))) {\n-      guards.add(new DiagnosticGroupWarningsGuard(\n-          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n-    }\n-\n-    this.warningsGuard = new ComposeWarningsGuard(guards);\n+(warningsGuard!= null &&!warningsGuard.CHECK_VARIABLES))) { guards.CHECK_VARIABLES))) { throw new ComposeWarningsGuard = new ComposeWarningsGuard(guards);\n   }\n \n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "(warningsGuard == null ||!warningsGuard.CHECK_VARIABLES))) { guards.CHECK_VARIABLES))) { throw new ComposeWarningsGuard(guards);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-160/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 00:30:34.188523187 +0200\n+++ /tmp/tmpxop4c6zs.java\t2022-07-19 00:30:34.188523187 +0200\n@@ -270,17 +270,11 @@\n     // variables later so that the compiler doesn't crash. It also\n     // checks the externs file for validity. If you don't want to warn\n     // about missing variable declarations, we shut that specific\n     // error off.\n     if (!options.checkSymbols &&\n-        (warningsGuard == null || !warningsGuard.disables(\n-            DiagnosticGroups.CHECK_VARIABLES))) {\n-      guards.add(new DiagnosticGroupWarningsGuard(\n-          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n-    }\n-\n-    this.warningsGuard = new ComposeWarningsGuard(guards);\n+(warningsGuard == null ||!warningsGuard.CHECK_VARIABLES))) { guards.CHECK_VARIABLES))) { throw new ComposeWarningsGuard(guards);\n   }\n \n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "(warningsGuard == null ||!warningsGuard.CHECK_VARIABLES))) { guards.CHECK_VARIABLES))) { throw new ComposeWarningsGuard(guards); } this.warningsGuard = new ComposeWarningsGuard(guards);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-160/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 00:30:36.784509125 +0200\n+++ /tmp/tmpclscy37r.java\t2022-07-19 00:30:36.784509125 +0200\n@@ -270,17 +270,11 @@\n     // variables later so that the compiler doesn't crash. It also\n     // checks the externs file for validity. If you don't want to warn\n     // about missing variable declarations, we shut that specific\n     // error off.\n     if (!options.checkSymbols &&\n-        (warningsGuard == null || !warningsGuard.disables(\n-            DiagnosticGroups.CHECK_VARIABLES))) {\n-      guards.add(new DiagnosticGroupWarningsGuard(\n-          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n-    }\n-\n-    this.warningsGuard = new ComposeWarningsGuard(guards);\n+(warningsGuard == null ||!warningsGuard.CHECK_VARIABLES))) { guards.CHECK_VARIABLES))) { throw new ComposeWarningsGuard(guards); } this.warningsGuard = new ComposeWarningsGuard(guards);\n   }\n \n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "(warningsGuard!= null &&!warningsGuard.CHECK_VARIABLES))) { guards.CHECK_VARIABLES))) { throw new ComposeWarningsGuard(guards);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-160/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 00:30:39.312495427 +0200\n+++ /tmp/tmpjk0n_3lo.java\t2022-07-19 00:30:39.316495406 +0200\n@@ -270,17 +270,11 @@\n     // variables later so that the compiler doesn't crash. It also\n     // checks the externs file for validity. If you don't want to warn\n     // about missing variable declarations, we shut that specific\n     // error off.\n     if (!options.checkSymbols &&\n-        (warningsGuard == null || !warningsGuard.disables(\n-            DiagnosticGroups.CHECK_VARIABLES))) {\n-      guards.add(new DiagnosticGroupWarningsGuard(\n-          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n-    }\n-\n-    this.warningsGuard = new ComposeWarningsGuard(guards);\n+(warningsGuard!= null &&!warningsGuard.CHECK_VARIABLES))) { guards.CHECK_VARIABLES))) { throw new ComposeWarningsGuard(guards);\n   }\n \n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "(warningsGuard == null || !warningsGuard.disables( DiagnosticGroups.CHECK_VARIABLES))) { guards.add(new DiagnosticGroupWarningsGuard( DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF)); } this.warningsGuard = new ComposeWarningsGuard(guards);",
        "fixed_line": "ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards); // All passes must run the variable check. This synthesizes // variables later so that the compiler doesn't crash. It also // checks the externs file for validity. If you don't want to warn // about missing variable declarations, we shut that specific // error off. if (!options.checkSymbols && !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) { composedGuards.addGuard(new DiagnosticGroupWarningsGuard( DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF)); } this.warningsGuard = composedGuards;"
    },
    "Math-55": {
        "fixes": [
            {
                "k": 1,
                "patch": "return new Vector3D(v1.x - v2.x, v2.y, v2.y - v1.y * v2.y);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-55/src/main/java/org/apache/commons/math/geometry/Vector3D.java\t2022-07-19 00:30:42.104480289 +0200\n+++ /tmp/tmpgloptwi1.java\t2022-07-19 00:30:42.112480247 +0200\n@@ -468,11 +468,11 @@\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n \n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n+return new Vector3D(v1.x - v2.x, v2.y, v2.y - v1.y * v2.y);\n \n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return new Vector3D(v1.x - v2.x, v2.y, v2.y - v2.y * v1.y);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-55/src/main/java/org/apache/commons/math/geometry/Vector3D.java\t2022-07-19 00:31:26.484238702 +0200\n+++ /tmp/tmp9b1ycfrh.java\t2022-07-19 00:31:26.484238702 +0200\n@@ -468,11 +468,11 @@\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n \n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n+return new Vector3D(v1.x - v2.x, v2.y, v2.y - v2.y * v1.y);\n \n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return new Vector3D(v1, v2.x - v1.x, v2.y, v2.y - v1.y * v2.y);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-55/src/main/java/org/apache/commons/math/geometry/Vector3D.java\t2022-07-19 00:32:09.348003727 +0200\n+++ /tmp/tmp9773yc62.java\t2022-07-19 00:32:09.348003727 +0200\n@@ -468,11 +468,11 @@\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n \n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n+return new Vector3D(v1, v2.x - v1.x, v2.y, v2.y - v1.y * v2.y);\n \n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return new Vector3D(v1.x - v2.x, v2.y, v2.y - v1.y);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-55/src/main/java/org/apache/commons/math/geometry/Vector3D.java\t2022-07-19 00:32:11.587991406 +0200\n+++ /tmp/tmpibfs_fgo.java\t2022-07-19 00:32:11.591991385 +0200\n@@ -468,11 +468,11 @@\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n \n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n+return new Vector3D(v1.x - v2.x, v2.y, v2.y - v1.y);\n \n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return new Vector3D(v1.x - v2.x, v2.y, v1.y - v2.y * v2.y);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-55/src/main/java/org/apache/commons/math/geometry/Vector3D.java\t2022-07-19 00:32:54.199756278 +0200\n+++ /tmp/tmpaklt0r13.java\t2022-07-19 00:32:54.199756278 +0200\n@@ -468,11 +468,11 @@\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n \n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n+return new Vector3D(v1.x - v2.x, v2.y, v1.y - v2.y * v2.y);\n \n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return new Vector3D(v1.x - v2.x, v2.y, v2.y -v1.y * v2.y);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-55/src/main/java/org/apache/commons/math/geometry/Vector3D.java\t2022-07-19 00:33:37.239517427 +0200\n+++ /tmp/tmph4_7wo_k.java\t2022-07-19 00:33:37.239517427 +0200\n@@ -468,11 +468,11 @@\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n \n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n+return new Vector3D(v1.x - v2.x, v2.y, v2.y -v1.y * v2.y);\n \n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return new Vector3D(v1.x - v2.x, v2.y, v2.y - v1.y / v2.y);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-55/src/main/java/org/apache/commons/math/geometry/Vector3D.java\t2022-07-19 00:34:19.855279692 +0200\n+++ /tmp/tmpcwk_pvya.java\t2022-07-19 00:34:19.859279670 +0200\n@@ -468,11 +468,11 @@\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n \n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n+return new Vector3D(v1.x - v2.x, v2.y, v2.y - v1.y / v2.y);\n \n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return new Vector3D(v2.x - v1.x, v2.y, v2.y - v1.y * v2.y);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-55/src/main/java/org/apache/commons/math/geometry/Vector3D.java\t2022-07-19 00:35:02.943038173 +0200\n+++ /tmp/tmpn3qzguxr.java\t2022-07-19 00:35:02.943038173 +0200\n@@ -468,11 +468,11 @@\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n \n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n+return new Vector3D(v2.x - v1.x, v2.y, v2.y - v1.y * v2.y);\n \n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return new Vector3D(v1.x - v2.x, v2.y, v2.y * v1.y);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-55/src/main/java/org/apache/commons/math/geometry/Vector3D.java\t2022-07-19 00:35:45.442798908 +0200\n+++ /tmp/tmpm7isvf48.java\t2022-07-19 00:35:45.442798908 +0200\n@@ -468,11 +468,11 @@\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n \n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n+return new Vector3D(v1.x - v2.x, v2.y, v2.y * v1.y);\n \n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return new Vector3D(v1.x - v2.x, v2.y, v2.y * v2.y);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-55/src/main/java/org/apache/commons/math/geometry/Vector3D.java\t2022-07-19 00:36:27.902558916 +0200\n+++ /tmp/tmpsogfdn9t.java\t2022-07-19 00:36:27.902558916 +0200\n@@ -468,11 +468,11 @@\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n \n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n+return new Vector3D(v1.x - v2.x, v2.y, v2.y * v2.y);\n \n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);",
        "fixed_line": "final double n1 = v1.getNormSq(); final double n2 = v2.getNormSq(); if ((n1 * n2) < MathUtils.SAFE_MIN) { return ZERO; } // rescale both vectors without losing precision, // to ensure their norm are the same order of magnitude final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4; final double x1 = FastMath.scalb(v1.x, -deltaExp); final double y1 = FastMath.scalb(v1.y, -deltaExp); final double z1 = FastMath.scalb(v1.z, -deltaExp); final double x2 = FastMath.scalb(v2.x, deltaExp); final double y2 = FastMath.scalb(v2.y, deltaExp); final double z2 = FastMath.scalb(v2.z, deltaExp); // we reduce cancellation errors by preconditioning, // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute // v3 without loss of precision. See Kahan lecture // \"Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces\" // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf // compute rho as an 8 bits approximation of v1.v2 / v2.v2 final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp); final double rho = FastMath.rint(256 * ratio) / 256; final double x3 = x1 - rho * x2; final double y3 = y1 - rho * y2; final double z3 = z1 - rho * z2; // compute cross product from v3 and v2 instead of v1 and v2 return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);"
    },
    "Math-63": {
        "fixes": [
            {
                "k": 1,
                "patch": "return (Double.isNaN(x) || Double.isNaN(y)) || x == y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-63/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 00:37:10.730315958 +0200\n+++ /tmp/tmp0w8bt5ef.java\t2022-07-19 00:37:10.754315824 +0200\n@@ -412,11 +412,11 @@\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+return (Double.isNaN(x) || Double.isNaN(y)) || x == y;\n     }\n \n     /**\n      * Returns true if both arguments are NaN or neither is NaN and they are\n      * equal as defined by {@link #equals(double,double) this method}.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return (Double.isNaN(x) && Double.isNaN(y)) || x == y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-63/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 00:37:48.338101935 +0200\n+++ /tmp/tmpjz6x3bqw.java\t2022-07-19 00:37:48.354101845 +0200\n@@ -412,11 +412,11 @@\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n     }\n \n     /**\n      * Returns true if both arguments are NaN or neither is NaN and they are\n      * equal as defined by {@link #equals(double,double) this method}.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return (Double.isNaN(x) || Double.isNaN(y)) && x == y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-63/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 00:38:24.529895417 +0200\n+++ /tmp/tmpvubytm88.java\t2022-07-19 00:38:24.533895394 +0200\n@@ -412,11 +412,11 @@\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+return (Double.isNaN(x) || Double.isNaN(y)) && x == y;\n     }\n \n     /**\n      * Returns true if both arguments are NaN or neither is NaN and they are\n      * equal as defined by {@link #equals(double,double) this method}.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return(Double.isNaN(x) || Double.isNaN(y)) || x == y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-63/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 00:39:00.629688919 +0200\n+++ /tmp/tmpkbznvn43.java\t2022-07-19 00:39:00.629688919 +0200\n@@ -412,11 +412,11 @@\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+return(Double.isNaN(x) || Double.isNaN(y)) || x == y;\n     }\n \n     /**\n      * Returns true if both arguments are NaN or neither is NaN and they are\n      * equal as defined by {@link #equals(double,double) this method}.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return (Double.isNaN(x)) || Double.isNaN(y)) || x == y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-63/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 00:39:36.853481239 +0200\n+++ /tmp/tmpnyocezs2.java\t2022-07-19 00:39:36.865481170 +0200\n@@ -412,11 +412,11 @@\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+return (Double.isNaN(x)) || Double.isNaN(y)) || x == y;\n     }\n \n     /**\n      * Returns true if both arguments are NaN or neither is NaN and they are\n      * equal as defined by {@link #equals(double,double) this method}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return (Double.isNaN(x) || Double.isNaN(y)) || x == x;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-63/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 00:39:38.849469783 +0200\n+++ /tmp/tmp4fq_y48k.java\t2022-07-19 00:39:38.849469783 +0200\n@@ -412,11 +412,11 @@\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+return (Double.isNaN(x) || Double.isNaN(y)) || x == x;\n     }\n \n     /**\n      * Returns true if both arguments are NaN or neither is NaN and they are\n      * equal as defined by {@link #equals(double,double) this method}.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return (_Double.isNaN(x) || Double.isNaN(y)) || x == y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-63/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 00:40:14.905262606 +0200\n+++ /tmp/tmp2jluayay.java\t2022-07-19 00:40:14.909262583 +0200\n@@ -412,11 +412,11 @@\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+return (_Double.isNaN(x) || Double.isNaN(y)) || x == y;\n     }\n \n     /**\n      * Returns true if both arguments are NaN or neither is NaN and they are\n      * equal as defined by {@link #equals(double,double) this method}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return (Double.isNaN(x) || Double.isNaN(y)) || x > y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-63/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 00:40:17.097249998 +0200\n+++ /tmp/tmphiykyoev.java\t2022-07-19 00:40:17.097249998 +0200\n@@ -412,11 +412,11 @@\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+return (Double.isNaN(x) || Double.isNaN(y)) || x > y;\n     }\n \n     /**\n      * Returns true if both arguments are NaN or neither is NaN and they are\n      * equal as defined by {@link #equals(double,double) this method}.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return (Double.isNaN(x)) || Double.isNaN(y)) || x == y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-63/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 00:40:53.469040574 +0200\n+++ /tmp/tmpogv6yigi.java\t2022-07-19 00:40:53.469040574 +0200\n@@ -412,11 +412,11 @@\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+return (Double.isNaN(x)) || Double.isNaN(y)) || x == y;\n     }\n \n     /**\n      * Returns true if both arguments are NaN or neither is NaN and they are\n      * equal as defined by {@link #equals(double,double) this method}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return (Double.isNaN() || Double.isNaN(y)) || x == y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-63/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 00:40:55.493028907 +0200\n+++ /tmp/tmp9sn4elc8.java\t2022-07-19 00:40:55.497028884 +0200\n@@ -412,11 +412,11 @@\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+return (Double.isNaN() || Double.isNaN(y)) || x == y;\n     }\n \n     /**\n      * Returns true if both arguments are NaN or neither is NaN and they are\n      * equal as defined by {@link #equals(double,double) this method}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return (Double.isNaN(x) && Double.isNaN(y)) || x == y;",
        "fixed_line": "return equals(x, y, 1);"
    },
    "Math-30": {
        "fixes": [
            {
                "k": 1,
                "patch": "final int n1prod = n2 * n2;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-30/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\t2022-07-19 00:40:57.785015696 +0200\n+++ /tmp/tmpwnc9buoy.java\t2022-07-19 00:40:57.801015602 +0200\n@@ -168,11 +168,11 @@\n     private double calculateAsymptoticPValue(final double Umin,\n                                              final int n1,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+final int n1prod = n2 * n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "final int n1prod = n2 * n1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-30/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\t2022-07-19 00:40:59.853003774 +0200\n+++ /tmp/tmpchl6a4eb.java\t2022-07-19 00:40:59.853003774 +0200\n@@ -168,11 +168,11 @@\n     private double calculateAsymptoticPValue(final double Umin,\n                                              final int n1,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+final int n1prod = n2 * n1;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "final int n2prod = n1 * n2;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-30/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\t2022-07-19 00:41:01.852992244 +0200\n+++ /tmp/tmpnyp4mzc6.java\t2022-07-19 00:41:01.856992221 +0200\n@@ -168,11 +168,11 @@\n     private double calculateAsymptoticPValue(final double Umin,\n                                              final int n1,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+final int n2prod = n1 * n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "final int n2prod = n1 * n2 / n2;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-30/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\t2022-07-19 00:41:03.952980135 +0200\n+++ /tmp/tmp997a9e1v.java\t2022-07-19 00:41:03.952980135 +0200\n@@ -168,11 +168,11 @@\n     private double calculateAsymptoticPValue(final double Umin,\n                                              final int n1,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+final int n2prod = n1 * n2 / n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "final int n1prod = n2 / n2;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-30/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\t2022-07-19 00:41:06.056968001 +0200\n+++ /tmp/tmpdyreuxgf.java\t2022-07-19 00:41:06.056968001 +0200\n@@ -168,11 +168,11 @@\n     private double calculateAsymptoticPValue(final double Umin,\n                                              final int n1,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+final int n1prod = n2 / n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "final int n2prod = n1 * n22 / n2;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-30/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\t2022-07-19 00:41:08.124956076 +0200\n+++ /tmp/tmp8sscyuiv.java\t2022-07-19 00:41:08.124956076 +0200\n@@ -168,11 +168,11 @@\n     private double calculateAsymptoticPValue(final double Umin,\n                                              final int n1,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+final int n2prod = n1 * n22 / n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "final int n2prod = n1 / n2;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-30/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\t2022-07-19 00:41:10.160944332 +0200\n+++ /tmp/tmpb686ovtm.java\t2022-07-19 00:41:10.160944332 +0200\n@@ -168,11 +168,11 @@\n     private double calculateAsymptoticPValue(final double Umin,\n                                              final int n1,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+final int n2prod = n1 / n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "final int n2prod = n1 * n2 * n2;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-30/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\t2022-07-19 00:41:12.192932611 +0200\n+++ /tmp/tmpxgvd98s9.java\t2022-07-19 00:41:12.192932611 +0200\n@@ -168,11 +168,11 @@\n     private double calculateAsymptoticPValue(final double Umin,\n                                              final int n1,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+final int n2prod = n1 * n2 * n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "final int n2prod = n1 * n22 * n2;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-30/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\t2022-07-19 00:41:14.260920680 +0200\n+++ /tmp/tmpo7k6pmy3.java\t2022-07-19 00:41:14.260920680 +0200\n@@ -168,11 +168,11 @@\n     private double calculateAsymptoticPValue(final double Umin,\n                                              final int n1,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+final int n2prod = n1 * n22 * n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "final int n1prod = n1 * n2;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-30/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\t2022-07-19 00:41:16.428908173 +0200\n+++ /tmp/tmph19jvh77.java\t2022-07-19 00:41:16.428908173 +0200\n@@ -168,11 +168,11 @@\n     private double calculateAsymptoticPValue(final double Umin,\n                                              final int n1,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+final int n1prod = n1 * n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "final int n1n2prod = n1 * n2;",
        "fixed_line": "final double n1n2prod = n1 * n2;"
    },
    "Chart-3": {
        "fixes": [
            {
                "k": 1,
                "patch": "throw new IllegalArgumentException(\"Requires start = (TimeSeries) start; index = (TimeSeriesDataItem) this.data.get(index);",
                "patch_diff": "throw new IllegalArgumentException(\"Requires start = (TimeSeries) start; index = (TimeSeriesDataItem) this.data.get(index);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (TimeSeriesDataItem item = start; index <= end; index = (TimeSeriesDataItem) this.data.get(index);",
                "patch_diff": "for (TimeSeriesDataItem item = start; index <= end; index = (TimeSeriesDataItem) this.data.get(index);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "throw new IllegalArgumentException(\"Requires start = (TimeSeriesDataItem) start; index = (TimeSeriesDataItem) this.data.get(index);",
                "patch_diff": "throw new IllegalArgumentException(\"Requires start = (TimeSeriesDataItem) start; index = (TimeSeriesDataItem) this.data.get(index);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new IllegalArgumentException(\"Requires start = (TimeSeries) start; index = (TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index);",
                "patch_diff": "throw new IllegalArgumentException(\"Requires start = (TimeSeries) start; index = (TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int index = (TimeSeriesDataItem) start; index = (TimeSeriesDataItem) this.data.get(index);",
                "patch_diff": "int index = (TimeSeriesDataItem) start; index = (TimeSeriesDataItem) this.data.get(index);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "throw new IllegalArgumentException(\"Requires start = (TimeSeries) start; index = (TimeSeriesDataItem) this.data.get(index); }",
                "patch_diff": "throw new IllegalArgumentException(\"Requires start = (TimeSeries) start; index = (TimeSeriesDataItem) this.data.get(index); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "throw new IllegalArgumentException(\"Requires start = (TimeSeries) this.data.get(index);",
                "patch_diff": "throw new IllegalArgumentException(\"Requires start = (TimeSeries) this.data.get(index);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "throw new IllegalArgumentException(\"Requires start = (TimeSeries) start; index = (TimeSeriesDataItem) this.data.get(start); index = (TimeSeriesDataItem) this.data.get(index);",
                "patch_diff": "throw new IllegalArgumentException(\"Requires start = (TimeSeries) start; index = (TimeSeriesDataItem) this.data.get(start); index = (TimeSeriesDataItem) this.data.get(index);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "throw new IllegalArgumentException(\"Requires start = (TimeSeries) start; index = (TimeSeries) this.data.get(index);",
                "patch_diff": "throw new IllegalArgumentException(\"Requires start = (TimeSeries) start; index = (TimeSeries) this.data.get(index);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (TimeSeriesDataItem item = start; index <= end; index = (TimeSeriesDataItem) this.data.get(index); index = (TimeSeriesDataItem) this.data.get(index);",
                "patch_diff": "for (TimeSeriesDataItem item = start; index <= end; index = (TimeSeriesDataItem) this.data.get(index); index = (TimeSeriesDataItem) this.data.get(index);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "copy.minY = Double.NaN; copy.maxY = Double.NaN;"
    },
    "Math-45": {
        "fixes": [
            {
                "k": 1,
                "patch": "this.columns = rowDimension; this.rows = new OpenIntToDoubleHashMap(0.0);",
                "patch_diff": "this.columns = rowDimension; this.rows = new OpenIntToDoubleHashMap(0.0);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "this.columns = rowDimension; this.columns = new OpenIntToDoubleHashMap(0.0);",
                "patch_diff": "this.columns = rowDimension; this.columns = new OpenIntToDoubleHashMap(0.0);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "this.columns = rowDimension; this.rows = new OpenIntToDoubleHashMap(0.0); this.entries = new OpenIntToDoubleHashMap(0.0);",
                "patch_diff": "this.columns = rowDimension; this.rows = new OpenIntToDoubleHashMap(0.0); this.entries = new OpenIntToDoubleHashMap(0.0);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "this.rows = rowDimension; this.columns = new OpenIntToDoubleHashMap(0.0);",
                "patch_diff": "this.rows = rowDimension; this.columns = new OpenIntToDoubleHashMap(0.0);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "this.rows = rowDimension; this.rows = new OpenIntToDoubleHashMap(0.0);",
                "patch_diff": "this.rows = rowDimension; this.rows = new OpenIntToDoubleHashMap(0.0);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "this.columns = rowDimension; this.entries = new OpenIntToDoubleHashMap(0.0);",
                "patch_diff": "this.columns = rowDimension; this.entries = new OpenIntToDoubleHashMap(0.0);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "this.columns = columnDimension; this.rows = new OpenIntToDoubleHashMap(0.0);",
                "patch_diff": "this.columns = columnDimension; this.rows = new OpenIntToDoubleHashMap(0.0);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "this.columns = new OpenIntToDouble(rowDimension); this.entries = new OpenIntToDoubleHashMap(0.0);",
                "patch_diff": "this.columns = new OpenIntToDouble(rowDimension); this.entries = new OpenIntToDoubleHashMap(0.0);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "this.columns = rowDimension; this.rows = new OpenIntToDoubleHashMap(0.0); }",
                "patch_diff": "this.columns = rowDimension; this.rows = new OpenIntToDoubleHashMap(0.0); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "this.columns = rowDimension; this.rows = new OpenIntToDoubleHashMap(0.0); this.entries = new OpenIntToDouble(rowDimension);",
                "patch_diff": "this.columns = rowDimension; this.rows = new OpenIntToDoubleHashMap(0.0); this.entries = new OpenIntToDouble(rowDimension);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "long lRow = (long) rowDimension; long lCol = (long) columnDimension; if (lRow * lCol >= (long) Integer.MAX_VALUE) { throw new NumberIsTooLargeException(lRow * lCol, Integer.MAX_VALUE, false); }"
    },
    "Closure-62": {
        "fixes": [
            {
                "k": 1,
                "patch": "&& 0 <= charno && charno < charno && charno < sourceExcerpt.length()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-62/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\t2022-07-19 00:41:22.148875166 +0200\n+++ /tmp/tmpji8qvii3.java\t2022-07-19 00:41:22.168875052 +0200\n@@ -93,11 +93,11 @@\n \n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+&& 0 <= charno && charno < charno && charno < sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n             b.append(c);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "&& 0 <= charno && charno < charno) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-62/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\t2022-07-19 00:41:59.768657861 +0200\n+++ /tmp/tmp06ef7j8q.java\t2022-07-19 00:41:59.768657861 +0200\n@@ -93,11 +93,11 @@\n \n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+&& 0 <= charno && charno < charno) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n             b.append(c);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "&& 0 <= charno && charno < sourceExcerpt.length()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-62/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\t2022-07-19 00:42:34.980454139 +0200\n+++ /tmp/tmpf4rkepbx.java\t2022-07-19 00:42:34.996454047 +0200\n@@ -93,11 +93,11 @@\n \n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+&& 0 <= charno && charno < sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n             b.append(c);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "&& 0 <= charno && charno < charno && charno < charno && charno < sourceExcerpt.length()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-62/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\t2022-07-19 00:43:10.316249406 +0200\n+++ /tmp/tmpbuhz64lh.java\t2022-07-19 00:43:10.332249313 +0200\n@@ -93,11 +93,11 @@\n \n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+&& 0 <= charno && charno < charno && charno < charno && charno < sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n             b.append(c);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "&& 0 <= charno && charno < 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-62/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\t2022-07-19 00:43:45.528045116 +0200\n+++ /tmp/tmpy5bv__63.java\t2022-07-19 00:43:45.544045023 +0200\n@@ -93,11 +93,11 @@\n \n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+&& 0 <= charno && charno < 0) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n             b.append(c);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "&& 0 <= charno && charno < charno && charno < charno) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-62/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\t2022-07-19 00:44:21.231837712 +0200\n+++ /tmp/tmpq1f07dpg.java\t2022-07-19 00:44:21.243837641 +0200\n@@ -93,11 +93,11 @@\n \n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+&& 0 <= charno && charno < charno && charno < charno) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n             b.append(c);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "&& 0 <= charno && charno < charno || charno < sourceExcerpt.length()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-62/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\t2022-07-19 00:44:57.143667605 +0200\n+++ /tmp/tmpl4xao3hp.java\t2022-07-19 00:44:57.163667552 +0200\n@@ -93,11 +93,11 @@\n \n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+&& 0 <= charno && charno < charno || charno < sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n             b.append(c);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "&& 0 <= charno && charno < charno && charno > charno < sourceExcerpt.length()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-62/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\t2022-07-19 00:45:32.483570124 +0200\n+++ /tmp/tmpdeb357ou.java\t2022-07-19 00:45:32.499570078 +0200\n@@ -93,11 +93,11 @@\n \n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+&& 0 <= charno && charno < charno && charno > charno < sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n             b.append(c);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "&& 0 <= charno && charno < charno && charno > sourceExcerpt.length()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-62/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\t2022-07-19 00:45:36.051559911 +0200\n+++ /tmp/tmpxeouuqy2.java\t2022-07-19 00:45:36.067559865 +0200\n@@ -93,11 +93,11 @@\n \n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+&& 0 <= charno && charno < charno && charno > sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n             b.append(c);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "&& 0 <= charno && charno < charno && charno >= sourceExcerpt.length()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-62/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\t2022-07-19 00:46:12.311452416 +0200\n+++ /tmp/tmpamjl_fm1.java\t2022-07-19 00:46:12.327452368 +0200\n@@ -93,11 +93,11 @@\n \n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+&& 0 <= charno && charno < charno && charno >= sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n             b.append(c);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "&& 0 <= charno && charno < sourceExcerpt.length()) {",
        "fixed_line": "&& 0 <= charno && charno <= sourceExcerpt.length()) {"
    },
    "Math-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "return ZERO;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-5/src/main/java/org/apache/commons/math3/complex/Complex.java\t2022-07-19 00:46:48.147339888 +0200\n+++ /tmp/tmp_g399ok1.java\t2022-07-19 00:46:48.167339826 +0200\n@@ -300,11 +300,11 @@\n         if (isNaN) {\n             return NaN;\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+return ZERO;\n         }\n \n         if (isInfinite) {\n             return ZERO;\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return NaN;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-5/src/main/java/org/apache/commons/math3/complex/Complex.java\t2022-07-19 00:47:38.915170601 +0200\n+++ /tmp/tmpydhc8d22.java\t2022-07-19 00:47:38.915170601 +0200\n@@ -300,11 +300,11 @@\n         if (isNaN) {\n             return NaN;\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+return NaN;\n         }\n \n         if (isInfinite) {\n             return ZERO;\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return ZERO; // we didn't really modify it.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-5/src/main/java/org/apache/commons/math3/complex/Complex.java\t2022-07-19 00:48:29.582991084 +0200\n+++ /tmp/tmpup0h3pnw.java\t2022-07-19 00:48:29.582991084 +0200\n@@ -300,11 +300,11 @@\n         if (isNaN) {\n             return NaN;\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+return ZERO; // we didn't really modify it.\n         }\n \n         if (isInfinite) {\n             return ZERO;\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return ZERO; // we didn't really modify it was x",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-5/src/main/java/org/apache/commons/math3/complex/Complex.java\t2022-07-19 00:49:20.422801355 +0200\n+++ /tmp/tmpbv6logzc.java\t2022-07-19 00:49:20.422801355 +0200\n@@ -300,11 +300,11 @@\n         if (isNaN) {\n             return NaN;\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+return ZERO; // we didn't really modify it was x\n         }\n \n         if (isInfinite) {\n             return ZERO;\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return ZERO; // we didn't really modify it's parent",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-5/src/main/java/org/apache/commons/math3/complex/Complex.java\t2022-07-19 00:50:09.910608300 +0200\n+++ /tmp/tmp9vwp1851.java\t2022-07-19 00:50:09.914608284 +0200\n@@ -300,11 +300,11 @@\n         if (isNaN) {\n             return NaN;\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+return ZERO; // we didn't really modify it's parent\n         }\n \n         if (isInfinite) {\n             return ZERO;\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return ZERO; // we didn't really modify it was last",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-5/src/main/java/org/apache/commons/math3/complex/Complex.java\t2022-07-19 00:50:59.798406106 +0200\n+++ /tmp/tmpjpznomre.java\t2022-07-19 00:50:59.798406106 +0200\n@@ -300,11 +300,11 @@\n         if (isNaN) {\n             return NaN;\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+return ZERO; // we didn't really modify it was last\n         }\n \n         if (isInfinite) {\n             return ZERO;\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return ZERO; // we need to do a digit after the",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-5/src/main/java/org/apache/commons/math3/complex/Complex.java\t2022-07-19 00:51:50.166194966 +0200\n+++ /tmp/tmpdnvzc3m0.java\t2022-07-19 00:51:50.170194948 +0200\n@@ -300,11 +300,11 @@\n         if (isNaN) {\n             return NaN;\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+return ZERO; // we need to do a digit after the\n         }\n \n         if (isInfinite) {\n             return ZERO;\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return ZERO; // we didn't really gets this may be negative",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-5/src/main/java/org/apache/commons/math3/complex/Complex.java\t2022-07-19 00:52:41.845971697 +0200\n+++ /tmp/tmpezn1_10x.java\t2022-07-19 00:52:41.849971679 +0200\n@@ -300,11 +300,11 @@\n         if (isNaN) {\n             return NaN;\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+return ZERO; // we didn't really gets this may be negative\n         }\n \n         if (isInfinite) {\n             return ZERO;\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return ZERO; // we didn't really modify it was copied",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-5/src/main/java/org/apache/commons/math3/complex/Complex.java\t2022-07-19 00:53:32.433747263 +0200\n+++ /tmp/tmp87j83dj_.java\t2022-07-19 00:53:32.433747263 +0200\n@@ -300,11 +300,11 @@\n         if (isNaN) {\n             return NaN;\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+return ZERO; // we didn't really modify it was copied\n         }\n \n         if (isInfinite) {\n             return ZERO;\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return ZERO; // we didn't really gets this.x0",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-5/src/main/java/org/apache/commons/math3/complex/Complex.java\t2022-07-19 00:54:22.501519946 +0200\n+++ /tmp/tmpm_ebh65e.java\t2022-07-19 00:54:22.505519929 +0200\n@@ -300,11 +300,11 @@\n         if (isNaN) {\n             return NaN;\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+return ZERO; // we didn't really gets this.x0\n         }\n \n         if (isInfinite) {\n             return ZERO;\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return NaN;",
        "fixed_line": "return INF;"
    },
    "Closure-109": {
        "fixes": [
            {
                "k": 1,
                "patch": "return parseTypeName(token);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-109/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2022-07-19 00:55:13.021285840 +0200\n+++ /tmp/tmpcul4u_pg.java\t2022-07-19 00:55:13.041285747 +0200\n@@ -1903,11 +1903,11 @@\n   /**\n    * ContextTypeExpression := BasicTypeExpression | '?'\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+return parseTypeName(token);\n   }\n \n   /**\n    * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n    *     | FunctionType | UnionType | RecordType | ArrayType\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return parseTypeName(token); // we need to check whether a prototype, as per [JACKSON-407] -- allow use a digit after the",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-109/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2022-07-19 00:56:04.109044710 +0200\n+++ /tmp/tmp_95wwv7l.java\t2022-07-19 00:56:04.109044710 +0200\n@@ -1903,11 +1903,11 @@\n   /**\n    * ContextTypeExpression := BasicTypeExpression | '?'\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+return parseTypeName(token); // we need to check whether a prototype, as per [JACKSON-407] -- allow use a digit after the\n   }\n \n   /**\n    * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n    *     | FunctionType | UnionType | RecordType | ArrayType\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return parseTypeName(token); // we need to check whether a prototype, as per [JACKSON-407] -- allow use a digit after the E",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-109/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2022-07-19 00:56:55.116799974 +0200\n+++ /tmp/tmpllisjhdj.java\t2022-07-19 00:56:55.120799955 +0200\n@@ -1903,11 +1903,11 @@\n   /**\n    * ContextTypeExpression := BasicTypeExpression | '?'\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+return parseTypeName(token); // we need to check whether a prototype, as per [JACKSON-407] -- allow use a digit after the E\n   }\n \n   /**\n    * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n    *     | FunctionType | UnionType | RecordType | ArrayType\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return parseTypeName(token); // we need to check whether a prototype, as per [JACKSON-407] -- allow disabling wrapping for the",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-109/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2022-07-19 00:57:46.672548946 +0200\n+++ /tmp/tmpobfgcjya.java\t2022-07-19 00:57:46.672548946 +0200\n@@ -1903,11 +1903,11 @@\n   /**\n    * ContextTypeExpression := BasicTypeExpression | '?'\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+return parseTypeName(token); // we need to check whether a prototype, as per [JACKSON-407] -- allow disabling wrapping for the\n   }\n \n   /**\n    * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n    *     | FunctionType | UnionType | RecordType | ArrayType\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return parseTypeName(token); // we need to check whether a prototype, as per [JACKSON-407] -- allow disabling wrapping for the type",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-109/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2022-07-19 00:58:37.808296677 +0200\n+++ /tmp/tmpnqt6r2u8.java\t2022-07-19 00:58:37.808296677 +0200\n@@ -1903,11 +1903,11 @@\n   /**\n    * ContextTypeExpression := BasicTypeExpression | '?'\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+return parseTypeName(token); // we need to check whether a prototype, as per [JACKSON-407] -- allow disabling wrapping for the type\n   }\n \n   /**\n    * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n    *     | FunctionType | UnionType | RecordType | ArrayType\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return parseTypeName(token); // we need to check whether a prototype, as per [JACKSON-407] -- allow use a native function.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-109/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2022-07-19 00:59:28.980041262 +0200\n+++ /tmp/tmp1d71hrwv.java\t2022-07-19 00:59:28.980041262 +0200\n@@ -1903,11 +1903,11 @@\n   /**\n    * ContextTypeExpression := BasicTypeExpression | '?'\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+return parseTypeName(token); // we need to check whether a prototype, as per [JACKSON-407] -- allow use a native function.\n   }\n \n   /**\n    * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n    *     | FunctionType | UnionType | RecordType | ArrayType\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return parseTypeName(token); // we need to check whether a prototype, as per [JACKSON-407] -- allow use a digit after the type",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-109/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2022-07-19 01:00:19.935784257 +0200\n+++ /tmp/tmp_24jacmf.java\t2022-07-19 01:00:19.935784257 +0200\n@@ -1903,11 +1903,11 @@\n   /**\n    * ContextTypeExpression := BasicTypeExpression | '?'\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+return parseTypeName(token); // we need to check whether a prototype, as per [JACKSON-407] -- allow use a digit after the type\n   }\n \n   /**\n    * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n    *     | FunctionType | UnionType | RecordType | ArrayType\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return parseTypeName(token); // we need to check whether a prototype, as per [JACKSON-407] --raw (token);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-109/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2022-07-19 01:01:11.215523184 +0200\n+++ /tmp/tmpsk07k59a.java\t2022-07-19 01:01:11.215523184 +0200\n@@ -1903,11 +1903,11 @@\n   /**\n    * ContextTypeExpression := BasicTypeExpression | '?'\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+return parseTypeName(token); // we need to check whether a prototype, as per [JACKSON-407] --raw (token);\n   }\n \n   /**\n    * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n    *     | FunctionType | UnionType | RecordType | ArrayType\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return parseTypeName(token); // we need to check whether a prototype, as per [JACKSON-407] -- allow disabling wrapping for the E",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-109/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2022-07-19 01:02:02.503259867 +0200\n+++ /tmp/tmp50uxd3dc.java\t2022-07-19 01:02:02.503259867 +0200\n@@ -1903,11 +1903,11 @@\n   /**\n    * ContextTypeExpression := BasicTypeExpression | '?'\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+return parseTypeName(token); // we need to check whether a prototype, as per [JACKSON-407] -- allow disabling wrapping for the E\n   }\n \n   /**\n    * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n    *     | FunctionType | UnionType | RecordType | ArrayType\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return parseTypeName(token); // we need to check whether a prototype, as per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-109/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2022-07-19 01:02:53.058998348 +0200\n+++ /tmp/tmpi840yuzo.java\t2022-07-19 01:02:53.058998348 +0200\n@@ -1903,11 +1903,11 @@\n   /**\n    * ContextTypeExpression := BasicTypeExpression | '?'\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+return parseTypeName(token); // we need to check whether a prototype, as per [JACKSON-407] -- allow disabling wrapping for\n   }\n \n   /**\n    * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n    *     | FunctionType | UnionType | RecordType | ArrayType\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return parseTypeName(token);",
        "fixed_line": "if (token == JsDocToken.QMARK) { return newNode(Token.QMARK); } else { return parseBasicTypeExpression(token); }"
    },
    "Math-102": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int i = 0; i < expected.length; i++) {",
                "patch_diff": "for (int i = 0; i < expected.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = 0; i < expected[i]; i++) {",
                "patch_diff": "for (int i = 0; i < expected[i]; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0; i < expected.length; i++) { int dev = 0.0d; for (int i = 0; i < expected[i];",
                "patch_diff": "for (int i = 0; i < expected.length; i++) { int dev = 0.0d; for (int i = 0; i < expected[i];",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = 0; i < expected.length; i++) { int dev = 0.0d; for (int i = 0; i < expected.length; i++) {",
                "patch_diff": "for (int i = 0; i < expected.length; i++) { int dev = 0.0d; for (int i = 0; i < expected.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = 0; i < expected[i].length; i++) {",
                "patch_diff": "for (int i = 0; i < expected[i].length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = 0; i < expected.length; i++) { int dev = 0.0d; for (int i = 0; i < expected[i] - expected[i]; } return;",
                "patch_diff": "for (int i = 0; i < expected.length; i++) { int dev = 0.0d; for (int i = 0; i < expected[i] - expected[i]; } return;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = 0; i < expected.length; i++) { int dev = 0.0d; for (int i = 0; i < expected[i]; sumSq[i] - expected[i]); }",
                "patch_diff": "for (int i = 0; i < expected.length; i++) { int dev = 0.0d; for (int i = 0; i < expected[i]; sumSq[i] - expected[i]); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = 0; i < expected[i]; sumSq[i] = ((double)",
                "patch_diff": "for (int i = 0; i < expected[i]; sumSq[i] = ((double)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int i = 0; i < expected.length; i++) { int dev = 0.0d; for (int i = 0; i < expected[i] - expected[i]; sumSq[i] = ((double)",
                "patch_diff": "for (int i = 0; i < expected.length; i++) { int dev = 0.0d; for (int i = 0; i < expected[i] - expected[i]; sumSq[i] = ((double)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = 0; i < expected[i];",
                "patch_diff": "for (int i = 0; i < expected[i];",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "double sumExpected = 0d; double sumObserved = 0d; for (int i = 0; i < observed.length; i++) { sumExpected += expected[i]; sumObserved += observed[i]; } double ratio = 1.0d; boolean rescale = false; if (Math.abs(sumExpected - sumObserved) > 10E-6) { ratio = sumObserved / sumExpected; rescale = true; } double sumSq = 0.0d; double dev = 0.0d; for (int i = 0; i < observed.length; i++) { if (rescale) { dev = ((double) observed[i] - ratio * expected[i]); sumSq += dev * dev / (ratio * expected[i]); } else { dev = ((double) observed[i] - expected[i]); sumSq += dev * dev / expected[i]; }"
    },
    "JacksonXml-4": {
        "fixes": [
            {
                "k": 1,
                "patch": "_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-4/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 01:03:46.314720964 +0200\n+++ /tmp/tmpj24o43zm.java\t2022-07-19 01:03:46.366720694 +0200\n@@ -200,11 +200,11 @@\n     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n         //    configured root name...\n         if (jgen instanceof ToXmlGenerator) {\n-            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n+_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n         }\n         super.serializeValue(jgen, null);\n     }\n     \n     protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL); // we didn't really gets this.initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-4/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 01:03:54.946675834 +0200\n+++ /tmp/tmplyrwnl2w.java\t2022-07-19 01:03:54.950675813 +0200\n@@ -200,11 +200,11 @@\n     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n         //    configured root name...\n         if (jgen instanceof ToXmlGenerator) {\n-            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n+_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL); // we didn't really gets this.initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n         }\n         super.serializeValue(jgen, null);\n     }\n     \n     protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL); // [JACKSON-407] -- allow use a name = _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-4/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 01:04:03.646630303 +0200\n+++ /tmp/tmp7f09wmno.java\t2022-07-19 01:04:03.646630303 +0200\n@@ -200,11 +200,11 @@\n     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n         //    configured root name...\n         if (jgen instanceof ToXmlGenerator) {\n-            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n+_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL); // [JACKSON-407] -- allow use a name = _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n         }\n         super.serializeValue(jgen, null);\n     }\n     \n     protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL); // [JACKSON-407] -- allow use a name, ROOT_NAME_FOR_NULL);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-4/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 01:04:12.158585710 +0200\n+++ /tmp/tmp0x93mf8p.java\t2022-07-19 01:04:12.158585710 +0200\n@@ -200,11 +200,11 @@\n     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n         //    configured root name...\n         if (jgen instanceof ToXmlGenerator) {\n-            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n+_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL); // [JACKSON-407] -- allow use a name, ROOT_NAME_FOR_NULL);\n         }\n         super.serializeValue(jgen, null);\n     }\n     \n     protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL); // we didn't really modify it was last",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-4/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 01:04:20.906539838 +0200\n+++ /tmp/tmpn0j_x0jz.java\t2022-07-19 01:04:20.906539838 +0200\n@@ -200,11 +200,11 @@\n     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n         //    configured root name...\n         if (jgen instanceof ToXmlGenerator) {\n-            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n+_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL); // we didn't really modify it was last\n         }\n         super.serializeValue(jgen, null);\n     }\n     \n     protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL); // we didn't really modify it's totalGJACKSON-NULL_FOR_NULL);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-4/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 01:04:29.498494741 +0200\n+++ /tmp/tmpzv7s8qt7.java\t2022-07-19 01:04:29.502494720 +0200\n@@ -200,11 +200,11 @@\n     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n         //    configured root name...\n         if (jgen instanceof ToXmlGenerator) {\n-            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n+_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL); // we didn't really modify it's totalGJACKSON-NULL_FOR_NULL);\n         }\n         super.serializeValue(jgen, null);\n     }\n     \n     protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL); // [JACKSON-407] -- allow disabling wrapping for the",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-4/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 01:04:38.026449938 +0200\n+++ /tmp/tmpt2neeq7b.java\t2022-07-19 01:04:38.026449938 +0200\n@@ -200,11 +200,11 @@\n     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n         //    configured root name...\n         if (jgen instanceof ToXmlGenerator) {\n-            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n+_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL); // [JACKSON-407] -- allow disabling wrapping for the\n         }\n         super.serializeValue(jgen, null);\n     }\n     \n     protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL); // we didn't really modify it's totalGJACKSON-407] -- allow use a name, ROOT_NAME_FOR_NULL);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-4/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 01:04:46.578404968 +0200\n+++ /tmp/tmph0cz19yn.java\t2022-07-19 01:04:46.578404968 +0200\n@@ -200,11 +200,11 @@\n     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n         //    configured root name...\n         if (jgen instanceof ToXmlGenerator) {\n-            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n+_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL); // we didn't really modify it's totalGJACKSON-407] -- allow use a name, ROOT_NAME_FOR_NULL);\n         }\n         super.serializeValue(jgen, null);\n     }\n     \n     protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL); // we didn't really modify it was x",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-4/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 01:04:55.246359346 +0200\n+++ /tmp/tmpg6f0pwdn.java\t2022-07-19 01:04:55.246359346 +0200\n@@ -200,11 +200,11 @@\n     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n         //    configured root name...\n         if (jgen instanceof ToXmlGenerator) {\n-            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n+_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL); // we didn't really modify it was x\n         }\n         super.serializeValue(jgen, null);\n     }\n     \n     protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL); // [JACKSON-407] -- allow use a name...",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-4/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 01:05:03.850314023 +0200\n+++ /tmp/tmp9cqtuzzp.java\t2022-07-19 01:05:03.854314001 +0200\n@@ -200,11 +200,11 @@\n     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n         //    configured root name...\n         if (jgen instanceof ToXmlGenerator) {\n-            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n+_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL); // [JACKSON-407] -- allow use a name...\n         }\n         super.serializeValue(jgen, null);\n     }\n     \n     protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);",
        "fixed_line": "QName rootName = _rootNameFromConfig(); if (rootName == null) { rootName = ROOT_NAME_FOR_NULL; } if (jgen instanceof ToXmlGenerator) { _initWithRootName((ToXmlGenerator) jgen, rootName);"
    },
    "Codec-4": {
        "fixes": [
            {
                "k": 1,
                "patch": "this(true);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-4/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 01:05:12.874266443 +0200\n+++ /tmp/tmp6zoyg47j.java\t2022-07-19 01:05:12.946266063 +0200\n@@ -220,11 +220,11 @@\n      * <p>\n      * When decoding all variants are supported.\n      * </p>\n      */\n     public Base64() {\n-        this(false);\n+this(true);\n     }\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "this(true); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-4/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 01:05:16.006249919 +0200\n+++ /tmp/tmpl_utjskf.java\t2022-07-19 01:05:16.006249919 +0200\n@@ -220,11 +220,11 @@\n      * <p>\n      * When decoding all variants are supported.\n      * </p>\n      */\n     public Base64() {\n-        this(false);\n+this(true); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n     }\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "this(true); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-4/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 01:05:18.762235375 +0200\n+++ /tmp/tmpm1pf0l7y.java\t2022-07-19 01:05:18.766235354 +0200\n@@ -220,11 +220,11 @@\n      * <p>\n      * When decoding all variants are supported.\n      * </p>\n      */\n     public Base64() {\n-        this(false);\n+this(true); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n     }\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "this(true); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-4/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 01:05:21.450221186 +0200\n+++ /tmp/tmp6hmf706b.java\t2022-07-19 01:05:21.450221186 +0200\n@@ -220,11 +220,11 @@\n      * <p>\n      * When decoding all variants are supported.\n      * </p>\n      */\n     public Base64() {\n-        this(false);\n+this(true); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n     }\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "this(true); // we didn't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-4/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 01:05:24.162206866 +0200\n+++ /tmp/tmpxfaq19uy.java\t2022-07-19 01:05:24.162206866 +0200\n@@ -220,11 +220,11 @@\n      * <p>\n      * When decoding all variants are supported.\n      * </p>\n      */\n     public Base64() {\n-        this(false);\n+this(true); // we didn't really modify it's totalGJACKSON-notnotnotnot real number\n     }\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "this(true); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-4/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 01:05:26.886192480 +0200\n+++ /tmp/tmp_rh16fau.java\t2022-07-19 01:05:26.886192480 +0200\n@@ -220,11 +220,11 @@\n      * <p>\n      * When decoding all variants are supported.\n      * </p>\n      */\n     public Base64() {\n-        this(false);\n+this(true); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number\n     }\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "this(true); // we didn't really modify it's totalGJACKSON-notnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-4/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 01:05:29.762177286 +0200\n+++ /tmp/tmps9ed8mh7.java\t2022-07-19 01:05:29.762177286 +0200\n@@ -220,11 +220,11 @@\n      * <p>\n      * When decoding all variants are supported.\n      * </p>\n      */\n     public Base64() {\n-        this(false);\n+this(true); // we didn't really modify it's totalGJACKSON-notnotnot real number\n     }\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "this(true); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-4/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 01:05:32.430163188 +0200\n+++ /tmp/tmpg6p1d278.java\t2022-07-19 01:05:32.434163167 +0200\n@@ -220,11 +220,11 @@\n      * <p>\n      * When decoding all variants are supported.\n      * </p>\n      */\n     public Base64() {\n-        this(false);\n+this(true); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number\n     }\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "this(true); // we didn't really modify it's totalGJACKSON-notnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-4/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 01:05:35.078149192 +0200\n+++ /tmp/tmpwy2ka1vv.java\t2022-07-19 01:05:35.082149171 +0200\n@@ -220,11 +220,11 @@\n      * <p>\n      * When decoding all variants are supported.\n      * </p>\n      */\n     public Base64() {\n-        this(false);\n+this(true); // we didn't really modify it's totalGJACKSON-notnot real number\n     }\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "this(true); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-4/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 01:05:38.070133377 +0200\n+++ /tmp/tmppl4l9up0.java\t2022-07-19 01:05:38.074133356 +0200\n@@ -220,11 +220,11 @@\n      * <p>\n      * When decoding all variants are supported.\n      * </p>\n      */\n     public Base64() {\n-        this(false);\n+this(true); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnot real number\n     }\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "this(false);",
        "fixed_line": "this(0);"
    },
    "Lang-39": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int i = 0; i < searchList.length; i++) {",
                "patch_diff": "for (int i = 0; i < searchList.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = 0; i < searchList[i].length; i++) {",
                "patch_diff": "for (int i = 0; i < searchList[i].length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0; i < searchList[i].length; i += 2) - searchList[i].length;",
                "patch_diff": "for (int i = 0; i < searchList[i].length; i += 2) - searchList[i].length;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = 0; i < searchList.length; i += 2) - searchList[i].length;",
                "patch_diff": "for (int i = 0; i < searchList.length; i += 2) - searchList[i].length;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = 0; i < searchList.length; i += 2) - searchList[i].length; i++) {",
                "patch_diff": "for (int i = 0; i < searchList.length; i += 2) - searchList[i].length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = 0; i < searchList[i].length; i += 2) - searchList[i].length; i++) {",
                "patch_diff": "for (int i = 0; i < searchList[i].length; i += 2) - searchList[i].length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = 0; i < searchList.length; i += 2) - searchList[i].length; i += 2) - searchList[i].length;",
                "patch_diff": "for (int i = 0; i < searchList.length; i += 2) - searchList[i].length; i += 2) - searchList[i].length;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = 0; i < searchList[i].length; i += 2) - searchList[i].length; i += 2) - searchList[i].length;",
                "patch_diff": "for (int i = 0; i < searchList[i].length; i += 2) - searchList[i].length; i += 2) - searchList[i].length;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int i = 0; i < searchList.length; i++) { if (searchList[i].length; } }",
                "patch_diff": "for (int i = 0; i < searchList.length; i++) { if (searchList[i].length; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = 0; i < searchList.length; i += 2) - searchList[i].length; i].length; i++) {",
                "patch_diff": "for (int i = 0; i < searchList.length; i += 2) - searchList[i].length; i].length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (searchList[i] == null || replacementList[i] == null) { continue; }"
    },
    "Jsoup-26": {
        "fixes": [
            {
                "k": 1,
                "patch": "// boolean clean = Document.notNull(dirtyDocument);",
                "patch_diff": "// boolean clean = Document.notNull(dirtyDocument);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// int clean = Document.notNull(dirtyDocument);",
                "patch_diff": "// int clean = Document.notNull(dirtyDocument);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return clean.notNull(dirtyDocument);",
                "patch_diff": "return clean.notNull(dirtyDocument);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// int clean = Document.notNull(dirtyDocument.baseUri());",
                "patch_diff": "// int clean = Document.notNull(dirtyDocument.baseUri());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// boolean clean = Document.notNull(dirtyDocument.baseUri());",
                "patch_diff": "// boolean clean = Document.notNull(dirtyDocument.baseUri());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int clean = Document.notNull(dirtyDocument);",
                "patch_diff": "int clean = Document.notNull(dirtyDocument);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return clean.notNull(dirtyDocument.baseUri());",
                "patch_diff": "return clean.notNull(dirtyDocument.baseUri());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int clean = Document.notNull(dirtyDocument.baseUri());",
                "patch_diff": "int clean = Document.notNull(dirtyDocument.baseUri());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// int clean = Document.notNull(dirtyDocument.baseUri()); }",
                "patch_diff": "// int clean = Document.notNull(dirtyDocument.baseUri()); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// Map clean = Document.notNull(dirtyDocument);",
                "patch_diff": "// Map clean = Document.notNull(dirtyDocument);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (dirtyDocument.body() != null) // frameset documents won't have a body. the clean doc will have empty body."
    },
    "Closure-96": {
        "fixes": [
            {
                "k": 1,
                "patch": "parameters.hasNext()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-96/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 01:05:44.618098738 +0200\n+++ /tmp/tmprg91rvnh.java\t2022-07-19 01:05:44.646098590 +0200\n@@ -1404,11 +1404,11 @@\n     Iterator<Node> parameters = functionType.getParameters().iterator();\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+parameters.hasNext()) {\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "parameters.hasNext()) { // block == null; can't really modify it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-96/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 01:06:09.809965293 +0200\n+++ /tmp/tmpvs7wrpb3.java\t2022-07-19 01:06:09.809965293 +0200\n@@ -1404,11 +1404,11 @@\n     Iterator<Node> parameters = functionType.getParameters().iterator();\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+parameters.hasNext()) { // block == null; can't really modify it's do implicit re-parse\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "parameters.hasNext()) { // block == null; non-empty's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-96/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 01:06:33.101841648 +0200\n+++ /tmp/tmpnlj4w1d7.java\t2022-07-19 01:06:33.101841648 +0200\n@@ -1404,11 +1404,11 @@\n     Iterator<Node> parameters = functionType.getParameters().iterator();\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+parameters.hasNext()) { // block == null; non-empty's do implicit re-parse\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "parameters.hasNext()) { // block == null; can't be null if we're not use a native function.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-96/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 01:06:56.553716908 +0200\n+++ /tmp/tmp3v16kuz0.java\t2022-07-19 01:06:56.557716887 +0200\n@@ -1404,11 +1404,11 @@\n     Iterator<Node> parameters = functionType.getParameters().iterator();\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+parameters.hasNext()) { // block == null; can't be null if we're not use a native function.\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "parameters.hasNext()) { // block == null; can't really modify it's do implicit re-initialized or EMPTY",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-96/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 01:07:19.937592297 +0200\n+++ /tmp/tmp8l8adf3u.java\t2022-07-19 01:07:19.937592297 +0200\n@@ -1404,11 +1404,11 @@\n     Iterator<Node> parameters = functionType.getParameters().iterator();\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+parameters.hasNext()) { // block == null; can't really modify it's do implicit re-initialized or EMPTY\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "parameters.hasNext()) { // block == null; can't really modify it was non-literal characters that might be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-96/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 01:07:42.953469428 +0200\n+++ /tmp/tmpnhccqpku.java\t2022-07-19 01:07:42.953469428 +0200\n@@ -1404,11 +1404,11 @@\n     Iterator<Node> parameters = functionType.getParameters().iterator();\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+parameters.hasNext()) { // block == null; can't really modify it was non-literal characters that might be null!\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "parameters.hasNext()) { // block == null; can't really modify it's do implicit re-returnType",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-96/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 01:08:05.829347105 +0200\n+++ /tmp/tmp8nzggpf1.java\t2022-07-19 01:08:05.833347082 +0200\n@@ -1404,11 +1404,11 @@\n     Iterator<Node> parameters = functionType.getParameters().iterator();\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+parameters.hasNext()) { // block == null; can't really modify it's do implicit re-returnType\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "parameters.hasNext()) { // block == null; can't be null if we're not.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-96/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 01:08:29.261221603 +0200\n+++ /tmp/tmpq6tnwtet.java\t2022-07-19 01:08:29.261221603 +0200\n@@ -1404,11 +1404,11 @@\n     Iterator<Node> parameters = functionType.getParameters().iterator();\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+parameters.hasNext()) { // block == null; can't be null if we're not.\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "parameters.hasNext()) { // block == null; can't really modify it's do implicit re-literal characters that might be null",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-96/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 01:08:52.345097774 +0200\n+++ /tmp/tmpgcohpp5v.java\t2022-07-19 01:08:52.345097774 +0200\n@@ -1404,11 +1404,11 @@\n     Iterator<Node> parameters = functionType.getParameters().iterator();\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+parameters.hasNext()) { // block == null; can't really modify it's do implicit re-literal characters that might be null\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "parameters.hasNext()) { // block == null; can't really modify it was non-literal characters that might be null or EMPTY",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-96/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 01:09:15.752972023 +0200\n+++ /tmp/tmphxgm69wv.java\t2022-07-19 01:09:15.752972023 +0200\n@@ -1404,11 +1404,11 @@\n     Iterator<Node> parameters = functionType.getParameters().iterator();\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+parameters.hasNext()) { // block == null; can't really modify it was non-literal characters that might be null or EMPTY\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "parameters.hasNext()) {",
        "fixed_line": "(parameters.hasNext() || parameter != null && parameter.isVarArgs())) { // If there are no parameters left in the list, then the while loop // above implies that this must be a var_args function. if (parameters.hasNext()) { parameter = parameters.next(); }"
    },
    "Chart-4": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int i = 0; i < DatasetUtilities.getAnnotations(); ++i) {",
                "patch_diff": "for (int i = 0; i < DatasetUtilities.getAnnotations(); ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = 0; i < DatasetUtilities.size(); ++i) {",
                "patch_diff": "for (int i = 0; i < DatasetUtilities.size(); ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0; i < DatasetUtilities.length; i++) {",
                "patch_diff": "for (int i = 0; i < DatasetUtilities.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "i = DatasetUtilities.findRangeBounds(a); }",
                "patch_diff": "i = DatasetUtilities.findRangeBounds(a); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = 0; i < DatasetUtilities.iterator(); ++i) {",
                "patch_diff": "for (int i = 0; i < DatasetUtilities.iterator(); ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = 0; i < DatasetUtilities.hasNext(); ++i) {",
                "patch_diff": "for (int i = 0; i < DatasetUtilities.hasNext(); ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (a instanceof XYAnnotationBoundsInfo) {",
                "patch_diff": "if (a instanceof XYAnnotationBoundsInfo) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = 0; i < n; ++i) {",
                "patch_diff": "for (int i = 0; i < n; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "i = DatasetUtilities.findRangeBounds(c); }",
                "patch_diff": "i = DatasetUtilities.findRangeBounds(c); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "i = DatasetUtilities.findRangeBounds(a); } else if (it.hasNext()) {",
                "patch_diff": "i = DatasetUtilities.findRangeBounds(a); } else if (it.hasNext()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (r != null) { Collection c = r.getAnnotations(); Iterator i = c.iterator(); while (i.hasNext()) { XYAnnotation a = (XYAnnotation) i.next(); if (a instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(a); } } }"
    },
    "Cli-25": {
        "fixes": [
            {
                "k": 1,
                "patch": "nextLineTabStop = width - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-25/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 01:09:40.640838124 +0200\n+++ /tmp/tmpfi4we79r.java\t2022-07-19 01:09:40.656838040 +0200\n@@ -820,11 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+nextLineTabStop = width - 1;\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "nextLineTabStop = pos - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-25/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 01:09:42.984825503 +0200\n+++ /tmp/tmpktd551a3.java\t2022-07-19 01:09:42.984825503 +0200\n@@ -820,11 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+nextLineTabStop = pos - 1;\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "nextLineTabStop = width - 1; // we didn't really modify it was last",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-25/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 01:09:45.440812279 +0200\n+++ /tmp/tmpkb8a4mia.java\t2022-07-19 01:09:45.444812256 +0200\n@@ -820,11 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+nextLineTabStop = width - 1; // we didn't really modify it was last\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "nextLineTabStop = width - 1; // we didn't really modify it.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-25/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 01:09:47.800799569 +0200\n+++ /tmp/tmpbhjl8s7m.java\t2022-07-19 01:09:47.804799546 +0200\n@@ -820,11 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+nextLineTabStop = width - 1; // we didn't really modify it.\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "nextLineTabStop = width - 1; // we didn't really modify it was x",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-25/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 01:09:50.132787006 +0200\n+++ /tmp/tmpyxq3avj9.java\t2022-07-19 01:09:50.132787006 +0200\n@@ -820,11 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+nextLineTabStop = width - 1; // we didn't really modify it was x\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "nextLineTabStop = width - 1; // we didn't really modify it's total",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-25/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 01:09:52.552773970 +0200\n+++ /tmp/tmp6eog9rgj.java\t2022-07-19 01:09:52.552773970 +0200\n@@ -820,11 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+nextLineTabStop = width - 1; // we didn't really modify it's total\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "nextLineTabStop = width - 1; // we didn't really gets this may be negative",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-25/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 01:09:54.936761124 +0200\n+++ /tmp/tmpxdqgw2by.java\t2022-07-19 01:09:54.936761124 +0200\n@@ -820,11 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+nextLineTabStop = width - 1; // we didn't really gets this may be negative\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "nextLineTabStop = width - 1; // we didn't really modify it",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-25/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 01:09:57.356748084 +0200\n+++ /tmp/tmp7_e2_52k.java\t2022-07-19 01:09:57.356748084 +0200\n@@ -820,11 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+nextLineTabStop = width - 1; // we didn't really modify it\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "nextLineTabStop = pos - 1; // we didn't really modify it was last",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-25/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 01:09:59.972733986 +0200\n+++ /tmp/tmpap7i4h1o.java\t2022-07-19 01:09:59.976733965 +0200\n@@ -820,11 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+nextLineTabStop = pos - 1; // we didn't really modify it was last\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "nextLineTabStop = width - 1; // we didn't really modify it's parent",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-25/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 01:10:02.360721115 +0200\n+++ /tmp/tmpz2jmx6hm.java\t2022-07-19 01:10:02.360721115 +0200\n@@ -820,11 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+nextLineTabStop = width - 1; // we didn't really modify it's parent\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "nextLineTabStop = width - 1;",
        "fixed_line": "nextLineTabStop = 1;"
    },
    "Closure-86": {
        "fixes": [
            {
                "k": 1,
                "patch": "return false; // can't really modify it was non-literal characters that might be valid (e if it was -->",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-86/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 01:10:04.884707508 +0200\n+++ /tmp/tmpsm5scqty.java\t2022-07-19 01:10:04.912707356 +0200\n@@ -2460,11 +2460,11 @@\n             || locals.apply(value);\n       case Token.NEW:\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return false; // can't really modify it was non-literal characters that might be valid (e if it was -->\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 2,
                "patch": "return false; // can't really modify it was non-literal characters that might be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-86/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 01:10:32.140560456 +0200\n+++ /tmp/tmpx0obexcz.java\t2022-07-19 01:10:32.140560456 +0200\n@@ -2460,11 +2460,11 @@\n             || locals.apply(value);\n       case Token.NEW:\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return false; // can't really modify it was non-literal characters that might be null!\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 3,
                "patch": "return false; // can't really modify it was non-literal characters that might be Token.REGEXPMD -",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-86/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 01:10:59.308413670 +0200\n+++ /tmp/tmpvddj_u98.java\t2022-07-19 01:10:59.308413670 +0200\n@@ -2460,11 +2460,11 @@\n             || locals.apply(value);\n       case Token.NEW:\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return false; // can't really modify it was non-literal characters that might be Token.REGEXPMD -\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 4,
                "patch": "return false; // can't really modify it was non-literal characters that might be valid (empty be valid)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-86/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 01:11:27.304262207 +0200\n+++ /tmp/tmpl56gxrkt.java\t2022-07-19 01:11:27.308262186 +0200\n@@ -2460,11 +2460,11 @@\n             || locals.apply(value);\n       case Token.NEW:\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return false; // can't really modify it was non-literal characters that might be valid (empty be valid)\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 5,
                "patch": "return false; // can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-86/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 01:11:54.892112757 +0200\n+++ /tmp/tmp7gbr_koz.java\t2022-07-19 01:11:54.896112737 +0200\n@@ -2460,11 +2460,11 @@\n             || locals.apply(value);\n       case Token.NEW:\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return false; // can't really modify it was non-literal characters that might be valid (toJsonNode)\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 6,
                "patch": "return false; // can't really modify it was non-literal characters that might be Token.REGEXPMD",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-86/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 01:12:22.631962302 +0200\n+++ /tmp/tmpikko7wfn.java\t2022-07-19 01:12:22.631962302 +0200\n@@ -2460,11 +2460,11 @@\n             || locals.apply(value);\n       case Token.NEW:\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return false; // can't really modify it was non-literal characters that might be Token.REGEXPMD\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 7,
                "patch": "return false; // can't really modify it was non-literal characters that were // need to check",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-86/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 01:12:50.567810607 +0200\n+++ /tmp/tmpsov3i2qs.java\t2022-07-19 01:12:50.567810607 +0200\n@@ -2460,11 +2460,11 @@\n             || locals.apply(value);\n       case Token.NEW:\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return false; // can't really modify it was non-literal characters that were // need to check\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 8,
                "patch": "return false; // can't really modify it was non-literal characters that might be valid (empty be",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-86/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 01:13:18.331659682 +0200\n+++ /tmp/tmp4p2z39jc.java\t2022-07-19 01:13:18.331659682 +0200\n@@ -2460,11 +2460,11 @@\n             || locals.apply(value);\n       case Token.NEW:\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return false; // can't really modify it was non-literal characters that might be valid (empty be\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 9,
                "patch": "return false; // can't really modify it was non-literal characters that might be valid (empty be Token.REGEXPMD -",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-86/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 01:13:46.055508820 +0200\n+++ /tmp/tmp9gshvl74.java\t2022-07-19 01:13:46.055508820 +0200\n@@ -2460,11 +2460,11 @@\n             || locals.apply(value);\n       case Token.NEW:\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return false; // can't really modify it was non-literal characters that might be valid (empty be Token.REGEXPMD -\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 10,
                "patch": "return false; // can't really modify it was non-literal characters that might be null or EMPTY",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-86/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-19 01:14:14.035356412 +0200\n+++ /tmp/tmpcz2apwpr.java\t2022-07-19 01:14:14.035356412 +0200\n@@ -2460,11 +2460,11 @@\n             || locals.apply(value);\n       case Token.NEW:\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return false; // can't really modify it was non-literal characters that might be null or EMPTY\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            }
        ],
        "buggy_line": "return true;",
        "fixed_line": "return false;"
    },
    "Closure-66": {
        "fixes": [
            {
                "k": 1,
                "patch": "// Object literal keys are not typeable }",
                "patch_diff": "// Object literal keys are not typeable }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// Object literal keys.getParent())) {",
                "patch_diff": "// Object literal keys.getParent())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// Object literal keys.pushObjectLitKey(t, n, STRING_TYPE);",
                "patch_diff": "// Object literal keys.pushObjectLitKey(t, n, STRING_TYPE);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// Object literal keys.pushObjectLitKey(t, n, STRING_TYPE); // Object literal keys are not type",
                "patch_diff": "// Object literal keys.pushObjectLitKey(t, n, STRING_TYPE); // Object literal keys are not type",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// Object literal keys.isObjectLitKey(t, n, STRING_TYPE);",
                "patch_diff": "// Object literal keys.isObjectLitKey(t, n, STRING_TYPE);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// Object literal keys.isObjectLitKey(t, n, STRING_TYPE); // Object literal keys are not type",
                "patch_diff": "// Object literal keys.isObjectLitKey(t, n, STRING_TYPE); // Object literal keys are not type",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// Object literal keys are not type \" + n.getParent())) {",
                "patch_diff": "// Object literal keys are not type \" + n.getParent())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// Object literal keys.pushObjectLitKey(t, n, STRING_TYPE); // Object literal keys are not typeable }",
                "patch_diff": "// Object literal keys.pushObjectLitKey(t, n, STRING_TYPE); // Object literal keys are not typeable }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// Object literal keys = n.getParent())) {",
                "patch_diff": "// Object literal keys = n.getParent())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// Object literal(t, n, STRING_TYPE); // Object literal keys are not type",
                "patch_diff": "// Object literal(t, n, STRING_TYPE); // Object literal keys are not type",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "} else { // Object literal keys are not typeable typeable = false;"
    },
    "Math-74": {
        "fixes": [
            {
                "k": 1,
                "patch": "final double[] scale; if (vecAbsoluteTolerance == null) { scale = new double[y0.util.Arrays.fill(scale); } else { scale = vecAbsoluteTolerance;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-74/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2022-07-19 01:14:43.703194656 +0200\n+++ /tmp/tmpnewif37s.java\t2022-07-19 01:14:43.779194244 +0200\n@@ -240,16 +240,11 @@\n           // first stage\n           computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n-            } else {\n-              scale = vecAbsoluteTolerance;\n+final double[] scale; if (vecAbsoluteTolerance == null) { scale = new double[y0.util.Arrays.fill(scale); } else { scale = vecAbsoluteTolerance;\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "final double[] scale; if (vecAbsoluteTolerance == null) { scale = new double[y0.util.Arrays.fill(scale, scalAbsoluteTolerance); } else { scale = vecAbsoluteTolerance;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-74/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2022-07-19 01:14:45.919182568 +0200\n+++ /tmp/tmp1e1ujqg9.java\t2022-07-19 01:14:45.923182548 +0200\n@@ -240,16 +240,11 @@\n           // first stage\n           computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n-            } else {\n-              scale = vecAbsoluteTolerance;\n+final double[] scale; if (vecAbsoluteTolerance == null) { scale = new double[y0.util.Arrays.fill(scale, scalAbsoluteTolerance); } else { scale = vecAbsoluteTolerance;\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "final double[] scale; if (vecAbsoluteTolerance!= null) { scale = new double[y0.util.Arrays.fill(scale, scalAbsoluteTolerance); } else { scale = vecAbsoluteTolerance;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-74/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2022-07-19 01:14:48.019171114 +0200\n+++ /tmp/tmpznjv2lil.java\t2022-07-19 01:14:48.019171114 +0200\n@@ -240,16 +240,11 @@\n           // first stage\n           computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n-            } else {\n-              scale = vecAbsoluteTolerance;\n+final double[] scale; if (vecAbsoluteTolerance!= null) { scale = new double[y0.util.Arrays.fill(scale, scalAbsoluteTolerance); } else { scale = vecAbsoluteTolerance;\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "final double[] scale; if (vecAbsoluteTolerance!= null) { scale = new double[y0.util.Arrays.fill(scale); } else { scale = vecAbsoluteTolerance;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-74/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2022-07-19 01:14:50.031160135 +0200\n+++ /tmp/tmp1ta_irc6.java\t2022-07-19 01:14:50.031160135 +0200\n@@ -240,16 +240,11 @@\n           // first stage\n           computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n-            } else {\n-              scale = vecAbsoluteTolerance;\n+final double[] scale; if (vecAbsoluteTolerance!= null) { scale = new double[y0.util.Arrays.fill(scale); } else { scale = vecAbsoluteTolerance;\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "final double[] scale; if (vecAbsoluteTolerance!= null) { scale = new double[y0.length];.util.Arrays.fill(scale, scalAbsoluteTolerance); } else { scale = vecAbsoluteTolerance;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-74/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2022-07-19 01:14:52.031149225 +0200\n+++ /tmp/tmpv0pb7ndb.java\t2022-07-19 01:14:52.035149201 +0200\n@@ -240,16 +240,11 @@\n           // first stage\n           computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n-            } else {\n-              scale = vecAbsoluteTolerance;\n+final double[] scale; if (vecAbsoluteTolerance!= null) { scale = new double[y0.length];.util.Arrays.fill(scale, scalAbsoluteTolerance); } else { scale = vecAbsoluteTolerance;\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "final double[] scale; if (vecAbsoluteTolerance == null) { scale = new double[y0.length];.util.Arrays.fill(scale, scalAbsoluteTolerance); } else { scale = vecAbsoluteTolerance;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-74/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2022-07-19 01:14:54.107137896 +0200\n+++ /tmp/tmp1m42heib.java\t2022-07-19 01:14:54.107137896 +0200\n@@ -240,16 +240,11 @@\n           // first stage\n           computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n-            } else {\n-              scale = vecAbsoluteTolerance;\n+final double[] scale; if (vecAbsoluteTolerance == null) { scale = new double[y0.length];.util.Arrays.fill(scale, scalAbsoluteTolerance); } else { scale = vecAbsoluteTolerance;\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "final double[] scale; if (vecAbsoluteTolerance!= null) { scale = new double[y0.get];.util.Arrays.fill(scale, scalAbsoluteTolerance); } else { scale = vecAbsoluteTolerance;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-74/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2022-07-19 01:14:56.131126851 +0200\n+++ /tmp/tmpb5up2gru.java\t2022-07-19 01:14:56.131126851 +0200\n@@ -240,16 +240,11 @@\n           // first stage\n           computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n-            } else {\n-              scale = vecAbsoluteTolerance;\n+final double[] scale; if (vecAbsoluteTolerance!= null) { scale = new double[y0.get];.util.Arrays.fill(scale, scalAbsoluteTolerance); } else { scale = vecAbsoluteTolerance;\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "final double[] scale; if (vecAbsoluteTolerance!= null) { scale = new double[y0.length];.util.Arrays.fill(scale); } else { scale = vecAbsoluteTolerance;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-74/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2022-07-19 01:14:58.107116068 +0200\n+++ /tmp/tmpucx6xyn3.java\t2022-07-19 01:14:58.107116068 +0200\n@@ -240,16 +240,11 @@\n           // first stage\n           computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n-            } else {\n-              scale = vecAbsoluteTolerance;\n+final double[] scale; if (vecAbsoluteTolerance!= null) { scale = new double[y0.length];.util.Arrays.fill(scale); } else { scale = vecAbsoluteTolerance;\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "final double[] scale; if (vecAbsoluteTolerance == null) { scale = new double[y0.get];.util.Arrays.fill(scale, scalAbsoluteTolerance); } else { scale = vecAbsoluteTolerance;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-74/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2022-07-19 01:15:00.263104301 +0200\n+++ /tmp/tmpxga_xxhj.java\t2022-07-19 01:15:00.263104301 +0200\n@@ -240,16 +240,11 @@\n           // first stage\n           computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n-            } else {\n-              scale = vecAbsoluteTolerance;\n+final double[] scale; if (vecAbsoluteTolerance == null) { scale = new double[y0.get];.util.Arrays.fill(scale, scalAbsoluteTolerance); } else { scale = vecAbsoluteTolerance;\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "final double[] scale; if (vecAbsoluteTolerance == null) { scale = new double[y0.length];.util.Arrays.fill(scale); } else { scale = vecAbsoluteTolerance;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-74/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2022-07-19 01:15:02.319093080 +0200\n+++ /tmp/tmpp5w2ea60.java\t2022-07-19 01:15:02.319093080 +0200\n@@ -240,16 +240,11 @@\n           // first stage\n           computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n-            } else {\n-              scale = vecAbsoluteTolerance;\n+final double[] scale; if (vecAbsoluteTolerance == null) { scale = new double[y0.length];.util.Arrays.fill(scale); } else { scale = vecAbsoluteTolerance;\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "final double[] scale; if (vecAbsoluteTolerance == null) { scale = new double[y0.length]; java.util.Arrays.fill(scale, scalAbsoluteTolerance); } else { scale = vecAbsoluteTolerance;",
        "fixed_line": "final double[] scale = new double[y0.length]; if (vecAbsoluteTolerance == null) { for (int i = 0; i < scale.length; ++i) { scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]); } } else { for (int i = 0; i < scale.length; ++i) { scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]); }"
    },
    "Cli-2": {
        "fixes": [
            {
                "k": 1,
                "patch": "tokens.add(\"-\" + ch); } }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-2/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 01:15:04.555080876 +0200\n+++ /tmp/tmpeiiv1ddi.java\t2022-07-19 01:15:04.579080745 +0200\n@@ -300,10 +300,6 @@\n             {\n                 process(token.substring(i));\n             }\n             else\n             {\n-                tokens.add(\"-\" + ch);\n-            }\n-        }\n-    }\n-}\n+tokens.add(\"-\" + ch); } }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "tokens.add(\"-\" + ch); } else {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-2/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 01:15:06.123072319 +0200\n+++ /tmp/tmplsonuelc.java\t2022-07-19 01:15:06.123072319 +0200\n@@ -300,10 +300,6 @@\n             {\n                 process(token.substring(i));\n             }\n             else\n             {\n-                tokens.add(\"-\" + ch);\n-            }\n-        }\n-    }\n-}\n+tokens.add(\"-\" + ch); } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "tokens.add(\"-\" + ch); } else if (ch < tokens.length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-2/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 01:15:07.595064284 +0200\n+++ /tmp/tmp0c8a8klq.java\t2022-07-19 01:15:07.595064284 +0200\n@@ -300,10 +300,6 @@\n             {\n                 process(token.substring(i));\n             }\n             else\n             {\n-                tokens.add(\"-\" + ch);\n-            }\n-        }\n-    }\n-}\n+tokens.add(\"-\" + ch); } else if (ch < tokens.length) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "tokens.add(\"-\" + ch); } else if (token.substring(i)); } }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-2/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 01:15:09.095056094 +0200\n+++ /tmp/tmp600pz3w9.java\t2022-07-19 01:15:09.099056074 +0200\n@@ -300,10 +300,6 @@\n             {\n                 process(token.substring(i));\n             }\n             else\n             {\n-                tokens.add(\"-\" + ch);\n-            }\n-        }\n-    }\n-}\n+tokens.add(\"-\" + ch); } else if (token.substring(i)); } }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "tokens.add(\"-\" + ch); } else if (token.substring(i)); } else {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-2/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 01:15:10.607047842 +0200\n+++ /tmp/tmpx95ur7sq.java\t2022-07-19 01:15:10.611047817 +0200\n@@ -300,10 +300,6 @@\n             {\n                 process(token.substring(i));\n             }\n             else\n             {\n-                tokens.add(\"-\" + ch);\n-            }\n-        }\n-    }\n-}\n+tokens.add(\"-\" + ch); } else if (token.substring(i)); } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "tokens.add(\"-\" + ch); } else if (token.substring(i));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-2/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 01:15:12.095039718 +0200\n+++ /tmp/tmpxr7mr2f4.java\t2022-07-19 01:15:12.099039694 +0200\n@@ -300,10 +300,6 @@\n             {\n                 process(token.substring(i));\n             }\n             else\n             {\n-                tokens.add(\"-\" + ch);\n-            }\n-        }\n-    }\n-}\n+tokens.add(\"-\" + ch); } else if (token.substring(i));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "tokens.add(\"-\" + ch); } else if (token.substring(i)); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-2/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 01:15:13.623031376 +0200\n+++ /tmp/tmpl1y_1mvm.java\t2022-07-19 01:15:13.623031376 +0200\n@@ -300,10 +300,6 @@\n             {\n                 process(token.substring(i));\n             }\n             else\n             {\n-                tokens.add(\"-\" + ch);\n-            }\n-        }\n-    }\n-}\n+tokens.add(\"-\" + ch); } else if (token.substring(i)); }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "tokens.add(\"-\" + ch); } else if (token.substring(i)); } else if (ch < tokens.length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-2/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 01:15:15.243022531 +0200\n+++ /tmp/tmp_kukv2tx.java\t2022-07-19 01:15:15.243022531 +0200\n@@ -300,10 +300,6 @@\n             {\n                 process(token.substring(i));\n             }\n             else\n             {\n-                tokens.add(\"-\" + ch);\n-            }\n-        }\n-    }\n-}\n+tokens.add(\"-\" + ch); } else if (token.substring(i)); } else if (ch < tokens.length) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "tokens.add(\"-\" + ch); } else if (tokenLen == 2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-2/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 01:15:16.747014316 +0200\n+++ /tmp/tmpzvpju2sd.java\t2022-07-19 01:15:16.747014316 +0200\n@@ -300,10 +300,6 @@\n             {\n                 process(token.substring(i));\n             }\n             else\n             {\n-                tokens.add(\"-\" + ch);\n-            }\n-        }\n-    }\n-}\n+tokens.add(\"-\" + ch); } else if (tokenLen == 2) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "tokens.add(\"-\" + ch); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-2/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 01:15:18.215006300 +0200\n+++ /tmp/tmpw5t8zxja.java\t2022-07-19 01:15:18.219006279 +0200\n@@ -300,10 +300,6 @@\n             {\n                 process(token.substring(i));\n             }\n             else\n             {\n-                tokens.add(\"-\" + ch);\n-            }\n-        }\n-    }\n-}\n+tokens.add(\"-\" + ch); }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "tokens.add(\"-\" + ch); } } } }",
        "fixed_line": "tokens.add(token); break; } } } }"
    },
    "JacksonCore-3": {
        "fixes": [
            {
                "k": 1,
                "patch": "ObjectCodec = _symbols; _inputEnd = end; // If we have to omit that from byte output",
                "patch_diff": "ObjectCodec = _symbols; _inputEnd = end; // If we have to omit that from byte output",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "Object Object = _symbols; _inputEnd = end; // If we have to omit that from byte output",
                "patch_diff": "Object Object = _symbols; _inputEnd = end; // If we have to omit that from byte output",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "ObjectCodec = _symbols; _inputEnd = end; // If we have to omit that from byte outputPtr",
                "patch_diff": "ObjectCodec = _symbols; _inputEnd = end; // If we have to omit that from byte outputPtr",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "Object Object = _symbols; _inputEnd = end; // If we have to omit that from byte outputPtr",
                "patch_diff": "Object Object = _symbols; _inputEnd = end; // If we have to omit that from byte outputPtr",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "Object Object = _symbols; _inputEnd = end; // If we have to omit that from '_next-inputPtr",
                "patch_diff": "Object Object = _symbols; _inputEnd = end; // If we have to omit that from '_next-inputPtr",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "ObjectCodec = _symbols; _inputEnd = end; // If we have to omit that from '_next-inputPtr",
                "patch_diff": "ObjectCodec = _symbols; _inputEnd = end; // If we have to omit that from '_next-inputPtr",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = start; // If we have to omit that from byte outputPtr = _inputEnd; // to omit that from '_next-inputPtr",
                "patch_diff": "for (int i = start; // If we have to omit that from byte outputPtr = _inputEnd; // to omit that from '_next-inputPtr",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = start; // If we have to omit that from byte outputPtr = _inputEnd; // to omit that from byte output",
                "patch_diff": "for (int i = start; // If we have to omit that from byte outputPtr = _inputEnd; // to omit that from byte output",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int i = start; // If we have to omit that from byte outputPtr = _inputEnd = end; // If we have to omit that from byte outputPtr",
                "patch_diff": "for (int i = start; // If we have to omit that from byte outputPtr = _inputEnd = end; // If we have to omit that from byte outputPtr",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = start; // If we have to omit that from byte outputPtr = _inputEnd; // If we have to omit that from byte output",
                "patch_diff": "for (int i = start; // If we have to omit that from byte outputPtr = _inputEnd; // If we have to omit that from byte output",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "_currInputRowStart = start; // If we have offset, need to omit that from byte offset, so: _currInputProcessed = -start;"
    },
    "Lang-33": {
        "fixes": [
            {
                "k": 1,
                "patch": "classes[i] = array[i].getClass();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-33/src/main/java/org/apache/commons/lang3/ClassUtils.java\t2022-07-19 01:15:21.930986008 +0200\n+++ /tmp/tmp4ns89hq4.java\t2022-07-19 01:15:22.042985399 +0200\n@@ -905,11 +905,11 @@\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+classes[i] = array[i].getClass();\n         }\n         return classes;\n     }\n \n     // Short canonical name\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "classes[i] = array[i].getClass(); // we didn't really modify it was non-literal characters that might be valid (array[i] = array[i].getClass();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-33/src/main/java/org/apache/commons/lang3/ClassUtils.java\t2022-07-19 01:15:31.734932463 +0200\n+++ /tmp/tmpnx7n8e9b.java\t2022-07-19 01:15:31.734932463 +0200\n@@ -905,11 +905,11 @@\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+classes[i] = array[i].getClass(); // we didn't really modify it was non-literal characters that might be valid (array[i] = array[i].getClass();\n         }\n         return classes;\n     }\n \n     // Short canonical name\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "classes[i] = array[i].getClass(); // we didn't really modify it was non-literal characters that might be Token.EMPTY_CLASS_ARRAY = array[i].getClass();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-33/src/main/java/org/apache/commons/lang3/ClassUtils.java\t2022-07-19 01:15:41.158880974 +0200\n+++ /tmp/tmpjqsla13_.java\t2022-07-19 01:15:41.158880974 +0200\n@@ -905,11 +905,11 @@\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+classes[i] = array[i].getClass(); // we didn't really modify it was non-literal characters that might be Token.EMPTY_CLASS_ARRAY = array[i].getClass();\n         }\n         return classes;\n     }\n \n     // Short canonical name\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "classes[i] = array[i].getClass(); // we didn't really modify it was non-literal characters that might be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-33/src/main/java/org/apache/commons/lang3/ClassUtils.java\t2022-07-19 01:15:50.522829803 +0200\n+++ /tmp/tmprgz_cniz.java\t2022-07-19 01:15:50.522829803 +0200\n@@ -905,11 +905,11 @@\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+classes[i] = array[i].getClass(); // we didn't really modify it was non-literal characters that might be null!\n         }\n         return classes;\n     }\n \n     // Short canonical name\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "classes[i] = array[i].getClass(); // we need to do a digit after the",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-33/src/main/java/org/apache/commons/lang3/ClassUtils.java\t2022-07-19 01:15:59.962778202 +0200\n+++ /tmp/tmp98bl7ikd.java\t2022-07-19 01:15:59.962778202 +0200\n@@ -905,11 +905,11 @@\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+classes[i] = array[i].getClass(); // we need to do a digit after the\n         }\n         return classes;\n     }\n \n     // Short canonical name\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "classes[i] = array[i].getClass(); // we didn't really modify it was non-literal characters that might be valid (array.length!= array[i].getClass();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-33/src/main/java/org/apache/commons/lang3/ClassUtils.java\t2022-07-19 01:16:09.494726082 +0200\n+++ /tmp/tmpf6wmgjup.java\t2022-07-19 01:16:09.494726082 +0200\n@@ -905,11 +905,11 @@\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+classes[i] = array[i].getClass(); // we didn't really modify it was non-literal characters that might be valid (array.length!= array[i].getClass();\n         }\n         return classes;\n     }\n \n     // Short canonical name\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "classes[i] = array[i].getClass(); // we didn't really modify it was non-literal characters that might be valid (array[i].getClass();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-33/src/main/java/org/apache/commons/lang3/ClassUtils.java\t2022-07-19 01:16:18.806675155 +0200\n+++ /tmp/tmpfvoidx2m.java\t2022-07-19 01:16:18.806675155 +0200\n@@ -905,11 +905,11 @@\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+classes[i] = array[i].getClass(); // we didn't really modify it was non-literal characters that might be valid (array[i].getClass();\n         }\n         return classes;\n     }\n \n     // Short canonical name\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "classes[i] = array[i].getClass(); // we didn't really gets this to_CLASS_ARRAY[i] = array[i].getClass();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-33/src/main/java/org/apache/commons/lang3/ClassUtils.java\t2022-07-19 01:16:28.134624130 +0200\n+++ /tmp/tmph2h_jga3.java\t2022-07-19 01:16:28.134624130 +0200\n@@ -905,11 +905,11 @@\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+classes[i] = array[i].getClass(); // we didn't really gets this to_CLASS_ARRAY[i] = array[i].getClass();\n         }\n         return classes;\n     }\n \n     // Short canonical name\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "classes[i] = array[i].getClass(); // we need to check whether a digit after the E",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-33/src/main/java/org/apache/commons/lang3/ClassUtils.java\t2022-07-19 01:16:37.558572563 +0200\n+++ /tmp/tmp61fmrqaf.java\t2022-07-19 01:16:37.558572563 +0200\n@@ -905,11 +905,11 @@\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+classes[i] = array[i].getClass(); // we need to check whether a digit after the E\n         }\n         return classes;\n     }\n \n     // Short canonical name\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "classes[i] = array[i].getClass(); // we didn't really gets this to_CLASS_ARRAY = array[i].getClass();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-33/src/main/java/org/apache/commons/lang3/ClassUtils.java\t2022-07-19 01:16:46.810521930 +0200\n+++ /tmp/tmp1nhftda1.java\t2022-07-19 01:16:46.810521930 +0200\n@@ -905,11 +905,11 @@\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+classes[i] = array[i].getClass(); // we didn't really gets this to_CLASS_ARRAY = array[i].getClass();\n         }\n         return classes;\n     }\n \n     // Short canonical name\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "classes[i] = array[i].getClass();",
        "fixed_line": "classes[i] = array[i] == null ? null : array[i].getClass();"
    },
    "Cli-19": {
        "fixes": [
            {
                "k": 1,
                "patch": "tokens.add(token); } else if (stopAtNonOption) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-19/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 01:16:56.558468568 +0200\n+++ /tmp/tmpoqr90y0h.java\t2022-07-19 01:16:56.662468002 +0200\n@@ -227,16 +227,11 @@\n     private void processOptionToken(String token, boolean stopAtNonOption)\n     {\n         if (options.hasOption(token))\n         {\n             currentOption = options.getOption(token);\n-            tokens.add(token);\n-        }\n-        else if (stopAtNonOption)\n-        {\n-            eatTheRest = true;\n-            tokens.add(token);\n+tokens.add(token); } else if (stopAtNonOption) {\n         }\n     }\n \n     /**\n      * <p>Breaks <code>token</code> into its constituent parts\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "tokens.add(token);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-19/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 01:16:59.502452447 +0200\n+++ /tmp/tmpg6dp7rbj.java\t2022-07-19 01:16:59.506452427 +0200\n@@ -227,16 +227,11 @@\n     private void processOptionToken(String token, boolean stopAtNonOption)\n     {\n         if (options.hasOption(token))\n         {\n             currentOption = options.getOption(token);\n-            tokens.add(token);\n-        }\n-        else if (stopAtNonOption)\n-        {\n-            eatTheRest = true;\n-            tokens.add(token);\n+tokens.add(token);\n         }\n     }\n \n     /**\n      * <p>Breaks <code>token</code> into its constituent parts\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "tokens.add(token); } else if (stopAtNonOption) { eatTheRest = true; tokens.add(token);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-19/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 01:17:01.910439262 +0200\n+++ /tmp/tmpbrs1uk9l.java\t2022-07-19 01:17:01.910439262 +0200\n@@ -227,16 +227,11 @@\n     private void processOptionToken(String token, boolean stopAtNonOption)\n     {\n         if (options.hasOption(token))\n         {\n             currentOption = options.getOption(token);\n-            tokens.add(token);\n-        }\n-        else if (stopAtNonOption)\n-        {\n-            eatTheRest = true;\n-            tokens.add(token);\n+tokens.add(token); } else if (stopAtNonOption) { eatTheRest = true; tokens.add(token);\n         }\n     }\n \n     /**\n      * <p>Breaks <code>token</code> into its constituent parts\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "tokens.add(token); } else if (stopAtNonOption) { break; } else if (stopAtNonOption) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-19/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 01:17:04.626424390 +0200\n+++ /tmp/tmpd13eqj_t.java\t2022-07-19 01:17:04.626424390 +0200\n@@ -227,16 +227,11 @@\n     private void processOptionToken(String token, boolean stopAtNonOption)\n     {\n         if (options.hasOption(token))\n         {\n             currentOption = options.getOption(token);\n-            tokens.add(token);\n-        }\n-        else if (stopAtNonOption)\n-        {\n-            eatTheRest = true;\n-            tokens.add(token);\n+tokens.add(token); } else if (stopAtNonOption) { break; } else if (stopAtNonOption) {\n         }\n     }\n \n     /**\n      * <p>Breaks <code>token</code> into its constituent parts\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "tokens.add(token); } else if (stopAtNonOption = true; tokens.add(token);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-19/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 01:17:06.174415915 +0200\n+++ /tmp/tmpt6e2py22.java\t2022-07-19 01:17:06.174415915 +0200\n@@ -227,16 +227,11 @@\n     private void processOptionToken(String token, boolean stopAtNonOption)\n     {\n         if (options.hasOption(token))\n         {\n             currentOption = options.getOption(token);\n-            tokens.add(token);\n-        }\n-        else if (stopAtNonOption)\n-        {\n-            eatTheRest = true;\n-            tokens.add(token);\n+tokens.add(token); } else if (stopAtNonOption = true; tokens.add(token);\n         }\n     }\n \n     /**\n      * <p>Breaks <code>token</code> into its constituent parts\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "tokens.add(token); } else if (stopAtNonOption) { eatTheRest = false; tokens.add(token);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-19/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 01:17:07.670407723 +0200\n+++ /tmp/tmpv69o9u2y.java\t2022-07-19 01:17:07.670407723 +0200\n@@ -227,16 +227,11 @@\n     private void processOptionToken(String token, boolean stopAtNonOption)\n     {\n         if (options.hasOption(token))\n         {\n             currentOption = options.getOption(token);\n-            tokens.add(token);\n-        }\n-        else if (stopAtNonOption)\n-        {\n-            eatTheRest = true;\n-            tokens.add(token);\n+tokens.add(token); } else if (stopAtNonOption) { eatTheRest = false; tokens.add(token);\n         }\n     }\n \n     /**\n      * <p>Breaks <code>token</code> into its constituent parts\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "tokens.add(token); } else if (stopAtNonOption) { //TheRest = false; tokens.add(token);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-19/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 01:17:10.190393920 +0200\n+++ /tmp/tmpnwtyb0fx.java\t2022-07-19 01:17:10.214393791 +0200\n@@ -227,16 +227,11 @@\n     private void processOptionToken(String token, boolean stopAtNonOption)\n     {\n         if (options.hasOption(token))\n         {\n             currentOption = options.getOption(token);\n-            tokens.add(token);\n-        }\n-        else if (stopAtNonOption)\n-        {\n-            eatTheRest = true;\n-            tokens.add(token);\n+tokens.add(token); } else if (stopAtNonOption) { //TheRest = false; tokens.add(token);\n         }\n     }\n \n     /**\n      * <p>Breaks <code>token</code> into its constituent parts\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "tokens.add(token); } else if (stopAtNonOption) { //TheRest = true; tokens.add(token);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-19/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 01:17:13.074378125 +0200\n+++ /tmp/tmpebyzh58f.java\t2022-07-19 01:17:13.074378125 +0200\n@@ -227,16 +227,11 @@\n     private void processOptionToken(String token, boolean stopAtNonOption)\n     {\n         if (options.hasOption(token))\n         {\n             currentOption = options.getOption(token);\n-            tokens.add(token);\n-        }\n-        else if (stopAtNonOption)\n-        {\n-            eatTheRest = true;\n-            tokens.add(token);\n+tokens.add(token); } else if (stopAtNonOption) { //TheRest = true; tokens.add(token);\n         }\n     }\n \n     /**\n      * <p>Breaks <code>token</code> into its constituent parts\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "tokens.add(token); } else if (stopAtNonOption = false; tokens.add(token);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-19/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 01:17:15.618364191 +0200\n+++ /tmp/tmpu6fn0qnf.java\t2022-07-19 01:17:15.618364191 +0200\n@@ -227,16 +227,11 @@\n     private void processOptionToken(String token, boolean stopAtNonOption)\n     {\n         if (options.hasOption(token))\n         {\n             currentOption = options.getOption(token);\n-            tokens.add(token);\n-        }\n-        else if (stopAtNonOption)\n-        {\n-            eatTheRest = true;\n-            tokens.add(token);\n+tokens.add(token); } else if (stopAtNonOption = false; tokens.add(token);\n         }\n     }\n \n     /**\n      * <p>Breaks <code>token</code> into its constituent parts\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "tokens.add(token); } else if (stopAtNonOption) { case 'I'; } else if (stopAtNonOption) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-19/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 01:17:17.102356062 +0200\n+++ /tmp/tmpnlbutaqs.java\t2022-07-19 01:17:17.102356062 +0200\n@@ -227,16 +227,11 @@\n     private void processOptionToken(String token, boolean stopAtNonOption)\n     {\n         if (options.hasOption(token))\n         {\n             currentOption = options.getOption(token);\n-            tokens.add(token);\n-        }\n-        else if (stopAtNonOption)\n-        {\n-            eatTheRest = true;\n-            tokens.add(token);\n+tokens.add(token); } else if (stopAtNonOption) { case 'I'; } else if (stopAtNonOption) {\n         }\n     }\n \n     /**\n      * <p>Breaks <code>token</code> into its constituent parts\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "tokens.add(token); } else if (stopAtNonOption) { eatTheRest = true; tokens.add(token);",
        "fixed_line": "tokens.add(token);"
    },
    "Closure-121": {
        "fixes": [
            {
                "k": 1,
                "patch": "referenceInfo.isAssignedOnceInLifetime()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-121/src/com/google/javascript/jscomp/InlineVariables.java\t2022-07-19 01:17:18.906346181 +0200\n+++ /tmp/tmpztzsrueu.java\t2022-07-19 01:17:18.934346027 +0200\n@@ -299,11 +299,11 @@\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+referenceInfo.isAssignedOnceInLifetime()) {\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "referenceInfo.isAssignedOnceInLifetime()) { // we didn't really modify it.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-121/src/com/google/javascript/jscomp/InlineVariables.java\t2022-07-19 01:18:11.838056063 +0200\n+++ /tmp/tmpz722z239.java\t2022-07-19 01:18:11.838056063 +0200\n@@ -299,11 +299,11 @@\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+referenceInfo.isAssignedOnceInLifetime()) { // we didn't really modify it.\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "referenceInfo.isAssignedOnceInLifetime()) { // we didn't really modify it was x",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-121/src/com/google/javascript/jscomp/InlineVariables.java\t2022-07-19 01:19:01.517790280 +0200\n+++ /tmp/tmpsncts8l_.java\t2022-07-19 01:19:01.517790280 +0200\n@@ -299,11 +299,11 @@\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+referenceInfo.isAssignedOnceInLifetime()) { // we didn't really modify it was x\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "referenceInfo.isAssignedOnceInLifetime()) { // we didn't really modify it was last",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-121/src/com/google/javascript/jscomp/InlineVariables.java\t2022-07-19 01:19:52.357554212 +0200\n+++ /tmp/tmp32x2f9he.java\t2022-07-19 01:19:52.361554193 +0200\n@@ -299,11 +299,11 @@\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+referenceInfo.isAssignedOnceInLifetime()) { // we didn't really modify it was last\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "referenceInfo.isAssignedOnceInLifetime()) { // we didn't really modify it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-121/src/com/google/javascript/jscomp/InlineVariables.java\t2022-07-19 01:20:42.833316018 +0200\n+++ /tmp/tmpztojpz4q.java\t2022-07-19 01:20:42.833316018 +0200\n@@ -299,11 +299,11 @@\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+referenceInfo.isAssignedOnceInLifetime()) { // we didn't really modify it's do implicit re-parse\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "referenceInfo.isAssignedOnceInLifetime()) { // we didn't really modify it's total",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-121/src/com/google/javascript/jscomp/InlineVariables.java\t2022-07-19 01:21:33.113075581 +0200\n+++ /tmp/tmpbegatl8r.java\t2022-07-19 01:21:33.113075581 +0200\n@@ -299,11 +299,11 @@\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+referenceInfo.isAssignedOnceInLifetime()) { // we didn't really modify it's total\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "referenceInfo.isAssignedOnceInLifetime()) { // we didn't really modify it's",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-121/src/com/google/javascript/jscomp/InlineVariables.java\t2022-07-19 01:22:23.104833692 +0200\n+++ /tmp/tmpvw3z6v2a.java\t2022-07-19 01:22:23.108833673 +0200\n@@ -299,11 +299,11 @@\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+referenceInfo.isAssignedOnceInLifetime()) { // we didn't really modify it's\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "referenceInfo.isAssignedOnceInLifetime()) { // we didn't really modify it's totalNode",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-121/src/com/google/javascript/jscomp/InlineVariables.java\t2022-07-19 01:23:13.676586400 +0200\n+++ /tmp/tmptpg5n173.java\t2022-07-19 01:23:13.676586400 +0200\n@@ -299,11 +299,11 @@\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+referenceInfo.isAssignedOnceInLifetime()) { // we didn't really modify it's totalNode\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "referenceInfo.isAssignedOnceInLifetime()) { // we didn't really modify it was non-literal characters that might be null",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-121/src/com/google/javascript/jscomp/InlineVariables.java\t2022-07-19 01:24:03.716339378 +0200\n+++ /tmp/tmp70msag6d.java\t2022-07-19 01:24:03.716339378 +0200\n@@ -299,11 +299,11 @@\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+referenceInfo.isAssignedOnceInLifetime()) { // we didn't really modify it was non-literal characters that might be null\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "referenceInfo.isAssignedOnceInLifetime()) { // we didn't really modify it's parent",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-121/src/com/google/javascript/jscomp/InlineVariables.java\t2022-07-19 01:24:53.716090450 +0200\n+++ /tmp/tmp_ada4gcp.java\t2022-07-19 01:24:53.716090450 +0200\n@@ -299,11 +299,11 @@\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+referenceInfo.isAssignedOnceInLifetime()) { // we didn't really modify it's parent\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "referenceInfo.isAssignedOnceInLifetime()) {",
        "fixed_line": "referenceInfo.isAssignedOnceInLifetime() && // Inlining the variable based solely on well-defined and assigned // once is *NOT* correct. We relax the correctness requirement if // the variable is declared constant. (isInlineableDeclaredConstant(v, referenceInfo) || referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) {"
    },
    "Math-8": {
        "fixes": [
            {
                "k": 1,
                "patch": "public T[] sampleSize = new NotStrictlyPositiveException(KEY_OF_MONTH, sampleSize);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\t2022-07-19 01:25:43.711839636 +0200\n+++ /tmp/tmpfxxthgij.java\t2022-07-19 01:25:43.735839516 +0200\n@@ -176,17 +176,11 @@\n      * @param sampleSize the number of random values to generate.\n      * @return an array representing the random sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n-        if (sampleSize <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n-                    sampleSize);\n-        }\n-\n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+public T[] sampleSize = new NotStrictlyPositiveException(KEY_OF_MONTH, sampleSize);\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "public T[] sampleSize = new NotStrictlyPositiveException(KEY_OF_DAY, sampleSize);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\t2022-07-19 01:25:45.823829002 +0200\n+++ /tmp/tmp806q69uk.java\t2022-07-19 01:25:45.823829002 +0200\n@@ -176,17 +176,11 @@\n      * @param sampleSize the number of random values to generate.\n      * @return an array representing the random sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n-        if (sampleSize <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n-                    sampleSize);\n-        }\n-\n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+public T[] sampleSize = new NotStrictlyPositiveException(KEY_OF_DAY, sampleSize);\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "public T[] sampleSize = new NotStrictlyPositiveN_OF_DAYS.get(0).lang.reflect.Array.reflect.Array.reflect.Array.get(0).getClass(), sampleSize);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\t2022-07-19 01:25:47.815818969 +0200\n+++ /tmp/tmp9l_iom62.java\t2022-07-19 01:25:47.815818969 +0200\n@@ -176,17 +176,11 @@\n      * @param sampleSize the number of random values to generate.\n      * @return an array representing the random sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n-        if (sampleSize <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n-                    sampleSize);\n-        }\n-\n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+public T[] sampleSize = new NotStrictlyPositiveN_OF_DAYS.get(0).lang.reflect.Array.reflect.Array.reflect.Array.get(0).getClass(), sampleSize);\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "public T[] sampleSize = new NotStrictlyPositiveN_OF_DAYS.get(0).lang.reflect.Array.reflect.Array.reflect.Array.get(0).lang.get(0).getClass(), sampleSize);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\t2022-07-19 01:25:49.823808853 +0200\n+++ /tmp/tmpwxl_1g9m.java\t2022-07-19 01:25:49.823808853 +0200\n@@ -176,17 +176,11 @@\n      * @param sampleSize the number of random values to generate.\n      * @return an array representing the random sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n-        if (sampleSize <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n-                    sampleSize);\n-        }\n-\n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+public T[] sampleSize = new NotStrictlyPositiveN_OF_DAYS.get(0).lang.reflect.Array.reflect.Array.reflect.Array.get(0).lang.get(0).getClass(), sampleSize);\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "public T[] sampleSize = new NotStrictlyPositiveException(KEY_OF_DAYS_OF_MONTH, sampleSize);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\t2022-07-19 01:25:51.839798694 +0200\n+++ /tmp/tmpynfm52zk.java\t2022-07-19 01:25:51.839798694 +0200\n@@ -176,17 +176,11 @@\n      * @param sampleSize the number of random values to generate.\n      * @return an array representing the random sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n-        if (sampleSize <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n-                    sampleSize);\n-        }\n-\n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+public T[] sampleSize = new NotStrictlyPositiveException(KEY_OF_DAYS_OF_MONTH, sampleSize);\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "public T[] sampleSize = new NotStrictlyPositiveN_OF_DAYS.get(0).lang.reflect.Array.reflect.Array.reflect.Array.get(0).lang.Builder().lang.get(0).getClass(), sampleSize);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\t2022-07-19 01:25:53.891788349 +0200\n+++ /tmp/tmpgry1pnwn.java\t2022-07-19 01:25:53.891788349 +0200\n@@ -176,17 +176,11 @@\n      * @param sampleSize the number of random values to generate.\n      * @return an array representing the random sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n-        if (sampleSize <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n-                    sampleSize);\n-        }\n-\n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+public T[] sampleSize = new NotStrictlyPositiveN_OF_DAYS.get(0).lang.reflect.Array.reflect.Array.reflect.Array.get(0).lang.Builder().lang.get(0).getClass(), sampleSize);\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "public T[] sampleSize = new NotStrictlyPositiveN_OF_DAY, sampleSize);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\t2022-07-19 01:25:55.883778307 +0200\n+++ /tmp/tmpgp_sxhuy.java\t2022-07-19 01:25:55.883778307 +0200\n@@ -176,17 +176,11 @@\n      * @param sampleSize the number of random values to generate.\n      * @return an array representing the random sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n-        if (sampleSize <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n-                    sampleSize);\n-        }\n-\n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+public T[] sampleSize = new NotStrictlyPositiveN_OF_DAY, sampleSize);\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "public T[] sampleSize = new NotStrictlyPositiveN_OF_DAYS.get(0).lang.reflect.Array.reflect.Array.sub_OF_MONTH;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\t2022-07-19 01:25:57.883768220 +0200\n+++ /tmp/tmpdb1c3e63.java\t2022-07-19 01:25:57.883768220 +0200\n@@ -176,17 +176,11 @@\n      * @param sampleSize the number of random values to generate.\n      * @return an array representing the random sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n-        if (sampleSize <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n-                    sampleSize);\n-        }\n-\n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+public T[] sampleSize = new NotStrictlyPositiveN_OF_DAYS.get(0).lang.reflect.Array.reflect.Array.sub_OF_MONTH;\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "public T[] sampleSize = new NotStrictlyPositiveN_OF_DAYS.get(0).lang.reflect.Array.reflect.Array.invoke_OF_MONTH;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\t2022-07-19 01:25:59.907758010 +0200\n+++ /tmp/tmpsmq5r646.java\t2022-07-19 01:25:59.907758010 +0200\n@@ -176,17 +176,11 @@\n      * @param sampleSize the number of random values to generate.\n      * @return an array representing the random sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n-        if (sampleSize <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n-                    sampleSize);\n-        }\n-\n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+public T[] sampleSize = new NotStrictlyPositiveN_OF_DAYS.get(0).lang.reflect.Array.reflect.Array.invoke_OF_MONTH;\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "public T[] sampleSize = new NotStrictlyPositive",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\t2022-07-19 01:26:01.975747574 +0200\n+++ /tmp/tmpl_erol3r.java\t2022-07-19 01:26:01.979747552 +0200\n@@ -176,17 +176,11 @@\n      * @param sampleSize the number of random values to generate.\n      * @return an array representing the random sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n-        if (sampleSize <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n-                    sampleSize);\n-        }\n-\n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+public T[] sampleSize = new NotStrictlyPositive\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "public T[] sample(int sampleSize) throws NotStrictlyPositiveException { if (sampleSize <= 0) { throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize); } final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);",
        "fixed_line": "public Object[] sample(int sampleSize) throws NotStrictlyPositiveException { if (sampleSize <= 0) { throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize); } final Object[] out = new Object[sampleSize];"
    },
    "Time-14": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if (valueToAdd == 0) { // can't be null if (DateTimeUtils.isContiguous(iChronology).getField(iChronology); for (int i = 0, isize = partial.getFieldType(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).",
                "patch_diff": "// if (valueToAdd == 0) { // can't be null if (DateTimeUtils.isContiguous(iChronology).getField(iChronology); for (int i = 0, isize = partial.getFieldType(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// if (valueToAdd == 0) { // can't be null if (DateTimeUtils.isContiguous(iChronology).getField(iChronology); for (int i = 0, isize = partial.getFieldType(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology);",
                "patch_diff": "// if (valueToAdd == 0) { // can't be null if (DateTimeUtils.isContiguous(iChronology).getField(iChronology); for (int i = 0, isize = partial.getFieldType(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if (valueToAdd == 0) { // can't be null if (DateTimeUtils.isContiguous(iChronology).getField(iChronology); for (int i = 0, isize = partial.getFieldType(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology());",
                "patch_diff": "// if (valueToAdd == 0) { // can't be null if (DateTimeUtils.isContiguous(iChronology).getField(iChronology); for (int i = 0, isize = partial.getFieldType(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// if (valueToAdd == 0) { // can't be null if (DateTimeUtils.isContiguous(iChronology).getField(iChronology); for (int i = 0, isize = partial.getFieldType(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology.",
                "patch_diff": "// if (valueToAdd == 0) { // can't be null if (DateTimeUtils.isContiguous(iChronology).getField(iChronology); for (int i = 0, isize = partial.getFieldType(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// if (valueToAdd == 0) { // can't be null if (DateTimeUtils.isContiguous(iChronology).getField(iChronology); for (int i = 0, isize = partial.getFieldType(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology[",
                "patch_diff": "// if (valueToAdd == 0) { // can't be null if (DateTimeUtils.isContiguous(iChronology).getField(iChronology); for (int i = 0, isize = partial.getFieldType(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology[",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if (valueToAdd == 0) { // can't be null if (DateTimeUtils.isContiguous(iChronology).getField(iChronology); for (int i = 0, isize = partial.getFieldType(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology[iChronology).getField(",
                "patch_diff": "// if (valueToAdd == 0) { // can't be null if (DateTimeUtils.isContiguous(iChronology).getField(iChronology); for (int i = 0, isize = partial.getFieldType(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology[iChronology).getField(",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// if (valueToAdd == 0) { // can't be null if (DateTimeUtils.isContiguous(iChronology).getField(iChronology); for (int i = 0, isize = partial.getFieldType(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology[iChronology).getField(iChronology).getField(",
                "patch_diff": "// if (valueToAdd == 0) { // can't be null if (DateTimeUtils.isContiguous(iChronology).getField(iChronology); for (int i = 0, isize = partial.getFieldType(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology[iChronology).getField(iChronology).getField(",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// if (valueToAdd == 0) { // can't be null if (DateTimeUtils.isContiguous(iChronology).getField(iChronology); for (int i = 0, isize = partial.getFieldType(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology[iChronology).getField(iChronology).getField(iChronology).getField(",
                "patch_diff": "// if (valueToAdd == 0) { // can't be null if (DateTimeUtils.isContiguous(iChronology).getField(iChronology); for (int i = 0, isize = partial.getFieldType(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology[iChronology).getField(iChronology).getField(iChronology).getField(",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// if (valueToAdd == 0) { // can't be null if (DateTimeUtils.isContiguous(iChronology).getField(iChronology); for (int i = 0, isize = partial.getFieldType(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology.getField(iChronology).getField(iChronology).getField(iChronology).",
                "patch_diff": "// if (valueToAdd == 0) { // can't be null if (DateTimeUtils.isContiguous(iChronology).getField(iChronology); for (int i = 0, isize = partial.getFieldType(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology.getField(iChronology).getField(iChronology).getField(iChronology).",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if (valueToAdd == 0) { // can't be null if (DateTimeUtils.isContiguous(iChronology).getField(iChronology); for (int i = 0, isize = partial.getFieldType(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology.getField(iChronology).getField(iChronology).",
                "patch_diff": "// if (valueToAdd == 0) { // can't be null if (DateTimeUtils.isContiguous(iChronology).getField(iChronology); for (int i = 0, isize = partial.getFieldType(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology).getField(iChronology.getField(iChronology).getField(iChronology).",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) { // month is largest field and being added to, such as month-day int curMonth0 = partial.getValue(0) - 1; int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1; return set(partial, 0, values, newMonth); }"
    },
    "Lang-44": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if (val.startsWith(\"\\\"\\\" is not a valid number.\"); }",
                "patch_diff": "// if (val.startsWith(\"\\\"\\\" is not a valid number.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// a valid number.\"); } if (val.startsWith(\"\\\"\\\" is not a valid number.\"); }",
                "patch_diff": "// a valid number.\"); } if (val.startsWith(\"\\\"\\\" is not a valid number.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// a valid number.\"); } if (val.startsWith(\"\\\"\\\" is not a valid number.\");",
                "patch_diff": "// a valid number.\"); } if (val.startsWith(\"\\\"\\\" is not a valid number.\");",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// // a valid number.\"); } if (val.startsWith(\"\\\"\\\" is not a valid number.\"); }",
                "patch_diff": "// // a valid number.\"); } if (val.startsWith(\"\\\"\\\" is not a valid number.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// a valid number.\"); } else if (val.startsWith(\"\\\"\\\" is not a valid number.\"); }",
                "patch_diff": "// a valid number.\"); } else if (val.startsWith(\"\\\"\\\" is not a valid number.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if (val.startsWith(\"\\\"\\\" is not a valid number.\");",
                "patch_diff": "// if (val.startsWith(\"\\\"\\\" is not a valid number.\");",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// // a valid number.\"); } if (val.startsWith(\"\\\"\\\" is not a valid number.\");",
                "patch_diff": "// // a valid number.\"); } if (val.startsWith(\"\\\"\\\" is not a valid number.\");",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// a valid number.\"); } else if (val.startsWith(\"\\\"\\\" is not a valid number.\");",
                "patch_diff": "// a valid number.\"); } else if (val.startsWith(\"\\\"\\\" is not a valid number.\");",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// if (val.startsWith(\"\\\"\\\" is not a valid number.\"); } if (val.length() == 0) {",
                "patch_diff": "// if (val.startsWith(\"\\\"\\\" is not a valid number.\"); } if (val.length() == 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// a valid number.\"); } if (val.startsWith(\"--\")) {",
                "patch_diff": "// a valid number.\"); } if (val.startsWith(\"--\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (val.length() == 1 && !Character.isDigit(val.charAt(0))) { throw new NumberFormatException(val + \" is not a valid number.\"); }"
    },
    "Jsoup-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "tq.consume(); // value is to do this",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-5/src/main/java/org/jsoup/parser/Parser.java\t2022-07-19 01:26:08.087716715 +0200\n+++ /tmp/tmpe8idxyao.java\t2022-07-19 01:26:08.167716311 +0200\n@@ -201,11 +201,11 @@\n             tq.consumeWhitespace();\n         }\n         if (key.length() != 0)\n             return Attribute.createFromEncoded(key, value);\n         else {\n-            tq.consume();\n+tq.consume(); // value is to do this\n                 \n             return null;\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "tq.consume(); // value is to do this // value is to do this",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-5/src/main/java/org/jsoup/parser/Parser.java\t2022-07-19 01:26:11.195701014 +0200\n+++ /tmp/tmpikd5j4f3.java\t2022-07-19 01:26:11.195701014 +0200\n@@ -201,11 +201,11 @@\n             tq.consumeWhitespace();\n         }\n         if (key.length() != 0)\n             return Attribute.createFromEncoded(key, value);\n         else {\n-            tq.consume();\n+tq.consume(); // value is to do this // value is to do this\n                 \n             return null;\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "tq.consume(); // we didn't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-5/src/main/java/org/jsoup/parser/Parser.java\t2022-07-19 01:26:13.991686882 +0200\n+++ /tmp/tmpsu7u5dni.java\t2022-07-19 01:26:13.991686882 +0200\n@@ -201,11 +201,11 @@\n             tq.consumeWhitespace();\n         }\n         if (key.length() != 0)\n             return Attribute.createFromEncoded(key, value);\n         else {\n-            tq.consume();\n+tq.consume(); // we didn't really modify it's totalGJACKSON-notnotnotnot real number\n                 \n             return null;\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "tq.consume(); // we didn't really modify it's totalGJACKSON-notnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-5/src/main/java/org/jsoup/parser/Parser.java\t2022-07-19 01:26:16.547673962 +0200\n+++ /tmp/tmpxdhfc787.java\t2022-07-19 01:26:16.547673962 +0200\n@@ -201,11 +201,11 @@\n             tq.consumeWhitespace();\n         }\n         if (key.length() != 0)\n             return Attribute.createFromEncoded(key, value);\n         else {\n-            tq.consume();\n+tq.consume(); // we didn't really modify it's totalGJACKSON-notnotnot real number\n                 \n             return null;\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "tq.consume(); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-5/src/main/java/org/jsoup/parser/Parser.java\t2022-07-19 01:26:18.895662088 +0200\n+++ /tmp/tmpwu0w8us0.java\t2022-07-19 01:26:18.895662088 +0200\n@@ -201,11 +201,11 @@\n             tq.consumeWhitespace();\n         }\n         if (key.length() != 0)\n             return Attribute.createFromEncoded(key, value);\n         else {\n-            tq.consume();\n+tq.consume(); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n                 \n             return null;\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "tq.consume(); // value is to do this // we didn't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-5/src/main/java/org/jsoup/parser/Parser.java\t2022-07-19 01:26:21.439649218 +0200\n+++ /tmp/tmpb4yn3hhf.java\t2022-07-19 01:26:21.443649196 +0200\n@@ -201,11 +201,11 @@\n             tq.consumeWhitespace();\n         }\n         if (key.length() != 0)\n             return Attribute.createFromEncoded(key, value);\n         else {\n-            tq.consume();\n+tq.consume(); // value is to do this // we didn't really modify it's totalGJACKSON-notnotnotnot real number\n                 \n             return null;\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "tq.consume(); // value is to do this // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-5/src/main/java/org/jsoup/parser/Parser.java\t2022-07-19 01:26:24.099635756 +0200\n+++ /tmp/tmpi3l6x71u.java\t2022-07-19 01:26:24.099635756 +0200\n@@ -201,11 +201,11 @@\n             tq.consumeWhitespace();\n         }\n         if (key.length() != 0)\n             return Attribute.createFromEncoded(key, value);\n         else {\n-            tq.consume();\n+tq.consume(); // value is to do this // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n                 \n             return null;\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "tq.consume(); // value is to do this // we didn't really modify it's totalGJACKSON-notnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-5/src/main/java/org/jsoup/parser/Parser.java\t2022-07-19 01:26:26.647622857 +0200\n+++ /tmp/tmperxd6p88.java\t2022-07-19 01:26:26.647622857 +0200\n@@ -201,11 +201,11 @@\n             tq.consumeWhitespace();\n         }\n         if (key.length() != 0)\n             return Attribute.createFromEncoded(key, value);\n         else {\n-            tq.consume();\n+tq.consume(); // value is to do this // we didn't really modify it's totalGJACKSON-notnotnot real number\n                 \n             return null;\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "tq.consume(); // we didn't really modify it's totalGJACKSON-notnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-5/src/main/java/org/jsoup/parser/Parser.java\t2022-07-19 01:26:29.075610564 +0200\n+++ /tmp/tmpwavsvju1.java\t2022-07-19 01:26:29.075610564 +0200\n@@ -201,11 +201,11 @@\n             tq.consumeWhitespace();\n         }\n         if (key.length() != 0)\n             return Attribute.createFromEncoded(key, value);\n         else {\n-            tq.consume();\n+tq.consume(); // we didn't really modify it's totalGJACKSON-notnot real number\n                 \n             return null;\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "tq.consume(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-5/src/main/java/org/jsoup/parser/Parser.java\t2022-07-19 01:26:31.611597719 +0200\n+++ /tmp/tmpwyr3eg27.java\t2022-07-19 01:26:31.611597719 +0200\n@@ -201,11 +201,11 @@\n             tq.consumeWhitespace();\n         }\n         if (key.length() != 0)\n             return Attribute.createFromEncoded(key, value);\n         else {\n-            tq.consume();\n+tq.consume(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n                 \n             return null;\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "tq.consume();",
        "fixed_line": "if (value.length() == 0) // no key, no val; unknown char, keep popping so not get stuck tq.advance();"
    },
    "Math-50": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (x < x0 = 0.5 * (x0 + x1 - FastMath.max(x0)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2022-07-19 01:26:34.479583185 +0200\n+++ /tmp/tmpo9gm9y0v.java\t2022-07-19 01:26:34.491583126 +0200\n@@ -182,14 +182,11 @@\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+if (x < x0 = 0.5 * (x0 + x1 - FastMath.max(x0)) {\n                     break;\n                 default:\n                     // Should never happen.\n                     throw new MathInternalError();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (x < x0 = 0.5 * (x0 + x1 - FastMath.max(x0)) { f0 = computeObjectiveValue(x0); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2022-07-19 01:26:36.459573149 +0200\n+++ /tmp/tmp9qqru7nu.java\t2022-07-19 01:26:36.459573149 +0200\n@@ -182,14 +182,11 @@\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+if (x < x0 = 0.5 * (x0 + x1 - FastMath.max(x0)) { f0 = computeObjectiveValue(x0); }\n                     break;\n                 default:\n                     // Should never happen.\n                     throw new MathInternalError();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (x < x0 = 0.5 * (x0 + x1 - FastMath.max(x0)) == f0 = computeObjectiveValue(x0); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2022-07-19 01:26:38.355563539 +0200\n+++ /tmp/tmp346i5evu.java\t2022-07-19 01:26:38.355563539 +0200\n@@ -182,14 +182,11 @@\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+if (x < x0 = 0.5 * (x0 + x1 - FastMath.max(x0)) == f0 = computeObjectiveValue(x0); }\n                     break;\n                 default:\n                     // Should never happen.\n                     throw new MathInternalError();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(x0)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2022-07-19 01:26:40.315553600 +0200\n+++ /tmp/tmpmxel6m9n.java\t2022-07-19 01:26:40.315553600 +0200\n@@ -182,14 +182,11 @@\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(x0)) {\n                     break;\n                 default:\n                     // Should never happen.\n                     throw new MathInternalError();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(x0)) { f0 = computeObjectiveValue(x0); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2022-07-19 01:26:42.275543660 +0200\n+++ /tmp/tmpz8m0o8ts.java\t2022-07-19 01:26:42.275543660 +0200\n@@ -182,14 +182,11 @@\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(x0)) { f0 = computeObjectiveValue(x0); }\n                     break;\n                 default:\n                     // Should never happen.\n                     throw new MathInternalError();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (x < x0 = 0.5 * (x0 + x1 - FastMath.max(x0)) == f0 = computeObjectiveValue(x0); f0 = computeObjectiveValue(x0); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2022-07-19 01:26:44.239533694 +0200\n+++ /tmp/tmp372_t90q.java\t2022-07-19 01:26:44.243533675 +0200\n@@ -182,14 +182,11 @@\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+if (x < x0 = 0.5 * (x0 + x1 - FastMath.max(x0)) == f0 = computeObjectiveValue(x0); f0 = computeObjectiveValue(x0); }\n                     break;\n                 default:\n                     // Should never happen.\n                     throw new MathInternalError();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (x >= x1) { x0 = 0.5 * (x0 + x1 - FastMath.abs(x0)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2022-07-19 01:26:46.311523180 +0200\n+++ /tmp/tmpg3m53igf.java\t2022-07-19 01:26:46.311523180 +0200\n@@ -182,14 +182,11 @@\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+if (x >= x1) { x0 = 0.5 * (x0 + x1 - FastMath.abs(x0)) {\n                     break;\n                 default:\n                     // Should never happen.\n                     throw new MathInternalError();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (x!= x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(x0)) { f0 = computeObjectiveValue(x0); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2022-07-19 01:26:48.315513007 +0200\n+++ /tmp/tmpnn5d38i0.java\t2022-07-19 01:26:48.315513007 +0200\n@@ -182,14 +182,11 @@\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+if (x!= x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(x0)) { f0 = computeObjectiveValue(x0); }\n                     break;\n                 default:\n                     // Should never happen.\n                     throw new MathInternalError();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (x >= x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(x0)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2022-07-19 01:26:50.475502043 +0200\n+++ /tmp/tmpvm43pvts.java\t2022-07-19 01:26:50.475502043 +0200\n@@ -182,14 +182,11 @@\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+if (x >= x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(x0)) {\n                     break;\n                 default:\n                     // Should never happen.\n                     throw new MathInternalError();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (x!= x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(x0)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2022-07-19 01:26:52.547491519 +0200\n+++ /tmp/tmphml4qpvu.java\t2022-07-19 01:26:52.547491519 +0200\n@@ -182,14 +182,11 @@\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+if (x!= x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(x0)) {\n                     break;\n                 default:\n                     // Should never happen.\n                     throw new MathInternalError();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); }",
        "fixed_line": ""
    },
    "Closure-124": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (node.isName() && isNameAssignedTo(node.getString(), replacement)) { return false; }",
                "patch_diff": "if (node.isName() && isNameAssignedTo(node.getString(), replacement)) { return false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (node.isName()) { return false; }",
                "patch_diff": "if (node.isName()) { return false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (node.isGetProp()) { return false; }",
                "patch_diff": "if (node.isGetProp()) { return false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (node.isName() && isNameAssignedTo(node.getFirstChild()) { return false; }",
                "patch_diff": "if (node.isName() && isNameAssignedTo(node.getFirstChild()) { return false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (node.isName() && isNameAssignedTo(node.getFirstChild()) {",
                "patch_diff": "if (node.isName() && isNameAssignedTo(node.getFirstChild()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (node.isName() && isNameAssignedTo(node.getString(), replacement)) {",
                "patch_diff": "if (node.isName() && isNameAssignedTo(node.getString(), replacement)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (node.checkArgument(node.getString(), replacement)) { return false; }",
                "patch_diff": "if (node.checkArgument(node.getString(), replacement)) { return false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (node.getString() && isNameAssignedTo(node.getString(), replacement)) { return false; }",
                "patch_diff": "if (node.getString() && isNameAssignedTo(node.getString(), replacement)) { return false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (node.isName() && isNameAssignedTo(node.getString(), replacement)) { return false; } else if (node.getFirstChild()) { return false; }",
                "patch_diff": "if (node.isName() && isNameAssignedTo(node.getString(), replacement)) { return false; } else if (node.getFirstChild()) { return false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return false; } Preconditions.isName() && isNameAssignedTo(node.getString(), replacement)) { return false; }",
                "patch_diff": "return false; } Preconditions.isName() && isNameAssignedTo(node.getString(), replacement)) { return false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "while (node.isGetProp()) { node = node.getFirstChild(); }"
    },
    "Jsoup-9": {
        "fixes": [
            {
                "k": 1,
                "patch": "private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+ChildChild\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-9/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 01:26:56.375472074 +0200\n+++ /tmp/tmp0w_8zio_.java\t2022-07-19 01:26:56.391471993 +0200\n@@ -33,11 +33,11 @@\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n-    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n+private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+ChildChild\");\n \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+ensure\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-9/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 01:26:59.567455850 +0200\n+++ /tmp/tmp922fs5dn.java\t2022-07-19 01:26:59.571455832 +0200\n@@ -33,11 +33,11 @@\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n-    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n+private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+ensure\");\n \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+ determine\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-9/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 01:27:02.127442835 +0200\n+++ /tmp/tmpmk_1kdr7.java\t2022-07-19 01:27:02.127442835 +0200\n@@ -33,11 +33,11 @@\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n-    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n+private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+ determine\");\n \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+Static\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-9/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 01:27:05.023428107 +0200\n+++ /tmp/tmpa1qt_qti.java\t2022-07-19 01:27:05.023428107 +0200\n@@ -33,11 +33,11 @@\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n-    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n+private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+Static\");\n \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+country\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-9/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 01:27:07.823413865 +0200\n+++ /tmp/tmp8462zjk6.java\t2022-07-19 01:27:07.823413865 +0200\n@@ -33,11 +33,11 @@\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n-    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n+private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+country\");\n \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+Child\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-9/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 01:27:10.547400004 +0200\n+++ /tmp/tmpykcc_qwa.java\t2022-07-19 01:27:10.547400004 +0200\n@@ -33,11 +33,11 @@\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n-    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n+private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+Child\");\n \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|[a-Z]+country\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-9/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 01:27:13.343385771 +0200\n+++ /tmp/tmpkd2agrcw.java\t2022-07-19 01:27:13.343385771 +0200\n@@ -33,11 +33,11 @@\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n-    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n+private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|[a-Z]+country\");\n \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+ determine\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-9/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 01:27:16.039372040 +0200\n+++ /tmp/tmpg0n_t11e.java\t2022-07-19 01:27:16.039372040 +0200\n@@ -33,11 +33,11 @@\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n-    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n+private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+ determine\");\n \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+ChildChildChild\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-9/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 01:27:18.607358960 +0200\n+++ /tmp/tmpx7bh_1td.java\t2022-07-19 01:27:18.607358960 +0200\n@@ -33,11 +33,11 @@\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n-    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n+private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+ChildChildChild\");\n \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|[a-Z]+ensure\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-9/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 01:27:21.563343899 +0200\n+++ /tmp/tmpprze81wr.java\t2022-07-19 01:27:21.567343881 +0200\n@@ -33,11 +33,11 @@\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n-    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n+private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|[a-Z]+ensure\");\n \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");",
        "fixed_line": "private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+\\\\d*);?\");"
    },
    "JacksonDatabind-19": {
        "fixes": [
            {
                "k": 1,
                "patch": "JavaType typeParams = findTypeParameters(rawClass, Map.class); // ok to have no types (\"rawClass, Map.class);",
                "patch_diff": "JavaType typeParams = findTypeParameters(rawClass, Map.class); // ok to have no types (\"rawClass, Map.class);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "JavaType typeParams = findTypeParameters(rawClass, Map.class); // ok to have no types (rawClass)",
                "patch_diff": "JavaType typeParams = findTypeParameters(rawClass, Map.class); // ok to have no types (rawClass)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "JavaType[] typeParams = findTypeParameters(rawClass, Map.class); // ok to have no types (\"rawClass, Map.class);",
                "patch_diff": "JavaType[] typeParams = findTypeParameters(rawClass, Map.class); // ok to have no types (\"rawClass, Map.class);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "JavaType int typeParams = findTypeParameters(rawClass, Map.class); // ok to have no types (\"rawClass, Map.class);",
                "patch_diff": "JavaType int typeParams = findTypeParameters(rawClass, Map.class); // ok to have no types (\"rawClass, Map.class);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "JavaType[] typeParams = findTypeParameters(rawClass, Map.class); // ok to have no types (rawClass)",
                "patch_diff": "JavaType[] typeParams = findTypeParameters(rawClass, Map.class); // ok to have no types (rawClass)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "JavaType typeParams = findTypeParameters(rawClass, Map.class); // ok to have no types (\"rawClass",
                "patch_diff": "JavaType typeParams = findTypeParameters(rawClass, Map.class); // ok to have no types (\"rawClass",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "JavaType typeParams = findTypeParameters(rawClass, Map.class); // ok to have no types (\"rawClass,",
                "patch_diff": "JavaType typeParams = findTypeParameters(rawClass, Map.class); // ok to have no types (\"rawClass,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "JavaType typeParams = findTypeParameters(rawClass, Map.class); // ok to have no types (\"rawClass.class);",
                "patch_diff": "JavaType typeParams = findTypeParameters(rawClass, Map.class); // ok to have no types (\"rawClass.class);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "JavaType[] typeParams = findTypeParameters(rawClass, Map.class); // ok to have no types (\"rawClass,",
                "patch_diff": "JavaType[] typeParams = findTypeParameters(rawClass, Map.class); // ok to have no types (\"rawClass,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "JavaType typeParams = findTypeParameters(rawClass, Map.class); // ok to have no types (\"rawClass.class",
                "patch_diff": "JavaType typeParams = findTypeParameters(rawClass, Map.class); // ok to have no types (\"rawClass.class",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (rawClass == Properties.class) { return MapType.construct(rawClass, CORE_TYPE_STRING, CORE_TYPE_STRING); }"
    },
    "JacksonDatabind-98": {
        "fixes": [
            {
                "k": 1,
                "patch": "buffer.assignParameter(typeProp, typeId);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-98/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\t2022-07-19 01:27:26.299319761 +0200\n+++ /tmp/tmpty12g7yg.java\t2022-07-19 01:27:26.367319412 +0200\n@@ -293,11 +293,11 @@\n                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n                 // for now, should only be needed for creator properties, too\n                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                     //    apply deserializer... fun fun.\n-                    buffer.assignParameter(typeProp, typeId);\n+buffer.assignParameter(typeProp, typeId);\n                 }\n             }\n         }\n         Object bean = creator.build(ctxt, buffer);\n         // third: assign non-creator properties\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "buffer.assignParameter(typeProp, typeId); // only override if it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-98/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\t2022-07-19 01:28:25.087019080 +0200\n+++ /tmp/tmpj21z5cii.java\t2022-07-19 01:28:25.087019080 +0200\n@@ -293,11 +293,11 @@\n                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n                 // for now, should only be needed for creator properties, too\n                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                     //    apply deserializer... fun fun.\n-                    buffer.assignParameter(typeProp, typeId);\n+buffer.assignParameter(typeProp, typeId); // only override if it's totalGJACKSON-notnotnotnotnotnotnot real number\n                 }\n             }\n         }\n         Object bean = creator.build(ctxt, buffer);\n         // third: assign non-creator properties\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "buffer.assignParameter(typeProp, typeId); // only override if it's totalGJACKSON-notnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-98/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\t2022-07-19 01:29:19.786737741 +0200\n+++ /tmp/tmp8j_53w0b.java\t2022-07-19 01:29:19.786737741 +0200\n@@ -293,11 +293,11 @@\n                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n                 // for now, should only be needed for creator properties, too\n                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                     //    apply deserializer... fun fun.\n-                    buffer.assignParameter(typeProp, typeId);\n+buffer.assignParameter(typeProp, typeId); // only override if it's totalGJACKSON-notnotnotnotnotnotnotnot real number\n                 }\n             }\n         }\n         Object bean = creator.build(ctxt, buffer);\n         // third: assign non-creator properties\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "buffer.assignParameter(typeProp, typeId); // only override if it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-98/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\t2022-07-19 01:30:13.466460329 +0200\n+++ /tmp/tmplm46iori.java\t2022-07-19 01:30:13.466460329 +0200\n@@ -293,11 +293,11 @@\n                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n                 // for now, should only be needed for creator properties, too\n                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                     //    apply deserializer... fun fun.\n-                    buffer.assignParameter(typeProp, typeId);\n+buffer.assignParameter(typeProp, typeId); // only override if it's totalGJACKSON-notnotnotnotnotnot real number\n                 }\n             }\n         }\n         Object bean = creator.build(ctxt, buffer);\n         // third: assign non-creator properties\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "buffer.assignParameter(typeProp, typeId); // only override if it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-98/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\t2022-07-19 01:31:07.694178892 +0200\n+++ /tmp/tmpi0v03aja.java\t2022-07-19 01:31:07.698178871 +0200\n@@ -293,11 +293,11 @@\n                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n                 // for now, should only be needed for creator properties, too\n                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                     //    apply deserializer... fun fun.\n-                    buffer.assignParameter(typeProp, typeId);\n+buffer.assignParameter(typeProp, typeId); // only override if it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number\n                 }\n             }\n         }\n         Object bean = creator.build(ctxt, buffer);\n         // third: assign non-creator properties\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "buffer.assignParameter(typeProp, typeId); // only override if it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-98/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\t2022-07-19 01:32:02.021895854 +0200\n+++ /tmp/tmplz0abs6s.java\t2022-07-19 01:32:02.021895854 +0200\n@@ -293,11 +293,11 @@\n                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n                 // for now, should only be needed for creator properties, too\n                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                     //    apply deserializer... fun fun.\n-                    buffer.assignParameter(typeProp, typeId);\n+buffer.assignParameter(typeProp, typeId); // only override if it's totalGJACKSON-notnotnotnotnot real number\n                 }\n             }\n         }\n         Object bean = creator.build(ctxt, buffer);\n         // third: assign non-creator properties\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "buffer.assignParameter(typeProp, typeId); // only override if it's totalGJACKSON-407] -- allow use a digit after the E",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-98/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\t2022-07-19 01:32:55.377616934 +0200\n+++ /tmp/tmppp5sgfrd.java\t2022-07-19 01:32:55.377616934 +0200\n@@ -293,11 +293,11 @@\n                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n                 // for now, should only be needed for creator properties, too\n                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                     //    apply deserializer... fun fun.\n-                    buffer.assignParameter(typeProp, typeId);\n+buffer.assignParameter(typeProp, typeId); // only override if it's totalGJACKSON-407] -- allow use a digit after the E\n                 }\n             }\n         }\n         Object bean = creator.build(ctxt, buffer);\n         // third: assign non-creator properties\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "buffer.assignParameter(typeProp, typeId); // only override if it's totalGJACKSON-notnotnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-98/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\t2022-07-19 01:33:49.101335235 +0200\n+++ /tmp/tmp3ddbd6_o.java\t2022-07-19 01:33:49.101335235 +0200\n@@ -293,11 +293,11 @@\n                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n                 // for now, should only be needed for creator properties, too\n                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                     //    apply deserializer... fun fun.\n-                    buffer.assignParameter(typeProp, typeId);\n+buffer.assignParameter(typeProp, typeId); // only override if it's totalGJACKSON-notnotnotnotnotnotnotnotnotnot real number\n                 }\n             }\n         }\n         Object bean = creator.build(ctxt, buffer);\n         // third: assign non-creator properties\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "buffer.assignParameter(typeProp, typeId); // remove old items if it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-98/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\t2022-07-19 01:34:42.773053036 +0200\n+++ /tmp/tmppjplonpq.java\t2022-07-19 01:34:42.773053036 +0200\n@@ -293,11 +293,11 @@\n                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n                 // for now, should only be needed for creator properties, too\n                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                     //    apply deserializer... fun fun.\n-                    buffer.assignParameter(typeProp, typeId);\n+buffer.assignParameter(typeProp, typeId); // remove old items if it's totalGJACKSON-notnotnotnotnotnotnot real number\n                 }\n             }\n         }\n         Object bean = creator.build(ctxt, buffer);\n         // third: assign non-creator properties\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "buffer.assignParameter(typeProp, typeId); // remove old items if it's totalGJACKSON-notnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-98/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\t2022-07-19 01:35:37.116766599 +0200\n+++ /tmp/tmp7ec9uzo1.java\t2022-07-19 01:35:37.116766599 +0200\n@@ -293,11 +293,11 @@\n                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n                 // for now, should only be needed for creator properties, too\n                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                     //    apply deserializer... fun fun.\n-                    buffer.assignParameter(typeProp, typeId);\n+buffer.assignParameter(typeProp, typeId); // remove old items if it's totalGJACKSON-notnotnotnotnotnotnotnot real number\n                 }\n             }\n         }\n         Object bean = creator.build(ctxt, buffer);\n         // third: assign non-creator properties\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "buffer.assignParameter(typeProp, typeId);",
        "fixed_line": "final Object v; if (typeProp.getType().hasRawClass(String.class)) { v = typeId; } else { TokenBuffer tb = new TokenBuffer(p, ctxt); tb.writeString(typeId); v = typeProp.getValueDeserializer().deserialize(tb.asParserOnFirstToken(), ctxt); tb.close(); } buffer.assignParameter(typeProp, v);"
    },
    "Closure-13": {
        "fixes": [
            {
                "k": 1,
                "patch": "Node next = c.getNext(); // c = c.next, block;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-13/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\t2022-07-19 01:36:31.456479543 +0200\n+++ /tmp/tmphb4sqvo_.java\t2022-07-19 01:36:31.528479162 +0200\n@@ -122,11 +122,11 @@\n     int visits = 0;\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         traverse(c);\n-        Node next = c.getNext();\n+Node next = c.getNext(); // c = c.next, block;\n         c = next;\n       }\n \n       visit(node);\n       visits++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "Node next = c.getNext(); // c may be removed (c)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-13/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\t2022-07-19 01:37:14.964249288 +0200\n+++ /tmp/tmpe6o4pqyp.java\t2022-07-19 01:37:14.964249288 +0200\n@@ -122,11 +122,11 @@\n     int visits = 0;\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         traverse(c);\n-        Node next = c.getNext();\n+Node next = c.getNext(); // c may be removed (c)\n         c = next;\n       }\n \n       visit(node);\n       visits++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "Node next = c.getNext(); // c = c.next;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-13/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\t2022-07-19 01:37:55.956032040 +0200\n+++ /tmp/tmpbyn5hsi4.java\t2022-07-19 01:37:55.960032019 +0200\n@@ -122,11 +122,11 @@\n     int visits = 0;\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         traverse(c);\n-        Node next = c.getNext();\n+Node next = c.getNext(); // c = c.next;\n         c = next;\n       }\n \n       visit(node);\n       visits++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "Node next = c.getNext(); // c may be removed.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-13/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\t2022-07-19 01:38:37.475811711 +0200\n+++ /tmp/tmp8524pysh.java\t2022-07-19 01:38:37.475811711 +0200\n@@ -122,11 +122,11 @@\n     int visits = 0;\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         traverse(c);\n-        Node next = c.getNext();\n+Node next = c.getNext(); // c may be removed.\n         c = next;\n       }\n \n       visit(node);\n       visits++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "Node next = c.getNext(); // c may be removed",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-13/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\t2022-07-19 01:39:19.107590524 +0200\n+++ /tmp/tmp15iyv85u.java\t2022-07-19 01:39:19.107590524 +0200\n@@ -122,11 +122,11 @@\n     int visits = 0;\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         traverse(c);\n-        Node next = c.getNext();\n+Node next = c.getNext(); // c may be removed\n         c = next;\n       }\n \n       visit(node);\n       visits++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "Node next = c.getNext(); // c = c.next, may be removed",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-13/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\t2022-07-19 01:40:00.563370032 +0200\n+++ /tmp/tmp6shqgvsz.java\t2022-07-19 01:40:00.563370032 +0200\n@@ -122,11 +122,11 @@\n     int visits = 0;\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         traverse(c);\n-        Node next = c.getNext();\n+Node next = c.getNext(); // c = c.next, may be removed\n         c = next;\n       }\n \n       visit(node);\n       visits++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "Node next = c.getNext(); // c may be null or empty",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-13/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\t2022-07-19 01:40:42.447147036 +0200\n+++ /tmp/tmpdvi_6lfh.java\t2022-07-19 01:40:42.451147015 +0200\n@@ -122,11 +122,11 @@\n     int visits = 0;\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         traverse(c);\n-        Node next = c.getNext();\n+Node next = c.getNext(); // c may be null or empty\n         c = next;\n       }\n \n       visit(node);\n       visits++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "Node next = c.getNext(); // c = c.next, block; // c = c.next, block;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-13/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\t2022-07-19 01:41:24.310923941 +0200\n+++ /tmp/tmpukmagy12.java\t2022-07-19 01:41:24.310923941 +0200\n@@ -122,11 +122,11 @@\n     int visits = 0;\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         traverse(c);\n-        Node next = c.getNext();\n+Node next = c.getNext(); // c = c.next, block; // c = c.next, block;\n         c = next;\n       }\n \n       visit(node);\n       visits++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "Node next = c.getNext(); // c may be removed = c.next, block;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-13/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\t2022-07-19 01:42:06.230700351 +0200\n+++ /tmp/tmp4b8xf5_f.java\t2022-07-19 01:42:06.230700351 +0200\n@@ -122,11 +122,11 @@\n     int visits = 0;\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         traverse(c);\n-        Node next = c.getNext();\n+Node next = c.getNext(); // c may be removed = c.next, block;\n         c = next;\n       }\n \n       visit(node);\n       visits++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "Node next = c.getNext(); // c = c.next, block; // c = c.next, may be removed",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-13/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\t2022-07-19 01:42:47.422480471 +0200\n+++ /tmp/tmpki54xlj6.java\t2022-07-19 01:42:47.426480450 +0200\n@@ -122,11 +122,11 @@\n     int visits = 0;\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         traverse(c);\n-        Node next = c.getNext();\n+Node next = c.getNext(); // c = c.next, block; // c = c.next, may be removed\n         c = next;\n       }\n \n       visit(node);\n       visits++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "Node next = c.getNext();",
        "fixed_line": "Node next = c.getNext();"
    },
    "JacksonCore-25": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (i <= maxCode) { // identifier, skip for a digit after the end",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-25/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\t2022-07-19 01:43:29.418256137 +0200\n+++ /tmp/tmpay2iyyml.java\t2022-07-19 01:43:29.438256031 +0200\n@@ -1958,11 +1958,11 @@\n                     break;\n                 }\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+if (i <= maxCode) { // identifier, skip for a digit after the end\n                 if (codes[i] != 0) {\n                     break;\n                 }\n             } else if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (i <= maxCode) { // don't really need 6",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-25/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\t2022-07-19 01:43:38.014210199 +0200\n+++ /tmp/tmpogkon51i.java\t2022-07-19 01:43:38.018210178 +0200\n@@ -1958,11 +1958,11 @@\n                     break;\n                 }\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+if (i <= maxCode) { // don't really need 6\n                 if (codes[i] != 0) {\n                     break;\n                 }\n             } else if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (i <= maxCode) { // followed by other number; return",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-25/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\t2022-07-19 01:43:46.686163850 +0200\n+++ /tmp/tmpml6o1jlk.java\t2022-07-19 01:43:46.690163828 +0200\n@@ -1958,11 +1958,11 @@\n                     break;\n                 }\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+if (i <= maxCode) { // followed by other number; return\n                 if (codes[i] != 0) {\n                     break;\n                 }\n             } else if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (i <= maxCode) { // identifier, just needs 2 byte/allowed chars",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-25/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\t2022-07-19 01:43:55.330117644 +0200\n+++ /tmp/tmpoehrwtdp.java\t2022-07-19 01:43:55.330117644 +0200\n@@ -1958,11 +1958,11 @@\n                     break;\n                 }\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+if (i <= maxCode) { // identifier, just needs 2 byte/allowed chars\n                 if (codes[i] != 0) {\n                     break;\n                 }\n             } else if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (i <= maxCode) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-25/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\t2022-07-19 01:44:04.046071047 +0200\n+++ /tmp/tmplvp94jik.java\t2022-07-19 01:44:04.046071047 +0200\n@@ -1958,11 +1958,11 @@\n                     break;\n                 }\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+if (i <= maxCode) {\n                 if (codes[i] != 0) {\n                     break;\n                 }\n             } else if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (i <= maxCode) { // yup, skip for now",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-25/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\t2022-07-19 01:44:12.570025473 +0200\n+++ /tmp/tmp61nr_pls.java\t2022-07-19 01:44:12.570025473 +0200\n@@ -1958,11 +1958,11 @@\n                     break;\n                 }\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+if (i <= maxCode) { // yup, skip for now\n                 if (codes[i] != 0) {\n                     break;\n                 }\n             } else if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (i <= maxCode) { // identifier, just needs 2 byte output",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-25/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\t2022-07-19 01:44:21.213979247 +0200\n+++ /tmp/tmpjciyjdyc.java\t2022-07-19 01:44:21.213979247 +0200\n@@ -1958,11 +1958,11 @@\n                     break;\n                 }\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+if (i <= maxCode) { // identifier, just needs 2 byte output\n                 if (codes[i] != 0) {\n                     break;\n                 }\n             } else if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (i <= maxCode) { // '9't really need 6",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-25/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\t2022-07-19 01:44:29.805933295 +0200\n+++ /tmp/tmp8yvs3hlc.java\t2022-07-19 01:44:29.809933272 +0200\n@@ -1958,11 +1958,11 @@\n                     break;\n                 }\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+if (i <= maxCode) { // '9't really need 6\n                 if (codes[i] != 0) {\n                     break;\n                 }\n             } else if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (i <= maxCode) { // identifier, just needs 2 triplets",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-25/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\t2022-07-19 01:44:38.625886118 +0200\n+++ /tmp/tmp0yi8cy06.java\t2022-07-19 01:44:38.625886118 +0200\n@@ -1958,11 +1958,11 @@\n                     break;\n                 }\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+if (i <= maxCode) { // identifier, just needs 2 triplets\n                 if (codes[i] != 0) {\n                     break;\n                 }\n             } else if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (i < maxCode) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-25/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\t2022-07-19 01:44:47.233840069 +0200\n+++ /tmp/tmpujzukj8d.java\t2022-07-19 01:44:47.233840069 +0200\n@@ -1958,11 +1958,11 @@\n                     break;\n                 }\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+if (i < maxCode) {\n                 if (codes[i] != 0) {\n                     break;\n                 }\n             } else if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            }
        ],
        "buggy_line": "if (i <= maxCode) {",
        "fixed_line": "if (i < maxCode) {"
    },
    "JacksonCore-7": {
        "fixes": [
            {
                "k": 1,
                "patch": "// Most likely, object: if (_type == TYPE_OBJECT) {",
                "patch_diff": "// Most likely, object: if (_type == TYPE_OBJECT) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// Most likely, object: if (_type == TYPE_OBJECT; return STATUS_OK_AFTER_COLON;",
                "patch_diff": "// Most likely, object: if (_type == TYPE_OBJECT; return STATUS_OK_AFTER_COLON;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// Most likely, object: if (_type == TYPE_OBJECT;",
                "patch_diff": "// Most likely, object: if (_type == TYPE_OBJECT;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "_gotName = TYPE_OBJECT; return STATUS_OK_AFTER_COLON;",
                "patch_diff": "_gotName = TYPE_OBJECT; return STATUS_OK_AFTER_COLON;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "_gotName = object: if (_type == TYPE_OBJECT) {",
                "patch_diff": "_gotName = object: if (_type == TYPE_OBJECT) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int writeValue() { _gotName = false; return STATUS_OK_AFTER_COLON; }",
                "patch_diff": "int writeValue() { _gotName = false; return STATUS_OK_AFTER_COLON; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// Most likely, object: if (_type == TYPE_OBJECT; return STATUS_OK_AFTER_COLON; }",
                "patch_diff": "// Most likely, object: if (_type == TYPE_OBJECT; return STATUS_OK_AFTER_COLON; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "_gotName = false; return STATUS_OK_AFTER_COLON;",
                "patch_diff": "_gotName = false; return STATUS_OK_AFTER_COLON;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// Most likely, object: if (_type == TYPE_OBJECT; ++_index; return STATUS_OK_AFTER_COLON;",
                "patch_diff": "// Most likely, object: if (_type == TYPE_OBJECT; ++_index; return STATUS_OK_AFTER_COLON;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "_gotName = 1); return STATUS_OK_AFTER_COLON;",
                "patch_diff": "_gotName = 1); return STATUS_OK_AFTER_COLON;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (!_gotName) { return STATUS_EXPECT_NAME; }"
    },
    "JacksonDatabind-92": {
        "fixes": [
            {
                "k": 1,
                "patch": "// [databind#17 // [databind#17 // [databind#17 // [JACKSON-notnotnot real number",
                "patch_diff": "// [databind#17 // [databind#17 // [databind#17 // [JACKSON-notnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// [databind#17 // [databind#17 // [databind#17 // [databind#17 // [JACKSON-notnotnot real number",
                "patch_diff": "// [databind#17 // [databind#17 // [databind#17 // [databind#17 // [JACKSON-notnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// [databind#17 // [databind#17 // [databind#17 // [JACKSON-notnot real number",
                "patch_diff": "// [databind#17 // [databind#17 // [databind#17 // [JACKSON-notnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// [databind#17 // [databind#17 // [databind#17 // [databind#17 // [JACKSON-notnot real number",
                "patch_diff": "// [databind#17 // [databind#17 // [databind#17 // [databind#17 // [JACKSON-notnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// [databind#17 // [databind#17 // [databind#17 // [databind#17 // [JACKSON-notnotnotnot real number",
                "patch_diff": "// [databind#17 // [databind#17 // [databind#17 // [databind#17 // [JACKSON-notnotnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// [databind#17 // [databind#17 // [databind#17 // [databind#17",
                "patch_diff": "// [databind#17 // [databind#17 // [databind#17 // [databind#17",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// [databind#17 // [databind#17 // [databind#17 // [databind#17 // [databind#17 // [JACKSON-notnotnot real number",
                "patch_diff": "// [databind#17 // [databind#17 // [databind#17 // [databind#17 // [databind#17 // [JACKSON-notnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// [databind#17 // [databind#17 // [databind#17 // [JACKSON-407] -- allow disabling wrapping for may not be problem",
                "patch_diff": "// [databind#17 // [databind#17 // [databind#17 // [JACKSON-407] -- allow disabling wrapping for may not be problem",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// [databind#17 // [databind#17 // [JACKSON-notnotnot real number",
                "patch_diff": "// [databind#17 // [databind#17 // [JACKSON-notnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// [databind#17 // [databind#17 // [databind#17 // [databind#17 // [databind#17 // [JACKSON-notnotnotnot real number",
                "patch_diff": "// [databind#17 // [databind#17 // [databind#17 // [databind#17 // [databind#17 // [JACKSON-notnotnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "s.add(\"java.util.logging.FileHandler\"); s.add(\"java.rmi.server.UnicastRemoteObject\"); // [databind#1737]; 3rd party s.add(\"org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor\"); s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\"); s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\"); s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");"
    },
    "Jsoup-34": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (length < length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-34/src/main/java/org/jsoup/parser/CharacterReader.java\t2022-07-19 01:44:59.489774496 +0200\n+++ /tmp/tmpyotuq72g.java\t2022-07-19 01:44:59.521774325 +0200\n@@ -86,11 +86,11 @@\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+if (length < length) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (i < length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-34/src/main/java/org/jsoup/parser/CharacterReader.java\t2022-07-19 01:45:03.293754140 +0200\n+++ /tmp/tmphdpndb75.java\t2022-07-19 01:45:03.309754056 +0200\n@@ -86,11 +86,11 @@\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+if (i < length) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (last < length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-34/src/main/java/org/jsoup/parser/CharacterReader.java\t2022-07-19 01:45:06.337737851 +0200\n+++ /tmp/tmp36xgi1ux.java\t2022-07-19 01:45:06.341737830 +0200\n@@ -86,11 +86,11 @@\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+if (last < length) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (offset < length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-34/src/main/java/org/jsoup/parser/CharacterReader.java\t2022-07-19 01:45:09.277722119 +0200\n+++ /tmp/tmp06lfrmll.java\t2022-07-19 01:45:09.277722119 +0200\n@@ -86,11 +86,11 @@\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+if (offset < length) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (i <= length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-34/src/main/java/org/jsoup/parser/CharacterReader.java\t2022-07-19 01:45:12.313705871 +0200\n+++ /tmp/tmpouczvowd.java\t2022-07-19 01:45:12.317705850 +0200\n@@ -86,11 +86,11 @@\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+if (i <= length) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (i > length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-34/src/main/java/org/jsoup/parser/CharacterReader.java\t2022-07-19 01:45:15.305689859 +0200\n+++ /tmp/tmp9bs4f5oe.java\t2022-07-19 01:45:15.305689859 +0200\n@@ -86,11 +86,11 @@\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+if (i > length) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (i == length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-34/src/main/java/org/jsoup/parser/CharacterReader.java\t2022-07-19 01:45:18.321673718 +0200\n+++ /tmp/tmpipb3tonf.java\t2022-07-19 01:45:18.321673718 +0200\n@@ -86,11 +86,11 @@\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+if (i == length) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (i!= length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-34/src/main/java/org/jsoup/parser/CharacterReader.java\t2022-07-19 01:45:21.433657062 +0200\n+++ /tmp/tmpbw647_m9.java\t2022-07-19 01:45:21.433657062 +0200\n@@ -86,11 +86,11 @@\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+if (i!= length) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (i >= length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-34/src/main/java/org/jsoup/parser/CharacterReader.java\t2022-07-19 01:45:24.365641369 +0200\n+++ /tmp/tmpazb0klrj.java\t2022-07-19 01:45:24.369641346 +0200\n@@ -86,11 +86,11 @@\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+if (i >= length) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (length > length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-34/src/main/java/org/jsoup/parser/CharacterReader.java\t2022-07-19 01:45:27.401625118 +0200\n+++ /tmp/tmp_i0z9a2b.java\t2022-07-19 01:45:27.401625118 +0200\n@@ -86,11 +86,11 @@\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+if (length > length) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (offset < length) {",
        "fixed_line": "if (offset < length && last <= length) {"
    },
    "Math-91": {
        "fixes": [
            {
                "k": 1,
                "patch": "double nOd = doubleValue(); double dOn = object.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-91/src/java/org/apache/commons/math/fraction/Fraction.java\t2022-07-19 01:45:30.417608974 +0200\n+++ /tmp/tmp99z1m455.java\t2022-07-19 01:45:30.433608887 +0200\n@@ -254,12 +254,11 @@\n      * @param object the object to compare to\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+double nOd = doubleValue(); double dOn = object.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n     /**\n      * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "double dOn = doubleValue(); double dOn = object.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-91/src/java/org/apache/commons/math/fraction/Fraction.java\t2022-07-19 01:45:36.733575164 +0200\n+++ /tmp/tmpi8wn64dx.java\t2022-07-19 01:45:36.733575164 +0200\n@@ -254,12 +254,11 @@\n      * @param object the object to compare to\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+double dOn = doubleValue(); double dOn = object.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n     /**\n      * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "double d = doubleValue(); double dOn = object.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-91/src/java/org/apache/commons/math/fraction/Fraction.java\t2022-07-19 01:45:38.737564436 +0200\n+++ /tmp/tmpkrfm0jhl.java\t2022-07-19 01:45:38.737564436 +0200\n@@ -254,12 +254,11 @@\n      * @param object the object to compare to\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+double d = doubleValue(); double dOn = object.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n     /**\n      * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "double dOd = doubleValue(); double dOn = object.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-91/src/java/org/apache/commons/math/fraction/Fraction.java\t2022-07-19 01:45:40.845553150 +0200\n+++ /tmp/tmp2fc0_jyx.java\t2022-07-19 01:45:40.845553150 +0200\n@@ -254,12 +254,11 @@\n      * @param object the object to compare to\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+double dOd = doubleValue(); double dOn = object.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n     /**\n      * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "double denominator = doubleValue(); double dOn = object.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-91/src/java/org/apache/commons/math/fraction/Fraction.java\t2022-07-19 01:45:42.981541714 +0200\n+++ /tmp/tmp3q7ic5ec.java\t2022-07-19 01:45:42.981541714 +0200\n@@ -254,12 +254,11 @@\n      * @param object the object to compare to\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+double denominator = doubleValue(); double dOn = object.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n     /**\n      * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "double denominatord = doubleValue(); double dOn = object.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-91/src/java/org/apache/commons/math/fraction/Fraction.java\t2022-07-19 01:45:45.133530194 +0200\n+++ /tmp/tmp2jf251iq.java\t2022-07-19 01:45:45.133530194 +0200\n@@ -254,12 +254,11 @@\n      * @param object the object to compare to\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+double denominatord = doubleValue(); double dOn = object.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n     /**\n      * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "double d d = doubleValue(); double dOn = object.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-91/src/java/org/apache/commons/math/fraction/Fraction.java\t2022-07-19 01:45:47.309518542 +0200\n+++ /tmp/tmpxowohfuh.java\t2022-07-19 01:45:47.313518521 +0200\n@@ -254,12 +254,11 @@\n      * @param object the object to compare to\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+double d d = doubleValue(); double dOn = object.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n     /**\n      * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "double d4 = doubleValue(); double dOn = object.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-91/src/java/org/apache/commons/math/fraction/Fraction.java\t2022-07-19 01:45:49.293507920 +0200\n+++ /tmp/tmp3bxjdsxg.java\t2022-07-19 01:45:49.293507920 +0200\n@@ -254,12 +254,11 @@\n      * @param object the object to compare to\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+double d4 = doubleValue(); double dOn = object.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n     /**\n      * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "double dOn -= doubleValue(); double dOn = object.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-91/src/java/org/apache/commons/math/fraction/Fraction.java\t2022-07-19 01:45:51.305497147 +0200\n+++ /tmp/tmpel_s86pr.java\t2022-07-19 01:45:51.305497147 +0200\n@@ -254,12 +254,11 @@\n      * @param object the object to compare to\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+double dOn -= doubleValue(); double dOn = object.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n     /**\n      * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "double nOd -= doubleValue(); double dOn = object.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-91/src/java/org/apache/commons/math/fraction/Fraction.java\t2022-07-19 01:45:53.309486417 +0200\n+++ /tmp/tmpdhluiyg7.java\t2022-07-19 01:45:53.309486417 +0200\n@@ -254,12 +254,11 @@\n      * @param object the object to compare to\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+double nOd -= doubleValue(); double dOn = object.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n     /**\n      * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "double nOd = doubleValue(); double dOn = object.doubleValue();",
        "fixed_line": "long nOd = ((long) numerator) * object.denominator; long dOn = ((long) denominator) * object.numerator;"
    },
    "Lang-40": {
        "fixes": [
            {
                "k": 1,
                "patch": "return contains(str.toUpperCase(), searchStr.toUpperCase());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-40/src/java/org/apache/commons/lang/StringUtils.java\t2022-07-19 01:45:55.361475431 +0200\n+++ /tmp/tmphdcdqed3.java\t2022-07-19 01:45:55.389475281 +0200\n@@ -1043,11 +1043,11 @@\n      */\n     public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+return contains(str.toUpperCase(), searchStr.toUpperCase());\n     }\n \n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return contains(str.toUpperCase(), searchStr, searchStr.toUpperCase());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-40/src/java/org/apache/commons/lang/StringUtils.java\t2022-07-19 01:46:04.129428479 +0200\n+++ /tmp/tmpzg3_b265.java\t2022-07-19 01:46:04.133428458 +0200\n@@ -1043,11 +1043,11 @@\n      */\n     public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+return contains(str.toUpperCase(), searchStr, searchStr.toUpperCase());\n     }\n \n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return contains(str.toUpperCase(), searchStr);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-40/src/java/org/apache/commons/lang/StringUtils.java\t2022-07-19 01:46:05.905418967 +0200\n+++ /tmp/tmp7vrujkqb.java\t2022-07-19 01:46:05.909418946 +0200\n@@ -1043,11 +1043,11 @@\n      */\n     public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+return contains(str.toUpperCase(), searchStr);\n     }\n \n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return contains(str.toUpperCase(), searchStr, replaceStr.toUpperCase());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-40/src/java/org/apache/commons/lang/StringUtils.java\t2022-07-19 01:46:14.153374797 +0200\n+++ /tmp/tmpgbibjxzn.java\t2022-07-19 01:46:14.153374797 +0200\n@@ -1043,11 +1043,11 @@\n      */\n     public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+return contains(str.toUpperCase(), searchStr, replaceStr.toUpperCase());\n     }\n \n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return contains(str.toUpperCase(), searchStr, searchStr);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-40/src/java/org/apache/commons/lang/StringUtils.java\t2022-07-19 01:46:15.941365220 +0200\n+++ /tmp/tmp9_w4h49o.java\t2022-07-19 01:46:15.945365199 +0200\n@@ -1043,11 +1043,11 @@\n      */\n     public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+return contains(str.toUpperCase(), searchStr, searchStr);\n     }\n \n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return contains(str.toUpperCase(), searchStr, this.toUpperCase());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-40/src/java/org/apache/commons/lang/StringUtils.java\t2022-07-19 01:46:17.725355664 +0200\n+++ /tmp/tmp_la369qk.java\t2022-07-19 01:46:17.725355664 +0200\n@@ -1043,11 +1043,11 @@\n      */\n     public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+return contains(str.toUpperCase(), searchStr, this.toUpperCase());\n     }\n \n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return contains(str.toUpperCase - searchStr.toUpperCase());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-40/src/java/org/apache/commons/lang/StringUtils.java\t2022-07-19 01:46:19.597345637 +0200\n+++ /tmp/tmp3zm9e14v.java\t2022-07-19 01:46:19.601345616 +0200\n@@ -1043,11 +1043,11 @@\n      */\n     public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+return contains(str.toUpperCase - searchStr.toUpperCase());\n     }\n \n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return contains(str.toUpperCasetoUpperCase(), searchStr.toUpperCase());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-40/src/java/org/apache/commons/lang/StringUtils.java\t2022-07-19 01:46:21.429335826 +0200\n+++ /tmp/tmpwfs3sw2u.java\t2022-07-19 01:46:21.429335826 +0200\n@@ -1043,11 +1043,11 @@\n      */\n     public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+return contains(str.toUpperCasetoUpperCase(), searchStr.toUpperCase());\n     }\n \n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return contains(str.toUpperCase(), replaceStr.toUpperCase());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-40/src/java/org/apache/commons/lang/StringUtils.java\t2022-07-19 01:46:23.385325348 +0200\n+++ /tmp/tmpki4xdlgl.java\t2022-07-19 01:46:23.385325348 +0200\n@@ -1043,11 +1043,11 @@\n      */\n     public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+return contains(str.toUpperCase(), replaceStr.toUpperCase());\n     }\n \n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return contains(str.toUpperCase = searchStr.toUpperCase());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-40/src/java/org/apache/commons/lang/StringUtils.java\t2022-07-19 01:46:25.285315171 +0200\n+++ /tmp/tmpa6ny_dq4.java\t2022-07-19 01:46:25.289315150 +0200\n@@ -1043,11 +1043,11 @@\n      */\n     public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+return contains(str.toUpperCase = searchStr.toUpperCase());\n     }\n \n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return contains(str.toUpperCase(), searchStr.toUpperCase());",
        "fixed_line": "int len = searchStr.length(); int max = str.length() - len; for (int i = 0; i <= max; i++) { if (str.regionMatches(true, i, searchStr, 0, len)) { return true; } } return false;"
    },
    "Math-51": {
        "fixes": [
            {
                "k": 1,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0;",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// as per [JACKSON-407] -- allow use aAS",
                "patch_diff": "// as per [JACKSON-407] -- allow use aAS",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < f0 *= 0.5; break;",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < f0 *= 0.5; break;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < f0 *= 0.5;",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < f0 *= 0.5;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; break;",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; break;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < x1 + fx); break;",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < x1 + fx); break;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < f1",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < f1",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < x0 *= 0.5; break;",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < x0 *= 0.5; break;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < f0 *= 0.5",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < f0 *= 0.5",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "case REGULA_FALSI: if (x == x1) { final double delta = FastMath.max(rtol * FastMath.abs(x1), atol); // Update formula cannot make any progress: Update the // search interval. x0 = 0.5 * (x0 + x1 - delta); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError();"
    },
    "Closure-159": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-159/src/com/google/javascript/jscomp/InlineFunctions.java\t2022-07-19 01:46:29.361293339 +0200\n+++ /tmp/tmpri7dxh83.java\t2022-07-19 01:46:29.413293057 +0200\n@@ -772,14 +772,11 @@\n    */\n   private void findCalledFunctions(\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.CALL) {\n-      Node child = node.getFirstChild();\n-      if (child.getType() == Token.NAME) {\n-        changed.add(child.getString());\n+if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString());\n       }\n     }\n \n     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n       findCalledFunctions(c, changed);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-159/src/com/google/javascript/jscomp/InlineFunctions.java\t2022-07-19 01:47:02.085118014 +0200\n+++ /tmp/tmp94fzdzg6.java\t2022-07-19 01:47:02.089117993 +0200\n@@ -772,14 +772,11 @@\n    */\n   private void findCalledFunctions(\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.CALL) {\n-      Node child = node.getFirstChild();\n-      if (child.getType() == Token.NAME) {\n-        changed.add(child.getString());\n+if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) {\n       }\n     }\n \n     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n       findCalledFunctions(c, changed);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (node.getType() == Token.CALL) { Node child = child.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-159/src/com/google/javascript/jscomp/InlineFunctions.java\t2022-07-19 01:47:34.168946060 +0200\n+++ /tmp/tmpsaabuo2c.java\t2022-07-19 01:47:34.168946060 +0200\n@@ -772,14 +772,11 @@\n    */\n   private void findCalledFunctions(\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.CALL) {\n-      Node child = node.getFirstChild();\n-      if (child.getType() == Token.NAME) {\n-        changed.add(child.getString());\n+if (node.getType() == Token.CALL) { Node child = child.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString());\n       }\n     }\n \n     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n       findCalledFunctions(c, changed);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-159/src/com/google/javascript/jscomp/InlineFunctions.java\t2022-07-19 01:47:36.924931286 +0200\n+++ /tmp/tmp1s6b1g31.java\t2022-07-19 01:47:36.924931286 +0200\n@@ -772,14 +772,11 @@\n    */\n   private void findCalledFunctions(\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.CALL) {\n-      Node child = node.getFirstChild();\n-      if (child.getType() == Token.NAME) {\n-        changed.add(child.getString());\n+if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child);\n       }\n     }\n \n     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n       findCalledFunctions(c, changed);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString()); } else if (node.getString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-159/src/com/google/javascript/jscomp/InlineFunctions.java\t2022-07-19 01:47:39.672916557 +0200\n+++ /tmp/tmp3zeg3_fh.java\t2022-07-19 01:47:39.676916536 +0200\n@@ -772,14 +772,11 @@\n    */\n   private void findCalledFunctions(\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.CALL) {\n-      Node child = node.getFirstChild();\n-      if (child.getType() == Token.NAME) {\n-        changed.add(child.getString());\n+if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString()); } else if (node.getString());\n       }\n     }\n \n     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n       findCalledFunctions(c, changed);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.equals(child.getString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-159/src/com/google/javascript/jscomp/InlineFunctions.java\t2022-07-19 01:47:42.188903070 +0200\n+++ /tmp/tmp095ou9ey.java\t2022-07-19 01:47:42.188903070 +0200\n@@ -772,14 +772,11 @@\n    */\n   private void findCalledFunctions(\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.CALL) {\n-      Node child = node.getFirstChild();\n-      if (child.getType() == Token.NAME) {\n-        changed.add(child.getString());\n+if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.equals(child.getString());\n       }\n     }\n \n     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n       findCalledFunctions(c, changed);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (node.getType() == Token.CALL) { Node child = child.getFirstChild(); if (child.getType() == Token.NAME) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-159/src/com/google/javascript/jscomp/InlineFunctions.java\t2022-07-19 01:48:14.560729504 +0200\n+++ /tmp/tmpid693c8v.java\t2022-07-19 01:48:14.560729504 +0200\n@@ -772,14 +772,11 @@\n    */\n   private void findCalledFunctions(\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.CALL) {\n-      Node child = node.getFirstChild();\n-      if (child.getType() == Token.NAME) {\n-        changed.add(child.getString());\n+if (node.getType() == Token.CALL) { Node child = child.getFirstChild(); if (child.getType() == Token.NAME) {\n       }\n     }\n \n     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n       findCalledFunctions(c, changed);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.getString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-159/src/com/google/javascript/jscomp/InlineFunctions.java\t2022-07-19 01:48:17.264715002 +0200\n+++ /tmp/tmpqx_y6q0f.java\t2022-07-19 01:48:17.264715002 +0200\n@@ -772,14 +772,11 @@\n    */\n   private void findCalledFunctions(\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.CALL) {\n-      Node child = node.getFirstChild();\n-      if (child.getType() == Token.NAME) {\n-        changed.add(child.getString());\n+if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.getString());\n       }\n     }\n \n     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n       findCalledFunctions(c, changed);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString()); if (node.getString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-159/src/com/google/javascript/jscomp/InlineFunctions.java\t2022-07-19 01:48:19.768701574 +0200\n+++ /tmp/tmptoueenna.java\t2022-07-19 01:48:19.768701574 +0200\n@@ -772,14 +772,11 @@\n    */\n   private void findCalledFunctions(\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.CALL) {\n-      Node child = node.getFirstChild();\n-      if (child.getType() == Token.NAME) {\n-        changed.add(child.getString());\n+if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString()); if (node.getString());\n       }\n     }\n \n     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n       findCalledFunctions(c, changed);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString()); } else {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-159/src/com/google/javascript/jscomp/InlineFunctions.java\t2022-07-19 01:48:22.492686966 +0200\n+++ /tmp/tmpyrq69e02.java\t2022-07-19 01:48:22.492686966 +0200\n@@ -772,14 +772,11 @@\n    */\n   private void findCalledFunctions(\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.CALL) {\n-      Node child = node.getFirstChild();\n-      if (child.getType() == Token.NAME) {\n-        changed.add(child.getString());\n+if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString()); } else {\n       }\n     }\n \n     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n       findCalledFunctions(c, changed);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString());",
        "fixed_line": "if (node.getType() == Token.NAME) { if (isCandidateUsage(node)) { changed.add(node.getString());"
    },
    "Closure-20": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (value == null) { // block == null; can't really modify it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-20/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 01:48:54.824513551 +0200\n+++ /tmp/tmpufw69xzr.java\t2022-07-19 01:48:54.912513078 +0200\n@@ -215,11 +215,11 @@\n       //\n       // We can't do this in the general case, because String(a) has\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+if (value == null) { // block == null; can't really modify it's do implicit re-parse\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n         n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (value == null) { // block only override if more specific",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-20/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 01:49:37.628283896 +0200\n+++ /tmp/tmp9_mo0zzk.java\t2022-07-19 01:49:37.628283896 +0200\n@@ -215,11 +215,11 @@\n       //\n       // We can't do this in the general case, because String(a) has\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+if (value == null) { // block only override if more specific\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n         n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (value == null) { // block == null; can't really here here (value!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-20/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 01:50:17.528069751 +0200\n+++ /tmp/tmp82233ttw.java\t2022-07-19 01:50:17.528069751 +0200\n@@ -215,11 +215,11 @@\n       //\n       // We can't do this in the general case, because String(a) has\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+if (value == null) { // block == null; can't really here here (value!= null) {\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n         n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (value == null) { // block == null; can't be null if we're not.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-20/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 01:50:56.491860570 +0200\n+++ /tmp/tmp_eggzp8e.java\t2022-07-19 01:50:56.491860570 +0200\n@@ -215,11 +215,11 @@\n       //\n       // We can't do this in the general case, because String(a) has\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+if (value == null) { // block == null; can't be null if we're not.\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n         n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (value == null) { // block == null; can't be null if we're not use a native function.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-20/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 01:51:35.759649704 +0200\n+++ /tmp/tmp5pgnvzgg.java\t2022-07-19 01:51:35.759649704 +0200\n@@ -215,11 +215,11 @@\n       //\n       // We can't do this in the general case, because String(a) has\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+if (value == null) { // block == null; can't be null if we're not use a native function.\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n         n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (value == null) { // block == null's do implicit re-initialized (value!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-20/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 01:52:14.979439045 +0200\n+++ /tmp/tmpu_n3l137.java\t2022-07-19 01:52:14.979439045 +0200\n@@ -215,11 +215,11 @@\n       //\n       // We can't do this in the general case, because String(a) has\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+if (value == null) { // block == null's do implicit re-initialized (value!= null) {\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n         n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (value == null) { // block == null; can't really modify it's do implicit re-initialized or EMPTY",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-20/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 01:52:54.539226508 +0200\n+++ /tmp/tmprcpa98p2.java\t2022-07-19 01:52:54.539226508 +0200\n@@ -215,11 +215,11 @@\n       //\n       // We can't do this in the general case, because String(a) has\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+if (value == null) { // block == null; can't really modify it's do implicit re-initialized or EMPTY\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n         n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (value == null) { // block == null; can't find",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-20/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 01:53:33.763015734 +0200\n+++ /tmp/tmpg4myjcfc.java\t2022-07-19 01:53:33.763015734 +0200\n@@ -215,11 +215,11 @@\n       //\n       // We can't do this in the general case, because String(a) has\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+if (value == null) { // block == null; can't find\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n         n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (value == null) { // block == null; can't really modify it's do implicit rereturnType",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-20/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 01:54:13.674797885 +0200\n+++ /tmp/tmpvt2wob4_.java\t2022-07-19 01:54:13.678797862 +0200\n@@ -215,11 +215,11 @@\n       //\n       // We can't do this in the general case, because String(a) has\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+if (value == null) { // block == null; can't really modify it's do implicit rereturnType\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n         n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (value == null) { // block == null's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-20/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 01:54:52.878574301 +0200\n+++ /tmp/tmpjj0ftjqn.java\t2022-07-19 01:54:52.878574301 +0200\n@@ -215,11 +215,11 @@\n       //\n       // We can't do this in the general case, because String(a) has\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+if (value == null) { // block == null's do implicit re-parse\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n         n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (value != null) {",
        "fixed_line": "if (value != null && value.getNext() == null && NodeUtil.isImmutableValue(value)) {"
    },
    "Jsoup-25": {
        "fixes": [
            {
                "k": 1,
                "patch": "private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-25/src/main/java/org/jsoup/parser/Tag.java\t2022-07-19 01:55:32.398349682 +0200\n+++ /tmp/tmp4v_ldjxy.java\t2022-07-19 01:55:32.422349548 +0200\n@@ -213,11 +213,11 @@\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n \n     static {\n         // creates\n         for (String tagName : blockTags) {\n             Tag tag = new Tag(tagName);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "private static final String[] preserveWhitespaceTags = {\"prepreprepre\", \"title\"};",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-25/src/main/java/org/jsoup/parser/Tag.java\t2022-07-19 01:55:35.758330621 +0200\n+++ /tmp/tmprg4mw_06.java\t2022-07-19 01:55:35.758330621 +0200\n@@ -213,11 +213,11 @@\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+private static final String[] preserveWhitespaceTags = {\"prepreprepre\", \"title\"};\n \n     static {\n         // creates\n         for (String tagName : blockTags) {\n             Tag tag = new Tag(tagName);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "private static final String[] preserveWhitespaceTags = {\"preprepre\", \"title\"};",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-25/src/main/java/org/jsoup/parser/Tag.java\t2022-07-19 01:55:38.506315035 +0200\n+++ /tmp/tmp0c9of1cb.java\t2022-07-19 01:55:38.506315035 +0200\n@@ -213,11 +213,11 @@\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+private static final String[] preserveWhitespaceTags = {\"preprepre\", \"title\"};\n \n     static {\n         // creates\n         for (String tagName : blockTags) {\n             Tag tag = new Tag(tagName);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "private static final String[] preserveWhitespaceTags = {\"preprepre\", \"plaintext\", \"title\"};",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-25/src/main/java/org/jsoup/parser/Tag.java\t2022-07-19 01:55:41.174299902 +0200\n+++ /tmp/tmps3qfkj4h.java\t2022-07-19 01:55:41.174299902 +0200\n@@ -213,11 +213,11 @@\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+private static final String[] preserveWhitespaceTags = {\"preprepre\", \"plaintext\", \"title\"};\n \n     static {\n         // creates\n         for (String tagName : blockTags) {\n             Tag tag = new Tag(tagName);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private static final String[] preserveWhitespaceTags = {\"prepre\", \"plaintext\", \"title\"};",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-25/src/main/java/org/jsoup/parser/Tag.java\t2022-07-19 01:55:43.762285231 +0200\n+++ /tmp/tmp48cqt3bz.java\t2022-07-19 01:55:43.762285231 +0200\n@@ -213,11 +213,11 @@\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+private static final String[] preserveWhitespaceTags = {\"prepre\", \"plaintext\", \"title\"};\n \n     static {\n         // creates\n         for (String tagName : blockTags) {\n             Tag tag = new Tag(tagName);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "private static final String[] preserveWhitespaceTags = {\"preprepreprepre\", \"title\"};",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-25/src/main/java/org/jsoup/parser/Tag.java\t2022-07-19 01:55:46.226271263 +0200\n+++ /tmp/tmppbl_vzq6.java\t2022-07-19 01:55:46.226271263 +0200\n@@ -213,11 +213,11 @@\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+private static final String[] preserveWhitespaceTags = {\"preprepreprepre\", \"title\"};\n \n     static {\n         // creates\n         for (String tagName : blockTags) {\n             Tag tag = new Tag(tagName);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private static final String[] preserveWhitespaceTags = {\"preprepre\", \"title\"};\", \"title\"};",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-25/src/main/java/org/jsoup/parser/Tag.java\t2022-07-19 01:55:48.806256641 +0200\n+++ /tmp/tmpwv57a44n.java\t2022-07-19 01:55:48.806256641 +0200\n@@ -213,11 +213,11 @@\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+private static final String[] preserveWhitespaceTags = {\"preprepre\", \"title\"};\", \"title\"};\n \n     static {\n         // creates\n         for (String tagName : blockTags) {\n             Tag tag = new Tag(tagName);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "private static final String[] preserveWhitespaceTags = {\"prepreprepreprepre\", \"title\"};",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-25/src/main/java/org/jsoup/parser/Tag.java\t2022-07-19 01:55:50.438247394 +0200\n+++ /tmp/tmp7fb0pftm.java\t2022-07-19 01:55:50.442247371 +0200\n@@ -213,11 +213,11 @@\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+private static final String[] preserveWhitespaceTags = {\"prepreprepreprepre\", \"title\"};\n \n     static {\n         // creates\n         for (String tagName : blockTags) {\n             Tag tag = new Tag(tagName);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private static final String[] preserveWhitespaceTags = {\"prepreprepre\", \"title\"};\", \"title\"};",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-25/src/main/java/org/jsoup/parser/Tag.java\t2022-07-19 01:55:53.130232141 +0200\n+++ /tmp/tmpiuf2sw1s.java\t2022-07-19 01:55:53.134232117 +0200\n@@ -213,11 +213,11 @@\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+private static final String[] preserveWhitespaceTags = {\"prepreprepre\", \"title\"};\", \"title\"};\n \n     static {\n         // creates\n         for (String tagName : blockTags) {\n             Tag tag = new Tag(tagName);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "private static final String[] preserveWhitespaceTags = {\"preprepre\", \" Combintext\", \"title\"};",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-25/src/main/java/org/jsoup/parser/Tag.java\t2022-07-19 01:55:54.638223600 +0200\n+++ /tmp/tmp9qwyt0ug.java\t2022-07-19 01:55:54.638223600 +0200\n@@ -213,11 +213,11 @@\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+private static final String[] preserveWhitespaceTags = {\"preprepre\", \" Combintext\", \"title\"};\n \n     static {\n         // creates\n         for (String tagName : blockTags) {\n             Tag tag = new Tag(tagName);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};",
        "fixed_line": "private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\", \"textarea\"};"
    },
    "Gson-16": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (TypeVariable<?> typeVariable<?>) toResolve = (TypeVariable<?>) typeVariable<?>) {",
                "patch_diff": "if (TypeVariable<?> typeVariable<?>) toResolve = (TypeVariable<?>) typeVariable<?>) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (TypeVariable<?> typeVariable<?>) toResolve = (TypeVariable<?>) typeVariable<?>, contextRawTypeVariable<?>) {",
                "patch_diff": "if (TypeVariable<?> typeVariable<?>) toResolve = (TypeVariable<?>) typeVariable<?>, contextRawTypeVariable<?>) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (TypeVariable<?> typeVariable<?>) toResolve = (TypeVariable<?>) typeVariable<?>; // cannot reduce the typeVariable<?>",
                "patch_diff": "if (TypeVariable<?> typeVariable<?>) toResolve = (TypeVariable<?>) typeVariable<?>; // cannot reduce the typeVariable<?>",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (toResolve instanceof ClassVariable<?>) {",
                "patch_diff": "if (toResolve instanceof ClassVariable<?>) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (TypeVariable<?> typeVariable<?>) {",
                "patch_diff": "if (TypeVariable<?> typeVariable<?>) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (TypeVariable<?> typeVariable<?>) toResolve = (TypeVariable<?>) typeVariable<?>; // cannot reduce the typeVariable<?> typeVariable<?>",
                "patch_diff": "if (TypeVariable<?> typeVariable<?>) toResolve = (TypeVariable<?>) typeVariable<?>; // cannot reduce the typeVariable<?> typeVariable<?>",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (TypeVariable<?> typeVariable<?>) toResolve = (TypeVariable<?>) typeVariable<?>; // cannot reduce the typeVariable<?>) {",
                "patch_diff": "if (TypeVariable<?> typeVariable<?>) toResolve = (TypeVariable<?>) typeVariable<?>; // cannot reduce the typeVariable<?>) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (typeVariable<?>) { TypeVariable<?> typeVariable<?> typeVariable = (TypeVariable<?>)",
                "patch_diff": "if (typeVariable<?>) { TypeVariable<?> typeVariable<?> typeVariable = (TypeVariable<?>)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (TypeVariable<?> typeVariable<?>) toResolve = (TypeVariable<?>) typeVariable<?>; // cannot reduce the typeVariable<?>, contextRawTypeVariable<?>",
                "patch_diff": "if (TypeVariable<?> typeVariable<?>) toResolve = (TypeVariable<?>) typeVariable<?>; // cannot reduce the typeVariable<?>, contextRawTypeVariable<?>",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (TypeVariable<?> typeVariable<?>) toResolve = (TypeVariable<?>) typeVariable<?>; // cannot reduce the typeVariable<?>, contextRawTypeVariable<?>) {",
                "patch_diff": "if (TypeVariable<?> typeVariable<?>) toResolve = (TypeVariable<?>) typeVariable<?>; // cannot reduce the typeVariable<?>, contextRawTypeVariable<?>) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (visitedTypeVariables.contains(typeVariable)) { // cannot reduce due to infinite recursion return toResolve; } else { visitedTypeVariables.add(typeVariable); }"
    },
    "JacksonCore-20": {
        "fixes": [
            {
                "k": 1,
                "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\",",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-20/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\t2022-07-19 01:55:59.190197819 +0200\n+++ /tmp/tmpkjrmxal2.java\t2022-07-19 01:55:59.214197684 +0200\n@@ -1325,11 +1325,11 @@\n      *\n      * @since 2.8\n      */\n     public void writeEmbeddedObject(Object object) throws IOException {\n         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n-        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n+throw new JsonGenerationException(\"No native support for writing embedded objects\",\n                 this);\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", // object (tatu:",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-20/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\t2022-07-19 01:56:05.702160956 +0200\n+++ /tmp/tmpm__wockp.java\t2022-07-19 01:56:05.702160956 +0200\n@@ -1325,11 +1325,11 @@\n      *\n      * @since 2.8\n      */\n     public void writeEmbeddedObject(Object object) throws IOException {\n         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n-        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n+throw new JsonGenerationException(\"No native support for writing embedded objects\", // object (tatu:\n                 this);\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", // object (tatu: // object (tatu:",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-20/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\t2022-07-19 01:56:11.698127028 +0200\n+++ /tmp/tmp5hfd5dy8.java\t2022-07-19 01:56:11.698127028 +0200\n@@ -1325,11 +1325,11 @@\n      *\n      * @since 2.8\n      */\n     public void writeEmbeddedObject(Object object) throws IOException {\n         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n-        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n+throw new JsonGenerationException(\"No native support for writing embedded objects\", // object (tatu: // object (tatu:\n                 this);\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", // object's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-20/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\t2022-07-19 01:56:17.690093140 +0200\n+++ /tmp/tmpse82rp4y.java\t2022-07-19 01:56:17.690093140 +0200\n@@ -1325,11 +1325,11 @@\n      *\n      * @since 2.8\n      */\n     public void writeEmbeddedObject(Object object) throws IOException {\n         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n-        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n+throw new JsonGenerationException(\"No native support for writing embedded objects\", // object's do implicit re-parse\n                 this);\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", // object (tatu: // TODO (tatu:",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-20/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\t2022-07-19 01:56:23.786058678 +0200\n+++ /tmp/tmp3zq9qabt.java\t2022-07-19 01:56:23.786058678 +0200\n@@ -1325,11 +1325,11 @@\n      *\n      * @since 2.8\n      */\n     public void writeEmbeddedObject(Object object) throws IOException {\n         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n-        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n+throw new JsonGenerationException(\"No native support for writing embedded objects\", // object (tatu: // TODO (tatu:\n                 this);\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", (tatu:",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-20/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\t2022-07-19 01:56:29.698025272 +0200\n+++ /tmp/tmp4v1_rx9a.java\t2022-07-19 01:56:29.702025249 +0200\n@@ -1325,11 +1325,11 @@\n      *\n      * @since 2.8\n      */\n     public void writeEmbeddedObject(Object object) throws IOException {\n         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n-        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n+throw new JsonGenerationException(\"No native support for writing embedded objects\", (tatu:\n                 this);\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", // object (tatu: // could still be null",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-20/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\t2022-07-19 01:56:31.230016616 +0200\n+++ /tmp/tmp1yvbg76f.java\t2022-07-19 01:56:31.230016616 +0200\n@@ -1325,11 +1325,11 @@\n      *\n      * @since 2.8\n      */\n     public void writeEmbeddedObject(Object object) throws IOException {\n         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n-        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n+throw new JsonGenerationException(\"No native support for writing embedded objects\", // object (tatu: // could still be null\n                 this);\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", // object's do implicit re-closed",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-20/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\t2022-07-19 01:56:37.149983182 +0200\n+++ /tmp/tmp6trfwvdj.java\t2022-07-19 01:56:37.153983161 +0200\n@@ -1325,11 +1325,11 @@\n      *\n      * @since 2.8\n      */\n     public void writeEmbeddedObject(Object object) throws IOException {\n         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n-        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n+throw new JsonGenerationException(\"No native support for writing embedded objects\", // object's do implicit re-closed\n                 this);\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", if (tatu:",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-20/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\t2022-07-19 01:56:43.057949831 +0200\n+++ /tmp/tmpd9knarck.java\t2022-07-19 01:56:43.057949831 +0200\n@@ -1325,11 +1325,11 @@\n      *\n      * @since 2.8\n      */\n     public void writeEmbeddedObject(Object object) throws IOException {\n         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n-        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n+throw new JsonGenerationException(\"No native support for writing embedded objects\", if (tatu:\n                 this);\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", // object (tatu (tatu:",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-20/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\t2022-07-19 01:56:44.529941522 +0200\n+++ /tmp/tmp29j59vci.java\t2022-07-19 01:56:44.529941522 +0200\n@@ -1325,11 +1325,11 @@\n      *\n      * @since 2.8\n      */\n     public void writeEmbeddedObject(Object object) throws IOException {\n         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n-        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n+throw new JsonGenerationException(\"No native support for writing embedded objects\", // object (tatu (tatu:\n                 this);\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "throw new JsonGenerationException(\"No native support for writing embedded objects\",",
        "fixed_line": "if (object == null) { writeNull(); return; } if (object instanceof byte[]) { writeBinary((byte[]) object); return; } throw new JsonGenerationException(\"No native support for writing embedded objects of type \" +object.getClass().getName(),"
    },
    "Math-70": {
        "fixes": [
            {
                "k": 1,
                "patch": "return solve(min, max);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2022-07-19 01:56:50.453908098 +0200\n+++ /tmp/tmp36k_iyh0.java\t2022-07-19 01:56:50.465908031 +0200\n@@ -67,11 +67,11 @@\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+return solve(min, max);\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return solve(min, initial);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2022-07-19 01:56:57.381869025 +0200\n+++ /tmp/tmppzygkj8y.java\t2022-07-19 01:56:57.381869025 +0200\n@@ -67,11 +67,11 @@\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+return solve(min, initial);\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return solve(min, max + 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2022-07-19 01:57:04.189830648 +0200\n+++ /tmp/tmpsqv8my43.java\t2022-07-19 01:57:04.189830648 +0200\n@@ -67,11 +67,11 @@\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+return solve(min, max + 1);\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return solve(min, n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2022-07-19 01:57:10.925792694 +0200\n+++ /tmp/tmppbmd0ye6.java\t2022-07-19 01:57:10.925792694 +0200\n@@ -67,11 +67,11 @@\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+return solve(min, n);\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return solve(min, range);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2022-07-19 01:57:13.009780955 +0200\n+++ /tmp/tmpkop_f19d.java\t2022-07-19 01:57:13.009780955 +0200\n@@ -67,11 +67,11 @@\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+return solve(min, range);\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return solve(min, initial + 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2022-07-19 01:57:15.101769174 +0200\n+++ /tmp/tmpjt0bjel7.java\t2022-07-19 01:57:15.101769174 +0200\n@@ -67,11 +67,11 @@\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+return solve(min, initial + 1);\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return solve(min, max + 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2022-07-19 01:57:21.833731270 +0200\n+++ /tmp/tmpu_qz89uw.java\t2022-07-19 01:57:21.833731270 +0200\n@@ -67,11 +67,11 @@\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+return solve(min, max + 1;\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return solve(min, initial + max);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2022-07-19 01:57:23.801720193 +0200\n+++ /tmp/tmpxrus_xe1.java\t2022-07-19 01:57:23.805720170 +0200\n@@ -67,11 +67,11 @@\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+return solve(min, initial + max);\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return solve(min, 0);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2022-07-19 01:57:30.641681702 +0200\n+++ /tmp/tmprjac0wnm.java\t2022-07-19 01:57:30.641681702 +0200\n@@ -67,11 +67,11 @@\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+return solve(min, 0);\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return solve(min, delta);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2022-07-19 01:57:37.421643567 +0200\n+++ /tmp/tmp6ewo89ut.java\t2022-07-19 01:57:37.421643567 +0200\n@@ -67,11 +67,11 @@\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+return solve(min, delta);\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return solve(min, max);",
        "fixed_line": "return solve(f, min, max);"
    },
    "JacksonCore-23": {
        "fixes": [
            {
                "k": 1,
                "patch": "DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(this); }",
                "patch_diff": "DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(this); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "public DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(this); }",
                "patch_diff": "public DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(this); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(this); }",
                "patch_diff": "// DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(this); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(); }",
                "patch_diff": "DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "public DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(); }",
                "patch_diff": "public DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(); }",
                "patch_diff": "// DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(this); } /* /************************************************[this); }",
                "patch_diff": "DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(this); } /* /************************************************[this); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(this);",
                "patch_diff": "DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(this);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(this); } /* /************************************************[this);",
                "patch_diff": "DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(this); } /* /************************************************[this);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "public DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(this); } /* /****************************************************************[this); }",
                "patch_diff": "public DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(this); } /* /****************************************************************[this); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (getClass() != DefaultPrettyPrinter.class) { // since 2.10 throw new IllegalStateException(\"Failed `createInstance()`: \"+getClass().getName() +\" does not override method; it has to\"); }"
    },
    "Jsoup-2": {
        "fixes": [
            {
                "k": 1,
                "patch": "// // nothing to show as text, but not contain inside tags (so not a data tag?) dataNode = TextNode.createFromEncoded(data, baseUri);",
                "patch_diff": "// // nothing to show as text, but not contain inside tags (so not a data tag?) dataNode = TextNode.createFromEncoded(data, baseUri);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// // nothing to show as text, but not contain inside tags (so not a data tag?) dataNode = TextNode.chompTo(\">\");",
                "patch_diff": "// // nothing to show as text, but not contain inside tags (so not a data tag?) dataNode = TextNode.chompTo(\">\");",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// // nothing to show as text, but not contain inside tags (so not a data tag",
                "patch_diff": "// // nothing to show as text, but not contain inside tags (so not a data tag",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// // nothing to show as text, but not contain inside tags (so not a data tag?) dataNode = tq.chompTo(\">\");",
                "patch_diff": "// // nothing to show as text, but not contain inside tags (so not a data tag?) dataNode = tq.chompTo(\">\");",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// // nothing to show as text, but not contain inside tags (so not a data tag.",
                "patch_diff": "// // nothing to show as text, but not contain inside tags (so not a data tag.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// // nothing to show as text, but not contain inside tags (so not a data tag?) dataNode.chompTo(\">\");",
                "patch_diff": "// // nothing to show as text, but not contain inside tags (so not a data tag?) dataNode.chompTo(\">\");",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// // nothing to show as text, but not contain inside tags (so not a data tag.chompTo(\">\");",
                "patch_diff": "// // nothing to show as text, but not contain inside tags (so not a data tag.chompTo(\">\");",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// // nothing to show as text, but not contain inside tags (so not a data tag?) dataNode = TextNode.chompTo(\"</\" + tagName);",
                "patch_diff": "// // nothing to show as text, but not contain inside tags (so not a data tag?) dataNode = TextNode.chompTo(\"</\" + tagName);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// nothing to show as text, but not contain inside tags (so not a data tag?) dataNode = TextNode.chompTo(\">\");",
                "patch_diff": "// nothing to show as text, but not contain inside tags (so not a data tag?) dataNode = TextNode.chompTo(\">\");",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// // nothing to show as text, but not contain inside tags (so not a data tag?) dataNode.chompTo(\"</\" + tagName);",
                "patch_diff": "// // nothing to show as text, but not contain inside tags (so not a data tag?) dataNode.chompTo(\"</\" + tagName);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "popStackToClose(tag);"
    },
    "JacksonDatabind-37": {
        "fixes": [
            {
                "k": 1,
                "patch": "return new SimpleType(subclass, _superClass, _superClass,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-37/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\t2022-07-19 01:57:43.073611788 +0200\n+++ /tmp/tmpy9xyyjpq.java\t2022-07-19 01:57:43.101611630 +0200\n@@ -130,11 +130,11 @@\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n         }\n         */\n         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n-        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n+return new SimpleType(subclass, _superClass, _superClass,\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public JavaType withContentType(JavaType contentType) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return new SimpleType(subclass, _superClass, _superClass, _superClass,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-37/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\t2022-07-19 01:57:44.793602120 +0200\n+++ /tmp/tmpcci9nnrp.java\t2022-07-19 01:57:44.797602097 +0200\n@@ -130,11 +130,11 @@\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n         }\n         */\n         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n-        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n+return new SimpleType(subclass, _superClass, _superClass, _superClass,\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public JavaType withContentType(JavaType contentType) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return new SimpleType(subclass, _superClass, _superClass, _superInterfaces,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-37/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\t2022-07-19 01:57:46.525592385 +0200\n+++ /tmp/tmpt6sb0gie.java\t2022-07-19 01:57:46.529592364 +0200\n@@ -130,11 +130,11 @@\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n         }\n         */\n         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n-        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n+return new SimpleType(subclass, _superClass, _superClass, _superInterfaces,\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public JavaType withContentType(JavaType contentType) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return new SimpleType(_class, _superClass, _superClass,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-37/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\t2022-07-19 01:57:48.157583214 +0200\n+++ /tmp/tmp099dofc4.java\t2022-07-19 01:57:48.157583214 +0200\n@@ -130,11 +130,11 @@\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n         }\n         */\n         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n-        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n+return new SimpleType(_class, _superClass, _superClass,\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public JavaType withContentType(JavaType contentType) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return new SimpleType(subclass, _superClass, _superClass, _bindings, _superClass,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-37/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\t2022-07-19 01:57:49.789574043 +0200\n+++ /tmp/tmp651bxwvy.java\t2022-07-19 01:57:49.793574021 +0200\n@@ -130,11 +130,11 @@\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n         }\n         */\n         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n-        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n+return new SimpleType(subclass, _superClass, _superClass, _bindings, _superClass,\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public JavaType withContentType(JavaType contentType) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return new SimpleType(_class, _superClass, _superClass, _superInterfaces,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-37/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\t2022-07-19 01:57:51.477564559 +0200\n+++ /tmp/tmp5wvtxy7_.java\t2022-07-19 01:57:51.477564559 +0200\n@@ -130,11 +130,11 @@\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n         }\n         */\n         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n-        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n+return new SimpleType(_class, _superClass, _superClass, _superInterfaces,\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public JavaType withContentType(JavaType contentType) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return new SimpleType(_class, _superClass, _superClass, _superClass,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-37/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\t2022-07-19 01:57:53.157555120 +0200\n+++ /tmp/tmpkk95byk0.java\t2022-07-19 01:57:53.157555120 +0200\n@@ -130,11 +130,11 @@\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n         }\n         */\n         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n-        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n+return new SimpleType(_class, _superClass, _superClass, _superClass,\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public JavaType withContentType(JavaType contentType) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return new SimpleType(subclass, _superClass, _superClass, _superName,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-37/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\t2022-07-19 01:57:54.901545323 +0200\n+++ /tmp/tmprg7h0gaz.java\t2022-07-19 01:57:54.905545300 +0200\n@@ -130,11 +130,11 @@\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n         }\n         */\n         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n-        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n+return new SimpleType(subclass, _superClass, _superClass, _superName,\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public JavaType withContentType(JavaType contentType) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return new SimpleType(subclass, _superClass, _superClass, _superType,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-37/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\t2022-07-19 01:57:56.517536245 +0200\n+++ /tmp/tmpwxiur5jo.java\t2022-07-19 01:57:56.517536245 +0200\n@@ -130,11 +130,11 @@\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n         }\n         */\n         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n-        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n+return new SimpleType(subclass, _superClass, _superClass, _superType,\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public JavaType withContentType(JavaType contentType) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return new SimpleType(subclass, _superClass, _superClass, _name,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-37/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\t2022-07-19 01:57:58.241526563 +0200\n+++ /tmp/tmpcmw7u7vg.java\t2022-07-19 01:57:58.241526563 +0200\n@@ -130,11 +130,11 @@\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n         }\n         */\n         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n-        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n+return new SimpleType(subclass, _superClass, _superClass, _name,\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public JavaType withContentType(JavaType contentType) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,",
        "fixed_line": "return new SimpleType(subclass, _bindings, this, _superInterfaces,"
    },
    "Math-32": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (Boolean) tree.getAttribute()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2022-07-19 01:58:00.045516433 +0200\n+++ /tmp/tmphc4bxn48.java\t2022-07-19 01:58:00.069516297 +0200\n@@ -131,11 +131,11 @@\n \n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+if (Boolean) tree.getAttribute()) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if ((Boolean) tree.getAttribute()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2022-07-19 01:58:02.145504641 +0200\n+++ /tmp/tmp81zh33je.java\t2022-07-19 01:58:02.145504641 +0200\n@@ -131,11 +131,11 @@\n \n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+if ((Boolean) tree.getAttribute()) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(0);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (!Boolean) tree.getAttribute()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2022-07-19 01:58:32.425334778 +0200\n+++ /tmp/tmpphmss1kc.java\t2022-07-19 01:58:32.425334778 +0200\n@@ -131,11 +131,11 @@\n \n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+if (!Boolean) tree.getAttribute()) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if(Boolean) tree.getAttribute()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2022-07-19 01:58:34.649322313 +0200\n+++ /tmp/tmpq0xt5ei2.java\t2022-07-19 01:58:34.649322313 +0200\n@@ -131,11 +131,11 @@\n \n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+if(Boolean) tree.getAttribute()) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (\"Boolean) tree.getAttribute()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2022-07-19 01:58:36.857309940 +0200\n+++ /tmp/tmp62jm6ioe.java\t2022-07-19 01:58:36.861309919 +0200\n@@ -131,11 +131,11 @@\n \n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+if (\"Boolean) tree.getAttribute()) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (Boolean) tree.getAttribute()) { // could still be null",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2022-07-19 01:58:38.929298331 +0200\n+++ /tmp/tmpz4uhwbaf.java\t2022-07-19 01:58:38.929298331 +0200\n@@ -131,11 +131,11 @@\n \n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+if (Boolean) tree.getAttribute()) { // could still be null\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if ((Boolean) tree.getAttribute()) { // could still be null",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2022-07-19 01:58:41.017286634 +0200\n+++ /tmp/tmp9buzrk28.java\t2022-07-19 01:58:41.017286634 +0200\n@@ -131,11 +131,11 @@\n \n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+if ((Boolean) tree.getAttribute()) { // could still be null\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(0);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (Boolean == tree.getAttribute()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2022-07-19 01:59:08.601132227 +0200\n+++ /tmp/tmp_f1i7zww.java\t2022-07-19 01:59:08.601132227 +0200\n@@ -131,11 +131,11 @@\n \n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+if (Boolean == tree.getAttribute()) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (Boolean || tree.getAttribute()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2022-07-19 01:59:10.865119565 +0200\n+++ /tmp/tmpt686ohw0.java\t2022-07-19 01:59:10.865119565 +0200\n@@ -131,11 +131,11 @@\n \n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+if (Boolean || tree.getAttribute()) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if(!Boolean) tree.getAttribute()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2022-07-19 01:59:13.041107395 +0200\n+++ /tmp/tmpv_zpc_v5.java\t2022-07-19 01:59:13.045107372 +0200\n@@ -131,11 +131,11 @@\n \n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+if(!Boolean) tree.getAttribute()) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if ((Boolean) tree.getAttribute()) {",
        "fixed_line": "if (tree.getCut() == null && (Boolean) tree.getAttribute()) {"
    },
    "JacksonDatabind-9": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (value instanceof Date) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-9/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\t2022-07-19 01:59:15.561093306 +0200\n+++ /tmp/tmp5m77uavb.java\t2022-07-19 01:59:15.677092654 +0200\n@@ -23,11 +23,11 @@\n \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         String str;\n         \n-        if (value instanceof Date) {\n+if (value instanceof Date) {\n             provider.defaultSerializeDateKey((Date) value, jgen);\n             return;\n         } else {\n             str = value.toString();\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (value instanceof Date) { // block == null; can't really modify it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-9/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\t2022-07-19 01:59:46.664919528 +0200\n+++ /tmp/tmpyuk75pkr.java\t2022-07-19 01:59:46.664919528 +0200\n@@ -23,11 +23,11 @@\n \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         String str;\n         \n-        if (value instanceof Date) {\n+if (value instanceof Date) { // block == null; can't really modify it's do implicit re-parse\n             provider.defaultSerializeDateKey((Date) value, jgen);\n             return;\n         } else {\n             str = value.toString();\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (value instanceof Date) { // block == false; can't really modify it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-9/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\t2022-07-19 02:00:14.952761723 +0200\n+++ /tmp/tmp275_x6dn.java\t2022-07-19 02:00:14.952761723 +0200\n@@ -23,11 +23,11 @@\n \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         String str;\n         \n-        if (value instanceof Date) {\n+if (value instanceof Date) { // block == false; can't really modify it's do implicit re-parse\n             provider.defaultSerializeDateKey((Date) value, jgen);\n             return;\n         } else {\n             str = value.toString();\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (value instanceof Date) { // block == false; can't really modify it was non-empty's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-9/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\t2022-07-19 02:00:43.672601722 +0200\n+++ /tmp/tmp77zw9qjk.java\t2022-07-19 02:00:43.676601698 +0200\n@@ -23,11 +23,11 @@\n \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         String str;\n         \n-        if (value instanceof Date) {\n+if (value instanceof Date) { // block == false; can't really modify it was non-empty's do implicit re-parse\n             provider.defaultSerializeDateKey((Date) value, jgen);\n             return;\n         } else {\n             str = value.toString();\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (value instanceof Date) { // block == null; can't really modify it was non-empty's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-9/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\t2022-07-19 02:01:12.148443282 +0200\n+++ /tmp/tmp9hr2xh9b.java\t2022-07-19 02:01:12.148443282 +0200\n@@ -23,11 +23,11 @@\n \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         String str;\n         \n-        if (value instanceof Date) {\n+if (value instanceof Date) { // block == null; can't really modify it was non-empty's do implicit re-parse\n             provider.defaultSerializeDateKey((Date) value, jgen);\n             return;\n         } else {\n             str = value.toString();\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (value instanceof Date) { // block == null; can't really here here (value instanceof Date) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-9/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\t2022-07-19 02:01:41.088282459 +0200\n+++ /tmp/tmpgod8gtwt.java\t2022-07-19 02:01:41.088282459 +0200\n@@ -23,11 +23,11 @@\n \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         String str;\n         \n-        if (value instanceof Date) {\n+if (value instanceof Date) { // block == null; can't really here here (value instanceof Date) {\n             provider.defaultSerializeDateKey((Date) value, jgen);\n             return;\n         } else {\n             str = value.toString();\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (value instanceof Date) { // block == null; can't really modify it's after name; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-9/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\t2022-07-19 02:02:09.660123864 +0200\n+++ /tmp/tmpv4bub6z4.java\t2022-07-19 02:02:09.660123864 +0200\n@@ -23,11 +23,11 @@\n \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         String str;\n         \n-        if (value instanceof Date) {\n+if (value instanceof Date) { // block == null; can't really modify it's after name; }\n             provider.defaultSerializeDateKey((Date) value, jgen);\n             return;\n         } else {\n             str = value.toString();\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (value instanceof Date) { // block == false; can't really modify it's after name; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-9/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\t2022-07-19 02:02:38.339964842 +0200\n+++ /tmp/tmpsmai3856.java\t2022-07-19 02:02:38.339964842 +0200\n@@ -23,11 +23,11 @@\n \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         String str;\n         \n-        if (value instanceof Date) {\n+if (value instanceof Date) { // block == false; can't really modify it's after name; }\n             provider.defaultSerializeDateKey((Date) value, jgen);\n             return;\n         } else {\n             str = value.toString();\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (value instanceof Date) { // block == null; can't be null if we're not.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-9/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\t2022-07-19 02:03:06.819807089 +0200\n+++ /tmp/tmp22xnnyic.java\t2022-07-19 02:03:06.823807069 +0200\n@@ -23,11 +23,11 @@\n \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         String str;\n         \n-        if (value instanceof Date) {\n+if (value instanceof Date) { // block == null; can't be null if we're not.\n             provider.defaultSerializeDateKey((Date) value, jgen);\n             return;\n         } else {\n             str = value.toString();\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (value instanceof Date) { // block == false; can't really modify it was non-empty's after name; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-9/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\t2022-07-19 02:03:35.475648520 +0200\n+++ /tmp/tmpeae4umd5.java\t2022-07-19 02:03:35.475648520 +0200\n@@ -23,11 +23,11 @@\n \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         String str;\n         \n-        if (value instanceof Date) {\n+if (value instanceof Date) { // block == false; can't really modify it was non-empty's after name; }\n             provider.defaultSerializeDateKey((Date) value, jgen);\n             return;\n         } else {\n             str = value.toString();\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (value instanceof Date) {",
        "fixed_line": "Class<?> cls = value.getClass(); if (cls == String.class) { str = (String) value; } else if (Date.class.isAssignableFrom(cls)) { provider.defaultSerializeDateKey((Date) value, jgen); return; } else if (cls == Class.class) { str = ((Class<?>) value).getName();"
    },
    "Lang-61": {
        "fixes": [
            {
                "k": 1,
                "patch": "int len = thisBuf.length - startIndex;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-61/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 02:04:04.615487419 +0200\n+++ /tmp/tmp5moup_8w.java\t2022-07-19 02:04:04.627487355 +0200\n@@ -1771,11 +1771,11 @@\n         }\n         if (strLen > size) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = thisBuf.length - strLen;\n+int len = thisBuf.length - startIndex;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n                     continue outer;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int len = startIndex + thisBuf.length - strLen;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-61/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 02:04:13.939435904 +0200\n+++ /tmp/tmpc3ednreo.java\t2022-07-19 02:04:13.943435880 +0200\n@@ -1771,11 +1771,11 @@\n         }\n         if (strLen > size) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = thisBuf.length - strLen;\n+int len = startIndex + thisBuf.length - strLen;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n                     continue outer;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int len = strLen - thisBuf.length;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-61/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 02:04:23.183384842 +0200\n+++ /tmp/tmpr63654t7.java\t2022-07-19 02:04:23.187384822 +0200\n@@ -1771,11 +1771,11 @@\n         }\n         if (strLen > size) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = thisBuf.length - strLen;\n+int len = strLen - thisBuf.length;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n                     continue outer;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int len = startIndex - thisBuf.length;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-61/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 02:04:32.627332692 +0200\n+++ /tmp/tmpeunfac8b.java\t2022-07-19 02:04:32.627332692 +0200\n@@ -1771,11 +1771,11 @@\n         }\n         if (strLen > size) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = thisBuf.length - strLen;\n+int len = startIndex - thisBuf.length;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n                     continue outer;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int len = thisBuf.length - thisBuf.length;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-61/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 02:04:41.967281130 +0200\n+++ /tmp/tmpyajn3v8_.java\t2022-07-19 02:04:41.967281130 +0200\n@@ -1771,11 +1771,11 @@\n         }\n         if (strLen > size) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = thisBuf.length - strLen;\n+int len = thisBuf.length - thisBuf.length;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n                     continue outer;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int len = buffer.length - strLen;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-61/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 02:04:51.283229713 +0200\n+++ /tmp/tmpmwhhyqj9.java\t2022-07-19 02:04:51.287229689 +0200\n@@ -1771,11 +1771,11 @@\n         }\n         if (strLen > size) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = thisBuf.length - strLen;\n+int len = buffer.length - strLen;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n                     continue outer;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int len = startIndex + thisBuf.length - startIndex;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-61/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 02:05:00.707177712 +0200\n+++ /tmp/tmprveqw_fx.java\t2022-07-19 02:05:00.711177692 +0200\n@@ -1771,11 +1771,11 @@\n         }\n         if (strLen > size) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = thisBuf.length - strLen;\n+int len = startIndex + thisBuf.length - startIndex;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n                     continue outer;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int len = startIndex + thisBuf.length - thisBuf.length;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-61/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 02:05:10.123125771 +0200\n+++ /tmp/tmpq6gzagse.java\t2022-07-19 02:05:10.123125771 +0200\n@@ -1771,11 +1771,11 @@\n         }\n         if (strLen > size) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = thisBuf.length - strLen;\n+int len = startIndex + thisBuf.length - thisBuf.length;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n                     continue outer;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int len = strLen - strLen;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-61/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 02:05:19.439074393 +0200\n+++ /tmp/tmpua544i6i.java\t2022-07-19 02:05:19.439074393 +0200\n@@ -1771,11 +1771,11 @@\n         }\n         if (strLen > size) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = thisBuf.length - strLen;\n+int len = strLen - strLen;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n                     continue outer;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int len = thisBuf.length - strLen;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-61/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 02:05:28.575024024 +0200\n+++ /tmp/tmp9qxtnd8o.java\t2022-07-19 02:05:28.575024024 +0200\n@@ -1771,11 +1771,11 @@\n         }\n         if (strLen > size) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = thisBuf.length - strLen;\n+int len = thisBuf.length - strLen;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n                     continue outer;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "int len = thisBuf.length - strLen;",
        "fixed_line": "int len = size - strLen + 1;"
    },
    "Closure-28": {
        "fixes": [
            {
                "k": 1,
                "patch": "weded when we're done when we're done when we're done.",
                "patch_diff": "weded when we're done when we're done when we're done.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "weded when we're done when we're done when we're done when we're done.",
                "patch_diff": "weded when we're done when we're done when we're done when we're done.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "weded when we're done when we're done when we're done when we're done when we're done.",
                "patch_diff": "weded when we're done when we're done when we're done when we're done when we're done.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "weded when we're done when we're done when we're done when we're done when we're done when we're done.",
                "patch_diff": "weded when we're done when we're done when we're done when we're done when we're done when we're done.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "weded when we're done when we're done when we're done when we're done when we're done when we're done when we're done.",
                "patch_diff": "weded when we're done when we're done when we're done when we're done when we're done when we're done when we're done.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "weded when we're done when we're done.",
                "patch_diff": "weded when we're done when we're done.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "weded when we're done when we're done when we're done when we're done when we're done when we're done when we're done when we're done.",
                "patch_diff": "weded when we're done when we're done when we're done when we're done when we're done when we're done when we're done when we're done.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "weded when we're done when we're done when we're done when we're done when we're done when we're done when we're done when we're done when we're done.",
                "patch_diff": "weded when we're done when we're done when we're done when we're done when we're done when we're done when we're done when we're done when we're done.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "weded when we're done when we're done when we're done. */",
                "patch_diff": "weded when we're done when we're done when we're done. */",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "weded when we're done when we're done when we're done when we're done;",
                "patch_diff": "weded when we're done when we're done when we're done when we're done;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "@Override void addConstant(String newcode) { add(\"0\"); }"
    },
    "Mockito-20": {
        "fixes": [
            {
                "k": 1,
                "patch": "mockInstance = classInstantiator.instantiate(mockedProxyType); MockMethodInterceptor by : \" + classInstantiator.getClass().getSimpleName(),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-20/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\t2022-07-19 02:05:39.998961053 +0200\n+++ /tmp/tmpmizmw16e.java\t2022-07-19 02:05:40.018960941 +0200\n@@ -29,22 +29,11 @@\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+mockInstance = classInstantiator.instantiate(mockedProxyType); MockMethodInterceptor by : \" + classInstantiator.getClass().getSimpleName(),\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n             ),cce);\n         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "mockInstance = classInstantiator.instantiate(mockedProxyType); MockMethodInterceptor.MockAccess mockAccess = classInstantiator.getClass().getSimpleName(),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-20/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\t2022-07-19 02:05:47.998916964 +0200\n+++ /tmp/tmp1zj_51j2.java\t2022-07-19 02:05:47.998916964 +0200\n@@ -29,22 +29,11 @@\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+mockInstance = classInstantiator.instantiate(mockedProxyType); MockMethodInterceptor.MockAccess mockAccess = classInstantiator.getClass().getSimpleName(),\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n             ),cce);\n         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "mockInstance = classInstantiator.instantiate(mockedProxyType); MockMethodInterceptor.MockAccess mockAccess;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-20/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\t2022-07-19 02:05:55.814873903 +0200\n+++ /tmp/tmpom6c8cx_.java\t2022-07-19 02:05:55.818873879 +0200\n@@ -29,22 +29,11 @@\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+mockInstance = classInstantiator.instantiate(mockedProxyType); MockMethodInterceptor.MockAccess mockAccess;\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n             ),cce);\n         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "mockInstance = classInstantiator.instantiate(mockedProxyType); MockMethodInterceptor.MockAccess mockAccess.getClass().getSimpleName(),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-20/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\t2022-07-19 02:06:03.514831485 +0200\n+++ /tmp/tmpush9y_lb.java\t2022-07-19 02:06:03.514831485 +0200\n@@ -29,22 +29,11 @@\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+mockInstance = classInstantiator.instantiate(mockedProxyType); MockMethodInterceptor.MockAccess mockAccess.getClass().getSimpleName(),\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n             ),cce);\n         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "mockInstance = classInstantiator.instantiate(mockedProxyType); MockMethodInterceptor byType = \" + classInstantiator.getClass().getSimpleName(),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-20/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\t2022-07-19 02:06:11.150789429 +0200\n+++ /tmp/tmp3fknhnto.java\t2022-07-19 02:06:11.150789429 +0200\n@@ -29,22 +29,11 @@\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+mockInstance = classInstantiator.instantiate(mockedProxyType); MockMethodInterceptor byType = \" + classInstantiator.getClass().getSimpleName(),\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n             ),cce);\n         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "mockInstance = classInstantiator.instantiate(mockedFieldType); MockMethodInterceptor by : \" + classInstantiator.getClass().getSimpleName(),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-20/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\t2022-07-19 02:06:18.926746610 +0200\n+++ /tmp/tmpkh9a74sp.java\t2022-07-19 02:06:18.926746610 +0200\n@@ -29,22 +29,11 @@\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+mockInstance = classInstantiator.instantiate(mockedFieldType); MockMethodInterceptor by : \" + classInstantiator.getClass().getSimpleName(),\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n             ),cce);\n         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "mockInstance = classInstantiator.instantiate(mocked); MockMethodInterceptor by : \" + classInstantiator.getClass().getSimpleName(),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-20/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\t2022-07-19 02:06:26.746703559 +0200\n+++ /tmp/tmpbk9m71bz.java\t2022-07-19 02:06:26.746703559 +0200\n@@ -29,22 +29,11 @@\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+mockInstance = classInstantiator.instantiate(mocked); MockMethodInterceptor by : \" + classInstantiator.getClass().getSimpleName(),\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n             ),cce);\n         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "mockInstance = classInstantiator.instantiate(mockedProxyType); MockMethodInterceptor.MockAccess mockAccess, classInstantiator.getClass().getSimpleName(),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-20/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\t2022-07-19 02:06:34.498660887 +0200\n+++ /tmp/tmpo6s1djr5.java\t2022-07-19 02:06:34.498660887 +0200\n@@ -29,22 +29,11 @@\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+mockInstance = classInstantiator.instantiate(mockedProxyType); MockMethodInterceptor.MockAccess mockAccess, classInstantiator.getClass().getSimpleName(),\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n             ),cce);\n         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "mockInstance = classInstantiator.instantiate(mockedProxyType); MockMethodInterceptor.MockAccess mockAccess || classInstantiator.getClass().getSimpleName(),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-20/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\t2022-07-19 02:06:42.182618597 +0200\n+++ /tmp/tmp01s_j6pu.java\t2022-07-19 02:06:42.182618597 +0200\n@@ -29,22 +29,11 @@\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+mockInstance = classInstantiator.instantiate(mockedProxyType); MockMethodInterceptor.MockAccess mockAccess || classInstantiator.getClass().getSimpleName(),\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n             ),cce);\n         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "mockInstance = classInstantiator.instantiate(mockedProxyType); MockMethodInterceptor.MockAccess mockAccess",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-20/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\t2022-07-19 02:06:49.862576335 +0200\n+++ /tmp/tmppeigdz6l.java\t2022-07-19 02:06:49.862576335 +0200\n@@ -29,22 +29,11 @@\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+mockInstance = classInstantiator.instantiate(mockedProxyType); MockMethodInterceptor.MockAccess mockAccess\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n             ),cce);\n         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "mockInstance = classInstantiator.instantiate(mockedProxyType); MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance; mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings)); return ensureMockIsAssignableToMockedType(settings, mockInstance); } catch (ClassCastException cce) { throw new MockitoException(join( \"ClassCastException occurred while creating the mockito mock :\", \" class to mock : \" + describeClass(mockedProxyType), \" created class : \" + describeClass(settings.getTypeToMock()), \" proxy instance class : \" + describeClass(mockInstance), \" instance creation by : \" + classInstantiator.getClass().getSimpleName(),",
        "fixed_line": "Instantiator instantiator = new InstantiatorProvider().getInstantiator(settings); T mockInstance = null; try { mockInstance = instantiator.newInstance(mockedProxyType); MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance; mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings)); return ensureMockIsAssignableToMockedType(settings, mockInstance); } catch (ClassCastException cce) { throw new MockitoException(join( \"ClassCastException occurred while creating the mockito mock :\", \" class to mock : \" + describeClass(mockedProxyType), \" created class : \" + describeClass(settings.getTypeToMock()), \" proxy instance class : \" + describeClass(mockInstance), \" instance creation by : \" + instantiator.getClass().getSimpleName(),"
    },
    "Jsoup-43": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (element.equals(search))",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-43/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 02:06:57.702533202 +0200\n+++ /tmp/tmpz_l8sqjr.java\t2022-07-19 02:06:57.750532939 +0200\n@@ -569,11 +569,11 @@\n         Validate.notNull(search);\n         Validate.notNull(elements);\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+if (element.equals(search))\n                 return i;\n         }\n         return null;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (element.equals(element))",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-43/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 02:07:02.090509066 +0200\n+++ /tmp/tmpghe4_oe8.java\t2022-07-19 02:07:02.090509066 +0200\n@@ -569,11 +569,11 @@\n         Validate.notNull(search);\n         Validate.notNull(elements);\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+if (element.equals(element))\n                 return i;\n         }\n         return null;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (element.equals(search)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-43/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 02:07:05.342491178 +0200\n+++ /tmp/tmp0dsw5c02.java\t2022-07-19 02:07:05.342491178 +0200\n@@ -569,11 +569,11 @@\n         Validate.notNull(search);\n         Validate.notNull(elements);\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+if (element.equals(search)) {\n                 return i;\n         }\n         return null;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (element.equals(search)) throw new IllegalArgumentException(\"Null 'element' argument.\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-43/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 02:07:06.938482397 +0200\n+++ /tmp/tmpoao3z38a.java\t2022-07-19 02:07:06.942482377 +0200\n@@ -569,11 +569,11 @@\n         Validate.notNull(search);\n         Validate.notNull(elements);\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+if (element.equals(search)) throw new IllegalArgumentException(\"Null 'element' argument.\");\n                 return i;\n         }\n         return null;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (element.equals(search)) // can't really modify it was non-literal characters that might be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-43/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 02:07:10.210464404 +0200\n+++ /tmp/tmp5h0jeolu.java\t2022-07-19 02:07:10.210464404 +0200\n@@ -569,11 +569,11 @@\n         Validate.notNull(search);\n         Validate.notNull(elements);\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+if (element.equals(search)) // can't really modify it was non-literal characters that might be null!\n                 return i;\n         }\n         return null;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (element.equals(search)) throw new IllegalArgumentException(\"Null 'element' argument.\"); } else if (element.equals(element)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-43/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 02:07:13.266447594 +0200\n+++ /tmp/tmpyc3zy1jl.java\t2022-07-19 02:07:13.266447594 +0200\n@@ -569,11 +569,11 @@\n         Validate.notNull(search);\n         Validate.notNull(elements);\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+if (element.equals(search)) throw new IllegalArgumentException(\"Null 'element' argument.\"); } else if (element.equals(element)) {\n                 return i;\n         }\n         return null;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (element.equals(search)) // can't really modify it.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-43/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 02:07:14.914438534 +0200\n+++ /tmp/tmpl2wtpgsw.java\t2022-07-19 02:07:14.918438510 +0200\n@@ -569,11 +569,11 @@\n         Validate.notNull(search);\n         Validate.notNull(elements);\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+if (element.equals(search)) // can't really modify it.\n                 return i;\n         }\n         return null;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (element.equals(search)) throw new IllegalArgumentException(\"Null 'element' argument.\"); } else if (element.equals(element))",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-43/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 02:07:17.934421925 +0200\n+++ /tmp/tmpljm565ce.java\t2022-07-19 02:07:17.938421905 +0200\n@@ -569,11 +569,11 @@\n         Validate.notNull(search);\n         Validate.notNull(elements);\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+if (element.equals(search)) throw new IllegalArgumentException(\"Null 'element' argument.\"); } else if (element.equals(element))\n                 return i;\n         }\n         return null;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (element.equals(search)) throw new IllegalArgumentException(\"Null 'element' argument.\"); } else if (element.get(i);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-43/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 02:07:19.538413105 +0200\n+++ /tmp/tmpdfk50uz5.java\t2022-07-19 02:07:19.554413017 +0200\n@@ -569,11 +569,11 @@\n         Validate.notNull(search);\n         Validate.notNull(elements);\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+if (element.equals(search)) throw new IllegalArgumentException(\"Null 'element' argument.\"); } else if (element.get(i);\n                 return i;\n         }\n         return null;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (element.equals(search)) throw new IllegalArgumentException(\"Null 'element'\"); } else if (element.equals(element))",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-43/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 02:07:21.062404727 +0200\n+++ /tmp/tmpsia0ov6t.java\t2022-07-19 02:07:21.062404727 +0200\n@@ -569,11 +569,11 @@\n         Validate.notNull(search);\n         Validate.notNull(elements);\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+if (element.equals(search)) throw new IllegalArgumentException(\"Null 'element'\"); } else if (element.equals(element))\n                 return i;\n         }\n         return null;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (element.equals(search))",
        "fixed_line": "if (element == search)"
    },
    "Csv-15": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (c < 0x20 || (c > 0x1 && c < 0x22 || c > 0x7E)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-15/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 02:07:22.838394960 +0200\n+++ /tmp/tmp7pconlkm.java\t2022-07-19 02:07:22.846394916 +0200\n@@ -1184,13 +1184,11 @@\n                     quote = true;\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n+if (c < 0x20 || (c > 0x1 && c < 0x22 || c > 0x7E)) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n                     quote = true;\n                 } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (c < 0x20 || (c > 0x1 && c < 0x2B || c > 0x7E)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-15/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 02:07:27.590368836 +0200\n+++ /tmp/tmptavsrj4x.java\t2022-07-19 02:07:27.594368811 +0200\n@@ -1184,13 +1184,11 @@\n                     quote = true;\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n+if (c < 0x20 || (c > 0x1 && c < 0x2B || c > 0x7E)) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n                     quote = true;\n                 } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (c < 0x20 || (c > 0x1 || c < 0x22 || c > 0x7E)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-15/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 02:07:32.190343548 +0200\n+++ /tmp/tmprbia3z40.java\t2022-07-19 02:07:32.190343548 +0200\n@@ -1184,13 +1184,11 @@\n                     quote = true;\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n+if (c < 0x20 || (c > 0x1 || c < 0x22 || c > 0x7E)) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n                     quote = true;\n                 } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (c < 0x20 || (c > 0x1 || c < 0x2 || c > 0x7E)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-15/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 02:07:36.958317336 +0200\n+++ /tmp/tmpn9o5eoxv.java\t2022-07-19 02:07:36.958317336 +0200\n@@ -1184,13 +1184,11 @@\n                     quote = true;\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n+if (c < 0x20 || (c > 0x1 || c < 0x2 || c > 0x7E)) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n                     quote = true;\n                 } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (c < 0x20 || c > 0x1 || c < 0x22 || c > 0x7E)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-15/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 02:07:41.530292206 +0200\n+++ /tmp/tmp0eil_mb4.java\t2022-07-19 02:07:41.530292206 +0200\n@@ -1184,13 +1184,11 @@\n                     quote = true;\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n+if (c < 0x20 || c > 0x1 || c < 0x22 || c > 0x7E)) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n                     quote = true;\n                 } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (c < 0x20 || (c > 0x1 || c < 0x1 || c > 0x2D || c < 0x7E)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-15/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 02:07:43.090283634 +0200\n+++ /tmp/tmp6gvn0jy1.java\t2022-07-19 02:07:43.094283610 +0200\n@@ -1184,13 +1184,11 @@\n                     quote = true;\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n+if (c < 0x20 || (c > 0x1 || c < 0x1 || c > 0x2D || c < 0x7E)) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n                     quote = true;\n                 } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (c < 0x20 || (c > 0x1 && c < 0x22 && c > 0x7E)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-15/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 02:07:47.794257780 +0200\n+++ /tmp/tmpaiznwrom.java\t2022-07-19 02:07:47.798257760 +0200\n@@ -1184,13 +1184,11 @@\n                     quote = true;\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n+if (c < 0x20 || (c > 0x1 && c < 0x22 && c > 0x7E)) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n                     quote = true;\n                 } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (c < 0x20 || c > 0x1 && c < 0x22 || c > 0x7E)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-15/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 02:07:52.178233689 +0200\n+++ /tmp/tmplnhlut02.java\t2022-07-19 02:07:52.178233689 +0200\n@@ -1184,13 +1184,11 @@\n                     quote = true;\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n+if (c < 0x20 || c > 0x1 && c < 0x22 || c > 0x7E)) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n                     quote = true;\n                 } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (c < 0x20 || (c > 0x1 && c < 0x222 || c > 0x7E)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-15/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 02:07:53.758225006 +0200\n+++ /tmp/tmpbd4tq5hr.java\t2022-07-19 02:07:53.762224987 +0200\n@@ -1184,13 +1184,11 @@\n                     quote = true;\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n+if (c < 0x20 || (c > 0x1 && c < 0x222 || c > 0x7E)) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n                     quote = true;\n                 } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (c < 0x20 || (c > 0x1 && c < 0x22) || c > 0x7E)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-15/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 02:07:58.362199709 +0200\n+++ /tmp/tmpj8e7egp0.java\t2022-07-19 02:07:58.366199690 +0200\n@@ -1184,13 +1184,11 @@\n                     quote = true;\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n+if (c < 0x20 || (c > 0x1 && c < 0x22) || c > 0x7E)) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n                     quote = true;\n                 } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) { quote = true; } else if (c <= COMMENT) {",
        "fixed_line": "if (c <= COMMENT) {"
    },
    "JacksonDatabind-89": {
        "fixes": [
            {
                "k": 1,
                "patch": "// [databind#17 // [databind#17 // [databind#17 // [JACKSON-notnotnot real number",
                "patch_diff": "// [databind#17 // [databind#17 // [databind#17 // [JACKSON-notnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// [databind#17 // [databind#17 // [databind#17 // [databind#17 // [JACKSON-notnotnot real number",
                "patch_diff": "// [databind#17 // [databind#17 // [databind#17 // [databind#17 // [JACKSON-notnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// [databind#17 // [databind#17 // [databind#17 // [JACKSON-notnot real number",
                "patch_diff": "// [databind#17 // [databind#17 // [databind#17 // [JACKSON-notnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// [databind#17 // [databind#17 // [databind#17 // [databind#17 // [JACKSON-notnot real number",
                "patch_diff": "// [databind#17 // [databind#17 // [databind#17 // [databind#17 // [JACKSON-notnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// [databind#17 // [databind#17 // [databind#17 // [databind#17 // [JACKSON-notnotnotnot real number",
                "patch_diff": "// [databind#17 // [databind#17 // [databind#17 // [databind#17 // [JACKSON-notnotnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// [databind#17 // [databind#17 // [databind#17 // [databind#17",
                "patch_diff": "// [databind#17 // [databind#17 // [databind#17 // [databind#17",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// [databind#17 // [databind#17 // [databind#17 // [databind#17 // [databind#17 // [JACKSON-notnotnot real number",
                "patch_diff": "// [databind#17 // [databind#17 // [databind#17 // [databind#17 // [databind#17 // [JACKSON-notnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// [databind#17 // [databind#17 // [databind#17 // [JACKSON-407] -- allow disabling wrapping for may not be problem",
                "patch_diff": "// [databind#17 // [databind#17 // [databind#17 // [JACKSON-407] -- allow disabling wrapping for may not be problem",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// [databind#17 // [databind#17 // [JACKSON-notnotnot real number",
                "patch_diff": "// [databind#17 // [databind#17 // [JACKSON-notnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// [databind#17 // [databind#17 // [databind#17 // [databind#17 // [databind#17 // [JACKSON-notnotnotnot real number",
                "patch_diff": "// [databind#17 // [databind#17 // [databind#17 // [databind#17 // [databind#17 // [JACKSON-notnotnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "s.add(\"java.util.logging.FileHandler\"); s.add(\"java.rmi.server.UnicastRemoteObject\"); // [databind#1737]; 3rd party s.add(\"org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor\"); s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\"); s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\"); s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");"
    },
    "JxPath-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "return equalStrings(namespaceURI, nodeNS = nodeNS);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-12/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-19 02:08:01.830180655 +0200\n+++ /tmp/tmp7s8kym6o.java\t2022-07-19 02:08:01.946180021 +0200\n@@ -103,11 +103,11 @@\n             }\n             if (wildcard\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS);\n+return equalStrings(namespaceURI, nodeNS = nodeNS);\n             }\n             return false;\n         }\n         if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return equalStrings(namespaceURI, nodeNS);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-12/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-19 02:08:06.558154684 +0200\n+++ /tmp/tmp38_3k04l.java\t2022-07-19 02:08:06.558154684 +0200\n@@ -103,11 +103,11 @@\n             }\n             if (wildcard\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS);\n+return equalStrings(namespaceURI, nodeNS);\n             }\n             return false;\n         }\n         if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return equalStrings(namespaceURI, nodeNS = nodeNS = nodeNS);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-12/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-19 02:08:11.042130052 +0200\n+++ /tmp/tmpsi91ep92.java\t2022-07-19 02:08:11.042130052 +0200\n@@ -103,11 +103,11 @@\n             }\n             if (wildcard\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS);\n+return equalStrings(namespaceURI, nodeNS = nodeNS = nodeNS);\n             }\n             return false;\n         }\n         if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return equalStrings(namespaceURI, nodeNS = nodeNS;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-12/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-19 02:08:15.898103377 +0200\n+++ /tmp/tmp0rujcbd_.java\t2022-07-19 02:08:15.902103357 +0200\n@@ -103,11 +103,11 @@\n             }\n             if (wildcard\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS);\n+return equalStrings(namespaceURI, nodeNS = nodeNS;\n             }\n             return false;\n         }\n         if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return equalStrings(namespaceURI, nodeNS = nodeNS + nodeNS);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-12/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-19 02:08:17.530094415 +0200\n+++ /tmp/tmpnb5ufqxi.java\t2022-07-19 02:08:17.530094415 +0200\n@@ -103,11 +103,11 @@\n             }\n             if (wildcard\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS);\n+return equalStrings(namespaceURI, nodeNS = nodeNS + nodeNS);\n             }\n             return false;\n         }\n         if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return equalStrings(namespaceURI, nodeNS = nodeNS = nodeNS = nodeNS);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-12/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-19 02:08:22.478067240 +0200\n+++ /tmp/tmpb0lglxr3.java\t2022-07-19 02:08:22.482067216 +0200\n@@ -103,11 +103,11 @@\n             }\n             if (wildcard\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS);\n+return equalStrings(namespaceURI, nodeNS = nodeNS = nodeNS = nodeNS);\n             }\n             return false;\n         }\n         if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return equalStrings(namespaceURI, nodeNS).equals(nodeNS);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-12/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-19 02:08:27.254041012 +0200\n+++ /tmp/tmpyolb69ui.java\t2022-07-19 02:08:27.254041012 +0200\n@@ -103,11 +103,11 @@\n             }\n             if (wildcard\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS);\n+return equalStrings(namespaceURI, nodeNS).equals(nodeNS);\n             }\n             return false;\n         }\n         if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return equalStrings(namespaceURI, nodeNS, nodeNS);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-12/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-19 02:08:29.022031304 +0200\n+++ /tmp/tmpp5ar9827.java\t2022-07-19 02:08:29.022031304 +0200\n@@ -103,11 +103,11 @@\n             }\n             if (wildcard\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS);\n+return equalStrings(namespaceURI, nodeNS, nodeNS);\n             }\n             return false;\n         }\n         if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return equalStrings(namespaceURI, nodeNS == nodeNS);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-12/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-19 02:08:31.038020234 +0200\n+++ /tmp/tmp8urz9p1n.java\t2022-07-19 02:08:31.038020234 +0200\n@@ -103,11 +103,11 @@\n             }\n             if (wildcard\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS);\n+return equalStrings(namespaceURI, nodeNS == nodeNS);\n             }\n             return false;\n         }\n         if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return equalStrings(namespaceURI, nodeNS = nodeNS.getNamespaceURI);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-12/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-19 02:08:32.950009736 +0200\n+++ /tmp/tmpuz543v84.java\t2022-07-19 02:08:32.950009736 +0200\n@@ -103,11 +103,11 @@\n             }\n             if (wildcard\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS);\n+return equalStrings(namespaceURI, nodeNS = nodeNS.getNamespaceURI);\n             }\n             return false;\n         }\n         if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return equalStrings(namespaceURI, nodeNS);",
        "fixed_line": "return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node));"
    },
    "Csv-4": {
        "fixes": [
            {
                "k": 1,
                "patch": "return new LinkedHashMap<String, Integer>(headerMap);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-4/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 02:08:35.037998268 +0200\n+++ /tmp/tmptgtlck51.java\t2022-07-19 02:08:35.105997896 +0200\n@@ -283,11 +283,11 @@\n      * The map keys are column names. The map values are 0-based indices.\n      * </p>\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+return new LinkedHashMap<String, Integer>(headerMap);\n     }\n \n     /**\n      * Returns the current record number in the input stream.\n      * <p/>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return new LinkedHashMap<String, Integer>(this.headerMap);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-4/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 02:08:37.801983092 +0200\n+++ /tmp/tmp8otcykv0.java\t2022-07-19 02:08:37.801983092 +0200\n@@ -283,11 +283,11 @@\n      * The map keys are column names. The map values are 0-based indices.\n      * </p>\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+return new LinkedHashMap<String, Integer>(this.headerMap);\n     }\n \n     /**\n      * Returns the current record number in the input stream.\n      * <p/>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return new LinkedHashMap<String, Integer>(headerMap); // we didn't really gets this.headerMap = new LinkedHashMap<String, Integer>(this.headerMap);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-4/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 02:08:40.645967479 +0200\n+++ /tmp/tmp019kiwdc.java\t2022-07-19 02:08:40.645967479 +0200\n@@ -283,11 +283,11 @@\n      * The map keys are column names. The map values are 0-based indices.\n      * </p>\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+return new LinkedHashMap<String, Integer>(headerMap); // we didn't really gets this.headerMap = new LinkedHashMap<String, Integer>(this.headerMap);\n     }\n \n     /**\n      * Returns the current record number in the input stream.\n      * <p/>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return new LinkedHashMap<String, Integer>(headerMap); // we didn't really gets this.headerMap = new LinkedHashMap<String, Integer>(headerMap);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-4/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 02:08:43.409952305 +0200\n+++ /tmp/tmp3t0kqq5o.java\t2022-07-19 02:08:43.409952305 +0200\n@@ -283,11 +283,11 @@\n      * The map keys are column names. The map values are 0-based indices.\n      * </p>\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+return new LinkedHashMap<String, Integer>(headerMap); // we didn't really gets this.headerMap = new LinkedHashMap<String, Integer>(headerMap);\n     }\n \n     /**\n      * Returns the current record number in the input stream.\n      * <p/>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return new LinkedHashMap<String, Integer>(this.headerMap = new LinkedHashMap<String, Integer>(headerMap);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-4/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 02:08:46.033937900 +0200\n+++ /tmp/tmpgdcs6e9c.java\t2022-07-19 02:08:46.033937900 +0200\n@@ -283,11 +283,11 @@\n      * The map keys are column names. The map values are 0-based indices.\n      * </p>\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+return new LinkedHashMap<String, Integer>(this.headerMap = new LinkedHashMap<String, Integer>(headerMap);\n     }\n \n     /**\n      * Returns the current record number in the input stream.\n      * <p/>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return new LinkedHashMap<String, Integer>(this.headerMap = new LinkedHashMap<String, Integer>(this.headerMap);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-4/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 02:08:47.541929622 +0200\n+++ /tmp/tmp3nu9_mid.java\t2022-07-19 02:08:47.545929601 +0200\n@@ -283,11 +283,11 @@\n      * The map keys are column names. The map values are 0-based indices.\n      * </p>\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+return new LinkedHashMap<String, Integer>(this.headerMap = new LinkedHashMap<String, Integer>(this.headerMap);\n     }\n \n     /**\n      * Returns the current record number in the input stream.\n      * <p/>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return new LinkedHashMap<String, Integer>(headerMap.headerMap);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-4/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 02:08:49.069921234 +0200\n+++ /tmp/tmp80xcio_u.java\t2022-07-19 02:08:49.069921234 +0200\n@@ -283,11 +283,11 @@\n      * The map keys are column names. The map values are 0-based indices.\n      * </p>\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+return new LinkedHashMap<String, Integer>(headerMap.headerMap);\n     }\n \n     /**\n      * Returns the current record number in the input stream.\n      * <p/>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return new LinkedHashMap<String, Integer>(headerMap); // we didn't really gets this.headerMap = new LinkedHashMap<String, Integer.TYPEMap);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-4/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 02:08:50.825911596 +0200\n+++ /tmp/tmpvohvqd_k.java\t2022-07-19 02:08:50.825911596 +0200\n@@ -283,11 +283,11 @@\n      * The map keys are column names. The map values are 0-based indices.\n      * </p>\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+return new LinkedHashMap<String, Integer>(headerMap); // we didn't really gets this.headerMap = new LinkedHashMap<String, Integer.TYPEMap);\n     }\n \n     /**\n      * Returns the current record number in the input stream.\n      * <p/>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return new LinkedHashMap<String, Integer>(e.headerMap);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-4/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 02:08:53.713895744 +0200\n+++ /tmp/tmpbwgshfzx.java\t2022-07-19 02:08:53.717895722 +0200\n@@ -283,11 +283,11 @@\n      * The map keys are column names. The map values are 0-based indices.\n      * </p>\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+return new LinkedHashMap<String, Integer>(e.headerMap);\n     }\n \n     /**\n      * Returns the current record number in the input stream.\n      * <p/>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return new LinkedHashMap<String, Integer>(headerMap); // TODO: this.headerMap = new LinkedHashMap<String, Integer>(this.headerMap);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-4/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 02:08:55.469886106 +0200\n+++ /tmp/tmpoc29r7zu.java\t2022-07-19 02:08:55.469886106 +0200\n@@ -283,11 +283,11 @@\n      * The map keys are column names. The map values are 0-based indices.\n      * </p>\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+return new LinkedHashMap<String, Integer>(headerMap); // TODO: this.headerMap = new LinkedHashMap<String, Integer>(this.headerMap);\n     }\n \n     /**\n      * Returns the current record number in the input stream.\n      * <p/>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return new LinkedHashMap<String, Integer>(this.headerMap);",
        "fixed_line": "return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);"
    },
    "Closure-55": {
        "fixes": [
            {
                "k": 1,
                "patch": "return NodeUtil.isFunctionExpression(n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2022-07-19 02:08:58.345870320 +0200\n+++ /tmp/tmpqgrqy_ez.java\t2022-07-19 02:08:58.417869925 +0200\n@@ -112,11 +112,11 @@\n         reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n     return (root != null) ? root.removeFirstChild() : null;\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+return NodeUtil.isFunctionExpression(n);\n   }\n \n   /**\n    * Information needed to apply a reduction.\n    */\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return NodeUtil.isFunctionExpression( n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2022-07-19 02:09:37.273656741 +0200\n+++ /tmp/tmpvszmny_a.java\t2022-07-19 02:09:38.257651344 +0200\n@@ -112,11 +112,11 @@\n         reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n     return (root != null) ? root.removeFirstChild() : null;\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+return NodeUtil.isFunctionExpression( n);\n   }\n \n   /**\n    * Information needed to apply a reduction.\n    */\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return NodeUtil.isFunctionExpression(n); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2022-07-19 02:10:22.873406724 +0200\n+++ /tmp/tmp4r_u_u84.java\t2022-07-19 02:10:22.873406724 +0200\n@@ -112,11 +112,11 @@\n         reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n     return (root != null) ? root.removeFirstChild() : null;\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+return NodeUtil.isFunctionExpression(n); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n   }\n \n   /**\n    * Information needed to apply a reduction.\n    */\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return NodeUtil.isFunctionExpression(n); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2022-07-19 02:11:05.613172542 +0200\n+++ /tmp/tmp2x_a7paa.java\t2022-07-19 02:11:05.613172542 +0200\n@@ -112,11 +112,11 @@\n         reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n     return (root != null) ? root.removeFirstChild() : null;\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+return NodeUtil.isFunctionExpression(n); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n   }\n \n   /**\n    * Information needed to apply a reduction.\n    */\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return NodeUtil.isFunctionExpression(n); // we didn't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2022-07-19 02:11:43.296966173 +0200\n+++ /tmp/tmpj6x4fvva.java\t2022-07-19 02:11:43.300966152 +0200\n@@ -112,11 +112,11 @@\n         reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n     return (root != null) ? root.removeFirstChild() : null;\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+return NodeUtil.isFunctionExpression(n); // we didn't really modify it's totalGJACKSON-notnotnotnot real number\n   }\n \n   /**\n    * Information needed to apply a reduction.\n    */\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return NodeUtil.isFunctionExpression(n); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2022-07-19 02:12:20.216764083 +0200\n+++ /tmp/tmpp6okr_2l.java\t2022-07-19 02:12:20.216764083 +0200\n@@ -112,11 +112,11 @@\n         reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n     return (root != null) ? root.removeFirstChild() : null;\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+return NodeUtil.isFunctionExpression(n); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n   }\n \n   /**\n    * Information needed to apply a reduction.\n    */\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return NodeUtil.isFunctionExpression(n); // we didn't really modify it's totalGJACKSON-notnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2022-07-19 02:12:57.188561796 +0200\n+++ /tmp/tmp0frvnofd.java\t2022-07-19 02:12:57.188561796 +0200\n@@ -112,11 +112,11 @@\n         reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n     return (root != null) ? root.removeFirstChild() : null;\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+return NodeUtil.isFunctionExpression(n); // we didn't really modify it's totalGJACKSON-notnotnot real number\n   }\n \n   /**\n    * Information needed to apply a reduction.\n    */\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return NodeUtil.isFunctionExpression(n); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2022-07-19 02:13:34.380358388 +0200\n+++ /tmp/tmp_roatd1h.java\t2022-07-19 02:13:34.384358367 +0200\n@@ -112,11 +112,11 @@\n         reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n     return (root != null) ? root.removeFirstChild() : null;\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+return NodeUtil.isFunctionExpression(n); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number\n   }\n \n   /**\n    * Information needed to apply a reduction.\n    */\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return NodeUtil.isFunctionExpression(n); // we didn't really modify it's totalGJACKSON-407] -- allow use a native function.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2022-07-19 02:14:11.124157504 +0200\n+++ /tmp/tmpo_stnkbb.java\t2022-07-19 02:14:11.124157504 +0200\n@@ -112,11 +112,11 @@\n         reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n     return (root != null) ? root.removeFirstChild() : null;\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+return NodeUtil.isFunctionExpression(n); // we didn't really modify it's totalGJACKSON-407] -- allow use a native function.\n   }\n \n   /**\n    * Information needed to apply a reduction.\n    */\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return NodeUtil.isFunctionExpression(n); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2022-07-19 02:14:47.743957368 +0200\n+++ /tmp/tmpnqfvtf5_.java\t2022-07-19 02:14:47.743957368 +0200\n@@ -112,11 +112,11 @@\n         reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n     return (root != null) ? root.removeFirstChild() : null;\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+return NodeUtil.isFunctionExpression(n); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number\n   }\n \n   /**\n    * Information needed to apply a reduction.\n    */\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return NodeUtil.isFunctionExpression(n);",
        "fixed_line": "return NodeUtil.isFunctionExpression(n) && !NodeUtil.isGetOrSetKey(n.getParent());"
    },
    "Chart-24": {
        "fixes": [
            {
                "k": 1,
                "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-24/source/org/jfree/chart/renderer/GrayPaintScale.java\t2022-07-19 02:15:25.003753801 +0200\n+++ /tmp/tmpyem254cu.java\t2022-07-19 02:15:25.023753692 +0200\n@@ -121,11 +121,11 @@\n      * @return A paint for the specified value.\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+int g = (int) ((value - this.lowerBound) / (this.upperBound\n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n     \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound)) / (this.upperBound",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-24/source/org/jfree/chart/renderer/GrayPaintScale.java\t2022-07-19 02:15:33.947704945 +0200\n+++ /tmp/tmpwfo87779.java\t2022-07-19 02:15:33.947704945 +0200\n@@ -121,11 +121,11 @@\n      * @return A paint for the specified value.\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound)) / (this.upperBound\n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n     \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound - this.upperBound",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-24/source/org/jfree/chart/renderer/GrayPaintScale.java\t2022-07-19 02:15:35.575696055 +0200\n+++ /tmp/tmpz02alcns.java\t2022-07-19 02:15:35.575696055 +0200\n@@ -121,11 +121,11 @@\n      * @return A paint for the specified value.\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+int g = (int) ((value - this.lowerBound) / (this.upperBound - this.upperBound\n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n     \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-24/source/org/jfree/chart/renderer/GrayPaintScale.java\t2022-07-19 02:15:43.231654236 +0200\n+++ /tmp/tmpep49lose.java\t2022-07-19 02:15:43.231654236 +0200\n@@ -121,11 +121,11 @@\n      * @return A paint for the specified value.\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound);\n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n     \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound)) * (this.upperBound",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-24/source/org/jfree/chart/renderer/GrayPaintScale.java\t2022-07-19 02:15:44.879645235 +0200\n+++ /tmp/tmpllea_3b2.java\t2022-07-19 02:15:44.879645235 +0200\n@@ -121,11 +121,11 @@\n      * @return A paint for the specified value.\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound)) * (this.upperBound\n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n     \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound + (this.upperBound",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-24/source/org/jfree/chart/renderer/GrayPaintScale.java\t2022-07-19 02:15:46.487636455 +0200\n+++ /tmp/tmpr56qb4om.java\t2022-07-19 02:15:46.487636455 +0200\n@@ -121,11 +121,11 @@\n      * @return A paint for the specified value.\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+int g = (int) ((value - this.lowerBound) / (this.upperBound + (this.upperBound\n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n     \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound - this.upperBound)) / (this.upperBound",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-24/source/org/jfree/chart/renderer/GrayPaintScale.java\t2022-07-19 02:15:48.055627890 +0200\n+++ /tmp/tmpl0mr6a4a.java\t2022-07-19 02:15:48.055627890 +0200\n@@ -121,11 +121,11 @@\n      * @return A paint for the specified value.\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+int g = (int) ((value - this.lowerBound) / (this.upperBound - this.upperBound)) / (this.upperBound\n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n     \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) / (this.upperBound",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-24/source/org/jfree/chart/renderer/GrayPaintScale.java\t2022-07-19 02:15:49.731618737 +0200\n+++ /tmp/tmp714c01u8.java\t2022-07-19 02:15:49.735618713 +0200\n@@ -121,11 +121,11 @@\n      * @return A paint for the specified value.\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) / (this.upperBound\n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n     \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-24/source/org/jfree/chart/renderer/GrayPaintScale.java\t2022-07-19 02:15:57.279577513 +0200\n+++ /tmp/tmpyt25dsbt.java\t2022-07-19 02:15:57.279577513 +0200\n@@ -121,11 +121,11 @@\n      * @return A paint for the specified value.\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound\n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n     \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound - this.upperBound);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-24/source/org/jfree/chart/renderer/GrayPaintScale.java\t2022-07-19 02:16:05.063535006 +0200\n+++ /tmp/tmpv6yhekl7.java\t2022-07-19 02:16:05.063535006 +0200\n@@ -121,11 +121,11 @@\n      * @return A paint for the specified value.\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+int g = (int) ((value - this.lowerBound) / (this.upperBound - this.upperBound);\n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n     \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "int g = (int) ((value - this.lowerBound) / (this.upperBound",
        "fixed_line": "int g = (int) ((v - this.lowerBound) / (this.upperBound"
    },
    "Lang-9": {
        "fixes": [
            {
                "k": 1,
                "patch": "// currentStrategy= nextStrategy;",
                "patch_diff": "// currentStrategy= nextStrategy;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "currentStrategy= nextFormatField= nextStrategy;",
                "patch_diff": "currentStrategy= nextFormatField= nextStrategy;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// currentStrategy= nextStrategy; currentStrategy.addRegex",
                "patch_diff": "// currentStrategy= nextStrategy; currentStrategy.addRegex",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// currentStrategy= nextStrategy.addRegex;",
                "patch_diff": "// currentStrategy= nextStrategy.addRegex;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// currentStrategy.addRegex(nextFormatField= collector.size() > 0;",
                "patch_diff": "// currentStrategy.addRegex(nextFormatField= collector.size() > 0;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// currentStrategy= nextStrategy.addRegex",
                "patch_diff": "// currentStrategy= nextStrategy.addRegex",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// currentStrategy= nextStrategy.addRegex(nextFormatField= collector.size() > 0;",
                "patch_diff": "// currentStrategy= nextStrategy.addRegex(nextFormatField= collector.size() > 0;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// currentStrategy= nextStrategy.addRegex(this, regex)) {",
                "patch_diff": "// currentStrategy= nextStrategy.addRegex(this, regex)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// currentStrategy= nextStrategy.addRegex(nextFormatField= collector.size()]);",
                "patch_diff": "// currentStrategy= nextStrategy.addRegex(nextFormatField= collector.size()]);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// currentStrategy= nextStrategy.addRegex(currentStrategy);",
                "patch_diff": "// currentStrategy= nextStrategy.addRegex(currentStrategy);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (patternMatcher.regionStart() != patternMatcher.regionEnd()) { throw new IllegalArgumentException(\"Failed to parse \\\"\"+pattern+\"\\\" ; gave up at index \"+patternMatcher.regionStart()); }"
    },
    "Jsoup-48": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (values.isEmpty())",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-48/src/main/java/org/jsoup/helper/HttpConnection.java\t2022-07-19 02:16:08.787514670 +0200\n+++ /tmp/tmp9cpsjp8e.java\t2022-07-19 02:16:08.883514143 +0200\n@@ -768,11 +768,11 @@\n                         // name not blank, value not null\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n+if (values.isEmpty())\n                         header(name, values.get(0));\n                 }\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (values.isEmpty()) // can't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-48/src/main/java/org/jsoup/helper/HttpConnection.java\t2022-07-19 02:16:13.327489877 +0200\n+++ /tmp/tmp0n9ktozb.java\t2022-07-19 02:16:13.327489877 +0200\n@@ -768,11 +768,11 @@\n                         // name not blank, value not null\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n+if (values.isEmpty()) // can't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n                         header(name, values.get(0));\n                 }\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (values.isEmpty()) // can't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-48/src/main/java/org/jsoup/helper/HttpConnection.java\t2022-07-19 02:16:16.499472556 +0200\n+++ /tmp/tmpwigv2u2k.java\t2022-07-19 02:16:16.499472556 +0200\n@@ -768,11 +768,11 @@\n                         // name not blank, value not null\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n+if (values.isEmpty()) // can't really modify it's totalGJACKSON-notnotnotnotnot real number\n                         header(name, values.get(0));\n                 }\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (values.isEmpty()) // can't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-48/src/main/java/org/jsoup/helper/HttpConnection.java\t2022-07-19 02:16:19.715454995 +0200\n+++ /tmp/tmpgqz0o03l.java\t2022-07-19 02:16:19.715454995 +0200\n@@ -768,11 +768,11 @@\n                         // name not blank, value not null\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n+if (values.isEmpty()) // can't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n                         header(name, values.get(0));\n                 }\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (values.isEmpty()) // [JACKSON-407] -- allow disabling wrapping for (int i = 0; i <values.length; ++values.get(0));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-48/src/main/java/org/jsoup/helper/HttpConnection.java\t2022-07-19 02:16:22.791438200 +0200\n+++ /tmp/tmpgj4hmee2.java\t2022-07-19 02:16:22.791438200 +0200\n@@ -768,11 +768,11 @@\n                         // name not blank, value not null\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n+if (values.isEmpty()) // [JACKSON-407] -- allow disabling wrapping for (int i = 0; i <values.length; ++values.get(0));\n                         header(name, values.get(0));\n                 }\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (values.isEmpty()) // can't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-48/src/main/java/org/jsoup/helper/HttpConnection.java\t2022-07-19 02:16:26.031420509 +0200\n+++ /tmp/tmp45a791by.java\t2022-07-19 02:16:26.031420509 +0200\n@@ -768,11 +768,11 @@\n                         // name not blank, value not null\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n+if (values.isEmpty()) // can't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number\n                         header(name, values.get(0));\n                 }\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (values.isEmpty()) // can't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-48/src/main/java/org/jsoup/helper/HttpConnection.java\t2022-07-19 02:16:29.143403517 +0200\n+++ /tmp/tmph27qs4xd.java\t2022-07-19 02:16:29.143403517 +0200\n@@ -768,11 +768,11 @@\n                         // name not blank, value not null\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n+if (values.isEmpty()) // can't really modify it's totalGJACKSON-notnotnotnot real number\n                         header(name, values.get(0));\n                 }\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (values.isEmpty()) // [JACKSON-407] -- allow disabling wrapping for (int i = 0; i <values.length; ++values.length;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-48/src/main/java/org/jsoup/helper/HttpConnection.java\t2022-07-19 02:16:32.239386614 +0200\n+++ /tmp/tmpw4eaiuxl.java\t2022-07-19 02:16:32.239386614 +0200\n@@ -768,11 +768,11 @@\n                         // name not blank, value not null\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n+if (values.isEmpty()) // [JACKSON-407] -- allow disabling wrapping for (int i = 0; i <values.length; ++values.length;\n                         header(name, values.get(0));\n                 }\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (values.isEmpty()) // can't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-48/src/main/java/org/jsoup/helper/HttpConnection.java\t2022-07-19 02:16:35.415369276 +0200\n+++ /tmp/tmp7lajc3vm.java\t2022-07-19 02:16:35.415369276 +0200\n@@ -768,11 +768,11 @@\n                         // name not blank, value not null\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n+if (values.isEmpty()) // can't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number\n                         header(name, values.get(0));\n                 }\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (values.isEmpty()) // [JACKSON-407] -- allow disabling wrapping for (int i = 0; i <values.length; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-48/src/main/java/org/jsoup/helper/HttpConnection.java\t2022-07-19 02:16:38.547352174 +0200\n+++ /tmp/tmpr65i335i.java\t2022-07-19 02:16:38.547352174 +0200\n@@ -768,11 +768,11 @@\n                         // name not blank, value not null\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n+if (values.isEmpty()) // [JACKSON-407] -- allow disabling wrapping for (int i = 0; i <values.length; i++) {\n                         header(name, values.get(0));\n                 }\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (!values.isEmpty())",
        "fixed_line": "if (values.size() == 1) header(name, values.get(0)); else if (values.size() > 1) { StringBuilder accum = new StringBuilder(); for (int i = 0; i < values.size(); i++) { final String val = values.get(i); if (i != 0) accum.append(\", \"); accum.append(val); } header(name, accum.toString()); }"
    },
    "Cli-17": {
        "fixes": [
            {
                "k": 1,
                "patch": "else if (stopAtNonOption) {",
                "patch_diff": "else if (stopAtNonOption) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "//(token.substring(i)); } else if (stopAtNonOption) {",
                "patch_diff": "//(token.substring(i)); } else if (stopAtNonOption) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (stopAtNonOption) {",
                "patch_diff": "} else if (stopAtNonOption) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (stopAtNonOption) {",
                "patch_diff": "if (stopAtNonOption) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "len(token.substring(i)); } else if (stopAtNonOption) {",
                "patch_diff": "len(token.substring(i)); } else if (stopAtNonOption) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "//(token.substring(i)); } else if (stopAtNonOption)",
                "patch_diff": "//(token.substring(i)); } else if (stopAtNonOption)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "//(token.substring(0, i)); } else if (stopAtNonOption) {",
                "patch_diff": "//(token.substring(0, i)); } else if (stopAtNonOption) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "//(token.substring(i));",
                "patch_diff": "//(token.substring(i));",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "//(token.substring(i)); else if (stopAtNonOption) {",
                "patch_diff": "//(token.substring(i)); else if (stopAtNonOption) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "//(token.substring(i)); } else if (stopAtNonOption) ==",
                "patch_diff": "//(token.substring(i)); } else if (stopAtNonOption) ==",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "break;"
    },
    "Math-75": {
        "fixes": [
            {
                "k": 1,
                "patch": "return getCumPct((Comparable<?>)v);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-75/src/main/java/org/apache/commons/math/stat/Frequency.java\t2022-07-19 02:16:43.299326231 +0200\n+++ /tmp/tmpe3wvdn39.java\t2022-07-19 02:16:43.327326078 +0200\n@@ -298,11 +298,11 @@\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+return getCumPct((Comparable<?>)v);\n     }\n \n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return getCumPct((Comparable<?>) v);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-75/src/main/java/org/apache/commons/math/stat/Frequency.java\t2022-07-19 02:16:50.763285484 +0200\n+++ /tmp/tmpgii_3k8q.java\t2022-07-19 02:16:50.767285464 +0200\n@@ -298,11 +298,11 @@\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+return getCumPct((Comparable<?>) v);\n     }\n \n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return getCumPct((Comparable<?>)value);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-75/src/main/java/org/apache/commons/math/stat/Frequency.java\t2022-07-19 02:16:57.451248975 +0200\n+++ /tmp/tmp9l0mwjp4.java\t2022-07-19 02:16:57.451248975 +0200\n@@ -298,11 +298,11 @@\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+return getCumPct((Comparable<?>)value);\n     }\n \n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return getCumPct((Comparable<?>) value);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-75/src/main/java/org/apache/commons/math/stat/Frequency.java\t2022-07-19 02:16:59.707236662 +0200\n+++ /tmp/tmp5tgx25xd.java\t2022-07-19 02:16:59.711236637 +0200\n@@ -298,11 +298,11 @@\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+return getCumPct((Comparable<?>) value);\n     }\n \n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return getCumPct((Comparable<?>) v + 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-75/src/main/java/org/apache/commons/math/stat/Frequency.java\t2022-07-19 02:17:01.895224718 +0200\n+++ /tmp/tmphql_5byf.java\t2022-07-19 02:17:01.895224718 +0200\n@@ -298,11 +298,11 @@\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+return getCumPct((Comparable<?>) v + 1);\n     }\n \n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return getCumPct((Comparable<?>)v + 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-75/src/main/java/org/apache/commons/math/stat/Frequency.java\t2022-07-19 02:17:03.955213473 +0200\n+++ /tmp/tmpdjec9fry.java\t2022-07-19 02:17:03.955213473 +0200\n@@ -298,11 +298,11 @@\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+return getCumPct((Comparable<?>)v + 1);\n     }\n \n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return getCumPct((Comparable<?>) n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-75/src/main/java/org/apache/commons/math/stat/Frequency.java\t2022-07-19 02:17:06.159201440 +0200\n+++ /tmp/tmp9sy92vus.java\t2022-07-19 02:17:06.159201440 +0200\n@@ -298,11 +298,11 @@\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+return getCumPct((Comparable<?>) n);\n     }\n \n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return getCumPct((Comparable<?>) v + 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-75/src/main/java/org/apache/commons/math/stat/Frequency.java\t2022-07-19 02:17:08.303189739 +0200\n+++ /tmp/tmpz3xl_orr.java\t2022-07-19 02:17:08.303189739 +0200\n@@ -298,11 +298,11 @@\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+return getCumPct((Comparable<?>) v + 1;\n     }\n \n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return getCumPct((Comparable<?>)l);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-75/src/main/java/org/apache/commons/math/stat/Frequency.java\t2022-07-19 02:17:10.259179061 +0200\n+++ /tmp/tmpumykr9hs.java\t2022-07-19 02:17:10.259179061 +0200\n@@ -298,11 +298,11 @@\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+return getCumPct((Comparable<?>)l);\n     }\n \n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return getCumPct((Comparable<?>) v).",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-75/src/main/java/org/apache/commons/math/stat/Frequency.java\t2022-07-19 02:17:12.395167401 +0200\n+++ /tmp/tmpvap7ffs_.java\t2022-07-19 02:17:12.395167401 +0200\n@@ -298,11 +298,11 @@\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+return getCumPct((Comparable<?>) v).\n     }\n \n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return getCumPct((Comparable<?>) v);",
        "fixed_line": "return getPct((Comparable<?>) v);"
    },
    "JxPath-14": {
        "fixes": [
            {
                "k": 1,
                "patch": "double v = context.getArg1().computeValue(v));",
                "patch_diff": "double v = context.getArg1().computeValue(v));",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "double v = context.doubleValue(v);",
                "patch_diff": "double v = context.doubleValue(v);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "double v = context.getArg1().computeValue(v);",
                "patch_diff": "double v = context.getArg1().computeValue(v);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "double v = context.getArg1().computeValue(v)); }",
                "patch_diff": "double v = context.getArg1().computeValue(v)); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "double v = context.doubleValue(v));",
                "patch_diff": "double v = context.doubleValue(v));",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "double v = context.doubleValue();",
                "patch_diff": "double v = context.doubleValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "double v = context.getArg1().computeValue(context));",
                "patch_diff": "double v = context.getArg1().computeValue(context));",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "double v = context.getArg1().computeValue(context);",
                "patch_diff": "double v = context.getArg1().computeValue(context);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "double v = context.getArg1().computeValue(doubleValue);",
                "patch_diff": "double v = context.getArg1().computeValue(doubleValue);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "double v = context.getArg1().computeValue();",
                "patch_diff": "double v = context.getArg1().computeValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (Double.isNaN(v) || Double.isInfinite(v)) { return new Double(v); } return new Double(Math.floor(v)); } protected Object functionCeiling(EvalContext context) { assertArgCount(1); double v = InfoSetUtil.doubleValue(getArg1().computeValue(context)); if (Double.isNaN(v) || Double.isInfinite(v)) { return new Double(v); } return new Double(Math.ceil(v)); } protected Object functionRound(EvalContext context) { assertArgCount(1); double v = InfoSetUtil.doubleValue(getArg1().computeValue(context)); if (Double.isNaN(v) || Double.isInfinite(v)) { return new Double(v); }"
    },
    "JacksonCore-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "char c = str.charAt(i++);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-5/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 02:17:16.243146399 +0200\n+++ /tmp/tmptwgn17cv.java\t2022-07-19 02:17:16.291146136 +0200\n@@ -188,11 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+char c = str.charAt(i++);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "char c = str.charAt(i++); // don't really modify it's totalGJACKSON-407] --str.charAt(i++);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-5/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 02:17:21.439118038 +0200\n+++ /tmp/tmp5jc3005k.java\t2022-07-19 02:17:21.443118017 +0200\n@@ -188,11 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+char c = str.charAt(i++); // don't really modify it's totalGJACKSON-407] --str.charAt(i++);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "char c = str.charAt(i++); // don't really gets this.str.charAt(i++);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-5/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 02:17:26.031092978 +0200\n+++ /tmp/tmpnv8om2os.java\t2022-07-19 02:17:26.031092978 +0200\n@@ -188,11 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+char c = str.charAt(i++); // don't really gets this.str.charAt(i++);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "char c = str.charAt(i++); // don't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-5/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 02:17:30.679067609 +0200\n+++ /tmp/tmp4tdw4u8s.java\t2022-07-19 02:17:30.679067609 +0200\n@@ -188,11 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+char c = str.charAt(i++); // don't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "char c = str.charAt(i++); // we didn't really gets this.str.charAt(i++);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-5/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 02:17:35.371042002 +0200\n+++ /tmp/tmpvzvusxyl.java\t2022-07-19 02:17:35.371042002 +0200\n@@ -188,11 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+char c = str.charAt(i++); // we didn't really gets this.str.charAt(i++);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "char c = str.charAt(i++); // don't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-5/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 02:17:40.115016112 +0200\n+++ /tmp/tmpwxeywwbx.java\t2022-07-19 02:17:40.115016112 +0200\n@@ -188,11 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+char c = str.charAt(i++); // don't really modify it's totalGJACKSON-notnotnotnotnot real number\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "char c -= str.charAt(i++);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-5/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 02:17:44.798990550 +0200\n+++ /tmp/tmp9zczdv8b.java\t2022-07-19 02:17:44.798990550 +0200\n@@ -188,11 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+char c -= str.charAt(i++);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "char c = str.charAt(i++); // don't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-5/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 02:17:46.310982300 +0200\n+++ /tmp/tmp5mfy6soz.java\t2022-07-19 02:17:46.310982300 +0200\n@@ -188,11 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+char c = str.charAt(i++); // don't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "char c = str.charAt(i++); // don't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-5/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 02:17:51.010956651 +0200\n+++ /tmp/tmpi24aucvu.java\t2022-07-19 02:17:51.014956632 +0200\n@@ -188,11 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+char c = str.charAt(i++); // don't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "char c = str.charAt(i++); // don't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-5/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-19 02:17:55.658931288 +0200\n+++ /tmp/tmpin4xgucb.java\t2022-07-19 02:17:55.662931268 +0200\n@@ -188,11 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+char c = str.charAt(i++); // don't really modify it's totalGJACKSON-notnotnotnot real number\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "char c = str.charAt(i++);",
        "fixed_line": "char c = str.charAt(i);"
    },
    "Closure-123": {
        "fixes": [
            {
                "k": 1,
                "patch": "Context rhsContext = context;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-123/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 02:18:00.486904945 +0200\n+++ /tmp/tmpovqsewpm.java\t2022-07-19 02:18:00.502904855 +0200\n@@ -280,11 +280,11 @@\n       }\n \n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+Context rhsContext = context;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n         cc.addOp(\":\", true);\n         addExpr(last, 1, rhsContext);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "Context rhsContext = Context.OTHER;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-123/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 02:18:49.946635097 +0200\n+++ /tmp/tmpchwp9bmr.java\t2022-07-19 02:18:49.946635097 +0200\n@@ -280,11 +280,11 @@\n       }\n \n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+Context rhsContext = Context.OTHER;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n         cc.addOp(\":\", true);\n         addExpr(last, 1, rhsContext);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "Context rhsContext = context; // can't really modify it was non-literal characters that might be valid (e if it.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-123/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 02:19:39.394365392 +0200\n+++ /tmp/tmp4fw9v63t.java\t2022-07-19 02:19:39.398365368 +0200\n@@ -280,11 +280,11 @@\n       }\n \n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+Context rhsContext = context; // can't really modify it was non-literal characters that might be valid (e if it.\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n         cc.addOp(\":\", true);\n         addExpr(last, 1, rhsContext);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "Context rhsContext = context; // can't really modify it was non-literal characters that might be Token.OTHER;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-123/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 02:20:28.874095577 +0200\n+++ /tmp/tmpjoyirzdg.java\t2022-07-19 02:20:28.874095577 +0200\n@@ -280,11 +280,11 @@\n       }\n \n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+Context rhsContext = context; // can't really modify it was non-literal characters that might be Token.OTHER;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n         cc.addOp(\":\", true);\n         addExpr(last, 1, rhsContext);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "Context rhsContext = context; // can't really modify it was non-literal characters that might be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-123/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 02:21:18.201826649 +0200\n+++ /tmp/tmp_nyqrrlp.java\t2022-07-19 02:21:18.201826649 +0200\n@@ -280,11 +280,11 @@\n       }\n \n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+Context rhsContext = context; // can't really modify it was non-literal characters that might be null!\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n         cc.addOp(\":\", true);\n         addExpr(last, 1, rhsContext);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "Context rhsContext = context; // can't really modify it was non-literal characters that might be Token.OTHER = context;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-123/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 02:22:07.901555749 +0200\n+++ /tmp/tmpvg8ms147.java\t2022-07-19 02:22:07.901555749 +0200\n@@ -280,11 +280,11 @@\n       }\n \n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+Context rhsContext = context; // can't really modify it was non-literal characters that might be Token.OTHER = context;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n         cc.addOp(\":\", true);\n         addExpr(last, 1, rhsContext);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "Context rhsContext = context; // can't really modify it was non-literal characters that might be valid (empty be valid)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-123/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 02:22:57.477285577 +0200\n+++ /tmp/tmpto_grxow.java\t2022-07-19 02:22:57.477285577 +0200\n@@ -280,11 +280,11 @@\n       }\n \n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+Context rhsContext = context; // can't really modify it was non-literal characters that might be valid (empty be valid)\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n         cc.addOp(\":\", true);\n         addExpr(last, 1, rhsContext);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "Context rhsContext = context; // can't really modify it was non-empty's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-123/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 02:23:46.929016123 +0200\n+++ /tmp/tmp32ajc5p6.java\t2022-07-19 02:23:46.929016123 +0200\n@@ -280,11 +280,11 @@\n       }\n \n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+Context rhsContext = context; // can't really modify it was non-empty's do implicit re-parse\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n         cc.addOp(\":\", true);\n         addExpr(last, 1, rhsContext);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "Context rhsContext = context; // can't really modify it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-123/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 02:24:36.400746601 +0200\n+++ /tmp/tmp60p6gk2r.java\t2022-07-19 02:24:36.400746601 +0200\n@@ -280,11 +280,11 @@\n       }\n \n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+Context rhsContext = context; // can't really modify it's do implicit re-parse\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n         cc.addOp(\":\", true);\n         addExpr(last, 1, rhsContext);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "Context rhsContext = context; // can't really modify it was non-literal characters that might be valid (e if it was -->",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-123/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 02:25:26.144475636 +0200\n+++ /tmp/tmpuh7uysgs.java\t2022-07-19 02:25:26.144475636 +0200\n@@ -280,11 +280,11 @@\n       }\n \n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+Context rhsContext = context; // can't really modify it was non-literal characters that might be valid (e if it was -->\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n         cc.addOp(\":\", true);\n         addExpr(last, 1, rhsContext);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "Context rhsContext = Context.OTHER;",
        "fixed_line": "Context rhsContext = getContextForNoInOperator(context);"
    },
    "Closure-119": {
        "fixes": [
            {
                "k": 1,
                "patch": "// default: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case",
                "patch_diff": "// default: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// if (type = Name.Type.OTHER; break;",
                "patch_diff": "// if (type = Name.Type.OTHER; break;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// default: case Token.INC: case Token.DEC: case Token.INC: case",
                "patch_diff": "// default: case Token.INC: case Token.DEC: case Token.INC: case",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// non-literal characters that might be Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.VAR: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.DEC:",
                "patch_diff": "// non-literal characters that might be Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.VAR: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.DEC:",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// non-literal characters that might be Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.VAR: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.DEC: case Token.INC: case Token.DEC:",
                "patch_diff": "// non-literal characters that might be Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.VAR: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.DEC: case Token.INC: case Token.DEC:",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// non-literal characters that might be Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.VAR: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.DEC:",
                "patch_diff": "// non-literal characters that might be Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.VAR: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.DEC:",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// non-literal characters that might be Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.VAR: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.DEC: case Token.DEC: case Token.INC: case Token.DEC: case Token.DEC:",
                "patch_diff": "// non-literal characters that might be Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.VAR: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.DEC: case Token.DEC: case Token.INC: case Token.DEC: case Token.DEC:",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// non-literal characters that might be Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.VAR: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.DEC: case Token.DEC: case Token.DEC:",
                "patch_diff": "// non-literal characters that might be Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.VAR: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.DEC: case Token.DEC: case Token.DEC:",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// non-literal characters that might be Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.VAR: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC:",
                "patch_diff": "// non-literal characters that might be Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.VAR: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC:",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// non-literal characters that might be Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.VAR: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.DEC: case Token.DEC: case Token.INC:",
                "patch_diff": "// non-literal characters that might be Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.VAR: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.INC: case Token.DEC: case Token.DEC: case Token.DEC: case Token.INC:",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "case Token.CATCH:"
    },
    "Jsoup-37": {
        "fixes": [
            {
                "k": 1,
                "patch": "return attributes.toString().trim();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-37/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 02:26:18.196192134 +0200\n+++ /tmp/tmpi98_4wct.java\t2022-07-19 02:26:18.208192069 +0200\n@@ -1096,11 +1096,11 @@\n      * @see #outerHtml()\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         html(accum);\n-        return accum.toString().trim();\n+return attributes.toString().trim();\n     }\n \n     private void html(StringBuilder accum) {\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return accum.toString().trim();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-37/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 02:26:21.336175035 +0200\n+++ /tmp/tmpv353dh94.java\t2022-07-19 02:26:21.336175035 +0200\n@@ -1096,11 +1096,11 @@\n      * @see #outerHtml()\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         html(accum);\n-        return accum.toString().trim();\n+return accum.toString().trim();\n     }\n \n     private void html(StringBuilder accum) {\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return attributes.toString().trim(); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-37/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 02:26:24.252159152 +0200\n+++ /tmp/tmparnr8lhr.java\t2022-07-19 02:26:24.256159131 +0200\n@@ -1096,11 +1096,11 @@\n      * @see #outerHtml()\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         html(accum);\n-        return accum.toString().trim();\n+return attributes.toString().trim(); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n     }\n \n     private void html(StringBuilder accum) {\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return attributes.toString().trim(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-37/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 02:26:27.280142664 +0200\n+++ /tmp/tmp_cjcroai.java\t2022-07-19 02:26:27.280142664 +0200\n@@ -1096,11 +1096,11 @@\n      * @see #outerHtml()\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         html(accum);\n-        return accum.toString().trim();\n+return attributes.toString().trim(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n     }\n \n     private void html(StringBuilder accum) {\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return attributes.toString().trim(); // we didn't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-37/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 02:26:30.300126215 +0200\n+++ /tmp/tmpqrd1uvnc.java\t2022-07-19 02:26:30.304126195 +0200\n@@ -1096,11 +1096,11 @@\n      * @see #outerHtml()\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         html(accum);\n-        return accum.toString().trim();\n+return attributes.toString().trim(); // we didn't really modify it's totalGJACKSON-notnotnotnot real number\n     }\n \n     private void html(StringBuilder accum) {\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return attributes.toString().trim(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-37/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 02:26:33.536108593 +0200\n+++ /tmp/tmpzhyvdfpn.java\t2022-07-19 02:26:33.540108569 +0200\n@@ -1096,11 +1096,11 @@\n      * @see #outerHtml()\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         html(accum);\n-        return accum.toString().trim();\n+return attributes.toString().trim(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n     }\n \n     private void html(StringBuilder accum) {\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return attributes.toString().trim(); // we didn't really modify it's totalGJACKSON-notnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-37/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 02:26:36.556092145 +0200\n+++ /tmp/tmpm8db26uz.java\t2022-07-19 02:26:36.556092145 +0200\n@@ -1096,11 +1096,11 @@\n      * @see #outerHtml()\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         html(accum);\n-        return accum.toString().trim();\n+return attributes.toString().trim(); // we didn't really modify it's totalGJACKSON-notnotnot real number\n     }\n \n     private void html(StringBuilder accum) {\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return attributes.toString().trim(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-37/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 02:26:39.524075982 +0200\n+++ /tmp/tmpg8l_clvp.java\t2022-07-19 02:26:39.524075982 +0200\n@@ -1096,11 +1096,11 @@\n      * @see #outerHtml()\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         html(accum);\n-        return accum.toString().trim();\n+return attributes.toString().trim(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number\n     }\n \n     private void html(StringBuilder accum) {\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return attributes.toString().trim(); // we didn't really modify it's totalGJACKSON-notnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-37/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 02:26:42.572059382 +0200\n+++ /tmp/tmp_qf593pn.java\t2022-07-19 02:26:42.572059382 +0200\n@@ -1096,11 +1096,11 @@\n      * @see #outerHtml()\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         html(accum);\n-        return accum.toString().trim();\n+return attributes.toString().trim(); // we didn't really modify it's totalGJACKSON-notnot real number\n     }\n \n     private void html(StringBuilder accum) {\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return attributes.toString().trim(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-37/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 02:26:45.508043394 +0200\n+++ /tmp/tmp9yx1zfk9.java\t2022-07-19 02:26:45.512043373 +0200\n@@ -1096,11 +1096,11 @@\n      * @see #outerHtml()\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         html(accum);\n-        return accum.toString().trim();\n+return attributes.toString().trim(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number\n     }\n \n     private void html(StringBuilder accum) {\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return accum.toString().trim();",
        "fixed_line": "return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();"
    },
    "Closure-120": {
        "fixes": [
            {
                "k": 1,
                "patch": "// block == null; block = block.getBasicBlock();",
                "patch_diff": "// block == null; block = block.getBasicBlock();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// block == null; block == null; block = block.getParent()) { return false; } }",
                "patch_diff": "// block == null; block == null; block = block.getParent()) { return false; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (block == null) { return false; } else if (block.isFunction) { return false; } }",
                "patch_diff": "if (block == null) { return false; } else if (block.isFunction) { return false; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// block == null; block == null; block = block.getParent()) { return false; } else if (block!= null) { return false; } }",
                "patch_diff": "// block == null; block == null; block = block.getParent()) { return false; } else if (block!= null) { return false; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// block == null; block = block.getBasicBlock(); } else if (block.getParent()) { return false; } else if (block!= null) { return false; } }",
                "patch_diff": "// block == null; block = block.getBasicBlock(); } else if (block.getParent()) { return false; } else if (block!= null) { return false; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (block == null) { return false; } else if (block == null) { return false; } else if (block.isLoop()) { return false; } }",
                "patch_diff": "if (block == null) { return false; } else if (block == null) { return false; } else if (block.isLoop()) { return false; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (block == null) { return false; } else if (block.isFunction) { return false; } else if (block.getParent()) { return false; } }",
                "patch_diff": "if (block == null) { return false; } else if (block.isFunction) { return false; } else if (block.getParent()) { return false; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (block == null) { return false; } else if (block.isFunction) { return false; } else if (block.isLoop()) { return false; } }",
                "patch_diff": "if (block == null) { return false; } else if (block.isFunction) { return false; } else if (block.isLoop()) { return false; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// block == null; block = block.getBasicBlock(); } else if (block.getParent()) { return false; } else if (block!= null) { return false; } else if (block.isLoop()) { return false; } }",
                "patch_diff": "// block == null; block = block.getBasicBlock(); } else if (block.getParent()) { return false; } else if (block!= null) { return false; } else if (block.isLoop()) { return false; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (block == null) { return false; } else if (block == null) { return false; } else if (block.isLoop()) { return false; } else if (block!= null) { return false; } }",
                "patch_diff": "if (block == null) { return false; } else if (block == null) { return false; } else if (block.isLoop()) { return false; } else if (block!= null) { return false; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (ref.getSymbol().getScope() != ref.scope) { return false; }"
    },
    "JacksonDatabind-45": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (format.getShape() == JsonFormat.Shape.STRING) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-45/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 02:26:50.940013812 +0200\n+++ /tmp/tmp66cogur1.java\t2022-07-19 02:26:50.964013682 +0200\n@@ -58,11 +58,11 @@\n                 JsonFormat.Shape shape = format.getShape();\n                 if (shape.isNumeric()) {\n                     return withFormat(Boolean.TRUE, null);\n                 }\n \n-                if (format.getShape() == JsonFormat.Shape.STRING) {\n+if (format.getShape() == JsonFormat.Shape.STRING) {\n                     TimeZone tz = format.getTimeZone();\n                     final String pattern = format.hasPattern()\n                                     ? format.getPattern()\n                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                     final Locale loc = format.hasLocale()\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (format.getShape() == JsonFormat.Shape.STRING) { // could still be null",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-45/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 02:27:27.347815550 +0200\n+++ /tmp/tmpp5cqucu0.java\t2022-07-19 02:27:27.351815529 +0200\n@@ -58,11 +58,11 @@\n                 JsonFormat.Shape shape = format.getShape();\n                 if (shape.isNumeric()) {\n                     return withFormat(Boolean.TRUE, null);\n                 }\n \n-                if (format.getShape() == JsonFormat.Shape.STRING) {\n+if (format.getShape() == JsonFormat.Shape.STRING) { // could still be null\n                     TimeZone tz = format.getTimeZone();\n                     final String pattern = format.hasPattern()\n                                     ? format.getPattern()\n                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                     final Locale loc = format.hasLocale()\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (format.getShape()!= JsonFormat.Shape.STRING) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-45/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 02:28:03.295619808 +0200\n+++ /tmp/tmp4ne3kt5e.java\t2022-07-19 02:28:03.295619808 +0200\n@@ -58,11 +58,11 @@\n                 JsonFormat.Shape shape = format.getShape();\n                 if (shape.isNumeric()) {\n                     return withFormat(Boolean.TRUE, null);\n                 }\n \n-                if (format.getShape() == JsonFormat.Shape.STRING) {\n+if (format.getShape()!= JsonFormat.Shape.STRING) {\n                     TimeZone tz = format.getTimeZone();\n                     final String pattern = format.hasPattern()\n                                     ? format.getPattern()\n                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                     final Locale loc = format.hasLocale()\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (format.getShape()!= JsonFormat.Shape.STRING) { // could still be null",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-45/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 02:28:39.531444393 +0200\n+++ /tmp/tmpg4yxrfhg.java\t2022-07-19 02:28:39.531444393 +0200\n@@ -58,11 +58,11 @@\n                 JsonFormat.Shape shape = format.getShape();\n                 if (shape.isNumeric()) {\n                     return withFormat(Boolean.TRUE, null);\n                 }\n \n-                if (format.getShape() == JsonFormat.Shape.STRING) {\n+if (format.getShape()!= JsonFormat.Shape.STRING) { // could still be null\n                     TimeZone tz = format.getTimeZone();\n                     final String pattern = format.hasPattern()\n                                     ? format.getPattern()\n                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                     final Locale loc = format.hasLocale()\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (format.getShape() == JsonFormat.Shape.STRING) { // could still be removed",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-45/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 02:29:15.751274396 +0200\n+++ /tmp/tmpkt10zut3.java\t2022-07-19 02:29:15.751274396 +0200\n@@ -58,11 +58,11 @@\n                 JsonFormat.Shape shape = format.getShape();\n                 if (shape.isNumeric()) {\n                     return withFormat(Boolean.TRUE, null);\n                 }\n \n-                if (format.getShape() == JsonFormat.Shape.STRING) {\n+if (format.getShape() == JsonFormat.Shape.STRING) { // could still be removed\n                     TimeZone tz = format.getTimeZone();\n                     final String pattern = format.hasPattern()\n                                     ? format.getPattern()\n                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                     final Locale loc = format.hasLocale()\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (format.getShape() == JsonFormat.Shape.STRING) { // could still be null // could still be null",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-45/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 02:29:52.051102392 +0200\n+++ /tmp/tmpiv3lm0xq.java\t2022-07-19 02:29:52.051102392 +0200\n@@ -58,11 +58,11 @@\n                 JsonFormat.Shape shape = format.getShape();\n                 if (shape.isNumeric()) {\n                     return withFormat(Boolean.TRUE, null);\n                 }\n \n-                if (format.getShape() == JsonFormat.Shape.STRING) {\n+if (format.getShape() == JsonFormat.Shape.STRING) { // could still be null // could still be null\n                     TimeZone tz = format.getTimeZone();\n                     final String pattern = format.hasPattern()\n                                     ? format.getPattern()\n                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                     final Locale loc = format.hasLocale()\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (format.getShape() < JsonFormat.Shape.STRING) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-45/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 02:30:28.162929766 +0200\n+++ /tmp/tmpfybsk29j.java\t2022-07-19 02:30:28.162929766 +0200\n@@ -58,11 +58,11 @@\n                 JsonFormat.Shape shape = format.getShape();\n                 if (shape.isNumeric()) {\n                     return withFormat(Boolean.TRUE, null);\n                 }\n \n-                if (format.getShape() == JsonFormat.Shape.STRING) {\n+if (format.getShape() < JsonFormat.Shape.STRING) {\n                     TimeZone tz = format.getTimeZone();\n                     final String pattern = format.hasPattern()\n                                     ? format.getPattern()\n                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                     final Locale loc = format.hasLocale()\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if(format.getShape() == JsonFormat.Shape.STRING) { // could still be null",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-45/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 02:30:29.854921645 +0200\n+++ /tmp/tmpgc6lvy71.java\t2022-07-19 02:30:29.854921645 +0200\n@@ -58,11 +58,11 @@\n                 JsonFormat.Shape shape = format.getShape();\n                 if (shape.isNumeric()) {\n                     return withFormat(Boolean.TRUE, null);\n                 }\n \n-                if (format.getShape() == JsonFormat.Shape.STRING) {\n+if(format.getShape() == JsonFormat.Shape.STRING) { // could still be null\n                     TimeZone tz = format.getTimeZone();\n                     final String pattern = format.hasPattern()\n                                     ? format.getPattern()\n                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                     final Locale loc = format.hasLocale()\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (format.getShape() == JsonFormat.Shape.STRING) { // could still be valid (empty be null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-45/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 02:31:05.966747554 +0200\n+++ /tmp/tmpkk6aflh6.java\t2022-07-19 02:31:05.970747535 +0200\n@@ -58,11 +58,11 @@\n                 JsonFormat.Shape shape = format.getShape();\n                 if (shape.isNumeric()) {\n                     return withFormat(Boolean.TRUE, null);\n                 }\n \n-                if (format.getShape() == JsonFormat.Shape.STRING) {\n+if (format.getShape() == JsonFormat.Shape.STRING) { // could still be valid (empty be null)\n                     TimeZone tz = format.getTimeZone();\n                     final String pattern = format.hasPattern()\n                                     ? format.getPattern()\n                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                     final Locale loc = format.hasLocale()\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (format.getShape() == JsonFormat.Shape.STRING) { // could still be null; return format; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-45/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 02:31:41.730573856 +0200\n+++ /tmp/tmpezom_oku.java\t2022-07-19 02:31:41.730573856 +0200\n@@ -58,11 +58,11 @@\n                 JsonFormat.Shape shape = format.getShape();\n                 if (shape.isNumeric()) {\n                     return withFormat(Boolean.TRUE, null);\n                 }\n \n-                if (format.getShape() == JsonFormat.Shape.STRING) {\n+if (format.getShape() == JsonFormat.Shape.STRING) { // could still be null; return format; }\n                     TimeZone tz = format.getTimeZone();\n                     final String pattern = format.hasPattern()\n                                     ? format.getPattern()\n                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                     final Locale loc = format.hasLocale()\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (format.getShape() == JsonFormat.Shape.STRING) {",
        "fixed_line": "if ((shape == JsonFormat.Shape.STRING) || format.hasPattern() || format.hasLocale() || format.hasTimeZone()) {"
    },
    "Lang-26": {
        "fixes": [
            {
                "k": 1,
                "patch": "Calendar c = new GregorianCalendar(2006, 10, 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-26/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 02:32:18.602393531 +0200\n+++ /tmp/tmpsvevlteh.java\t2022-07-19 02:32:18.618393452 +0200\n@@ -815,11 +815,11 @@\n      * \n      * @param date  the date to format\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+Calendar c = new GregorianCalendar(2006, 10, 1);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "Calendar c = new GregorianCalendar(mTimeZone);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-26/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 02:32:28.794343475 +0200\n+++ /tmp/tmp0f63o1er.java\t2022-07-19 02:32:28.798343455 +0200\n@@ -815,11 +815,11 @@\n      * \n      * @param date  the date to format\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+Calendar c = new GregorianCalendar(mTimeZone);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "Calendar c = new GregorianCalendar(2006, 10, 1); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-26/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 02:32:38.230297053 +0200\n+++ /tmp/tmpi7q_dra9.java\t2022-07-19 02:32:38.230297053 +0200\n@@ -815,11 +815,11 @@\n      * \n      * @param date  the date to format\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+Calendar c = new GregorianCalendar(2006, 10, 1); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "Calendar c = new GregorianCalendar(2006, 10, 1); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-26/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 02:32:47.654250616 +0200\n+++ /tmp/tmpx4fwnqmq.java\t2022-07-19 02:32:47.658250596 +0200\n@@ -815,11 +815,11 @@\n      * \n      * @param date  the date to format\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+Calendar c = new GregorianCalendar(2006, 10, 1); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "Calendar c = new GregorianCalendar(2006, 10, 1); // we didn't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-26/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 02:32:57.078204109 +0200\n+++ /tmp/tmplrlhavj9.java\t2022-07-19 02:32:57.078204109 +0200\n@@ -815,11 +815,11 @@\n      * \n      * @param date  the date to format\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+Calendar c = new GregorianCalendar(2006, 10, 1); // we didn't really modify it's totalGJACKSON-notnotnotnot real number\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "Calendar c = new GregorianCalendar(2006, 10, 1); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-26/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 02:33:06.546157307 +0200\n+++ /tmp/tmpr3xt6ro4.java\t2022-07-19 02:33:06.546157307 +0200\n@@ -815,11 +815,11 @@\n      * \n      * @param date  the date to format\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+Calendar c = new GregorianCalendar(2006, 10, 1); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "Calendar c = new GregorianCalendar(2006, 10, 1); // we didn't really modify it's totalGJACKSON-notnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-26/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 02:33:15.974110637 +0200\n+++ /tmp/tmppi_dy9l2.java\t2022-07-19 02:33:15.974110637 +0200\n@@ -815,11 +815,11 @@\n      * \n      * @param date  the date to format\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+Calendar c = new GregorianCalendar(2006, 10, 1); // we didn't really modify it's totalGJACKSON-notnotnot real number\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "Calendar c = new GregorianCalendar(2006, 10, 1); // we didn't really gets this.c = new GregorianCalendar(2006, 10, 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-26/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 02:33:25.414063839 +0200\n+++ /tmp/tmp0w6yzgcj.java\t2022-07-19 02:33:25.414063839 +0200\n@@ -815,11 +815,11 @@\n      * \n      * @param date  the date to format\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+Calendar c = new GregorianCalendar(2006, 10, 1); // we didn't really gets this.c = new GregorianCalendar(2006, 10, 1);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "Calendar c = new GregorianCalendar(2006, 10, 1); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-26/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 02:33:34.742017528 +0200\n+++ /tmp/tmps4wxmta2.java\t2022-07-19 02:33:34.742017528 +0200\n@@ -815,11 +815,11 @@\n      * \n      * @param date  the date to format\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+Calendar c = new GregorianCalendar(2006, 10, 1); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "Calendar c = new GregorianCalendar(2006, 10, 1); // we didn't really modify it's totalGJACKSON-notnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-26/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 02:33:44.105970971 +0200\n+++ /tmp/tmpwzrkzpb0.java\t2022-07-19 02:33:44.105970971 +0200\n@@ -815,11 +815,11 @@\n      * \n      * @param date  the date to format\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+Calendar c = new GregorianCalendar(2006, 10, 1); // we didn't really modify it's totalGJACKSON-notnot real number\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "Calendar c = new GregorianCalendar(mTimeZone);",
        "fixed_line": "Calendar c = new GregorianCalendar(mTimeZone, mLocale);"
    },
    "Codec-17": {
        "fixes": [
            {
                "k": 1,
                "patch": "return new String(bytes, Charsets.ISO_8859_1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-17/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-19 02:33:53.833922539 +0200\n+++ /tmp/tmpt6ug4ohr.java\t2022-07-19 02:33:53.849922458 +0200\n@@ -334,11 +334,11 @@\n      *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+return new String(bytes, Charsets.ISO_8859_1);\n     }\n \n     /**\n      * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n      *\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return new String(bytes, Charsets.ISO_8859_1 = newString(bytes, Charsets.length), Charsets.ISO_8859_1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-17/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-19 02:33:59.293895324 +0200\n+++ /tmp/tmph1od12dt.java\t2022-07-19 02:33:59.293895324 +0200\n@@ -334,11 +334,11 @@\n      *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+return new String(bytes, Charsets.ISO_8859_1 = newString(bytes, Charsets.length), Charsets.ISO_8859_1);\n     }\n \n     /**\n      * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return new String(bytes, Charsets.ISO_8859_1 = newString(bytes, Charsets.ISO_8859_1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-17/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-19 02:34:00.925887186 +0200\n+++ /tmp/tmpmz6a4p66.java\t2022-07-19 02:34:00.925887186 +0200\n@@ -334,11 +334,11 @@\n      *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+return new String(bytes, Charsets.ISO_8859_1 = newString(bytes, Charsets.ISO_8859_1);\n     }\n \n     /**\n      * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return new String(bytes, Charsets.ISO_8859_1 = newString(bytes, Charsets.length);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-17/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-19 02:34:02.513879265 +0200\n+++ /tmp/tmp0f7ukrw9.java\t2022-07-19 02:34:02.513879265 +0200\n@@ -334,11 +334,11 @@\n      *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+return new String(bytes, Charsets.ISO_8859_1 = newString(bytes, Charsets.length);\n     }\n \n     /**\n      * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return new String(bytes, Charsets.ISO_8859_1 = newString(bytes, Charsets.length;8859_1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-17/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-19 02:34:04.073871482 +0200\n+++ /tmp/tmp2jfse5hq.java\t2022-07-19 02:34:04.073871482 +0200\n@@ -334,11 +334,11 @@\n      *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+return new String(bytes, Charsets.ISO_8859_1 = newString(bytes, Charsets.length;8859_1);\n     }\n \n     /**\n      * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return new String(bytes, Charsets.ISO_8859_1); } else if (bytes.length == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-17/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-19 02:34:05.617863778 +0200\n+++ /tmp/tmp1vfdeb80.java\t2022-07-19 02:34:05.617863778 +0200\n@@ -334,11 +334,11 @@\n      *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+return new String(bytes, Charsets.ISO_8859_1); } else if (bytes.length == 0) {\n     }\n \n     /**\n      * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return new String(bytes, Charsets.ISO_8859_1 = newString(bytes, Charsets.getSort(), Charsets.ISO_8859_1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-17/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-19 02:34:07.197855892 +0200\n+++ /tmp/tmpc9t3jpm5.java\t2022-07-19 02:34:07.197855892 +0200\n@@ -334,11 +334,11 @@\n      *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+return new String(bytes, Charsets.ISO_8859_1 = newString(bytes, Charsets.getSort(), Charsets.ISO_8859_1);\n     }\n \n     /**\n      * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return new String(bytes, Charsets.ISO_8859_1); // TODO:8859_1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-17/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-19 02:34:08.737848204 +0200\n+++ /tmp/tmpzvkrqbra.java\t2022-07-19 02:34:08.737848204 +0200\n@@ -334,11 +334,11 @@\n      *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+return new String(bytes, Charsets.ISO_8859_1); // TODO:8859_1);\n     }\n \n     /**\n      * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n      *\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return new String(bytes, Charsets.ISO_8859_1 = newString(bytes, Charsets.length));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-17/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-19 02:34:13.817822832 +0200\n+++ /tmp/tmporl3gpbl.java\t2022-07-19 02:34:13.821822811 +0200\n@@ -334,11 +334,11 @@\n      *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+return new String(bytes, Charsets.ISO_8859_1 = newString(bytes, Charsets.length));\n     }\n \n     /**\n      * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return new String(bytes, Charsets.ISO_8859_1); // TODO_8859_1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-17/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-19 02:34:15.441814717 +0200\n+++ /tmp/tmp1pua7w49.java\t2022-07-19 02:34:15.441814717 +0200\n@@ -334,11 +334,11 @@\n      *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+return new String(bytes, Charsets.ISO_8859_1); // TODO_8859_1);\n     }\n \n     /**\n      * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n      *\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return new String(bytes, Charsets.ISO_8859_1);",
        "fixed_line": "return newString(bytes, Charsets.ISO_8859_1);"
    },
    "Collections-27": {
        "fixes": [
            {
                "k": 1,
                "patch": "class: \" + clazz, ex); } catch (final Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } }",
                "patch_diff": "class: \" + clazz, ex); } catch (final Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "class: \" + clazz, ex); } else { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } }",
                "patch_diff": "class: \" + clazz, ex); } else { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "class: \" + clazz, ex); } catch (final Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } else { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } }",
                "patch_diff": "class: \" + clazz, ex); } catch (final Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } else { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "class: \" + clazz, ex); } catch (final Exception ex) { throw new IllegalArgumentException(\"Cannot instantiate class: \" + clazz, ex); } }",
                "patch_diff": "class: \" + clazz, ex); } catch (final Exception ex) { throw new IllegalArgumentException(\"Cannot instantiate class: \" + clazz, ex); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "class: \" + clazz, ex); } catch (final Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz); } }",
                "patch_diff": "class: \" + clazz, ex); } catch (final Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "class: \" + clazz, ex); }",
                "patch_diff": "class: \" + clazz, ex); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "class: \" + clazz, ex); } catch (final Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } else { throw new IllegalArgumentException(\"Cannot instantiate class: \" + clazz, ex); } }",
                "patch_diff": "class: \" + clazz, ex); } catch (final Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } else { throw new IllegalArgumentException(\"Cannot instantiate class: \" + clazz, ex); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "class: \" + clazz, ex); } catch (Exception e) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } }",
                "patch_diff": "class: \" + clazz, ex); } catch (Exception e) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "class: \" + clazz, ex); } }",
                "patch_diff": "class: \" + clazz, ex); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "class: \" + clazz, ex); } catch (final Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } else { throw new FunctorException(\"Cannot instantiate class: \" + clazz); } }",
                "patch_diff": "class: \" + clazz, ex); } catch (final Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } else { throw new FunctorException(\"Cannot instantiate class: \" + clazz); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "private void readObject(ObjectInputStream is) throws IOException, ClassNotFoundException { is.defaultReadObject(); // ensure that the de-serialized class is a Collection, COLLECTIONS-580 if (clazz != null && !Collection.class.isAssignableFrom(clazz)) { throw new UnsupportedOperationException(); } }"
    },
    "JxPath-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"'base '\" + p2 + \"'\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-5/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\t2022-07-19 02:34:22.913777356 +0200\n+++ /tmp/tmp18yw8fsx.java\t2022-07-19 02:34:22.941777217 +0200\n@@ -660,13 +660,11 @@\n         if (p1 != null && p1.equals(p2)) {\n             return 0;\n         }\n \n         if (depth1 == 1) {\n-            throw new JXPathException(\n-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n-                            + p1 + \"' and '\" + p2 + \"'\");\n+throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"'base '\" + p2 + \"'\");\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n             return r;\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 + \"'\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-5/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\t2022-07-19 02:34:27.801752895 +0200\n+++ /tmp/tmpeqill8ky.java\t2022-07-19 02:34:27.801752895 +0200\n@@ -660,13 +660,11 @@\n         if (p1 != null && p1.equals(p2)) {\n             return 0;\n         }\n \n         if (depth1 == 1) {\n-            throw new JXPathException(\n-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n-                            + p1 + \"' and '\" + p2 + \"'\");\n+throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 + \"'\");\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n             return r;\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"'Vars '\" + p2 + \"'\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-5/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\t2022-07-19 02:34:32.329730223 +0200\n+++ /tmp/tmpb8ubzkgo.java\t2022-07-19 02:34:32.329730223 +0200\n@@ -660,13 +660,11 @@\n         if (p1 != null && p1.equals(p2)) {\n             return 0;\n         }\n \n         if (depth1 == 1) {\n-            throw new JXPathException(\n-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n-                            + p1 + \"' and '\" + p2 + \"'\");\n+throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"'Vars '\" + p2 + \"'\");\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n             return r;\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p2 + \"' and '\" + p1 + \"'\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-5/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\t2022-07-19 02:34:36.617708738 +0200\n+++ /tmp/tmp6mvo9_5e.java\t2022-07-19 02:34:36.621708717 +0200\n@@ -660,13 +660,11 @@\n         if (p1 != null && p1.equals(p2)) {\n             return 0;\n         }\n \n         if (depth1 == 1) {\n-            throw new JXPathException(\n-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n-                            + p1 + \"' and '\" + p2 + \"'\");\n+throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p2 + \"' and '\" + p1 + \"'\");\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n             return r;\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' a '\" + p2 + \"'\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-5/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\t2022-07-19 02:34:40.777687883 +0200\n+++ /tmp/tmpm_yclkbb.java\t2022-07-19 02:34:40.781687864 +0200\n@@ -660,13 +660,11 @@\n         if (p1 != null && p1.equals(p2)) {\n             return 0;\n         }\n \n         if (depth1 == 1) {\n-            throw new JXPathException(\n-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n-                            + p1 + \"' and '\" + p2 + \"'\");\n+throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' a '\" + p2 + \"'\");\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n             return r;\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p2 + \"'base '\" + p1 + \"'\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-5/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\t2022-07-19 02:34:45.105666174 +0200\n+++ /tmp/tmpu0zjohwg.java\t2022-07-19 02:34:45.105666174 +0200\n@@ -660,13 +660,11 @@\n         if (p1 != null && p1.equals(p2)) {\n             return 0;\n         }\n \n         if (depth1 == 1) {\n-            throw new JXPathException(\n-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n-                            + p1 + \"' and '\" + p2 + \"'\");\n+throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p2 + \"'base '\" + p1 + \"'\");\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n             return r;\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"'dec '\" + p2 + \"'\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-5/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\t2022-07-19 02:34:49.353644856 +0200\n+++ /tmp/tmpnpza4r28.java\t2022-07-19 02:34:49.357644835 +0200\n@@ -660,13 +660,11 @@\n         if (p1 != null && p1.equals(p2)) {\n             return 0;\n         }\n \n         if (depth1 == 1) {\n-            throw new JXPathException(\n-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n-                            + p1 + \"' and '\" + p2 + \"'\");\n+throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"'dec '\" + p2 + \"'\");\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n             return r;\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"'base '\" + p1 + \"'\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-5/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\t2022-07-19 02:34:53.705623001 +0200\n+++ /tmp/tmpib6c0rr6.java\t2022-07-19 02:34:53.705623001 +0200\n@@ -660,13 +660,11 @@\n         if (p1 != null && p1.equals(p2)) {\n             return 0;\n         }\n \n         if (depth1 == 1) {\n-            throw new JXPathException(\n-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n-                            + p1 + \"' and '\" + p2 + \"'\");\n+throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"'base '\" + p1 + \"'\");\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n             return r;\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p1 + \"'\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-5/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\t2022-07-19 02:34:57.957601638 +0200\n+++ /tmp/tmp709dl08t.java\t2022-07-19 02:34:57.961601619 +0200\n@@ -660,13 +660,11 @@\n         if (p1 != null && p1.equals(p2)) {\n             return 0;\n         }\n \n         if (depth1 == 1) {\n-            throw new JXPathException(\n-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n-                            + p1 + \"' and '\" + p2 + \"'\");\n+throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p1 + \"'\");\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n             return r;\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p2 + \"' and '\" + p2 + \"'\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-5/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\t2022-07-19 02:35:02.121580707 +0200\n+++ /tmp/tmptdsdrm6x.java\t2022-07-19 02:35:02.121580707 +0200\n@@ -660,13 +660,11 @@\n         if (p1 != null && p1.equals(p2)) {\n             return 0;\n         }\n \n         if (depth1 == 1) {\n-            throw new JXPathException(\n-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n-                            + p1 + \"' and '\" + p2 + \"'\");\n+throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p2 + \"' and '\" + p2 + \"'\");\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n             return r;\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 + \"'\");",
        "fixed_line": "return 0;"
    },
    "Math-56": {
        "fixes": [
            {
                "k": 1,
                "patch": "int idx = 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-56/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\t2022-07-19 02:35:06.529558537 +0200\n+++ /tmp/tmpot3hk443.java\t2022-07-19 02:35:06.549558436 +0200\n@@ -232,17 +232,11 @@\n             --idx;\n             count -= offset;\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n-        indices[last] = idx;\n+int idx = 0;\n \n         return indices;\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int idx = 0;count < index; ++idx; ++idx; } --idx; indices[last] = idx;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-56/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\t2022-07-19 02:35:53.629320907 +0200\n+++ /tmp/tmpeqr83o0n.java\t2022-07-19 02:35:53.633320885 +0200\n@@ -232,17 +232,11 @@\n             --idx;\n             count -= offset;\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n-        indices[last] = idx;\n+int idx = 0;count < index; ++idx; ++idx; } --idx; indices[last] = idx;\n \n         return indices;\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int idx = 0;count < index; ++idx; ++idx; indices[last] = idx;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-56/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\t2022-07-19 02:35:55.821309816 +0200\n+++ /tmp/tmpcs8nqb49.java\t2022-07-19 02:35:55.821309816 +0200\n@@ -232,17 +232,11 @@\n             --idx;\n             count -= offset;\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n-        indices[last] = idx;\n+int idx = 0;count < index; ++idx; ++idx; indices[last] = idx;\n \n         return indices;\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int idx = index < 0) { count += 1; } --idx; indices[last] = idx;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-56/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\t2022-07-19 02:35:57.913299229 +0200\n+++ /tmp/tmps71wm30g.java\t2022-07-19 02:35:57.913299229 +0200\n@@ -232,17 +232,11 @@\n             --idx;\n             count -= offset;\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n-        indices[last] = idx;\n+int idx = index < 0) { count += 1; } --idx; indices[last] = idx;\n \n         return indices;\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int idx = index < count; ++idx; ++idx; } --idx; indices[last] = idx;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-56/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\t2022-07-19 02:35:59.921289062 +0200\n+++ /tmp/tmp4szeusk7.java\t2022-07-19 02:35:59.921289062 +0200\n@@ -232,17 +232,11 @@\n             --idx;\n             count -= offset;\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n-        indices[last] = idx;\n+int idx = index < count; ++idx; ++idx; } --idx; indices[last] = idx;\n \n         return indices;\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int idx = index < count; ++idx; ++idx; indices[last] = idx;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-56/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\t2022-07-19 02:36:01.901279038 +0200\n+++ /tmp/tmpjpydvba1.java\t2022-07-19 02:36:01.901279038 +0200\n@@ -232,17 +232,11 @@\n             --idx;\n             count -= offset;\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n-        indices[last] = idx;\n+int idx = index < count; ++idx; ++idx; indices[last] = idx;\n \n         return indices;\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int idx = idx < 0) { count += 1; } --idx; indices[last] = idx;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-56/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\t2022-07-19 02:36:04.017268322 +0200\n+++ /tmp/tmpu8ma2_0w.java\t2022-07-19 02:36:04.017268322 +0200\n@@ -232,17 +232,11 @@\n             --idx;\n             count -= offset;\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n-        indices[last] = idx;\n+int idx = idx < 0) { count += 1; } --idx; indices[last] = idx;\n \n         return indices;\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int idx = index < 0) {count += 1; } --idx; indices[last] = idx;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-56/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\t2022-07-19 02:36:06.061257969 +0200\n+++ /tmp/tmp8dor4nh_.java\t2022-07-19 02:36:06.061257969 +0200\n@@ -232,17 +232,11 @@\n             --idx;\n             count -= offset;\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n-        indices[last] = idx;\n+int idx = index < 0) {count += 1; } --idx; indices[last] = idx;\n \n         return indices;\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int idx = index < count; ++idx; ++idx = --idx; indices[last] = idx;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-56/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\t2022-07-19 02:36:08.241246923 +0200\n+++ /tmp/tmpbql97f6r.java\t2022-07-19 02:36:08.241246923 +0200\n@@ -232,17 +232,11 @@\n             --idx;\n             count -= offset;\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n-        indices[last] = idx;\n+int idx = index < count; ++idx; ++idx = --idx; indices[last] = idx;\n \n         return indices;\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int idx = idx.size < 0; ++idx; ++idx; indices[last] = idx;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-56/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\t2022-07-19 02:36:10.341236281 +0200\n+++ /tmp/tmp_fpddidc.java\t2022-07-19 02:36:10.341236281 +0200\n@@ -232,17 +232,11 @@\n             --idx;\n             count -= offset;\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n-        indices[last] = idx;\n+int idx = idx.size < 0; ++idx; ++idx; indices[last] = idx;\n \n         return indices;\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "int idx = 1; while (count < index) { count += idx; ++idx; } --idx; indices[last] = idx;",
        "fixed_line": "indices[last] = index - count;"
    },
    "Cli-32": {
        "fixes": [
            {
                "k": 1,
                "patch": "while ((pos <= text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { ++pos; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-32/src/main/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 02:36:12.941223102 +0200\n+++ /tmp/tmpo9q0u12h.java\t2022-07-19 02:36:13.009222758 +0200\n@@ -932,15 +932,11 @@\n             return pos;\n         }\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n-        {\n-            ++pos;\n-        }        \n+while ((pos <= text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { ++pos; }\n         return pos == text.length() ? -1 : pos;\n     }\n \n     /**\n      * Return a String of padding of length <code>len</code>.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "while (pos < text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { ++pos; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-32/src/main/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 02:36:14.645214463 +0200\n+++ /tmp/tmp2txoigg1.java\t2022-07-19 02:36:14.649214441 +0200\n@@ -932,15 +932,11 @@\n             return pos;\n         }\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n-        {\n-            ++pos;\n-        }        \n+while (pos < text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { ++pos; }\n         return pos == text.length() ? -1 : pos;\n     }\n \n     /**\n      * Return a String of padding of length <code>len</code>.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "while (pos <= text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { ++pos; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-32/src/main/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 02:36:16.101207079 +0200\n+++ /tmp/tmp8ulf6w0z.java\t2022-07-19 02:36:16.105207058 +0200\n@@ -932,15 +932,11 @@\n             return pos;\n         }\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n-        {\n-            ++pos;\n-        }        \n+while (pos <= text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { ++pos; }\n         return pos == text.length() ? -1 : pos;\n     }\n \n     /**\n      * Return a String of padding of length <code>len</code>.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "while ((pos < text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { ++pos; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-32/src/main/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 02:36:17.645199248 +0200\n+++ /tmp/tmplynsu4q3.java\t2022-07-19 02:36:17.645199248 +0200\n@@ -932,15 +932,11 @@\n             return pos;\n         }\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n-        {\n-            ++pos;\n-        }        \n+while ((pos < text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { ++pos; }\n         return pos == text.length() ? -1 : pos;\n     }\n \n     /**\n      * Return a String of padding of length <code>len</code>.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "while ((pos <= text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-32/src/main/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 02:36:19.333190683 +0200\n+++ /tmp/tmpq9hgx8ak.java\t2022-07-19 02:36:19.333190683 +0200\n@@ -932,15 +932,11 @@\n             return pos;\n         }\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n-        {\n-            ++pos;\n-        }        \n+while ((pos <= text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) {\n         return pos == text.length() ? -1 : pos;\n     }\n \n     /**\n      * Return a String of padding of length <code>len</code>.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "while (pos < text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-32/src/main/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 02:36:21.009182180 +0200\n+++ /tmp/tmpe_ib888r.java\t2022-07-19 02:36:21.009182180 +0200\n@@ -932,15 +932,11 @@\n             return pos;\n         }\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n-        {\n-            ++pos;\n-        }        \n+while (pos < text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) {\n         return pos == text.length() ? -1 : pos;\n     }\n \n     /**\n      * Return a String of padding of length <code>len</code>.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "while (pos <= text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-32/src/main/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 02:36:22.505174589 +0200\n+++ /tmp/tmpeoqwl8o2.java\t2022-07-19 02:36:22.509174568 +0200\n@@ -932,15 +932,11 @@\n             return pos;\n         }\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n-        {\n-            ++pos;\n-        }        \n+while (pos <= text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) {\n         return pos == text.length() ? -1 : pos;\n     }\n \n     /**\n      * Return a String of padding of length <code>len</code>.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "while ((pos <= text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') || (c!= '\\r')) { ++pos; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-32/src/main/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 02:36:24.061166693 +0200\n+++ /tmp/tmp52ydw5pu.java\t2022-07-19 02:36:24.065166672 +0200\n@@ -932,15 +932,11 @@\n             return pos;\n         }\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n-        {\n-            ++pos;\n-        }        \n+while ((pos <= text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') || (c!= '\\r')) { ++pos; }\n         return pos == text.length() ? -1 : pos;\n     }\n \n     /**\n      * Return a String of padding of length <code>len</code>.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "while (pos < text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') || (c!= '\\r')) { ++pos; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-32/src/main/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 02:36:25.657158589 +0200\n+++ /tmp/tmpe8hx9diq.java\t2022-07-19 02:36:25.657158589 +0200\n@@ -932,15 +932,11 @@\n             return pos;\n         }\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n-        {\n-            ++pos;\n-        }        \n+while (pos < text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') || (c!= '\\r')) { ++pos; }\n         return pos == text.length() ? -1 : pos;\n     }\n \n     /**\n      * Return a String of padding of length <code>len</code>.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "while (pos <= text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') || (c!= '\\r')) { ++pos; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-32/src/main/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 02:36:27.241150549 +0200\n+++ /tmp/tmp_2_fboxv.java\t2022-07-19 02:36:27.241150549 +0200\n@@ -932,15 +932,11 @@\n             return pos;\n         }\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n-        {\n-            ++pos;\n-        }        \n+while (pos <= text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') || (c!= '\\r')) { ++pos; }\n         return pos == text.length() ? -1 : pos;\n     }\n \n     /**\n      * Return a String of padding of length <code>len</code>.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ') && (c != '\\n') && (c != '\\r')) { ++pos; }",
        "fixed_line": ""
    },
    "Math-42": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (basicRows.contains(basicRow)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-42/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 02:36:28.905142099 +0200\n+++ /tmp/tmpj_snnewu.java\t2022-07-19 02:36:28.925141997 +0200\n@@ -408,11 +408,11 @@\n           }\n           Integer basicRow = getBasicRow(colIndex);\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n+if (basicRows.contains(basicRow)) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (basicRows.contains(coefficients)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-42/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 02:36:47.825045919 +0200\n+++ /tmp/tmpf81fjxky.java\t2022-07-19 02:36:47.825045919 +0200\n@@ -408,11 +408,11 @@\n           }\n           Integer basicRow = getBasicRow(colIndex);\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n+if (basicRows.contains(coefficients)) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (coefficients.contains(basicRow)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-42/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 02:37:05.304956899 +0200\n+++ /tmp/tmp2pe7dn9j.java\t2022-07-19 02:37:05.304956899 +0200\n@@ -408,11 +408,11 @@\n           }\n           Integer basicRow = getBasicRow(colIndex);\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n+if (coefficients.contains(basicRow)) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (basicRows.contains(coRow)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-42/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 02:37:07.520945602 +0200\n+++ /tmp/tmpsuq9ye2e.java\t2022-07-19 02:37:07.520945602 +0200\n@@ -408,11 +408,11 @@\n           }\n           Integer basicRow = getBasicRow(colIndex);\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n+if (basicRows.contains(coRow)) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (basicRows.contains(cocoefficients)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-42/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 02:37:09.660934692 +0200\n+++ /tmp/tmpu2k7oaad.java\t2022-07-19 02:37:09.664934670 +0200\n@@ -408,11 +408,11 @@\n           }\n           Integer basicRow = getBasicRow(colIndex);\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n+if (basicRows.contains(cocoefficients)) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (basicRows.contains(ANTRow)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-42/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 02:37:11.832923613 +0200\n+++ /tmp/tmpend2san7.java\t2022-07-19 02:37:11.832923613 +0200\n@@ -408,11 +408,11 @@\n           }\n           Integer basicRow = getBasicRow(colIndex);\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n+if (basicRows.contains(ANTRow)) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (basicRows.contains(coefficients) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-42/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 02:37:14.012912495 +0200\n+++ /tmp/tmpxaslnash.java\t2022-07-19 02:37:14.012912495 +0200\n@@ -408,11 +408,11 @@\n           }\n           Integer basicRow = getBasicRow(colIndex);\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n+if (basicRows.contains(coefficients) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (basicRows.contains(ch)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-42/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 02:37:16.048902106 +0200\n+++ /tmp/tmpco5xyx20.java\t2022-07-19 02:37:16.048902106 +0200\n@@ -408,11 +408,11 @@\n           }\n           Integer basicRow = getBasicRow(colIndex);\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n+if (basicRows.contains(ch)) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (coed.contains(basicRow)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-42/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 02:37:18.212891063 +0200\n+++ /tmp/tmp3xakzbzc.java\t2022-07-19 02:37:18.212891063 +0200\n@@ -408,11 +408,11 @@\n           }\n           Integer basicRow = getBasicRow(colIndex);\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n+if (coed.contains(basicRow)) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (basicRows.contains(maxRow)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-42/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 02:37:20.372880040 +0200\n+++ /tmp/tmpdq_f75t3.java\t2022-07-19 02:37:20.372880040 +0200\n@@ -408,11 +408,11 @@\n           }\n           Integer basicRow = getBasicRow(colIndex);\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n+if (basicRows.contains(maxRow)) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (basicRows.contains(basicRow)) {",
        "fixed_line": "if (basicRow != null && basicRow == 0) { // if the basic row is found to be the objective function row // set the coefficient to 0 -> this case handles unconstrained // variables that are still part of the objective function coefficients[i] = 0; } else if (basicRows.contains(basicRow)) {"
    },
    "Lang-57": {
        "fixes": [
            {
                "k": 1,
                "patch": "return cAvailableLocaleSet.contains(locale);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-57/src/java/org/apache/commons/lang/LocaleUtils.java\t2022-07-19 02:37:22.752867890 +0200\n+++ /tmp/tmp2uiw0y1g.java\t2022-07-19 02:37:22.772867787 +0200\n@@ -218,11 +218,11 @@\n      *\n      * @param locale the Locale object to check if it is available\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+return cAvailableLocaleSet.contains(locale);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Obtains the list of languages supported for a given country.</p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return cAvailableLocaleSet.contains(locale); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-57/src/java/org/apache/commons/lang/LocaleUtils.java\t2022-07-19 02:37:32.188819693 +0200\n+++ /tmp/tmprj37di62.java\t2022-07-19 02:37:32.188819693 +0200\n@@ -218,11 +218,11 @@\n      *\n      * @param locale the Locale object to check if it is available\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+return cAvailableLocaleSet.contains(locale); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Obtains the list of languages supported for a given country.</p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return cAvailableLocaleSet.contains(locale); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-57/src/java/org/apache/commons/lang/LocaleUtils.java\t2022-07-19 02:37:41.712771001 +0200\n+++ /tmp/tmpbho0vske.java\t2022-07-19 02:37:41.712771001 +0200\n@@ -218,11 +218,11 @@\n      *\n      * @param locale the Locale object to check if it is available\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+return cAvailableLocaleSet.contains(locale); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Obtains the list of languages supported for a given country.</p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return cAvailableLocaleSet.contains(locale); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-57/src/java/org/apache/commons/lang/LocaleUtils.java\t2022-07-19 02:37:51.272722087 +0200\n+++ /tmp/tmp_mlpyd6e.java\t2022-07-19 02:37:51.272722087 +0200\n@@ -218,11 +218,11 @@\n      *\n      * @param locale the Locale object to check if it is available\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+return cAvailableLocaleSet.contains(locale); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Obtains the list of languages supported for a given country.</p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return cAvailableLocaleSet.contains(locale); // we didn't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-57/src/java/org/apache/commons/lang/LocaleUtils.java\t2022-07-19 02:38:00.704673786 +0200\n+++ /tmp/tmpr2qpvz1j.java\t2022-07-19 02:38:00.708673764 +0200\n@@ -218,11 +218,11 @@\n      *\n      * @param locale the Locale object to check if it is available\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+return cAvailableLocaleSet.contains(locale); // we didn't really modify it's totalGJACKSON-notnotnotnot real number\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Obtains the list of languages supported for a given country.</p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return cAvailableLocaleSet.contains(locale); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-57/src/java/org/apache/commons/lang/LocaleUtils.java\t2022-07-19 02:38:10.216625035 +0200\n+++ /tmp/tmphzrtt2tx.java\t2022-07-19 02:38:10.216625035 +0200\n@@ -218,11 +218,11 @@\n      *\n      * @param locale the Locale object to check if it is available\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+return cAvailableLocaleSet.contains(locale); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Obtains the list of languages supported for a given country.</p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return cAvailableLocaleSet.contains(locale); // we didn't really modify it's totalGJACKSON-notnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-57/src/java/org/apache/commons/lang/LocaleUtils.java\t2022-07-19 02:38:19.796575896 +0200\n+++ /tmp/tmpb5e15gb1.java\t2022-07-19 02:38:19.800575875 +0200\n@@ -218,11 +218,11 @@\n      *\n      * @param locale the Locale object to check if it is available\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+return cAvailableLocaleSet.contains(locale); // we didn't really modify it's totalGJACKSON-notnotnot real number\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Obtains the list of languages supported for a given country.</p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return cAvailableLocaleSet.contains(locale); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-57/src/java/org/apache/commons/lang/LocaleUtils.java\t2022-07-19 02:38:29.452526327 +0200\n+++ /tmp/tmpym1w5b_l.java\t2022-07-19 02:38:29.452526327 +0200\n@@ -218,11 +218,11 @@\n      *\n      * @param locale the Locale object to check if it is available\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+return cAvailableLocaleSet.contains(locale); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Obtains the list of languages supported for a given country.</p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return cAvailableLocaleSet.contains(locale); // we didn't really modify it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-57/src/java/org/apache/commons/lang/LocaleUtils.java\t2022-07-19 02:38:38.772478446 +0200\n+++ /tmp/tmpepptacrb.java\t2022-07-19 02:38:38.772478446 +0200\n@@ -218,11 +218,11 @@\n      *\n      * @param locale the Locale object to check if it is available\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+return cAvailableLocaleSet.contains(locale); // we didn't really modify it's do implicit re-parse\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Obtains the list of languages supported for a given country.</p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return cAvailableLocaleSet.contains(locale); // object (locale)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-57/src/java/org/apache/commons/lang/LocaleUtils.java\t2022-07-19 02:38:48.276429583 +0200\n+++ /tmp/tmpfox5dxgv.java\t2022-07-19 02:38:48.276429583 +0200\n@@ -218,11 +218,11 @@\n      *\n      * @param locale the Locale object to check if it is available\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+return cAvailableLocaleSet.contains(locale); // object (locale)\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Obtains the list of languages supported for a given country.</p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return cAvailableLocaleSet.contains(locale);",
        "fixed_line": "return availableLocaleList().contains(locale);"
    },
    "JacksonDatabind-1": {
        "fixes": [
            {
                "k": 1,
                "patch": "_nullSerializer<Object> ser = _nullSerializer.serialize(null, jgen, prov); } else if (ser == null) { // can NOT suppress entries in tabular output",
                "patch_diff": "_nullSerializer<Object> ser = _nullSerializer.serialize(null, jgen, prov); } else if (ser == null) { // can NOT suppress entries in tabular output",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// can NOT suppress entries in tabular output jgen.writeNull(); // can NOT suppress entries in tabular output",
                "patch_diff": "// can NOT suppress entries in tabular output jgen.writeNull(); // can NOT suppress entries in tabular output",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "_nullSerializer<Object> ser = _nullSerializer.writeNull(); // can NOT suppress entries in tabular output",
                "patch_diff": "_nullSerializer<Object> ser = _nullSerializer.writeNull(); // can NOT suppress entries in tabular output",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "_nullSerializer<Object> ser = _nullSerializer.write(null, jgen, prov); } else if (ser == null) { // can NOT suppress entries in tabular output",
                "patch_diff": "_nullSerializer<Object> ser = _nullSerializer.write(null, jgen, prov); } else if (ser == null) { // can NOT suppress entries in tabular output",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// can NOT suppress entries in tabular output jgen.writeNull(); } else if (ser == null) { // can NOT suppress entries in tabular output",
                "patch_diff": "// can NOT suppress entries in tabular output jgen.writeNull(); } else if (ser == null) { // can NOT suppress entries in tabular output",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "_nullSerializer<Object> ser = _nullSerializer.writeNull(); } else if (ser == null) { // can NOT suppress entries in tabular output",
                "patch_diff": "_nullSerializer<Object> ser = _nullSerializer.writeNull(); } else if (ser == null) { // can NOT suppress entries in tabular output",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "_nullSerializer<Object> ser = _nullSerializer.serialize(null, jgen, provider); } else if (ser == null) { // can NOT suppress entries in tabular output",
                "patch_diff": "_nullSerializer<Object> ser = _nullSerializer.serialize(null, jgen, provider); } else if (ser == null) { // can NOT suppress entries in tabular output",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// can NOT suppress entries in tabular output",
                "patch_diff": "// can NOT suppress entries in tabular output",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "_nullSerializer<Object> ser = _nullSerializer.serialize(null, jgen, prov); } else if (ser == null) {",
                "patch_diff": "_nullSerializer<Object> ser = _nullSerializer.serialize(null, jgen, prov); } else if (ser == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "_nullSerializer<Object> ser = _nullSerializer.serialize(null, jgen, prov);",
                "patch_diff": "_nullSerializer<Object> ser = _nullSerializer.serialize(null, jgen, prov);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "return;"
    },
    "Lang-18": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen); } else { rule = TwoDigitYearField.INSTANCE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-18/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 02:38:59.996369276 +0200\n+++ /tmp/tmpf5zr2cjg.java\t2022-07-19 02:39:00.080368842 +0200\n@@ -490,14 +490,11 @@\n             switch (c) {\n             case 'G': // era designator (text)\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n+if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen); } else { rule = TwoDigitYearField.INSTANCE;\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 if (tokenLen >= 4) {\n                     rule = new TextField(Calendar.MONTH, months);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (tokenLen == 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen); } else { rule = TwoDigitYearField.INSTANCE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-18/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 02:39:10.736313964 +0200\n+++ /tmp/tmpe9v_p7q0.java\t2022-07-19 02:39:10.740313942 +0200\n@@ -490,14 +490,11 @@\n             switch (c) {\n             case 'G': // era designator (text)\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n+if (tokenLen == 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen); } else { rule = TwoDigitYearField.INSTANCE;\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 if (tokenLen >= 4) {\n                     rule = new TextField(Calendar.MONTH, months);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen); } else {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-18/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 02:39:20.572263269 +0200\n+++ /tmp/tmpmz8z7bix.java\t2022-07-19 02:39:20.572263269 +0200\n@@ -490,14 +490,11 @@\n             switch (c) {\n             case 'G': // era designator (text)\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n+if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen); } else {\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 if (tokenLen >= 4) {\n                     rule = new TextField(Calendar.MONTH, months);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (tokenLen == 2) { rule = selectNumberRule(Calendar.YEAR, tokenLen); } else { rule = TwoDigitYearField.INSTANCE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-18/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 02:39:22.304254339 +0200\n+++ /tmp/tmpo8xes9x5.java\t2022-07-19 02:39:22.304254339 +0200\n@@ -490,14 +490,11 @@\n             switch (c) {\n             case 'G': // era designator (text)\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n+if (tokenLen == 2) { rule = selectNumberRule(Calendar.YEAR, tokenLen); } else { rule = TwoDigitYearField.INSTANCE;\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 if (tokenLen >= 4) {\n                     rule = new TextField(Calendar.MONTH, months);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen); } else if (tokenLen == 2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-18/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 02:39:32.148203558 +0200\n+++ /tmp/tmpjgnca9lc.java\t2022-07-19 02:39:32.148203558 +0200\n@@ -490,14 +490,11 @@\n             switch (c) {\n             case 'G': // era designator (text)\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n+if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen); } else if (tokenLen == 2) {\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 if (tokenLen >= 4) {\n                     rule = new TextField(Calendar.MONTH, months);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen); } else { int tokenLen = TwoDigitYearField.INSTANCE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-18/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 02:39:33.872194662 +0200\n+++ /tmp/tmpbmpronok.java\t2022-07-19 02:39:33.872194662 +0200\n@@ -490,14 +490,11 @@\n             switch (c) {\n             case 'G': // era designator (text)\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n+if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen); } else { int tokenLen = TwoDigitYearField.INSTANCE;\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 if (tokenLen >= 4) {\n                     rule = new TextField(Calendar.MONTH, months);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (tokenLen > 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen); } else { rule = TwoDigitYearField.INSTANCE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-18/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 02:39:35.516186176 +0200\n+++ /tmp/tmp0nmf7p6u.java\t2022-07-19 02:39:35.520186157 +0200\n@@ -490,14 +490,11 @@\n             switch (c) {\n             case 'G': // era designator (text)\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n+if (tokenLen > 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen); } else { rule = TwoDigitYearField.INSTANCE;\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 if (tokenLen >= 4) {\n                     rule = new TextField(Calendar.MONTH, months);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (tokenLen!= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen); } else { rule = TwoDigitYearField.INSTANCE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-18/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 02:39:45.392135184 +0200\n+++ /tmp/tmpdltb0qjl.java\t2022-07-19 02:39:45.396135163 +0200\n@@ -490,14 +490,11 @@\n             switch (c) {\n             case 'G': // era designator (text)\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n+if (tokenLen!= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen); } else { rule = TwoDigitYearField.INSTANCE;\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 if (tokenLen >= 4) {\n                     rule = new TextField(Calendar.MONTH, months);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen); } else if (tokenLen = TwoDigitYearField.INSTANCE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-18/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 02:39:55.228084362 +0200\n+++ /tmp/tmpxrrporuh.java\t2022-07-19 02:39:55.228084362 +0200\n@@ -490,14 +490,11 @@\n             switch (c) {\n             case 'G': // era designator (text)\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n+if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen); } else if (tokenLen = TwoDigitYearField.INSTANCE;\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 if (tokenLen >= 4) {\n                     rule = new TextField(Calendar.MONTH, months);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (tokenLen == 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen); } else {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-18/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-19 02:39:56.760076442 +0200\n+++ /tmp/tmpe3h_kizu.java\t2022-07-19 02:39:56.764076424 +0200\n@@ -490,14 +490,11 @@\n             switch (c) {\n             case 'G': // era designator (text)\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n+if (tokenLen == 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen); } else {\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 if (tokenLen >= 4) {\n                     rule = new TextField(Calendar.MONTH, months);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen); } else { rule = TwoDigitYearField.INSTANCE;",
        "fixed_line": "if (tokenLen == 2) { rule = TwoDigitYearField.INSTANCE; } else { rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);"
    },
    "Jsoup-1": {
        "fixes": [
            {
                "k": 1,
                "patch": "body().appendChild(new TextNode(\" \", \"\")); body().appendChild(node);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-1/src/main/java/org/jsoup/nodes/Document.java\t2022-07-19 02:39:58.640066725 +0200\n+++ /tmp/tmpu81r2vb1.java\t2022-07-19 02:39:58.676066535 +0200\n@@ -120,12 +120,11 @@\n             }\n         }\n \n         for (Node node: toMove) {\n             element.removeChild(node);\n-            body().appendChild(new TextNode(\" \", \"\"));\n-            body().appendChild(node);\n+body().appendChild(new TextNode(\" \", \"\")); body().appendChild(node);\n         }\n     }\n \n     @Override\n     public String outerHtml() {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "body().appendChild(new TextNode(\" \", \" + body().appendChild(node);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-1/src/main/java/org/jsoup/nodes/Document.java\t2022-07-19 02:40:01.512051876 +0200\n+++ /tmp/tmp_elb9c_v.java\t2022-07-19 02:40:01.512051876 +0200\n@@ -120,12 +120,11 @@\n             }\n         }\n \n         for (Node node: toMove) {\n             element.removeChild(node);\n-            body().appendChild(new TextNode(\" \", \"\"));\n-            body().appendChild(node);\n+body().appendChild(new TextNode(\" \", \" + body().appendChild(node);\n         }\n     }\n \n     @Override\n     public String outerHtml() {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "body().appendChild(new TextNode(\" \", \"); body().appendChild(node);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-1/src/main/java/org/jsoup/nodes/Document.java\t2022-07-19 02:40:02.988044244 +0200\n+++ /tmp/tmpczmcu1v7.java\t2022-07-19 02:40:02.988044244 +0200\n@@ -120,12 +120,11 @@\n             }\n         }\n \n         for (Node node: toMove) {\n             element.removeChild(node);\n-            body().appendChild(new TextNode(\" \", \"\"));\n-            body().appendChild(node);\n+body().appendChild(new TextNode(\" \", \"); body().appendChild(node);\n         }\n     }\n \n     @Override\n     public String outerHtml() {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "body().appendChild(new TextNode(\" \", \"\")); body().appendChild(node));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-1/src/main/java/org/jsoup/nodes/Document.java\t2022-07-19 02:40:04.516036341 +0200\n+++ /tmp/tmpbu1bgqft.java\t2022-07-19 02:40:04.516036341 +0200\n@@ -120,12 +120,11 @@\n             }\n         }\n \n         for (Node node: toMove) {\n             element.removeChild(node);\n-            body().appendChild(new TextNode(\" \", \"\"));\n-            body().appendChild(node);\n+body().appendChild(new TextNode(\" \", \"\")); body().appendChild(node));\n         }\n     }\n \n     @Override\n     public String outerHtml() {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "body().appendChild(new TextNode(\" \", \"] body().appendChild(node);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-1/src/main/java/org/jsoup/nodes/Document.java\t2022-07-19 02:40:05.976028790 +0200\n+++ /tmp/tmpma5xqbcy.java\t2022-07-19 02:40:05.976028790 +0200\n@@ -120,12 +120,11 @@\n             }\n         }\n \n         for (Node node: toMove) {\n             element.removeChild(node);\n-            body().appendChild(new TextNode(\" \", \"\"));\n-            body().appendChild(node);\n+body().appendChild(new TextNode(\" \", \"] body().appendChild(node);\n         }\n     }\n \n     @Override\n     public String outerHtml() {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "body().appendChild(new TextNode(\" \", \"\")); body().appendChild(node = node);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-1/src/main/java/org/jsoup/nodes/Document.java\t2022-07-19 02:40:07.604020369 +0200\n+++ /tmp/tmphh9k923n.java\t2022-07-19 02:40:07.604020369 +0200\n@@ -120,12 +120,11 @@\n             }\n         }\n \n         for (Node node: toMove) {\n             element.removeChild(node);\n-            body().appendChild(new TextNode(\" \", \"\"));\n-            body().appendChild(node);\n+body().appendChild(new TextNode(\" \", \"\")); body().appendChild(node = node);\n         }\n     }\n \n     @Override\n     public String outerHtml() {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "body().appendChild(new TextNode(\" must \"\")); body().appendChild(node);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-1/src/main/java/org/jsoup/nodes/Document.java\t2022-07-19 02:40:10.068007621 +0200\n+++ /tmp/tmpt7mb2hmt.java\t2022-07-19 02:40:10.068007621 +0200\n@@ -120,12 +120,11 @@\n             }\n         }\n \n         for (Node node: toMove) {\n             element.removeChild(node);\n-            body().appendChild(new TextNode(\" \", \"\"));\n-            body().appendChild(node);\n+body().appendChild(new TextNode(\" must \"\")); body().appendChild(node);\n         }\n     }\n \n     @Override\n     public String outerHtml() {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "body().appendChild(new TextNode(\" \", \"\")); body().ify(node);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-1/src/main/java/org/jsoup/nodes/Document.java\t2022-07-19 02:40:11.639999488 +0200\n+++ /tmp/tmpwusxmavd.java\t2022-07-19 02:40:11.639999488 +0200\n@@ -120,12 +120,11 @@\n             }\n         }\n \n         for (Node node: toMove) {\n             element.removeChild(node);\n-            body().appendChild(new TextNode(\" \", \"\"));\n-            body().appendChild(node);\n+body().appendChild(new TextNode(\" \", \"\")); body().ify(node);\n         }\n     }\n \n     @Override\n     public String outerHtml() {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "body.appendChild(new TextNode(\" \", \"\")); body().appendChild(node);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-1/src/main/java/org/jsoup/nodes/Document.java\t2022-07-19 02:40:13.295990917 +0200\n+++ /tmp/tmpv29cy7w4.java\t2022-07-19 02:40:13.295990917 +0200\n@@ -120,12 +120,11 @@\n             }\n         }\n \n         for (Node node: toMove) {\n             element.removeChild(node);\n-            body().appendChild(new TextNode(\" \", \"\"));\n-            body().appendChild(node);\n+body.appendChild(new TextNode(\" \", \"\")); body().appendChild(node);\n         }\n     }\n \n     @Override\n     public String outerHtml() {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "body().appendChild(new TextNode(\"(\", \"\")); body().appendChild(node);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-1/src/main/java/org/jsoup/nodes/Document.java\t2022-07-19 02:40:14.971982245 +0200\n+++ /tmp/tmpdte6yktx.java\t2022-07-19 02:40:14.971982245 +0200\n@@ -120,12 +120,11 @@\n             }\n         }\n \n         for (Node node: toMove) {\n             element.removeChild(node);\n-            body().appendChild(new TextNode(\" \", \"\"));\n-            body().appendChild(node);\n+body().appendChild(new TextNode(\"(\", \"\")); body().appendChild(node);\n         }\n     }\n \n     @Override\n     public String outerHtml() {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "body().appendChild(new TextNode(\" \", \"\")); body().appendChild(node);",
        "fixed_line": "body().prependChild(node); body().prependChild(new TextNode(\" \", \"\"));"
    },
    "Closure-18": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (options.dependencyOptions.needsManagement() && options.closurePass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-18/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 02:40:17.839967404 +0200\n+++ /tmp/tmpg730f33v.java\t2022-07-19 02:40:17.871967234 +0200\n@@ -1283,11 +1283,11 @@\n \n       hoistExterns(externsRoot);\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+if (options.dependencyOptions.needsManagement() && options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n             getTypeRegistry().forwardDeclareType(provide);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (options.dependencyOptions.needsManagement() || options.closurePass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-18/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 02:41:01.007743631 +0200\n+++ /tmp/tmpdfnimrpu.java\t2022-07-19 02:41:01.007743631 +0200\n@@ -1283,11 +1283,11 @@\n \n       hoistExterns(externsRoot);\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+if (options.dependencyOptions.needsManagement() || options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n             getTypeRegistry().forwardDeclareType(provide);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 3,
                "patch": "if (options.dependencyOptions.needsManagement()) && options.closurePass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-18/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 02:41:41.031535643 +0200\n+++ /tmp/tmpjrghxl86.java\t2022-07-19 02:41:41.031535643 +0200\n@@ -1283,11 +1283,11 @@\n \n       hoistExterns(externsRoot);\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+if (options.dependencyOptions.needsManagement()) && options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n             getTypeRegistry().forwardDeclareType(provide);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (options.dependencyOptions.needs\ud788() && options.closurePass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-18/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 02:41:44.539517390 +0200\n+++ /tmp/tmpy7pc7ix_.java\t2022-07-19 02:41:44.543517368 +0200\n@@ -1283,11 +1283,11 @@\n \n       hoistExterns(externsRoot);\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+if (options.dependencyOptions.needs\ud788() && options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n             getTypeRegistry().forwardDeclareType(provide);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (options.dependencyOptions.needsNot() && options.closurePass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-18/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 02:41:48.175498469 +0200\n+++ /tmp/tmpo7f770nx.java\t2022-07-19 02:41:48.179498448 +0200\n@@ -1283,11 +1283,11 @@\n \n       hoistExterns(externsRoot);\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+if (options.dependencyOptions.needsNot() && options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n             getTypeRegistry().forwardDeclareType(provide);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (options.dependencyOptions.needsiform() && options.closurePass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-18/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 02:41:51.979478668 +0200\n+++ /tmp/tmpcuwqgcxb.java\t2022-07-19 02:41:51.979478668 +0200\n@@ -1283,11 +1283,11 @@\n \n       hoistExterns(externsRoot);\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+if (options.dependencyOptions.needsiform() && options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n             getTypeRegistry().forwardDeclareType(provide);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (options.dependencyOptions.needsRating() && options.closurePass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-18/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 02:41:55.819458676 +0200\n+++ /tmp/tmp_vu_shzq.java\t2022-07-19 02:41:55.819458676 +0200\n@@ -1283,11 +1283,11 @@\n \n       hoistExterns(externsRoot);\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+if (options.dependencyOptions.needsRating() && options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n             getTypeRegistry().forwardDeclareType(provide);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (options.dependencyOptions.needsManagement() < options.closurePass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-18/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 02:41:59.663438657 +0200\n+++ /tmp/tmp4x5a2b9q.java\t2022-07-19 02:41:59.663438657 +0200\n@@ -1283,11 +1283,11 @@\n \n       hoistExterns(externsRoot);\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+if (options.dependencyOptions.needsManagement() < options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n             getTypeRegistry().forwardDeclareType(provide);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (options.dependencyOptions.needsManagement() == null || options.closurePass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-18/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 02:42:03.719417533 +0200\n+++ /tmp/tmpd9iq1_ep.java\t2022-07-19 02:42:03.723417511 +0200\n@@ -1283,11 +1283,11 @@\n \n       hoistExterns(externsRoot);\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+if (options.dependencyOptions.needsManagement() == null || options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n             getTypeRegistry().forwardDeclareType(provide);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (options.dependencyOptions.needsManagement() == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-18/src/com/google/javascript/jscomp/Compiler.java\t2022-07-19 02:42:07.715396717 +0200\n+++ /tmp/tmpa1pbes0v.java\t2022-07-19 02:42:07.715396717 +0200\n@@ -1283,11 +1283,11 @@\n \n       hoistExterns(externsRoot);\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+if (options.dependencyOptions.needsManagement() == null) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n             getTypeRegistry().forwardDeclareType(provide);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (options.dependencyOptions.needsManagement() && options.closurePass) {",
        "fixed_line": "if (options.dependencyOptions.needsManagement()) {"
    },
    "Math-59": {
        "fixes": [
            {
                "k": 1,
                "patch": "return (a < b)? b : (Float.isNaN(a + b)? Float.NaN : b);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-59/src/main/java/org/apache/commons/math/util/FastMath.java\t2022-07-19 02:42:11.975374520 +0200\n+++ /tmp/tmp3lejvyz4.java\t2022-07-19 02:42:12.003374373 +0200\n@@ -3477,11 +3477,11 @@\n      * @param a first value\n      * @param b second value\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+return (a < b)? b : (Float.isNaN(a + b)? Float.NaN : b);\n     }\n \n     /** Compute the maximum of two values\n      * @param a first value\n      * @param b second value\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return (a == b)? b : (Float.isNaN(a + b)? Float.NaN : b);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-59/src/main/java/org/apache/commons/math/util/FastMath.java\t2022-07-19 02:42:54.719151529 +0200\n+++ /tmp/tmpgh5_4f44.java\t2022-07-19 02:42:54.723151508 +0200\n@@ -3477,11 +3477,11 @@\n      * @param a first value\n      * @param b second value\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+return (a == b)? b : (Float.isNaN(a + b)? Float.NaN : b);\n     }\n \n     /** Compute the maximum of two values\n      * @param a first value\n      * @param b second value\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return (a < b)? a : (Float.isNaN(a + b)? Float.NaN : b);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-59/src/main/java/org/apache/commons/math/util/FastMath.java\t2022-07-19 02:43:34.378944219 +0200\n+++ /tmp/tmpvce7p6pd.java\t2022-07-19 02:43:34.382944198 +0200\n@@ -3477,11 +3477,11 @@\n      * @param a first value\n      * @param b second value\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+return (a < b)? a : (Float.isNaN(a + b)? Float.NaN : b);\n     }\n \n     /** Compute the maximum of two values\n      * @param a first value\n      * @param b second value\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return (a < b)? b : (Float.isNaN(b + b)? Float.NaN : b);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-59/src/main/java/org/apache/commons/math/util/FastMath.java\t2022-07-19 02:44:13.742738095 +0200\n+++ /tmp/tmpy2ytkuwl.java\t2022-07-19 02:44:13.742738095 +0200\n@@ -3477,11 +3477,11 @@\n      * @param a first value\n      * @param b second value\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+return (a < b)? b : (Float.isNaN(b + b)? Float.NaN : b);\n     }\n \n     /** Compute the maximum of two values\n      * @param a first value\n      * @param b second value\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return (a!= b)? b : (Float.isNaN(a + b)? Float.NaN : b);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-59/src/main/java/org/apache/commons/math/util/FastMath.java\t2022-07-19 02:44:53.534529393 +0200\n+++ /tmp/tmpyv1pujco.java\t2022-07-19 02:44:53.538529372 +0200\n@@ -3477,11 +3477,11 @@\n      * @param a first value\n      * @param b second value\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+return (a!= b)? b : (Float.isNaN(a + b)? Float.NaN : b);\n     }\n \n     /** Compute the maximum of two values\n      * @param a first value\n      * @param b second value\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return (a <= b)? b : (Float.isNaN(a + b)? Float.NaN : b);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-59/src/main/java/org/apache/commons/math/util/FastMath.java\t2022-07-19 02:45:33.310320459 +0200\n+++ /tmp/tmpbp8jaksu.java\t2022-07-19 02:45:33.310320459 +0200\n@@ -3477,11 +3477,11 @@\n      * @param a first value\n      * @param b second value\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+return (a <= b)? b : (Float.isNaN(a + b)? Float.NaN : b);\n     }\n \n     /** Compute the maximum of two values\n      * @param a first value\n      * @param b second value\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return (a <= b)? a : (Float.isNaN(a + b)? Float.NaN : b);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-59/src/main/java/org/apache/commons/math/util/FastMath.java\t2022-07-19 02:46:12.674113409 +0200\n+++ /tmp/tmp19z8aa7s.java\t2022-07-19 02:46:12.678113388 +0200\n@@ -3477,11 +3477,11 @@\n      * @param a first value\n      * @param b second value\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+return (a <= b)? a : (Float.isNaN(a + b)? Float.NaN : b);\n     }\n \n     /** Compute the maximum of two values\n      * @param a first value\n      * @param b second value\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return (a == b)? a : (Float.isNaN(a + b)? Float.NaN : b);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-59/src/main/java/org/apache/commons/math/util/FastMath.java\t2022-07-19 02:46:52.037906093 +0200\n+++ /tmp/tmp6v376mn9.java\t2022-07-19 02:46:52.037906093 +0200\n@@ -3477,11 +3477,11 @@\n      * @param a first value\n      * @param b second value\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+return (a == b)? a : (Float.isNaN(a + b)? Float.NaN : b);\n     }\n \n     /** Compute the maximum of two values\n      * @param a first value\n      * @param b second value\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return (a < b)? a : (Float.isNaN(b + b)? Float.NaN : b);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-59/src/main/java/org/apache/commons/math/util/FastMath.java\t2022-07-19 02:47:31.621697373 +0200\n+++ /tmp/tmpivqrr0en.java\t2022-07-19 02:47:31.621697373 +0200\n@@ -3477,11 +3477,11 @@\n      * @param a first value\n      * @param b second value\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+return (a < b)? a : (Float.isNaN(b + b)? Float.NaN : b);\n     }\n \n     /** Compute the maximum of two values\n      * @param a first value\n      * @param b second value\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return (a == b)? b : (Float.isNaN(b + b)? Float.NaN : b);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-59/src/main/java/org/apache/commons/math/util/FastMath.java\t2022-07-19 02:48:11.329487769 +0200\n+++ /tmp/tmp3hrkhcj3.java\t2022-07-19 02:48:11.333487748 +0200\n@@ -3477,11 +3477,11 @@\n      * @param a first value\n      * @param b second value\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+return (a == b)? b : (Float.isNaN(b + b)? Float.NaN : b);\n     }\n \n     /** Compute the maximum of two values\n      * @param a first value\n      * @param b second value\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);",
        "fixed_line": "return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);"
    },
    "JacksonDatabind-85": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (format == JsonFormat.Shape.STRING) || format.hasPattern() { // could still be null",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-85/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 02:48:52.009272815 +0200\n+++ /tmp/tmpfnp7t0b9.java\t2022-07-19 02:48:52.101272330 +0200\n@@ -62,38 +62,11 @@\n             return withFormat(Boolean.TRUE, null);\n         }\n \n         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n         // First: custom pattern will override things\n-                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n-                                || format.hasLocale() || format.hasTimeZone()) {\n-                    TimeZone tz = format.getTimeZone();\n-                    final String pattern = format.hasPattern()\n-                                    ? format.getPattern()\n-                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n-            final Locale loc = format.hasLocale()\n-                            ? format.getLocale()\n-                            : serializers.getLocale();\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n-                    if (tz == null) {\n-                        tz = serializers.getTimeZone();\n-                    }\n-            df.setTimeZone(tz);\n-            return withFormat(Boolean.FALSE, df);\n-        }\n-\n-        // Otherwise, need one of these changes:\n-\n-\n-        // Jackson's own `StdDateFormat` is quite easy to deal with...\n-\n-        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-        //    So: require it be `SimpleDateFormat`; can't config other types\n-//            serializers.reportBadDefinition(handledType(), String.format(\n-            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        return this;\n+if (format == JsonFormat.Shape.STRING) || format.hasPattern() { // could still be null\n     }\n \n     /*\n     /**********************************************************\n     /* Accessors\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (format == JsonFormat.Shape.STRING) || format.hasPattern() {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-85/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 02:48:53.857263046 +0200\n+++ /tmp/tmpbi_5qy3c.java\t2022-07-19 02:48:53.857263046 +0200\n@@ -62,38 +62,11 @@\n             return withFormat(Boolean.TRUE, null);\n         }\n \n         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n         // First: custom pattern will override things\n-                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n-                                || format.hasLocale() || format.hasTimeZone()) {\n-                    TimeZone tz = format.getTimeZone();\n-                    final String pattern = format.hasPattern()\n-                                    ? format.getPattern()\n-                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n-            final Locale loc = format.hasLocale()\n-                            ? format.getLocale()\n-                            : serializers.getLocale();\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n-                    if (tz == null) {\n-                        tz = serializers.getTimeZone();\n-                    }\n-            df.setTimeZone(tz);\n-            return withFormat(Boolean.FALSE, df);\n-        }\n-\n-        // Otherwise, need one of these changes:\n-\n-\n-        // Jackson's own `StdDateFormat` is quite easy to deal with...\n-\n-        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-        //    So: require it be `SimpleDateFormat`; can't config other types\n-//            serializers.reportBadDefinition(handledType(), String.format(\n-            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        return this;\n+if (format == JsonFormat.Shape.STRING) || format.hasPattern() {\n     }\n \n     /*\n     /**********************************************************\n     /* Accessors\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (format == JsonFormat.Shape.STRING) || format.hasPattern()!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-85/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 02:48:55.473254501 +0200\n+++ /tmp/tmpb78jiq80.java\t2022-07-19 02:48:55.477254482 +0200\n@@ -62,38 +62,11 @@\n             return withFormat(Boolean.TRUE, null);\n         }\n \n         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n         // First: custom pattern will override things\n-                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n-                                || format.hasLocale() || format.hasTimeZone()) {\n-                    TimeZone tz = format.getTimeZone();\n-                    final String pattern = format.hasPattern()\n-                                    ? format.getPattern()\n-                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n-            final Locale loc = format.hasLocale()\n-                            ? format.getLocale()\n-                            : serializers.getLocale();\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n-                    if (tz == null) {\n-                        tz = serializers.getTimeZone();\n-                    }\n-            df.setTimeZone(tz);\n-            return withFormat(Boolean.FALSE, df);\n-        }\n-\n-        // Otherwise, need one of these changes:\n-\n-\n-        // Jackson's own `StdDateFormat` is quite easy to deal with...\n-\n-        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-        //    So: require it be `SimpleDateFormat`; can't config other types\n-//            serializers.reportBadDefinition(handledType(), String.format(\n-            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        return this;\n+if (format == JsonFormat.Shape.STRING) || format.hasPattern()!= null) {\n     }\n \n     /*\n     /**********************************************************\n     /* Accessors\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (format == JsonFormat.Shape.STRING) || format.hasPattern()!= null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-85/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 02:48:57.073246042 +0200\n+++ /tmp/tmpuldu2ecc.java\t2022-07-19 02:48:57.073246042 +0200\n@@ -62,38 +62,11 @@\n             return withFormat(Boolean.TRUE, null);\n         }\n \n         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n         // First: custom pattern will override things\n-                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n-                                || format.hasLocale() || format.hasTimeZone()) {\n-                    TimeZone tz = format.getTimeZone();\n-                    final String pattern = format.hasPattern()\n-                                    ? format.getPattern()\n-                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n-            final Locale loc = format.hasLocale()\n-                            ? format.getLocale()\n-                            : serializers.getLocale();\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n-                    if (tz == null) {\n-                        tz = serializers.getTimeZone();\n-                    }\n-            df.setTimeZone(tz);\n-            return withFormat(Boolean.FALSE, df);\n-        }\n-\n-        // Otherwise, need one of these changes:\n-\n-\n-        // Jackson's own `StdDateFormat` is quite easy to deal with...\n-\n-        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-        //    So: require it be `SimpleDateFormat`; can't config other types\n-//            serializers.reportBadDefinition(handledType(), String.format(\n-            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        return this;\n+if (format == JsonFormat.Shape.STRING) || format.hasPattern()!= null;\n     }\n \n     /*\n     /**********************************************************\n     /* Accessors\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (format == JsonFormat.Shape.STRING) || format.hasPattern() == JsonFormat.class;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-85/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 02:48:58.829236758 +0200\n+++ /tmp/tmphy_ik4aw.java\t2022-07-19 02:48:58.829236758 +0200\n@@ -62,38 +62,11 @@\n             return withFormat(Boolean.TRUE, null);\n         }\n \n         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n         // First: custom pattern will override things\n-                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n-                                || format.hasLocale() || format.hasTimeZone()) {\n-                    TimeZone tz = format.getTimeZone();\n-                    final String pattern = format.hasPattern()\n-                                    ? format.getPattern()\n-                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n-            final Locale loc = format.hasLocale()\n-                            ? format.getLocale()\n-                            : serializers.getLocale();\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n-                    if (tz == null) {\n-                        tz = serializers.getTimeZone();\n-                    }\n-            df.setTimeZone(tz);\n-            return withFormat(Boolean.FALSE, df);\n-        }\n-\n-        // Otherwise, need one of these changes:\n-\n-\n-        // Jackson's own `StdDateFormat` is quite easy to deal with...\n-\n-        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-        //    So: require it be `SimpleDateFormat`; can't config other types\n-//            serializers.reportBadDefinition(handledType(), String.format(\n-            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        return this;\n+if (format == JsonFormat.Shape.STRING) || format.hasPattern() == JsonFormat.class;\n     }\n \n     /*\n     /**********************************************************\n     /* Accessors\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (format == JsonFormat.Shape.STRING) { // could still be null",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-85/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 02:49:00.553227642 +0200\n+++ /tmp/tmpgniai3r5.java\t2022-07-19 02:49:00.553227642 +0200\n@@ -62,38 +62,11 @@\n             return withFormat(Boolean.TRUE, null);\n         }\n \n         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n         // First: custom pattern will override things\n-                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n-                                || format.hasLocale() || format.hasTimeZone()) {\n-                    TimeZone tz = format.getTimeZone();\n-                    final String pattern = format.hasPattern()\n-                                    ? format.getPattern()\n-                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n-            final Locale loc = format.hasLocale()\n-                            ? format.getLocale()\n-                            : serializers.getLocale();\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n-                    if (tz == null) {\n-                        tz = serializers.getTimeZone();\n-                    }\n-            df.setTimeZone(tz);\n-            return withFormat(Boolean.FALSE, df);\n-        }\n-\n-        // Otherwise, need one of these changes:\n-\n-\n-        // Jackson's own `StdDateFormat` is quite easy to deal with...\n-\n-        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-        //    So: require it be `SimpleDateFormat`; can't config other types\n-//            serializers.reportBadDefinition(handledType(), String.format(\n-            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        return this;\n+if (format == JsonFormat.Shape.STRING) { // could still be null\n     }\n \n     /*\n     /**********************************************************\n     /* Accessors\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (format == JsonFormat.Shape.STRING) || format.hasPattern() == null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-85/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 02:49:02.109219414 +0200\n+++ /tmp/tmpzswvila2.java\t2022-07-19 02:49:02.109219414 +0200\n@@ -62,38 +62,11 @@\n             return withFormat(Boolean.TRUE, null);\n         }\n \n         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n         // First: custom pattern will override things\n-                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n-                                || format.hasLocale() || format.hasTimeZone()) {\n-                    TimeZone tz = format.getTimeZone();\n-                    final String pattern = format.hasPattern()\n-                                    ? format.getPattern()\n-                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n-            final Locale loc = format.hasLocale()\n-                            ? format.getLocale()\n-                            : serializers.getLocale();\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n-                    if (tz == null) {\n-                        tz = serializers.getTimeZone();\n-                    }\n-            df.setTimeZone(tz);\n-            return withFormat(Boolean.FALSE, df);\n-        }\n-\n-        // Otherwise, need one of these changes:\n-\n-\n-        // Jackson's own `StdDateFormat` is quite easy to deal with...\n-\n-        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-        //    So: require it be `SimpleDateFormat`; can't config other types\n-//            serializers.reportBadDefinition(handledType(), String.format(\n-            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        return this;\n+if (format == JsonFormat.Shape.STRING) || format.hasPattern() == null;\n     }\n \n     /*\n     /**********************************************************\n     /* Accessors\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (format == JsonFormat.Shape.STRING) || format.hasPattern() == JsonFormat.class) { // could still be null",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-85/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 02:49:03.765210657 +0200\n+++ /tmp/tmp2bkb60fy.java\t2022-07-19 02:49:03.765210657 +0200\n@@ -62,38 +62,11 @@\n             return withFormat(Boolean.TRUE, null);\n         }\n \n         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n         // First: custom pattern will override things\n-                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n-                                || format.hasLocale() || format.hasTimeZone()) {\n-                    TimeZone tz = format.getTimeZone();\n-                    final String pattern = format.hasPattern()\n-                                    ? format.getPattern()\n-                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n-            final Locale loc = format.hasLocale()\n-                            ? format.getLocale()\n-                            : serializers.getLocale();\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n-                    if (tz == null) {\n-                        tz = serializers.getTimeZone();\n-                    }\n-            df.setTimeZone(tz);\n-            return withFormat(Boolean.FALSE, df);\n-        }\n-\n-        // Otherwise, need one of these changes:\n-\n-\n-        // Jackson's own `StdDateFormat` is quite easy to deal with...\n-\n-        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-        //    So: require it be `SimpleDateFormat`; can't config other types\n-//            serializers.reportBadDefinition(handledType(), String.format(\n-            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        return this;\n+if (format == JsonFormat.Shape.STRING) || format.hasPattern() == JsonFormat.class) { // could still be null\n     }\n \n     /*\n     /**********************************************************\n     /* Accessors\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (format == JsonFormat.Shape.STRING) || format.hasPattern() || format.hasTimeZone()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-85/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 02:49:05.505201456 +0200\n+++ /tmp/tmp751v2fnc.java\t2022-07-19 02:49:05.505201456 +0200\n@@ -62,38 +62,11 @@\n             return withFormat(Boolean.TRUE, null);\n         }\n \n         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n         // First: custom pattern will override things\n-                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n-                                || format.hasLocale() || format.hasTimeZone()) {\n-                    TimeZone tz = format.getTimeZone();\n-                    final String pattern = format.hasPattern()\n-                                    ? format.getPattern()\n-                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n-            final Locale loc = format.hasLocale()\n-                            ? format.getLocale()\n-                            : serializers.getLocale();\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n-                    if (tz == null) {\n-                        tz = serializers.getTimeZone();\n-                    }\n-            df.setTimeZone(tz);\n-            return withFormat(Boolean.FALSE, df);\n-        }\n-\n-        // Otherwise, need one of these changes:\n-\n-\n-        // Jackson's own `StdDateFormat` is quite easy to deal with...\n-\n-        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-        //    So: require it be `SimpleDateFormat`; can't config other types\n-//            serializers.reportBadDefinition(handledType(), String.format(\n-            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        return this;\n+if (format == JsonFormat.Shape.STRING) || format.hasPattern() || format.hasTimeZone()) {\n     }\n \n     /*\n     /**********************************************************\n     /* Accessors\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (format == JsonFormat.Shape.STRING) || format.hasPattern() == null) { // could still be null",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-85/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 02:49:07.077193144 +0200\n+++ /tmp/tmp9hzwo132.java\t2022-07-19 02:49:07.077193144 +0200\n@@ -62,38 +62,11 @@\n             return withFormat(Boolean.TRUE, null);\n         }\n \n         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n         // First: custom pattern will override things\n-                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n-                                || format.hasLocale() || format.hasTimeZone()) {\n-                    TimeZone tz = format.getTimeZone();\n-                    final String pattern = format.hasPattern()\n-                                    ? format.getPattern()\n-                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n-            final Locale loc = format.hasLocale()\n-                            ? format.getLocale()\n-                            : serializers.getLocale();\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n-                    if (tz == null) {\n-                        tz = serializers.getTimeZone();\n-                    }\n-            df.setTimeZone(tz);\n-            return withFormat(Boolean.FALSE, df);\n-        }\n-\n-        // Otherwise, need one of these changes:\n-\n-\n-        // Jackson's own `StdDateFormat` is quite easy to deal with...\n-\n-        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-        //    So: require it be `SimpleDateFormat`; can't config other types\n-//            serializers.reportBadDefinition(handledType(), String.format(\n-            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        return this;\n+if (format == JsonFormat.Shape.STRING) || format.hasPattern() == null) { // could still be null\n     }\n \n     /*\n     /**********************************************************\n     /* Accessors\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if ((shape == JsonFormat.Shape.STRING) || format.hasPattern() || format.hasLocale() || format.hasTimeZone()) { TimeZone tz = format.getTimeZone(); final String pattern = format.hasPattern() ? format.getPattern() : StdDateFormat.DATE_FORMAT_STR_ISO8601; final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(pattern, loc); if (tz == null) { tz = serializers.getTimeZone(); } df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } // Otherwise, need one of these changes: // Jackson's own `StdDateFormat` is quite easy to deal with... // 08-Jun-2017, tatu: Unfortunately there's no generally usable // mechanism for changing `DateFormat` instances (or even clone()ing) // So: require it be `SimpleDateFormat`; can't config other types // serializers.reportBadDefinition(handledType(), String.format( // Ugh. No way to change `Locale`, create copy; must re-crete completely: return this;",
        "fixed_line": "if (format.hasPattern()) { final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc); TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone(); df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } // Otherwise, need one of these changes: final boolean hasLocale = format.hasLocale(); final boolean hasTZ = format.hasTimeZone(); final boolean asString = (shape == JsonFormat.Shape.STRING); if (!hasLocale && !hasTZ && !asString) { return this; } DateFormat df0 = serializers.getConfig().getDateFormat(); // Jackson's own `StdDateFormat` is quite easy to deal with... if (df0 instanceof StdDateFormat) { StdDateFormat std = (StdDateFormat) df0; if (format.hasLocale()) { std = std.withLocale(format.getLocale()); } if (format.hasTimeZone()) { std = std.withTimeZone(format.getTimeZone()); } return withFormat(Boolean.FALSE, std); } // 08-Jun-2017, tatu: Unfortunately there's no generally usable // mechanism for changing `DateFormat` instances (or even clone()ing) // So: require it be `SimpleDateFormat`; can't config other types if (!(df0 instanceof SimpleDateFormat)) { // serializers.reportBadDefinition(handledType(), String.format( serializers.reportMappingProblem( \"Configured `DateFormat` (%s) not a `SimpleDateFormat`; can not configure `Locale` or `TimeZone`\", df0.getClass().getName()); } SimpleDateFormat df = (SimpleDateFormat) df0; if (hasLocale) { // Ugh. No way to change `Locale`, create copy; must re-crete completely: df = new SimpleDateFormat(df.toPattern(), format.getLocale()); } else { df = (SimpleDateFormat) df.clone(); } TimeZone newTz = format.getTimeZone(); boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone()); if (changeTZ) { df.setTimeZone(newTz); } return withFormat(Boolean.FALSE, df);"
    },
    "Lang-49": {
        "fixes": [
            {
                "k": 1,
                "patch": "int gcd = greatestCommonDivisor; } return Fraction.getFraction(numerator, gcd);",
                "patch_diff": "int gcd = greatestCommonDivisor; } return Fraction.getFraction(numerator, gcd);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int gcd = greatestCommonDivisor; } return Fraction.getFraction(numerator);",
                "patch_diff": "int gcd = greatestCommonDivisor; } return Fraction.getFraction(numerator);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int gcd = greatestCommonDivisor; } return Fraction.getFraction(numerator * gcd);",
                "patch_diff": "int gcd = greatestCommonDivisor; } return Fraction.getFraction(numerator * gcd);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int gcd = greatestCommonDivisor(this; } return Fraction.getFraction(), gcd);",
                "patch_diff": "int gcd = greatestCommonDivisor(this; } return Fraction.getFraction(), gcd);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int gcd = greatestCommonDivisor; } return Fraction.getFraction(numerator / gcd);",
                "patch_diff": "int gcd = greatestCommonDivisor; } return Fraction.getFraction(numerator / gcd);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int gcd = greatestCommonDivisor(this; } return Fraction.getFraction(numerator, gcd);",
                "patch_diff": "int gcd = greatestCommonDivisor(this; } return Fraction.getFraction(numerator, gcd);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int gcd = greatestCommonDivisor(this; } return Fraction.getFraction(numerator);",
                "patch_diff": "int gcd = greatestCommonDivisor(this; } return Fraction.getFraction(numerator);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int gcd = greatestCommonDivisor(this; } return Fraction.getFraction(denominator, gcd);",
                "patch_diff": "int gcd = greatestCommonDivisor(this; } return Fraction.getFraction(denominator, gcd);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int gcd = greatestCommonDivisor(this; } return Fraction.getFraction(numerator * gcd);",
                "patch_diff": "int gcd = greatestCommonDivisor(this; } return Fraction.getFraction(numerator * gcd);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int gcd = greatestCommonDivisor; } return Fraction.getFraction(numerator, denominator);",
                "patch_diff": "int gcd = greatestCommonDivisor; } return Fraction.getFraction(numerator, denominator);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (numerator == 0) { return equals(ZERO) ? this : ZERO; }"
    },
    "JacksonDatabind-112": {
        "fixes": [
            {
                "k": 1,
                "patch": "AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-112/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\t2022-07-19 02:49:10.753173702 +0200\n+++ /tmp/tmperxm4739.java\t2022-07-19 02:49:10.817173364 +0200\n@@ -102,11 +102,11 @@\n     {\n         // May need to resolve types for delegate-based creators:\n         JsonDeserializer<Object> delegate = null;\n         if (_valueInstantiator != null) {\n             // [databind#2324]: check both array-delegating and delegating\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n             if (delegateCreator != null) {\n                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                 delegate = findDeserializer(ctxt, delegateType, property);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); // delegateType = _valueInstantiator.getDelegateCreator();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-112/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\t2022-07-19 02:50:11.824850481 +0200\n+++ /tmp/tmppfvm5vaq.java\t2022-07-19 02:50:11.828850460 +0200\n@@ -102,11 +102,11 @@\n     {\n         // May need to resolve types for delegate-based creators:\n         JsonDeserializer<Object> delegate = null;\n         if (_valueInstantiator != null) {\n             // [databind#2324]: check both array-delegating and delegating\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); // delegateType = _valueInstantiator.getDelegateCreator();\n             if (delegateCreator != null) {\n                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                 delegate = findDeserializer(ctxt, delegateType, property);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); // can't really modify it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-112/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\t2022-07-19 02:51:06.548560520 +0200\n+++ /tmp/tmp96xp3c0n.java\t2022-07-19 02:51:06.552560499 +0200\n@@ -102,11 +102,11 @@\n     {\n         // May need to resolve types for delegate-based creators:\n         JsonDeserializer<Object> delegate = null;\n         if (_valueInstantiator != null) {\n             // [databind#2324]: check both array-delegating and delegating\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); // can't really modify it's do implicit re-parse\n             if (delegateCreator != null) {\n                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                 delegate = findDeserializer(ctxt, delegateType, property);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "AnnotatedWithParams delegateCreator = valueInstantiator.getDelegateCreator();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-112/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\t2022-07-19 02:52:01.496269084 +0200\n+++ /tmp/tmpsyr3iyb6.java\t2022-07-19 02:52:01.496269084 +0200\n@@ -102,11 +102,11 @@\n     {\n         // May need to resolve types for delegate-based creators:\n         JsonDeserializer<Object> delegate = null;\n         if (_valueInstantiator != null) {\n             // [databind#2324]: check both array-delegating and delegating\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+AnnotatedWithParams delegateCreator = valueInstantiator.getDelegateCreator();\n             if (delegateCreator != null) {\n                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                 delegate = findDeserializer(ctxt, delegateType, property);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); // value is lower case",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-112/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\t2022-07-19 02:52:03.220259938 +0200\n+++ /tmp/tmp9f00bk72.java\t2022-07-19 02:52:03.220259938 +0200\n@@ -102,11 +102,11 @@\n     {\n         // May need to resolve types for delegate-based creators:\n         JsonDeserializer<Object> delegate = null;\n         if (_valueInstantiator != null) {\n             // [databind#2324]: check both array-delegating and delegating\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); // value is lower case\n             if (delegateCreator != null) {\n                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                 delegate = findDeserializer(ctxt, delegateType, property);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); // can't really modify it's",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-112/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\t2022-07-19 02:52:57.987969190 +0200\n+++ /tmp/tmpcd0qcel6.java\t2022-07-19 02:52:57.987969190 +0200\n@@ -102,11 +102,11 @@\n     {\n         // May need to resolve types for delegate-based creators:\n         JsonDeserializer<Object> delegate = null;\n         if (_valueInstantiator != null) {\n             // [databind#2324]: check both array-delegating and delegating\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); // can't really modify it's\n             if (delegateCreator != null) {\n                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                 delegate = findDeserializer(ctxt, delegateType, property);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); // delegate-check value is lower case",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-112/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\t2022-07-19 02:53:52.335680445 +0200\n+++ /tmp/tmplyfok96y.java\t2022-07-19 02:53:52.335680445 +0200\n@@ -102,11 +102,11 @@\n     {\n         // May need to resolve types for delegate-based creators:\n         JsonDeserializer<Object> delegate = null;\n         if (_valueInstantiator != null) {\n             // [databind#2324]: check both array-delegating and delegating\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); // delegate-check value is lower case\n             if (delegateCreator != null) {\n                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                 delegate = findDeserializer(ctxt, delegateType, property);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); // can't really modify it.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-112/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\t2022-07-19 02:54:47.423387560 +0200\n+++ /tmp/tmpgopak7h4.java\t2022-07-19 02:54:47.427387538 +0200\n@@ -102,11 +102,11 @@\n     {\n         // May need to resolve types for delegate-based creators:\n         JsonDeserializer<Object> delegate = null;\n         if (_valueInstantiator != null) {\n             // [databind#2324]: check both array-delegating and delegating\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); // can't really modify it.\n             if (delegateCreator != null) {\n                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                 delegate = findDeserializer(ctxt, delegateType, property);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); // delegate-empty to do a _valueInstantiator.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-112/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\t2022-07-19 02:55:41.575099468 +0200\n+++ /tmp/tmphbl6ej8p.java\t2022-07-19 02:55:41.575099468 +0200\n@@ -102,11 +102,11 @@\n     {\n         // May need to resolve types for delegate-based creators:\n         JsonDeserializer<Object> delegate = null;\n         if (_valueInstantiator != null) {\n             // [databind#2324]: check both array-delegating and delegating\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); // delegate-empty to do a _valueInstantiator.\n             if (delegateCreator != null) {\n                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                 delegate = findDeserializer(ctxt, delegateType, property);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); // delegate value is lower case",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-112/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\t2022-07-19 02:56:36.866805141 +0200\n+++ /tmp/tmp1_m44gif.java\t2022-07-19 02:56:36.866805141 +0200\n@@ -102,11 +102,11 @@\n     {\n         // May need to resolve types for delegate-based creators:\n         JsonDeserializer<Object> delegate = null;\n         if (_valueInstantiator != null) {\n             // [databind#2324]: check both array-delegating and delegating\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); // delegate value is lower case\n             if (delegateCreator != null) {\n                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                 delegate = findDeserializer(ctxt, delegateType, property);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();",
        "fixed_line": "AnnotatedWithParams delegateCreator = _valueInstantiator.getArrayDelegateCreator(); if (delegateCreator != null) { JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig()); delegate = findDeserializer(ctxt, delegateType, property); } else if ((delegateCreator = _valueInstantiator.getDelegateCreator()) != null) {"
    },
    "Lang-58": {
        "fixes": [
            {
                "k": 1,
                "patch": "&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-58/src/java/org/apache/commons/lang/math/NumberUtils.java\t2022-07-19 02:57:31.846512324 +0200\n+++ /tmp/tmpknybmbly.java\t2022-07-19 02:57:31.898512045 +0200\n@@ -449,12 +449,11 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "&& isDigits(numeric.charAt(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-58/src/java/org/apache/commons/lang/math/NumberUtils.java\t2022-07-19 02:57:41.790459348 +0200\n+++ /tmp/tmpbizusdw2.java\t2022-07-19 02:57:41.794459327 +0200\n@@ -449,12 +449,11 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+&& isDigits(numeric.charAt(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "&& isDigits(numeric.substring(1)) || (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-58/src/java/org/apache/commons/lang/math/NumberUtils.java\t2022-07-19 02:57:43.486450313 +0200\n+++ /tmp/tmp387p5y50.java\t2022-07-19 02:57:43.486450313 +0200\n@@ -449,12 +449,11 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+&& isDigits(numeric.substring(1)) || (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 4,
                "patch": "|| isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-58/src/java/org/apache/commons/lang/math/NumberUtils.java\t2022-07-19 02:57:52.926400017 +0200\n+++ /tmp/tmppap2twga.java\t2022-07-19 02:57:52.926400017 +0200\n@@ -449,12 +449,11 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+|| isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 5,
                "patch": "&& isDigits(numeric.substring(1)) && (numeric.charAt(0)!= '-' || Character.isDigit(numeric.charAt(0)))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-58/src/java/org/apache/commons/lang/math/NumberUtils.java\t2022-07-19 02:58:02.138350934 +0200\n+++ /tmp/tmpnf7bgwkd.java\t2022-07-19 02:58:02.138350934 +0200\n@@ -449,12 +449,11 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+&& isDigits(numeric.substring(1)) && (numeric.charAt(0)!= '-' || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' && Character.isDigit(numeric.charAt(0)))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-58/src/java/org/apache/commons/lang/math/NumberUtils.java\t2022-07-19 02:58:11.346301863 +0200\n+++ /tmp/tmp6yz5hdja.java\t2022-07-19 02:58:11.346301863 +0200\n@@ -449,12 +449,11 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' && Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "&& isDigits(numeric.charAt(0)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-58/src/java/org/apache/commons/lang/math/NumberUtils.java\t2022-07-19 02:58:20.686252093 +0200\n+++ /tmp/tmprhb3htk7.java\t2022-07-19 02:58:20.686252093 +0200\n@@ -449,12 +449,11 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+&& isDigits(numeric.charAt(0)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "&& isDigits(numeric.toString(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-58/src/java/org/apache/commons/lang/math/NumberUtils.java\t2022-07-19 02:58:22.398242969 +0200\n+++ /tmp/tmptrs9omvy.java\t2022-07-19 02:58:22.398242969 +0200\n@@ -449,12 +449,11 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+&& isDigits(numeric.toString(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-58/src/java/org/apache/commons/lang/math/NumberUtils.java\t2022-07-19 02:58:24.034234250 +0200\n+++ /tmp/tmp_6bykyw0.java\t2022-07-19 02:58:24.034234250 +0200\n@@ -449,12 +449,11 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+// isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { if (numeric.charAt(0)))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-58/src/java/org/apache/commons/lang/math/NumberUtils.java\t2022-07-19 02:58:25.558226128 +0200\n+++ /tmp/tmpris4ee_3.java\t2022-07-19 02:58:25.558226128 +0200\n@@ -449,12 +449,11 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { if (numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {",
        "fixed_line": "&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {"
    },
    "Codec-3": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (contains(value, index + 1, 3, \"IER\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-3/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\t2022-07-19 02:58:27.278216962 +0200\n+++ /tmp/tmppyhcl1fu.java\t2022-07-19 02:58:27.294216876 +0200\n@@ -450,11 +450,11 @@\n                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n             //-- Italian \"biaggi\" --//\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+} else if (contains(value, index + 1, 3, \"IER\")) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n             }\n             index += 2;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 2,
                "patch": "} else if (contains(value, index + 1, 4, \"IERER\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-3/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\t2022-07-19 02:58:30.094201953 +0200\n+++ /tmp/tmpl5j0nmjn.java\t2022-07-19 02:58:30.098201932 +0200\n@@ -450,11 +450,11 @@\n                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n             //-- Italian \"biaggi\" --//\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+} else if (contains(value, index + 1, 4, \"IERER\")) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n             }\n             index += 2;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (contains(value, index + 1, 3, \"IERER\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-3/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\t2022-07-19 02:58:32.746187819 +0200\n+++ /tmp/tmp27qlz1zn.java\t2022-07-19 02:58:32.746187819 +0200\n@@ -450,11 +450,11 @@\n                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n             //-- Italian \"biaggi\" --//\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+} else if (contains(value, index + 1, 3, \"IERER\")) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n             }\n             index += 2;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (contains(value, index + 1, 4, \"IER\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-3/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\t2022-07-19 02:58:35.418173578 +0200\n+++ /tmp/tmp10xhunhl.java\t2022-07-19 02:58:35.418173578 +0200\n@@ -450,11 +450,11 @@\n                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n             //-- Italian \"biaggi\" --//\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+} else if (contains(value, index + 1, 4, \"IER\")) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n             }\n             index += 2;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (contains(value, index + 1, 4, \"IERERER\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-3/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\t2022-07-19 02:58:38.090159336 +0200\n+++ /tmp/tmprayws4gs.java\t2022-07-19 02:58:38.094159315 +0200\n@@ -450,11 +450,11 @@\n                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n             //-- Italian \"biaggi\" --//\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+} else if (contains(value, index + 1, 4, \"IERERER\")) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n             }\n             index += 2;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (contains(value, index + 1, 5, \"IER\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-3/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\t2022-07-19 02:58:40.882144455 +0200\n+++ /tmp/tmpzk8ji2kq.java\t2022-07-19 02:58:40.882144455 +0200\n@@ -450,11 +450,11 @@\n                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n             //-- Italian \"biaggi\" --//\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+} else if (contains(value, index + 1, 5, \"IER\")) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n             }\n             index += 2;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (contains(value, index + 1, 5, \"IERER\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-3/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\t2022-07-19 02:58:43.630129807 +0200\n+++ /tmp/tmpeujqokxa.java\t2022-07-19 02:58:43.630129807 +0200\n@@ -450,11 +450,11 @@\n                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n             //-- Italian \"biaggi\" --//\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+} else if (contains(value, index + 1, 5, \"IERER\")) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n             }\n             index += 2;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (contains(value, index + 1, 2, \"IER\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-3/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\t2022-07-19 02:58:46.250115842 +0200\n+++ /tmp/tmplp_413a8.java\t2022-07-19 02:58:46.250115842 +0200\n@@ -450,11 +450,11 @@\n                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n             //-- Italian \"biaggi\" --//\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+} else if (contains(value, index + 1, 2, \"IER\")) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n             }\n             index += 2;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (contains(value, index + 1, 3, \"IER\")) { // 'Y'",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-3/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\t2022-07-19 02:58:48.806102218 +0200\n+++ /tmp/tmp1nbhyuii.java\t2022-07-19 02:58:48.806102218 +0200\n@@ -450,11 +450,11 @@\n                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n             //-- Italian \"biaggi\" --//\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+} else if (contains(value, index + 1, 3, \"IER\")) { // 'Y'\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n             }\n             index += 2;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 10,
                "patch": "} else if (contains(value, index + 1, 1, \"IERER\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-3/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\t2022-07-19 02:58:51.538087656 +0200\n+++ /tmp/tmputpatodc.java\t2022-07-19 02:58:51.538087656 +0200\n@@ -450,11 +450,11 @@\n                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n             //-- Italian \"biaggi\" --//\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+} else if (contains(value, index + 1, 1, \"IERER\")) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n             }\n             index += 2;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "} else if (contains(value, index + 1, 4, \"IER\")) {",
        "fixed_line": "} else if (contains(value, index + 1, 3, \"IER\")) {"
    },
    "JacksonDatabind-17": {
        "fixes": [
            {
                "k": 1,
                "patch": "|| TreeNode.class.isAssignableFrom(t.getRawClass()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-17/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\t2022-07-19 02:58:54.514071792 +0200\n+++ /tmp/tmpsvvgcpc_.java\t2022-07-19 02:58:54.534071688 +0200\n@@ -175,11 +175,11 @@\n             case OBJECT_AND_NON_CONCRETE:\n //                return t.isJavaLangObject() || \n                 return (t.getRawClass() == Object.class)\n                         || (!t.isConcrete()\n                                 // [databind#88] Should not apply to JSON tree models:\n-                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n+|| TreeNode.class.isAssignableFrom(t.getRawClass()));\n \n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "&& TreeNode.class.isAssignableFrom(t.getRawClass()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-17/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\t2022-07-19 02:59:24.709910813 +0200\n+++ /tmp/tmpa3st1nzt.java\t2022-07-19 02:59:24.709910813 +0200\n@@ -175,11 +175,11 @@\n             case OBJECT_AND_NON_CONCRETE:\n //                return t.isJavaLangObject() || \n                 return (t.getRawClass() == Object.class)\n                         || (!t.isConcrete()\n                                 // [databind#88] Should not apply to JSON tree models:\n-                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n+&& TreeNode.class.isAssignableFrom(t.getRawClass()));\n \n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "|| TreeNode.class.isAssignableFrom(t.getRawClass())); // we didn't really modify it.getRawClass()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-17/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\t2022-07-19 02:59:53.293758396 +0200\n+++ /tmp/tmpaayhob30.java\t2022-07-19 02:59:53.293758396 +0200\n@@ -175,11 +175,11 @@\n             case OBJECT_AND_NON_CONCRETE:\n //                return t.isJavaLangObject() || \n                 return (t.getRawClass() == Object.class)\n                         || (!t.isConcrete()\n                                 // [databind#88] Should not apply to JSON tree models:\n-                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n+|| TreeNode.class.isAssignableFrom(t.getRawClass())); // we didn't really modify it.getRawClass()));\n \n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "|| TreeNode.class.isAssignableFrom(t.getRawClass())); // we didn't really modify it.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-17/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\t2022-07-19 03:00:21.689606953 +0200\n+++ /tmp/tmpp81l_4yk.java\t2022-07-19 03:00:21.693606932 +0200\n@@ -175,11 +175,11 @@\n             case OBJECT_AND_NON_CONCRETE:\n //                return t.isJavaLangObject() || \n                 return (t.getRawClass() == Object.class)\n                         || (!t.isConcrete()\n                                 // [databind#88] Should not apply to JSON tree models:\n-                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n+|| TreeNode.class.isAssignableFrom(t.getRawClass())); // we didn't really modify it.\n \n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "|| TreeNode.class.isAssignableFrom(t, parent.getRawClass()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-17/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\t2022-07-19 03:00:49.833456831 +0200\n+++ /tmp/tmp2mqembxv.java\t2022-07-19 03:00:49.833456831 +0200\n@@ -175,11 +175,11 @@\n             case OBJECT_AND_NON_CONCRETE:\n //                return t.isJavaLangObject() || \n                 return (t.getRawClass() == Object.class)\n                         || (!t.isConcrete()\n                                 // [databind#88] Should not apply to JSON tree models:\n-                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n+|| TreeNode.class.isAssignableFrom(t, parent.getRawClass()));\n \n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "|| TreeNode.class.isAssignableFrom(t, c.getRawClass()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-17/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\t2022-07-19 03:00:51.633447228 +0200\n+++ /tmp/tmpz_4pa_rb.java\t2022-07-19 03:00:51.633447228 +0200\n@@ -175,11 +175,11 @@\n             case OBJECT_AND_NON_CONCRETE:\n //                return t.isJavaLangObject() || \n                 return (t.getRawClass() == Object.class)\n                         || (!t.isConcrete()\n                                 // [databind#88] Should not apply to JSON tree models:\n-                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n+|| TreeNode.class.isAssignableFrom(t, c.getRawClass()));\n \n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// TreeNode.class.isAssignableFrom(t.getRawClass()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-17/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\t2022-07-19 03:00:53.501437263 +0200\n+++ /tmp/tmp2laydnz8.java\t2022-07-19 03:00:53.505437242 +0200\n@@ -175,11 +175,11 @@\n             case OBJECT_AND_NON_CONCRETE:\n //                return t.isJavaLangObject() || \n                 return (t.getRawClass() == Object.class)\n                         || (!t.isConcrete()\n                                 // [databind#88] Should not apply to JSON tree models:\n-                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n+// TreeNode.class.isAssignableFrom(t.getRawClass()));\n \n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "|| TreeNode.class.isAssignableFrom(t.getRawClass())); // TODO:",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-17/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\t2022-07-19 03:00:55.117428642 +0200\n+++ /tmp/tmp9xcem0ub.java\t2022-07-19 03:00:55.121428621 +0200\n@@ -175,11 +175,11 @@\n             case OBJECT_AND_NON_CONCRETE:\n //                return t.isJavaLangObject() || \n                 return (t.getRawClass() == Object.class)\n                         || (!t.isConcrete()\n                                 // [databind#88] Should not apply to JSON tree models:\n-                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n+|| TreeNode.class.isAssignableFrom(t.getRawClass())); // TODO:\n \n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "|| TreeNode.class.isAssignableFrom(t.getRawClass())); // to JSON object (t.getRawClass()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-17/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\t2022-07-19 03:01:23.413277679 +0200\n+++ /tmp/tmpmug8v3x_.java\t2022-07-19 03:01:23.417277658 +0200\n@@ -175,11 +175,11 @@\n             case OBJECT_AND_NON_CONCRETE:\n //                return t.isJavaLangObject() || \n                 return (t.getRawClass() == Object.class)\n                         || (!t.isConcrete()\n                                 // [databind#88] Should not apply to JSON tree models:\n-                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n+|| TreeNode.class.isAssignableFrom(t.getRawClass())); // to JSON object (t.getRawClass()));\n \n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "|| TreeNode.class.isAssignableFrom(t.getRawClass())); // we didn't really gets this.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-17/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\t2022-07-19 03:01:51.461128017 +0200\n+++ /tmp/tmp0p_of044.java\t2022-07-19 03:01:51.461128017 +0200\n@@ -175,11 +175,11 @@\n             case OBJECT_AND_NON_CONCRETE:\n //                return t.isJavaLangObject() || \n                 return (t.getRawClass() == Object.class)\n                         || (!t.isConcrete()\n                                 // [databind#88] Should not apply to JSON tree models:\n-                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n+|| TreeNode.class.isAssignableFrom(t.getRawClass())); // we didn't really gets this.\n \n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "|| TreeNode.class.isAssignableFrom(t.getRawClass()));",
        "fixed_line": "&& !TreeNode.class.isAssignableFrom(t.getRawClass()));"
    },
    "Jsoup-32": {
        "fixes": [
            {
                "k": 1,
                "patch": "clone.classNames();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-32/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 03:02:19.904976200 +0200\n+++ /tmp/tmpt8uhf_a_.java\t2022-07-19 03:02:19.916976134 +0200\n@@ -1133,9 +1133,9 @@\n     }\n \n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames();\n+clone.classNames();\n         return clone;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "clone.classNames(); // can't really modify it was non-literal characters that might be Token.classNames();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-32/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 03:02:23.024956969 +0200\n+++ /tmp/tmpvw8iodi6.java\t2022-07-19 03:02:23.028956945 +0200\n@@ -1133,9 +1133,9 @@\n     }\n \n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames();\n+clone.classNames(); // can't really modify it was non-literal characters that might be Token.classNames();\n         return clone;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "clone.classNames(); // can't really modify it was non-literal characters that might be valid (e if it.classNames();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-32/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 03:02:25.944938913 +0200\n+++ /tmp/tmpsmggxabk.java\t2022-07-19 03:02:25.944938913 +0200\n@@ -1133,9 +1133,9 @@\n     }\n \n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames();\n+clone.classNames(); // can't really modify it was non-literal characters that might be valid (e if it.classNames();\n         return clone;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "clone.classNames(); // can't really modify it was non-literal characters that might be valid (e if (this.classNames == clone.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-32/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 03:02:28.988920103 +0200\n+++ /tmp/tmptzz48ofc.java\t2022-07-19 03:02:28.988920103 +0200\n@@ -1133,9 +1133,9 @@\n     }\n \n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames();\n+clone.classNames(); // can't really modify it was non-literal characters that might be valid (e if (this.classNames == clone.class) {\n         return clone;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "clone.classNames(); // can't really modify it was non-literal characters that might be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-32/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 03:02:32.004901482 +0200\n+++ /tmp/tmpbj1a3nwo.java\t2022-07-19 03:02:32.004901482 +0200\n@@ -1133,9 +1133,9 @@\n     }\n \n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames();\n+clone.classNames(); // can't really modify it was non-literal characters that might be null!\n         return clone;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "clone.classNames(); // can't really modify it was non-literal characters that might be valid (e if (name == clone.classNames();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-32/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 03:02:34.896883636 +0200\n+++ /tmp/tmpbarb89e2.java\t2022-07-19 03:02:34.896883636 +0200\n@@ -1133,9 +1133,9 @@\n     }\n \n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames();\n+clone.classNames(); // can't really modify it was non-literal characters that might be valid (e if (name == clone.classNames();\n         return clone;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "clone.classNames(); // can't really modify it was non-literal characters that might be valid (e if (this.classNames.classNames();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-32/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 03:02:37.760865974 +0200\n+++ /tmp/tmp1l56izw6.java\t2022-07-19 03:02:37.760865974 +0200\n@@ -1133,9 +1133,9 @@\n     }\n \n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames();\n+clone.classNames(); // can't really modify it was non-literal characters that might be valid (e if (this.classNames.classNames();\n         return clone;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "clone.classNames(); // can't really modify it was non-literal characters that might be valid (e if (name == clone.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-32/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 03:02:40.720847732 +0200\n+++ /tmp/tmps10qi9au.java\t2022-07-19 03:02:40.720847732 +0200\n@@ -1133,9 +1133,9 @@\n     }\n \n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames();\n+clone.classNames(); // can't really modify it was non-literal characters that might be valid (e if (name == clone.class) {\n         return clone;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "clone.classNames(); // can't really modify it was non-literal characters that might be valid (e if (this.classNames == clone.classNames();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-32/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 03:02:43.680829505 +0200\n+++ /tmp/tmpffvt_uu_.java\t2022-07-19 03:02:43.680829505 +0200\n@@ -1133,9 +1133,9 @@\n     }\n \n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames();\n+clone.classNames(); // can't really modify it was non-literal characters that might be valid (e if (this.classNames == clone.classNames();\n         return clone;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "clone.classNames(); // can't really modify it was non-literal characters that might be valid (e.classNames();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-32/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 03:02:46.668811115 +0200\n+++ /tmp/tmpt6rcbilc.java\t2022-07-19 03:02:46.668811115 +0200\n@@ -1133,9 +1133,9 @@\n     }\n \n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames();\n+clone.classNames(); // can't really modify it was non-literal characters that might be valid (e.classNames();\n         return clone;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "clone.classNames();",
        "fixed_line": "clone.classNames = null; // derived on first hit, otherwise gets a pointer to source classnames"
    },
    "Closure-33": {
        "fixes": [
            {
                "k": 1,
                "patch": "// We only want to match the constraint object is a record the",
                "patch_diff": "// We only want to match the constraint object is a record the",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// We only want to match the",
                "patch_diff": "// We only want to match the",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// We only want to match the constraint object is a record the the",
                "patch_diff": "// We only want to match the constraint object is a record the the",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// We only want to match the constraint object is a record",
                "patch_diff": "// We only want to match the constraint object is a record",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// We only want to match the constraint object is a record the the the",
                "patch_diff": "// We only want to match the constraint object is a record the the the",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// We only want to match the constraint object is a record in the",
                "patch_diff": "// We only want to match the constraint object is a record in the",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// We only want to match the constraint object is a record the case 'e' argument.\");",
                "patch_diff": "// We only want to match the constraint object is a record the case 'e' argument.\");",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// We only want to match the constraint object is a record the the the the",
                "patch_diff": "// We only want to match the constraint object is a record the the the the",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// We only want to match the constraint object is a record the case 'e' argument",
                "patch_diff": "// We only want to match the constraint object is a record the case 'e' argument",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// We only want to match the constraint object is a record the case 'D' argument.\");",
                "patch_diff": "// We only want to match the constraint object is a record the case 'D' argument.\");",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (hasReferenceName()) { return; }"
    },
    "JacksonCore-14": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (toRelease!= src) && (toRelease.length < src) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-14/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\t2022-07-19 03:02:51.536781183 +0200\n+++ /tmp/tmp44l67vvy.java\t2022-07-19 03:02:51.548781109 +0200\n@@ -269,18 +269,8 @@\n         if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n     }\n \n     protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    protected final void _verifyRelease(char[] toRelease, char[] src) {\n-        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    private IllegalArgumentException wrongBuf() {\n-        // sanity check failed; trying to return different, smaller buffer.\n-return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n+if (toRelease!= src) && (toRelease.length < src) {\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (toRelease!= src) && (toRelease.length < src.length)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-14/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\t2022-07-19 03:02:53.156771229 +0200\n+++ /tmp/tmpsb54mnnw.java\t2022-07-19 03:02:53.156771229 +0200\n@@ -269,18 +269,8 @@\n         if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n     }\n \n     protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    protected final void _verifyRelease(char[] toRelease, char[] src) {\n-        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    private IllegalArgumentException wrongBuf() {\n-        // sanity check failed; trying to return different, smaller buffer.\n-return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n+if (toRelease!= src) && (toRelease.length < src.length)) {\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (toRelease!= src) && (toRelease.length!= src.length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-14/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\t2022-07-19 03:02:54.624762212 +0200\n+++ /tmp/tmpmikamy0i.java\t2022-07-19 03:02:54.624762212 +0200\n@@ -269,18 +269,8 @@\n         if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n     }\n \n     protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    protected final void _verifyRelease(char[] toRelease, char[] src) {\n-        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    private IllegalArgumentException wrongBuf() {\n-        // sanity check failed; trying to return different, smaller buffer.\n-return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n+if (toRelease!= src) && (toRelease.length!= src.length) {\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (toRelease!= src) && (toRelease.length < src.length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-14/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\t2022-07-19 03:02:56.184752633 +0200\n+++ /tmp/tmplpz4wzms.java\t2022-07-19 03:02:56.184752633 +0200\n@@ -269,18 +269,8 @@\n         if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n     }\n \n     protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    protected final void _verifyRelease(char[] toRelease, char[] src) {\n-        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    private IllegalArgumentException wrongBuf() {\n-        // sanity check failed; trying to return different, smaller buffer.\n-return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n+if (toRelease!= src) && (toRelease.length < src.length) {\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (toRelease!= src) && (toRelease.length == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-14/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\t2022-07-19 03:02:57.680743450 +0200\n+++ /tmp/tmpoch3983q.java\t2022-07-19 03:02:57.680743450 +0200\n@@ -269,18 +269,8 @@\n         if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n     }\n \n     protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    protected final void _verifyRelease(char[] toRelease, char[] src) {\n-        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    private IllegalArgumentException wrongBuf() {\n-        // sanity check failed; trying to return different, smaller buffer.\n-return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n+if (toRelease!= src) && (toRelease.length == 0) {\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (toRelease!= src) && (toRelease.length < len) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-14/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\t2022-07-19 03:02:59.188734197 +0200\n+++ /tmp/tmpg6s9xp_9.java\t2022-07-19 03:02:59.192734173 +0200\n@@ -269,18 +269,8 @@\n         if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n     }\n \n     protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    protected final void _verifyRelease(char[] toRelease, char[] src) {\n-        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    private IllegalArgumentException wrongBuf() {\n-        // sanity check failed; trying to return different, smaller buffer.\n-return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n+if (toRelease!= src) && (toRelease.length < len) {\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (toRelease!= src) && (toRelease.length!= src.length)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-14/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\t2022-07-19 03:03:00.724724775 +0200\n+++ /tmp/tmpplutugvr.java\t2022-07-19 03:03:00.724724775 +0200\n@@ -269,18 +269,8 @@\n         if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n     }\n \n     protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    protected final void _verifyRelease(char[] toRelease, char[] src) {\n-        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    private IllegalArgumentException wrongBuf() {\n-        // sanity check failed; trying to return different, smaller buffer.\n-return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n+if (toRelease!= src) && (toRelease.length!= src.length)) {\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (toRelease!= src) && (toRelease.length > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-14/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\t2022-07-19 03:03:02.252715405 +0200\n+++ /tmp/tmphshh499c.java\t2022-07-19 03:03:02.252715405 +0200\n@@ -269,18 +269,8 @@\n         if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n     }\n \n     protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    protected final void _verifyRelease(char[] toRelease, char[] src) {\n-        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    private IllegalArgumentException wrongBuf() {\n-        // sanity check failed; trying to return different, smaller buffer.\n-return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n+if (toRelease!= src) && (toRelease.length > 0) {\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (toRelease!= src) && (toRelease.length < 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-14/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\t2022-07-19 03:03:03.740706284 +0200\n+++ /tmp/tmpanncubm8.java\t2022-07-19 03:03:03.744706260 +0200\n@@ -269,18 +269,8 @@\n         if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n     }\n \n     protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    protected final void _verifyRelease(char[] toRelease, char[] src) {\n-        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    private IllegalArgumentException wrongBuf() {\n-        // sanity check failed; trying to return different, smaller buffer.\n-return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n+if (toRelease!= src) && (toRelease.length < 1) {\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (toRelease!= src.length) && (toRelease.length < src) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-14/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\t2022-07-19 03:03:05.256696994 +0200\n+++ /tmp/tmpuoxg1m08.java\t2022-07-19 03:03:05.256696994 +0200\n@@ -269,18 +269,8 @@\n         if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n     }\n \n     protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    protected final void _verifyRelease(char[] toRelease, char[] src) {\n-        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    private IllegalArgumentException wrongBuf() {\n-        // sanity check failed; trying to return different, smaller buffer.\n-return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n+if (toRelease!= src.length) && (toRelease.length < src) {\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); } } protected final void _verifyRelease(char[] toRelease, char[] src) { // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); } } private IllegalArgumentException wrongBuf() { // sanity check failed; trying to return different, smaller buffer. return new IllegalArgumentException(\"Trying to release buffer not owned by the context\");",
        "fixed_line": "if ((toRelease != src) && (toRelease.length < src.length)) { throw wrongBuf(); } } protected final void _verifyRelease(char[] toRelease, char[] src) { // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer if ((toRelease != src) && (toRelease.length < src.length)) { throw wrongBuf(); } } private IllegalArgumentException wrongBuf() { // sanity check failed; trying to return different, smaller buffer. return new IllegalArgumentException(\"Trying to release buffer smaller than original\");"
    },
    "Lang-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "int start = 'z' + 1; start ='';",
                "patch_diff": "int start = 'z' + 1; start ='';",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int start = 'Z' + 1; start ='';",
                "patch_diff": "int start = 'Z' + 1; start ='';",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int start = 'z' + 1; start =''; } char[] buffer ='';",
                "patch_diff": "int start = 'z' + 1; start =''; } char[] buffer ='';",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int start = 'z' + 1; end ='';",
                "patch_diff": "int start = 'z' + 1; end ='';",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int start = 'z' + 1; start =''; }",
                "patch_diff": "int start = 'z' + 1; start =''; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int start = 'z' + 1; start =''; } char[] buffer = new char[count]; int[] buffer ='';",
                "patch_diff": "int start = 'z' + 1; start =''; } char[] buffer = new char[count]; int[] buffer ='';",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int start = 'z' + 1; start =''; } char[] buffer = new char[count];",
                "patch_diff": "int start = 'z' + 1; start =''; } char[] buffer = new char[count];",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int start = 'z' + 1; start ='';':",
                "patch_diff": "int start = 'z' + 1; start ='';':",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int start = 'z' + 1; start =''; } char[] buffer =''z'",
                "patch_diff": "int start = 'z' + 1; start =''; } char[] buffer =''z'",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int start = 'z' + 1; start =''; } char[] buffer ='';",
                "patch_diff": "int start = 'z' + 1; start =''; } char[] buffer ='';",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "} else { if (end <= start) { throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\"); }"
    },
    "Cli-40": {
        "fixes": [
            {
                "k": 1,
                "patch": "return null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-40/src/main/java/org/apache/commons/cli/TypeHandler.java\t2022-07-19 03:03:08.568676710 +0200\n+++ /tmp/tmpl16uf0st.java\t2022-07-19 03:03:08.636676295 +0200\n@@ -98,11 +98,11 @@\n         {\n             return (T) createURL(str);\n         }\n         else\n         {\n-            return null;\n+return null;\n         }\n     }\n \n     /**\n       * Create an Object from the classname and empty constructor.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return null; // can't really modify it was non-empty's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-40/src/main/java/org/apache/commons/cli/TypeHandler.java\t2022-07-19 03:03:11.280660111 +0200\n+++ /tmp/tmpk194k7ql.java\t2022-07-19 03:03:11.280660111 +0200\n@@ -98,11 +98,11 @@\n         {\n             return (T) createURL(str);\n         }\n         else\n         {\n-            return null;\n+return null; // can't really modify it was non-empty's do implicit re-parse\n         }\n     }\n \n     /**\n       * Create an Object from the classname and empty constructor.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return null; // can't really modify it was non-literal characters that might be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-40/src/main/java/org/apache/commons/cli/TypeHandler.java\t2022-07-19 03:03:13.816644596 +0200\n+++ /tmp/tmpj_h2jpvu.java\t2022-07-19 03:03:13.816644596 +0200\n@@ -98,11 +98,11 @@\n         {\n             return (T) createURL(str);\n         }\n         else\n         {\n-            return null;\n+return null; // can't really modify it was non-literal characters that might be null!\n         }\n     }\n \n     /**\n       * Create an Object from the classname and empty constructor.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return null; // can't really modify it was non-empty's after name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-40/src/main/java/org/apache/commons/cli/TypeHandler.java\t2022-07-19 03:03:16.300629410 +0200\n+++ /tmp/tmperqa1ng5.java\t2022-07-19 03:03:16.300629410 +0200\n@@ -98,11 +98,11 @@\n         {\n             return (T) createURL(str);\n         }\n         else\n         {\n-            return null;\n+return null; // can't really modify it was non-empty's after name;\n         }\n     }\n \n     /**\n       * Create an Object from the classname and empty constructor.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return null; // can't really modify it was non-literal characters that might be null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-40/src/main/java/org/apache/commons/cli/TypeHandler.java\t2022-07-19 03:03:18.820614011 +0200\n+++ /tmp/tmp9l64m1ns.java\t2022-07-19 03:03:18.820614011 +0200\n@@ -98,11 +98,11 @@\n         {\n             return (T) createURL(str);\n         }\n         else\n         {\n-            return null;\n+return null; // can't really modify it was non-literal characters that might be null;\n         }\n     }\n \n     /**\n       * Create an Object from the classname and empty constructor.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return null; // can't really modify it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-40/src/main/java/org/apache/commons/cli/TypeHandler.java\t2022-07-19 03:03:21.480597765 +0200\n+++ /tmp/tmpqygltru0.java\t2022-07-19 03:03:21.480597765 +0200\n@@ -98,11 +98,11 @@\n         {\n             return (T) createURL(str);\n         }\n         else\n         {\n-            return null;\n+return null; // can't really modify it's do implicit re-parse\n         }\n     }\n \n     /**\n       * Create an Object from the classname and empty constructor.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return null; // can't really modify it was non-literal characters that might be null or EMPTY",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-40/src/main/java/org/apache/commons/cli/TypeHandler.java\t2022-07-19 03:03:23.928582823 +0200\n+++ /tmp/tmpqaqsm1jv.java\t2022-07-19 03:03:23.928582823 +0200\n@@ -98,11 +98,11 @@\n         {\n             return (T) createURL(str);\n         }\n         else\n         {\n-            return null;\n+return null; // can't really modify it was non-literal characters that might be null or EMPTY\n         }\n     }\n \n     /**\n       * Create an Object from the classname and empty constructor.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return null; // we didn't really modify it was non-literal characters that might be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-40/src/main/java/org/apache/commons/cli/TypeHandler.java\t2022-07-19 03:03:26.436567521 +0200\n+++ /tmp/tmpii5efjx1.java\t2022-07-19 03:03:26.436567521 +0200\n@@ -98,11 +98,11 @@\n         {\n             return (T) createURL(str);\n         }\n         else\n         {\n-            return null;\n+return null; // we didn't really modify it was non-literal characters that might be null!\n         }\n     }\n \n     /**\n       * Create an Object from the classname and empty constructor.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return null; // can't really modify it was non-literal characters that were // need to check",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-40/src/main/java/org/apache/commons/cli/TypeHandler.java\t2022-07-19 03:03:28.992551937 +0200\n+++ /tmp/tmpe52pim_9.java\t2022-07-19 03:03:28.992551937 +0200\n@@ -98,11 +98,11 @@\n         {\n             return (T) createURL(str);\n         }\n         else\n         {\n-            return null;\n+return null; // can't really modify it was non-literal characters that were // need to check\n         }\n     }\n \n     /**\n       * Create an Object from the classname and empty constructor.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return null; // can't really modify it was non-literal characters that might be null",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-40/src/main/java/org/apache/commons/cli/TypeHandler.java\t2022-07-19 03:03:31.428537091 +0200\n+++ /tmp/tmpnp5x302x.java\t2022-07-19 03:03:31.428537091 +0200\n@@ -98,11 +98,11 @@\n         {\n             return (T) createURL(str);\n         }\n         else\n         {\n-            return null;\n+return null; // can't really modify it was non-literal characters that might be null\n         }\n     }\n \n     /**\n       * Create an Object from the classname and empty constructor.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return null;",
        "fixed_line": "throw new ParseException(\"Unable to handle the class: \" + clazz);"
    },
    "Time-22": {
        "fixes": [
            {
                "k": 1,
                "patch": "this(0, duration, null, null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-22/src/main/java/org/joda/time/base/BasePeriod.java\t2022-07-19 03:03:34.192520256 +0200\n+++ /tmp/tmp5s3h176s.java\t2022-07-19 03:03:34.216520109 +0200\n@@ -217,11 +217,11 @@\n      * The calculation uses the hour, minute, second and millisecond fields.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        this(duration, null, null);\n+this(0, duration, null, null);\n         // bug [3264409]\n     }\n \n     /**\n      * Creates a period from the given millisecond duration, which is only really\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "this(duration, null, null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-22/src/main/java/org/joda/time/base/BasePeriod.java\t2022-07-19 03:03:48.068435878 +0200\n+++ /tmp/tmp2bqf0qkm.java\t2022-07-19 03:03:48.068435878 +0200\n@@ -217,11 +217,11 @@\n      * The calculation uses the hour, minute, second and millisecond fields.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        this(duration, null, null);\n+this(duration, null, null);\n         // bug [3264409]\n     }\n \n     /**\n      * Creates a period from the given millisecond duration, which is only really\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "this(0, duration, null, null); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-22/src/main/java/org/joda/time/base/BasePeriod.java\t2022-07-19 03:03:57.120380965 +0200\n+++ /tmp/tmpq68n63ts.java\t2022-07-19 03:03:57.120380965 +0200\n@@ -217,11 +217,11 @@\n      * The calculation uses the hour, minute, second and millisecond fields.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        this(duration, null, null);\n+this(0, duration, null, null); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n         // bug [3264409]\n     }\n \n     /**\n      * Creates a period from the given millisecond duration, which is only really\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "this(0, duration, null, null); // we didn't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-22/src/main/java/org/joda/time/base/BasePeriod.java\t2022-07-19 03:04:06.232325788 +0200\n+++ /tmp/tmpuh4yb9b4.java\t2022-07-19 03:04:06.232325788 +0200\n@@ -217,11 +217,11 @@\n      * The calculation uses the hour, minute, second and millisecond fields.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        this(duration, null, null);\n+this(0, duration, null, null); // we didn't really modify it's totalGJACKSON-notnotnotnot real number\n         // bug [3264409]\n     }\n \n     /**\n      * Creates a period from the given millisecond duration, which is only really\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "this(0, duration, null, null); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-22/src/main/java/org/joda/time/base/BasePeriod.java\t2022-07-19 03:04:15.464269982 +0200\n+++ /tmp/tmp1l7m72qt.java\t2022-07-19 03:04:15.464269982 +0200\n@@ -217,11 +217,11 @@\n      * The calculation uses the hour, minute, second and millisecond fields.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        this(duration, null, null);\n+this(0, duration, null, null); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n         // bug [3264409]\n     }\n \n     /**\n      * Creates a period from the given millisecond duration, which is only really\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "this(0, duration, null, null); // we didn't really modify it's totalGJACKSON-notnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-22/src/main/java/org/joda/time/base/BasePeriod.java\t2022-07-19 03:04:24.780213772 +0200\n+++ /tmp/tmposnr60ms.java\t2022-07-19 03:04:24.780213772 +0200\n@@ -217,11 +217,11 @@\n      * The calculation uses the hour, minute, second and millisecond fields.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        this(duration, null, null);\n+this(0, duration, null, null); // we didn't really modify it's totalGJACKSON-notnotnot real number\n         // bug [3264409]\n     }\n \n     /**\n      * Creates a period from the given millisecond duration, which is only really\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "this(0, duration, null, null); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-22/src/main/java/org/joda/time/base/BasePeriod.java\t2022-07-19 03:04:33.740159801 +0200\n+++ /tmp/tmp4x45jzlt.java\t2022-07-19 03:04:33.744159779 +0200\n@@ -217,11 +217,11 @@\n      * The calculation uses the hour, minute, second and millisecond fields.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        this(duration, null, null);\n+this(0, duration, null, null); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n         // bug [3264409]\n     }\n \n     /**\n      * Creates a period from the given millisecond duration, which is only really\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "this(0, duration, null, null); // we didn't really modify it's totalGJACKSON-407] --raw (duration, null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-22/src/main/java/org/joda/time/base/BasePeriod.java\t2022-07-19 03:04:42.924104577 +0200\n+++ /tmp/tmpihi2uncf.java\t2022-07-19 03:04:42.924104577 +0200\n@@ -217,11 +217,11 @@\n      * The calculation uses the hour, minute, second and millisecond fields.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        this(duration, null, null);\n+this(0, duration, null, null); // we didn't really modify it's totalGJACKSON-407] --raw (duration, null);\n         // bug [3264409]\n     }\n \n     /**\n      * Creates a period from the given millisecond duration, which is only really\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "this(0, duration, null, null); // we didn't really modify it's totalGJACKSON-notnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-22/src/main/java/org/joda/time/base/BasePeriod.java\t2022-07-19 03:04:52.128049323 +0200\n+++ /tmp/tmpruqxwjll.java\t2022-07-19 03:04:52.128049323 +0200\n@@ -217,11 +217,11 @@\n      * The calculation uses the hour, minute, second and millisecond fields.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        this(duration, null, null);\n+this(0, duration, null, null); // we didn't really modify it's totalGJACKSON-notnot real number\n         // bug [3264409]\n     }\n \n     /**\n      * Creates a period from the given millisecond duration, which is only really\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "this(0, duration, null, null); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-22/src/main/java/org/joda/time/base/BasePeriod.java\t2022-07-19 03:05:01.499993157 +0200\n+++ /tmp/tmp0o_6996a.java\t2022-07-19 03:05:01.499993157 +0200\n@@ -217,11 +217,11 @@\n      * The calculation uses the hour, minute, second and millisecond fields.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        this(duration, null, null);\n+this(0, duration, null, null); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number\n         // bug [3264409]\n     }\n \n     /**\n      * Creates a period from the given millisecond duration, which is only really\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "this(duration, null, null);",
        "fixed_line": "super(); // bug [3264409] iType = PeriodType.time(); int[] values = ISOChronology.getInstanceUTC().get(this, duration); iType = PeriodType.standard(); iValues = new int[8]; System.arraycopy(values, 0, iValues, 4, 4);"
    },
    "Math-48": {
        "fixes": [
            {
                "k": 1,
                "patch": "// REGULA_FALSI (f1 / (f1 + fx); break;",
                "patch_diff": "// REGULA_FALSI (f1 / (f1 + fx); break;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// REGULA_FALSI (f1 / (f0 + fx); break;",
                "patch_diff": "// REGULA_FALSI (f1 / (f0 + fx); break;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// REGULA_FALSI (f1 / (f1 + fx); break; case REGULA_FALSI;",
                "patch_diff": "// REGULA_FALSI (f1 / (f1 + fx); break; case REGULA_FALSI;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// REGULA_FALSI (f1 / (f0 + fx); break; case REGULA_FALSI;",
                "patch_diff": "// REGULA_FALSI (f1 / (f0 + fx); break; case REGULA_FALSI;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// REGULA_FALSI (f1 / (f1 + fx); break; case REGULA_FALSI:",
                "patch_diff": "// REGULA_FALSI (f1 / (f1 + fx); break; case REGULA_FALSI:",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// REGULA_FALSI. break;",
                "patch_diff": "// REGULA_FALSI. break;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// REGULA_FALSI: // REGULA_FALSI (f1 / (f1 + fx); break;",
                "patch_diff": "// REGULA_FALSI: // REGULA_FALSI (f1 / (f1 + fx); break;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// REGULA_FALSI (f1 / (f1 + fx); break; case 'FALSI;",
                "patch_diff": "// REGULA_FALSI (f1 / (f1 + fx); break; case 'FALSI;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// REGULA_FALSI (f1 / (f1 + fx); break; case 'FALSI:",
                "patch_diff": "// REGULA_FALSI (f1 / (f1 + fx); break; case 'FALSI:",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// REGULA_FALSI. throw new MathInternalError(f1 / (f1 + fx); break;",
                "patch_diff": "// REGULA_FALSI. throw new MathInternalError(f1 / (f1 + fx); break;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (x == x1) { throw new ConvergenceException(); }"
    },
    "Math-27": {
        "fixes": [
            {
                "k": 1,
                "patch": "return multiply(100).doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-27/src/main/java/org/apache/commons/math3/fraction/Fraction.java\t2022-07-19 03:05:12.823925419 +0200\n+++ /tmp/tmppq6y4_l6.java\t2022-07-19 03:05:12.891925013 +0200\n@@ -592,11 +592,11 @@\n      * </p>\n      *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+return multiply(100).doubleValue();\n     }\n \n     /**\n      * <p>Creates a {@code Fraction} instance with the 2 parts\n      * of a fraction Y/Z.</p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return multiply(100).doubleValue(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-27/src/main/java/org/apache/commons/math3/fraction/Fraction.java\t2022-07-19 03:05:49.879704667 +0200\n+++ /tmp/tmp926yyy9g.java\t2022-07-19 03:05:49.879704667 +0200\n@@ -592,11 +592,11 @@\n      * </p>\n      *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+return multiply(100).doubleValue(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n     }\n \n     /**\n      * <p>Creates a {@code Fraction} instance with the 2 parts\n      * of a fraction Y/Z.</p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return multiply(100).doubleValue(); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-27/src/main/java/org/apache/commons/math3/fraction/Fraction.java\t2022-07-19 03:06:21.691516222 +0200\n+++ /tmp/tmporbxfr7g.java\t2022-07-19 03:06:21.691516222 +0200\n@@ -592,11 +592,11 @@\n      * </p>\n      *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+return multiply(100).doubleValue(); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n     }\n \n     /**\n      * <p>Creates a {@code Fraction} instance with the 2 parts\n      * of a fraction Y/Z.</p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return multiply(100).doubleValue(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-27/src/main/java/org/apache/commons/math3/fraction/Fraction.java\t2022-07-19 03:06:54.143324932 +0200\n+++ /tmp/tmpznrp7eik.java\t2022-07-19 03:06:54.143324932 +0200\n@@ -592,11 +592,11 @@\n      * </p>\n      *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+return multiply(100).doubleValue(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n     }\n \n     /**\n      * <p>Creates a {@code Fraction} instance with the 2 parts\n      * of a fraction Y/Z.</p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return multiply(100).doubleValue(); // we didn't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-27/src/main/java/org/apache/commons/math3/fraction/Fraction.java\t2022-07-19 03:07:25.799139203 +0200\n+++ /tmp/tmp6z7aqad5.java\t2022-07-19 03:07:25.799139203 +0200\n@@ -592,11 +592,11 @@\n      * </p>\n      *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+return multiply(100).doubleValue(); // we didn't really modify it's totalGJACKSON-notnotnotnot real number\n     }\n \n     /**\n      * <p>Creates a {@code Fraction} instance with the 2 parts\n      * of a fraction Y/Z.</p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return multiply(100).doubleValue(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-27/src/main/java/org/apache/commons/math3/fraction/Fraction.java\t2022-07-19 03:07:57.730952670 +0200\n+++ /tmp/tmpq7prt573.java\t2022-07-19 03:07:57.730952670 +0200\n@@ -592,11 +592,11 @@\n      * </p>\n      *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+return multiply(100).doubleValue(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number\n     }\n \n     /**\n      * <p>Creates a {@code Fraction} instance with the 2 parts\n      * of a fraction Y/Z.</p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return multiply(100).doubleValue(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-27/src/main/java/org/apache/commons/math3/fraction/Fraction.java\t2022-07-19 03:08:29.218769485 +0200\n+++ /tmp/tmp84h_06mr.java\t2022-07-19 03:08:29.218769485 +0200\n@@ -592,11 +592,11 @@\n      * </p>\n      *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+return multiply(100).doubleValue(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number\n     }\n \n     /**\n      * <p>Creates a {@code Fraction} instance with the 2 parts\n      * of a fraction Y/Z.</p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return multiply(100).doubleValue(); // we didn't really modify it's totalGJACKSON-notnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-27/src/main/java/org/apache/commons/math3/fraction/Fraction.java\t2022-07-19 03:09:00.866586078 +0200\n+++ /tmp/tmp50cixql4.java\t2022-07-19 03:09:00.866586078 +0200\n@@ -592,11 +592,11 @@\n      * </p>\n      *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+return multiply(100).doubleValue(); // we didn't really modify it's totalGJACKSON-notnotnot real number\n     }\n \n     /**\n      * <p>Creates a {@code Fraction} instance with the 2 parts\n      * of a fraction Y/Z.</p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return multiply(100).doubleValue(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-27/src/main/java/org/apache/commons/math3/fraction/Fraction.java\t2022-07-19 03:09:32.646402577 +0200\n+++ /tmp/tmpaw8z2i6k.java\t2022-07-19 03:09:32.650402554 +0200\n@@ -592,11 +592,11 @@\n      * </p>\n      *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+return multiply(100).doubleValue(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnot real number\n     }\n \n     /**\n      * <p>Creates a {@code Fraction} instance with the 2 parts\n      * of a fraction Y/Z.</p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return multiply(100).doubleValue(); // we didn't really modify it's totalGJACKSON-notnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-27/src/main/java/org/apache/commons/math3/fraction/Fraction.java\t2022-07-19 03:10:04.582218814 +0200\n+++ /tmp/tmpvml6cgdc.java\t2022-07-19 03:10:04.582218814 +0200\n@@ -592,11 +592,11 @@\n      * </p>\n      *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+return multiply(100).doubleValue(); // we didn't really modify it's totalGJACKSON-notnot real number\n     }\n \n     /**\n      * <p>Creates a {@code Fraction} instance with the 2 parts\n      * of a fraction Y/Z.</p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return multiply(100).doubleValue();",
        "fixed_line": "return 100 * doubleValue();"
    },
    "Closure-104": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (result == null) { // can be null if the type in result; caller should never be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-104/src/com/google/javascript/rhino/jstype/UnionType.java\t2022-07-19 03:10:36.722034485 +0200\n+++ /tmp/tmpapzh52ms.java\t2022-07-19 03:10:36.742034370 +0200\n@@ -286,11 +286,11 @@\n       }\n     } else if (that.isSubtype(this)) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+if (result == null) { // can be null if the type in result; caller should never be null!\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     } else {\n       return getNativeType(JSTypeNative.NO_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (result == null) { // should never be null if the type in result; caller should never be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-104/src/com/google/javascript/rhino/jstype/UnionType.java\t2022-07-19 03:10:55.069929514 +0200\n+++ /tmp/tmp11_igkx1.java\t2022-07-19 03:10:55.069929514 +0200\n@@ -286,11 +286,11 @@\n       }\n     } else if (that.isSubtype(this)) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+if (result == null) { // should never be null if the type in result; caller should never be null!\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     } else {\n       return getNativeType(JSTypeNative.NO_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (result == null) { // block == null; return result; caller should never be null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-104/src/com/google/javascript/rhino/jstype/UnionType.java\t2022-07-19 03:11:13.709823054 +0200\n+++ /tmp/tmpv__g5p2c.java\t2022-07-19 03:11:13.709823054 +0200\n@@ -286,11 +286,11 @@\n       }\n     } else if (that.isSubtype(this)) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+if (result == null) { // block == null; return result; caller should never be null)\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     } else {\n       return getNativeType(JSTypeNative.NO_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (result == null) { // should never be null if the type in result; return result; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-104/src/com/google/javascript/rhino/jstype/UnionType.java\t2022-07-19 03:11:32.205717594 +0200\n+++ /tmp/tmprd3cvda3.java\t2022-07-19 03:11:32.209717571 +0200\n@@ -286,11 +286,11 @@\n       }\n     } else if (that.isSubtype(this)) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+if (result == null) { // should never be null if the type in result; return result; }\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     } else {\n       return getNativeType(JSTypeNative.NO_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (result == null) { // can be null if the type in result; return result; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-104/src/com/google/javascript/rhino/jstype/UnionType.java\t2022-07-19 03:11:50.973610758 +0200\n+++ /tmp/tmpre2p37fn.java\t2022-07-19 03:11:50.977610735 +0200\n@@ -286,11 +286,11 @@\n       }\n     } else if (that.isSubtype(this)) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+if (result == null) { // can be null if the type in result; return result; }\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     } else {\n       return getNativeType(JSTypeNative.NO_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (result == null) { // should never be null if the type in result; return result; caller should never be null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-104/src/com/google/javascript/rhino/jstype/UnionType.java\t2022-07-19 03:12:09.217507065 +0200\n+++ /tmp/tmppn9tki5q.java\t2022-07-19 03:12:09.217507065 +0200\n@@ -286,11 +286,11 @@\n       }\n     } else if (that.isSubtype(this)) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+if (result == null) { // should never be null if the type in result; return result; caller should never be null)\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     } else {\n       return getNativeType(JSTypeNative.NO_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (result == null) { // can be null if the type in result; return result; caller should never be null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-104/src/com/google/javascript/rhino/jstype/UnionType.java\t2022-07-19 03:12:27.677402301 +0200\n+++ /tmp/tmpgrt2cj5e.java\t2022-07-19 03:12:27.681402278 +0200\n@@ -286,11 +286,11 @@\n       }\n     } else if (that.isSubtype(this)) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+if (result == null) { // can be null if the type in result; return result; caller should never be null)\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     } else {\n       return getNativeType(JSTypeNative.NO_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (result!= null) { // can be null if the type in result; caller should never be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-104/src/com/google/javascript/rhino/jstype/UnionType.java\t2022-07-19 03:12:46.005298435 +0200\n+++ /tmp/tmpylrvr0_0.java\t2022-07-19 03:12:46.005298435 +0200\n@@ -286,11 +286,11 @@\n       }\n     } else if (that.isSubtype(this)) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+if (result!= null) { // can be null if the type in result; caller should never be null!\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     } else {\n       return getNativeType(JSTypeNative.NO_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (result == null) { // block only override if the type in result; caller should never be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-104/src/com/google/javascript/rhino/jstype/UnionType.java\t2022-07-19 03:13:04.373194488 +0200\n+++ /tmp/tmph7y4zhan.java\t2022-07-19 03:13:04.377194467 +0200\n@@ -286,11 +286,11 @@\n       }\n     } else if (that.isSubtype(this)) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+if (result == null) { // block only override if the type in result; caller should never be null!\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     } else {\n       return getNativeType(JSTypeNative.NO_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (result!= null) { // should never be null if the type in result; caller should never be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-104/src/com/google/javascript/rhino/jstype/UnionType.java\t2022-07-19 03:13:22.725090772 +0200\n+++ /tmp/tmpnk0qbflk.java\t2022-07-19 03:13:22.729090749 +0200\n@@ -286,11 +286,11 @@\n       }\n     } else if (that.isSubtype(this)) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+if (result!= null) { // should never be null if the type in result; caller should never be null!\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     } else {\n       return getNativeType(JSTypeNative.NO_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (result != null) {",
        "fixed_line": "if (!result.isNoType()) {"
    },
    "Csv-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-12/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 03:13:41.340985701 +0200\n+++ /tmp/tmpxb8jwq2s.java\t2022-07-19 03:13:41.364985565 +0200\n@@ -214,11 +214,11 @@\n      * </ul>\n      * <p>\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n+public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n \n     /**\n      * Tab-delimited format.\n      *\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(true);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-12/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 03:13:44.528967719 +0200\n+++ /tmp/tmpc35980wm.java\t2022-07-19 03:13:44.532967699 +0200\n@@ -214,11 +214,11 @@\n      * </ul>\n      * <p>\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n+public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(true);\n \n     /**\n      * Tab-delimited format.\n      *\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "public static final CSVFormat EXCEL = DEFAULT_TOTEmptyLines(false);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-12/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 03:13:47.144952970 +0200\n+++ /tmp/tmp9mpg975u.java\t2022-07-19 03:13:47.148952947 +0200\n@@ -214,11 +214,11 @@\n      * </ul>\n      * <p>\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n+public static final CSVFormat EXCEL = DEFAULT_TOTEmptyLines(false);\n \n     /**\n      * Tab-delimited format.\n      *\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "public static final CSVFormat EXCEL = DEFAULT_TOTYPE.withIgnoreEmptyLines(false);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-12/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 03:13:48.772943791 +0200\n+++ /tmp/tmp1dp190a_.java\t2022-07-19 03:13:48.776943767 +0200\n@@ -214,11 +214,11 @@\n      * </ul>\n      * <p>\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n+public static final CSVFormat EXCEL = DEFAULT_TOTYPE.withIgnoreEmptyLines(false);\n \n     /**\n      * Tab-delimited format.\n      *\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "public static final CSVFormat EXCEL = DEFAULT_LINE_LENGTH_EXTENDED_TYPE.withIgnoreEmptyLines(false);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-12/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 03:13:50.428934456 +0200\n+++ /tmp/tmpw9142vvk.java\t2022-07-19 03:13:50.432934433 +0200\n@@ -214,11 +214,11 @@\n      * </ul>\n      * <p>\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n+public static final CSVFormat EXCEL = DEFAULT_LINE_LENGTH_EXTENDED_TYPE.withIgnoreEmptyLines(false);\n \n     /**\n      * Tab-delimited format.\n      *\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "public static final CSVFormat EXCEL = DEFAULT_TABLEEmptyLines(false);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-12/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 03:13:52.072925187 +0200\n+++ /tmp/tmp_zf51rco.java\t2022-07-19 03:13:52.072925187 +0200\n@@ -214,11 +214,11 @@\n      * </ul>\n      * <p>\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n+public static final CSVFormat EXCEL = DEFAULT_TABLEEmptyLines(false);\n \n     /**\n      * Tab-delimited format.\n      *\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "public static final CSVFormat EXCEL = DEFAULT_TOTEmptyLines(true);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-12/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 03:13:53.748915742 +0200\n+++ /tmp/tmpttnycvey.java\t2022-07-19 03:13:53.752915719 +0200\n@@ -214,11 +214,11 @@\n      * </ul>\n      * <p>\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n+public static final CSVFormat EXCEL = DEFAULT_TOTEmptyLines(true);\n \n     /**\n      * Tab-delimited format.\n      *\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "public static final CSVFormat EXCEL = DEFAULT_oogEmptyLines(false);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-12/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 03:13:55.396906455 +0200\n+++ /tmp/tmpkj6t49r7.java\t2022-07-19 03:13:55.400906431 +0200\n@@ -214,11 +214,11 @@\n      * </ul>\n      * <p>\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n+public static final CSVFormat EXCEL = DEFAULT_oogEmptyLines(false);\n \n     /**\n      * Tab-delimited format.\n      *\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "public static final CSVFormat EXCEL = DEFAULT_LINE_LENGTH_EXTENDED_TYPE.withIgnoreEmptyLines(true);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-12/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 03:13:57.128896694 +0200\n+++ /tmp/tmphoq97wpq.java\t2022-07-19 03:13:57.128896694 +0200\n@@ -214,11 +214,11 @@\n      * </ul>\n      * <p>\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n+public static final CSVFormat EXCEL = DEFAULT_LINE_LENGTH_EXTENDED_TYPE.withIgnoreEmptyLines(true);\n \n     /**\n      * Tab-delimited format.\n      *\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "public static final CSVFormat EXCEL = DEFAULT_TOTYPE.withIgnoreEmptyLines(true);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-12/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 03:13:58.880886825 +0200\n+++ /tmp/tmp3umwt45j.java\t2022-07-19 03:13:58.880886825 +0200\n@@ -214,11 +214,11 @@\n      * </ul>\n      * <p>\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n+public static final CSVFormat EXCEL = DEFAULT_TOTYPE.withIgnoreEmptyLines(true);\n \n     /**\n      * Tab-delimited format.\n      *\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);",
        "fixed_line": "public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true);"
    },
    "Math-39": {
        "fixes": [
            {
                "k": 1,
                "patch": "k k = 0; k < xDotK[1]); firstTime = false;",
                "patch_diff": "k k = 0; k < xDotK[1]); firstTime = false;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "k k = 0;",
                "patch_diff": "k k = 0;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "k = 0; k < xDotK[1]); firstTime = false;",
                "patch_diff": "k = 0; k < xDotK[1]); firstTime = false;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int k = 0; k < yDotK[1]); firstTime = false;",
                "patch_diff": "for (int k = 0; k < yDotK[1]); firstTime = false;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "k k = 0; k < yDotK[1]); firstTime = false;",
                "patch_diff": "k k = 0; k < yDotK[1]); firstTime = false;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int k = 0; k < yDotK[1]); firstTime = false; k > 0; k < yDotK[1]); firstTime = false;",
                "patch_diff": "for (int k = 0; k < yDotK[1]); firstTime = false; k > 0; k < yDotK[1]); firstTime = false;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "k k = 0; k < xDotK[1]); firstTime = true;",
                "patch_diff": "k k = 0; k < xDotK[1]); firstTime = true;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "k k = xDotK[1]); firstTime = false;",
                "patch_diff": "k k = xDotK[1]); firstTime = false;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int k = 0; k < yDotK[1]); firstTime = false; k < yDotK[1]); firstTime = false;",
                "patch_diff": "for (int k = 0; k < yDotK[1]); firstTime = false; k < yDotK[1]); firstTime = false;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int k = 0; k < yDotK[1]); firstTime = true;",
                "patch_diff": "for (int k = 0; k < yDotK[1]); firstTime = true;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (forward) { if (stepStart + stepSize >= t) { stepSize = t - stepStart; } } else { if (stepStart + stepSize <= t) { stepSize = t - stepStart; } }"
    },
    "JacksonDatabind-40": {
        "fixes": [
            {
                "k": 1,
                "patch": "final T getNullValue() { return _nullValue; }",
                "patch_diff": "final T getNullValue() { return _nullValue; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "final T getNullValue() {",
                "patch_diff": "final T getNullValue() {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "final T getNullValue() { return null; }",
                "patch_diff": "final T getNullValue() { return null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "final T getNullValue() { return _nullValue; } // either, if",
                "patch_diff": "final T getNullValue() { return _nullValue; } // either, if",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "final T getNullValue() { return _nullValue; } // either, if (",
                "patch_diff": "final T getNullValue() { return _nullValue; } // either, if (",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "final T getNullValue() { return _nullValue; } // either, if not allowed }",
                "patch_diff": "final T getNullValue() { return _nullValue; } // either, if not allowed }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "final T getNullValue() { return _nullValue;",
                "patch_diff": "final T getNullValue() { return _nullValue;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "final T getNullValue() { return _nullValue; } // either,",
                "patch_diff": "final T getNullValue() { return _nullValue; } // either,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "final T getNullValue() { return _nullValue; } else if (nullValue == null) {",
                "patch_diff": "final T getNullValue() { return _nullValue; } else if (nullValue == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "final T getNullValue() { return null; } // either, if",
                "patch_diff": "final T getNullValue() { return null; } // either, if",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "@Override public T getEmptyValue(DeserializationContext ctxt) throws JsonMappingException { // [databind#1095]: Should not allow coercion from into null from Empty String // either, if `null` not allowed if (_primitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) { throw ctxt.mappingException( \"Can not map Empty String as null into type %s (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to 'false' to allow)\", handledType().toString()); } return _nullValue; }"
    },
    "Csv-10": {
        "fixes": [
            {
                "k": 1,
                "patch": "// TODO: return this.out = format;",
                "patch_diff": "// TODO: return this.out = format;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// TODO: return this.out = format; // TODO: Is it.",
                "patch_diff": "// TODO: return this.out = format; // TODO: Is it.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// TODO: Is it.format = format; this.format = format;",
                "patch_diff": "// TODO: Is it.format = format; this.format = format;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// TODO: Is it.format = format;",
                "patch_diff": "// TODO: Is it.format = format;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// TODO: return this.out = format; // TODO:",
                "patch_diff": "// TODO: return this.out = format; // TODO:",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// TODO: Is it.format = format; // TODO:",
                "patch_diff": "// TODO: Is it.format = format; // TODO:",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// TODO: return this.out = format; // TODO: Is it.format = format;",
                "patch_diff": "// TODO: return this.out = format; // TODO: Is it.format = format;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// TODO: return this.out = format; // TODO: Is it.validate(); // TODO:",
                "patch_diff": "// TODO: return this.out = format; // TODO: Is it.validate(); // TODO:",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// TODO: Is it.format = format; // TODO: Is it.",
                "patch_diff": "// TODO: Is it.format = format; // TODO: Is it.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// TODO: Is it.format = format; this.format = format; // TODO:",
                "patch_diff": "// TODO: Is it.format = format; this.format = format; // TODO:",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (format.getHeader() != null) { this.printRecord((Object[]) format.getHeader()); }"
    },
    "Lang-21": {
        "fixes": [
            {
                "k": 1,
                "patch": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-21/src/main/java/org/apache/commons/lang3/time/DateUtils.java\t2022-07-19 03:14:05.864847487 +0200\n+++ /tmp/tmp04pw6g65.java\t2022-07-19 03:14:05.896847305 +0200\n@@ -260,11 +260,11 @@\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                 cal1.getClass() == cal2.getClass());\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-21/src/main/java/org/apache/commons/lang3/time/DateUtils.java\t2022-07-19 03:14:15.368793982 +0200\n+++ /tmp/tmprcd_e_7l.java\t2022-07-19 03:14:15.368793982 +0200\n@@ -260,11 +260,11 @@\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                 cal1.getClass() == cal2.getClass());\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "cal1.get(Calendar.HOUR)!= cal2.get(Calendar.HOUR) &&",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-21/src/main/java/org/apache/commons/lang3/time/DateUtils.java\t2022-07-19 03:14:24.836740715 +0200\n+++ /tmp/tmpazk6uua2.java\t2022-07-19 03:14:24.840740692 +0200\n@@ -260,11 +260,11 @@\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+cal1.get(Calendar.HOUR)!= cal2.get(Calendar.HOUR) &&\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                 cal1.getClass() == cal2.getClass());\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && // no property name1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-21/src/main/java/org/apache/commons/lang3/time/DateUtils.java\t2022-07-19 03:14:34.188688131 +0200\n+++ /tmp/tmpl_jd2gtx.java\t2022-07-19 03:14:34.188688131 +0200\n@@ -260,11 +260,11 @@\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && // no property name1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                 cal1.getClass() == cal2.getClass());\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && // no cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-21/src/main/java/org/apache/commons/lang3/time/DateUtils.java\t2022-07-19 03:14:43.612635172 +0200\n+++ /tmp/tmpbwxvaar0.java\t2022-07-19 03:14:43.612635172 +0200\n@@ -260,11 +260,11 @@\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && // no cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                 cal1.getClass() == cal2.getClass());\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.HOUR) == cal2.get(Calendar.DAY_OF_MONTH) &&",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-21/src/main/java/org/apache/commons/lang3/time/DateUtils.java\t2022-07-19 03:14:53.020582333 +0200\n+++ /tmp/tmp3_z_0fmo.java\t2022-07-19 03:14:53.024582312 +0200\n@@ -260,11 +260,11 @@\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.HOUR) == cal2.get(Calendar.DAY_OF_MONTH) &&\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                 cal1.getClass() == cal2.getClass());\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.HOUR) &&",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-21/src/main/java/org/apache/commons/lang3/time/DateUtils.java\t2022-07-19 03:15:02.488529189 +0200\n+++ /tmp/tmpgtvyh577.java\t2022-07-19 03:15:02.492529166 +0200\n@@ -260,11 +260,11 @@\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.HOUR) &&\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                 cal1.getClass() == cal2.getClass());\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_MONTH) == cal2.get(Calendar.HOUR) &&",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-21/src/main/java/org/apache/commons/lang3/time/DateUtils.java\t2022-07-19 03:15:12.044475579 +0200\n+++ /tmp/tmp7dwk2crg.java\t2022-07-19 03:15:12.044475579 +0200\n@@ -260,11 +260,11 @@\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_MONTH) == cal2.get(Calendar.HOUR) &&\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                 cal1.getClass() == cal2.getClass());\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && // no1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-21/src/main/java/org/apache/commons/lang3/time/DateUtils.java\t2022-07-19 03:15:21.676421573 +0200\n+++ /tmp/tmptbazy4rg.java\t2022-07-19 03:15:21.680421549 +0200\n@@ -260,11 +260,11 @@\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && // no1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                 cal1.getClass() == cal2.getClass());\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && // name1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-21/src/main/java/org/apache/commons/lang3/time/DateUtils.java\t2022-07-19 03:15:31.176368337 +0200\n+++ /tmp/tmpcc7ab4wv.java\t2022-07-19 03:15:31.180368314 +0200\n@@ -260,11 +260,11 @@\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && // name1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                 cal1.getClass() == cal2.getClass());\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&",
        "fixed_line": "cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&"
    },
    "Closure-118": {
        "fixes": [
            {
                "k": 1,
                "patch": "// name = n.getFirstChild(); child = child.getNext()) {",
                "patch_diff": "// name = n.getFirstChild(); child = child.getNext()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// name = child.getFirstChild(); child = child.getNext()) {",
                "patch_diff": "// name = child.getFirstChild(); child = child.getNext()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// Function STRING child = n.getFirstChild(); child = child.getNext()) {",
                "patch_diff": "// Function STRING child = n.getFirstChild(); child = child.getNext()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// n.getFirstChild(); child = child.getNext()) {",
                "patch_diff": "// n.getFirstChild(); child = child.getNext()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// name node type = child.getFirstChild(); child = child.getNext()) {",
                "patch_diff": "// name node type = child.getFirstChild(); child = child.getNext()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// n = child.getFirstChild(); child = child.getNext()) {",
                "patch_diff": "// n = child.getFirstChild(); child = child.getNext()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// name = n.getFirstChild(); child = n.getNext()) {",
                "patch_diff": "// name = n.getFirstChild(); child = n.getNext()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// // can be null if it.getFirstChild(); child = child.getNext()) {",
                "patch_diff": "// // can be null if it.getFirstChild(); child = child.getNext()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// name = child.getFirstChild(); child = n.getNext()) {",
                "patch_diff": "// name = child.getFirstChild(); child = n.getNext()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// Function STRING child = n.getFirstChild(); child = n.getNext()) {",
                "patch_diff": "// Function STRING child = n.getFirstChild(); child = n.getNext()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (child.isQuotedString()) { continue; }"
    },
    "Chart-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "this.dataset = dataset; // the dataset when the dataset is to the dataset (this.dataset;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2022-07-19 03:15:42.400305472 +0200\n+++ /tmp/tmpw5jpjd6u.java\t2022-07-19 03:15:42.428305315 +0200\n@@ -140,11 +140,11 @@\n      *\n      * @param dataset  the dataset (<code>null</code> permitted).\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+this.dataset = dataset; // the dataset when the dataset is to the dataset (this.dataset;\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "this.dataset = dataset; // the dataset when the dataset is to the dataset (this.dataset = dataset;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2022-07-19 03:15:50.676259145 +0200\n+++ /tmp/tmpcfyoekgp.java\t2022-07-19 03:15:50.692259058 +0200\n@@ -140,11 +140,11 @@\n      *\n      * @param dataset  the dataset (<code>null</code> permitted).\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+this.dataset = dataset; // the dataset when the dataset is to the dataset (this.dataset = dataset;\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "this.dataset = dataset; // the dataset when the dataset is to the dataset (this.dataset)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2022-07-19 03:15:58.684214340 +0200\n+++ /tmp/tmp0xzjtdtl.java\t2022-07-19 03:15:58.688214316 +0200\n@@ -140,11 +140,11 @@\n      *\n      * @param dataset  the dataset (<code>null</code> permitted).\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+this.dataset = dataset; // the dataset when the dataset is to the dataset (this.dataset)\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "this.dataset = dataset; // the dataset when the dataset is to the dataset (dataset) this.dataset;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2022-07-19 03:16:06.624169932 +0200\n+++ /tmp/tmp32a447it.java\t2022-07-19 03:16:06.644169821 +0200\n@@ -140,11 +140,11 @@\n      *\n      * @param dataset  the dataset (<code>null</code> permitted).\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+this.dataset = dataset; // the dataset when the dataset is to the dataset (dataset) this.dataset;\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "this.dataset = dataset; // the dataset when the dataset (this.dataset = dataset;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2022-07-19 03:16:14.960123330 +0200\n+++ /tmp/tmpgo7yfimo.java\t2022-07-19 03:16:14.960123330 +0200\n@@ -140,11 +140,11 @@\n      *\n      * @param dataset  the dataset (<code>null</code> permitted).\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+this.dataset = dataset; // the dataset when the dataset (this.dataset = dataset;\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "this.dataset = dataset; // the dataset (this.dataset = dataset;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2022-07-19 03:16:23.128077685 +0200\n+++ /tmp/tmp8iobl1m4.java\t2022-07-19 03:16:23.128077685 +0200\n@@ -140,11 +140,11 @@\n      *\n      * @param dataset  the dataset (<code>null</code> permitted).\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+this.dataset = dataset; // the dataset (this.dataset = dataset;\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "this.dataset = dataset; // the dataset when the dataset (this.dataset)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2022-07-19 03:16:31.168032774 +0200\n+++ /tmp/tmpfbbjqm9f.java\t2022-07-19 03:16:31.168032774 +0200\n@@ -140,11 +140,11 @@\n      *\n      * @param dataset  the dataset (<code>null</code> permitted).\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+this.dataset = dataset; // the dataset when the dataset (this.dataset)\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "this.dataset = dataset; // the dataset (dataset) this.dataset = dataset;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2022-07-19 03:16:39.075988617 +0200\n+++ /tmp/tmp_d32uwey.java\t2022-07-19 03:16:39.075988617 +0200\n@@ -140,11 +140,11 @@\n      *\n      * @param dataset  the dataset (<code>null</code> permitted).\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+this.dataset = dataset; // the dataset (dataset) this.dataset = dataset;\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "this.dataset = dataset; // the dataset when the dataset is to the dataset is to the dataset (this.dataset;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2022-07-19 03:16:47.079943943 +0200\n+++ /tmp/tmpd_h2zh2v.java\t2022-07-19 03:16:47.095943853 +0200\n@@ -140,11 +140,11 @@\n      *\n      * @param dataset  the dataset (<code>null</code> permitted).\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+this.dataset = dataset; // the dataset when the dataset is to the dataset is to the dataset (this.dataset;\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "this.dataset = dataset; // the dataset when the dataset is to the dataset is to the dataset (dataset) this.dataset;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2022-07-19 03:16:55.207898592 +0200\n+++ /tmp/tmpr2ky5bjm.java\t2022-07-19 03:16:55.211898571 +0200\n@@ -140,11 +140,11 @@\n      *\n      * @param dataset  the dataset (<code>null</code> permitted).\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+this.dataset = dataset; // the dataset when the dataset is to the dataset is to the dataset (dataset) this.dataset;\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "this.dataset = dataset;",
        "fixed_line": "setDataset(dataset);"
    },
    "Chart-20": {
        "fixes": [
            {
                "k": 1,
                "patch": "super(paint, stroke, outlinePaint, stroke, alpha);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-20/source/org/jfree/chart/plot/ValueMarker.java\t2022-07-19 03:17:03.475852479 +0200\n+++ /tmp/tmpwc74pkot.java\t2022-07-19 03:17:03.531852168 +0200\n@@ -90,11 +90,11 @@\n      * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n      * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+super(paint, stroke, outlinePaint, stroke, alpha);\n         this.value = value;\n     }\n     \n     /**\n      * Returns the value.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "super(paint, stroke, outlinePaint, outlineStroke, alpha);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-20/source/org/jfree/chart/plot/ValueMarker.java\t2022-07-19 03:17:12.435802526 +0200\n+++ /tmp/tmpkio14qwm.java\t2022-07-19 03:17:12.435802526 +0200\n@@ -90,11 +90,11 @@\n      * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n      * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+super(paint, stroke, outlinePaint, outlineStroke, alpha);\n         this.value = value;\n     }\n     \n     /**\n      * Returns the value.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 3,
                "patch": "super(paint, stroke, paint, stroke, alpha);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-20/source/org/jfree/chart/plot/ValueMarker.java\t2022-07-19 03:17:20.095759838 +0200\n+++ /tmp/tmpm79r99r5.java\t2022-07-19 03:17:20.095759838 +0200\n@@ -90,11 +90,11 @@\n      * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n      * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+super(paint, stroke, paint, stroke, alpha);\n         this.value = value;\n     }\n     \n     /**\n      * Returns the value.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "super(paint, stroke, outlinePaint, paint, stroke, alpha);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-20/source/org/jfree/chart/plot/ValueMarker.java\t2022-07-19 03:17:27.923716229 +0200\n+++ /tmp/tmpsrtxdc1h.java\t2022-07-19 03:17:28.143715003 +0200\n@@ -90,11 +90,11 @@\n      * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n      * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+super(paint, stroke, outlinePaint, paint, stroke, alpha);\n         this.value = value;\n     }\n     \n     /**\n      * Returns the value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "super(paint, stroke, alpha, outlinePaint, stroke, alpha);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-20/source/org/jfree/chart/plot/ValueMarker.java\t2022-07-19 03:17:29.915705134 +0200\n+++ /tmp/tmp3f0ny76e.java\t2022-07-19 03:17:29.915705134 +0200\n@@ -90,11 +90,11 @@\n      * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n      * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+super(paint, stroke, alpha, outlinePaint, stroke, alpha);\n         this.value = value;\n     }\n     \n     /**\n      * Returns the value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "super(paint, stroke, stroke, alpha);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-20/source/org/jfree/chart/plot/ValueMarker.java\t2022-07-19 03:17:31.631695577 +0200\n+++ /tmp/tmp7nyg9n55.java\t2022-07-19 03:17:31.631695577 +0200\n@@ -90,11 +90,11 @@\n      * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n      * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+super(paint, stroke, stroke, alpha);\n         this.value = value;\n     }\n     \n     /**\n      * Returns the value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "super(paint, stroke, this.paint, stroke, alpha);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-20/source/org/jfree/chart/plot/ValueMarker.java\t2022-07-19 03:17:33.431685555 +0200\n+++ /tmp/tmprwh7qto8.java\t2022-07-19 03:17:33.431685555 +0200\n@@ -90,11 +90,11 @@\n      * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n      * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+super(paint, stroke, this.paint, stroke, alpha);\n         this.value = value;\n     }\n     \n     /**\n      * Returns the value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "super(paint, stroke, outlinePaint, alpha);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-20/source/org/jfree/chart/plot/ValueMarker.java\t2022-07-19 03:17:35.127676111 +0200\n+++ /tmp/tmph46e253c.java\t2022-07-19 03:17:35.127676111 +0200\n@@ -90,11 +90,11 @@\n      * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n      * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+super(paint, stroke, outlinePaint, alpha);\n         this.value = value;\n     }\n     \n     /**\n      * Returns the value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "super(paint, stroke, outlinePaint, stroke, outlineStroke, alpha);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-20/source/org/jfree/chart/plot/ValueMarker.java\t2022-07-19 03:17:36.927666088 +0200\n+++ /tmp/tmptuqm55v9.java\t2022-07-19 03:17:36.927666088 +0200\n@@ -90,11 +90,11 @@\n      * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n      * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+super(paint, stroke, outlinePaint, stroke, outlineStroke, alpha);\n         this.value = value;\n     }\n     \n     /**\n      * Returns the value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "super(paint, stroke, alpha, stroke, alpha);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-20/source/org/jfree/chart/plot/ValueMarker.java\t2022-07-19 03:17:38.783655753 +0200\n+++ /tmp/tmpdv952kju.java\t2022-07-19 03:17:38.787655733 +0200\n@@ -90,11 +90,11 @@\n      * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n      * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+super(paint, stroke, alpha, stroke, alpha);\n         this.value = value;\n     }\n     \n     /**\n      * Returns the value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "super(paint, stroke, paint, stroke, alpha);",
        "fixed_line": "super(paint, stroke, outlinePaint, outlineStroke, alpha);"
    },
    "Collections-28": {
        "fixes": [
            {
                "k": 1,
                "patch": "final boolean toInclusive = toKey, fromInclusive, toKey, toInclusive); return new RangeEntryMap(fromKey, toInclusive, toKey, toInclusive); } else { return new RangeEntryMap(fromKey, toInclusive, toKey, toInclusive); } }",
                "patch_diff": "final boolean toInclusive = toKey, fromInclusive, toKey, toInclusive); return new RangeEntryMap(fromKey, toInclusive, toKey, toInclusive); } else { return new RangeEntryMap(fromKey, toInclusive, toKey, toInclusive); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "final boolean toInclusive = toKey, fromInclusive, toKey, toInclusive); return new RangeEntryMap(fromKey, toInclusive, toKey, toInclusive); }",
                "patch_diff": "final boolean toInclusive = toKey, fromInclusive, toKey, toInclusive); return new RangeEntryMap(fromKey, toInclusive, toKey, toInclusive); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "final boolean toInclusive = toKey, fromInclusive, toKey, toInclusive); return new RangeEntryMap(fromKey, toInclusive, toKey, toInclusive); } else { return new RangeEntryMap(fromKey, toKey, toInclusive, toKey, toInclusive); } }",
                "patch_diff": "final boolean toInclusive = toKey, fromInclusive, toKey, toInclusive); return new RangeEntryMap(fromKey, toInclusive, toKey, toInclusive); } else { return new RangeEntryMap(fromKey, toKey, toInclusive, toKey, toInclusive); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "final boolean toKey, fromInclusive, toKey, toInclusive); return new RangeEntryMap(fromKey, toInclusive, toKey, toInclusive); }",
                "patch_diff": "final boolean toKey, fromInclusive, toKey, toInclusive); return new RangeEntryMap(fromKey, toInclusive, toKey, toInclusive); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return toKey, fromInclusive, toKey, toInclusive); } else { return new RangeEntryMap(fromKey, toKey, toInclusive, toKey, toInclusive); } else { return new RangeEntryMap(fromKey, toKey, toInclusive, toKey, toInclusive); } }",
                "patch_diff": "return toKey, fromInclusive, toKey, toInclusive); } else { return new RangeEntryMap(fromKey, toKey, toInclusive, toKey, toInclusive); } else { return new RangeEntryMap(fromKey, toKey, toInclusive, toKey, toInclusive); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return toKey, fromInclusive, toKey, toInclusive); } else { return new RangeEntryMap(fromKey, toKey, toInclusive, toKey, toInclusive); } else { return new RangeEntryMap(fromKey, toInclusive, toKey, toInclusive); } }",
                "patch_diff": "return toKey, fromInclusive, toKey, toInclusive); } else { return new RangeEntryMap(fromKey, toKey, toInclusive, toKey, toInclusive); } else { return new RangeEntryMap(fromKey, toInclusive, toKey, toInclusive); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "final boolean toInclusive = toKey, fromInclusive, toKey, toInclusive); return new RangeEntryMap(fromKey, toInclusive, toKey, toInclusive); } else { return new RangeEntryMap(fromKey, toKey, toInclusive, toInclusive, toKey, toInclusive); } }",
                "patch_diff": "final boolean toInclusive = toKey, fromInclusive, toKey, toInclusive); return new RangeEntryMap(fromKey, toInclusive, toKey, toInclusive); } else { return new RangeEntryMap(fromKey, toKey, toInclusive, toInclusive, toKey, toInclusive); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "final boolean toInclusive = toKey, fromInclusive, toKey, toInclusive); return new RangeEntryMap(fromKey, toInclusive, toKey, toInclusive); } else { return new RangeEntryMap(fromKey, toInclusive, toKey, toInclusive, toInclusive); } }",
                "patch_diff": "final boolean toInclusive = toKey, fromInclusive, toKey, toInclusive); return new RangeEntryMap(fromKey, toInclusive, toKey, toInclusive); } else { return new RangeEntryMap(fromKey, toInclusive, toKey, toInclusive, toInclusive); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return toKey, fromInclusive, toKey, toInclusive); } else { return new RangeEntryMap(fromKey, toKey, toInclusive, toKey, toInclusive); } }",
                "patch_diff": "return toKey, fromInclusive, toKey, toInclusive); } else { return new RangeEntryMap(fromKey, toKey, toInclusive, toKey, toInclusive); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return toKey, fromInclusive, toKey, toInclusive); } else { return new RangeEntryMap(fromKey, toInclusive, toKey, toInclusive); } }",
                "patch_diff": "return toKey, fromInclusive, toKey, toInclusive); } else { return new RangeEntryMap(fromKey, toInclusive, toKey, toInclusive); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "@Override public void clear() { Iterator<Map.Entry<K, V>> it = AbstractPatriciaTrie.this.entrySet().iterator(); Set<K> currentKeys = keySet(); while (it.hasNext()) { if (currentKeys.contains(it.next().getKey())) { it.remove(); } } }"
    },
    "Closure-130": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (name.globalSets == 1 && name.localSets == 0 && // no property name.aliasingGets > 0) // empty String means 'default'",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-130/src/com/google/javascript/jscomp/CollapseProperties.java\t2022-07-19 03:17:42.675634087 +0200\n+++ /tmp/tmpivrilk6j.java\t2022-07-19 03:17:42.695633976 +0200\n@@ -167,11 +167,11 @@\n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+if (name.globalSets == 1 && name.localSets == 0 && // no property name.aliasingGets > 0) // empty String means 'default'\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (name.globalSets == 1 && name.localSets == 0 && // no property name.aliasingGets > 0) // empty String meaning \"use default name.aliasingGets",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-130/src/com/google/javascript/jscomp/CollapseProperties.java\t2022-07-19 03:18:29.387374326 +0200\n+++ /tmp/tmplfwqctew.java\t2022-07-19 03:18:29.391374302 +0200\n@@ -167,11 +167,11 @@\n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+if (name.globalSets == 1 && name.localSets == 0 && // no property name.aliasingGets > 0) // empty String meaning \"use default name.aliasingGets\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (name.globalSets == 1 && name.localSets == 0 && // name.aliasingGets > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-130/src/com/google/javascript/jscomp/CollapseProperties.java\t2022-07-19 03:19:13.307130529 +0200\n+++ /tmp/tmpzwaa6sjg.java\t2022-07-19 03:19:13.311130504 +0200\n@@ -167,11 +167,11 @@\n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+if (name.globalSets == 1 && name.localSets == 0 && // name.aliasingGets > 0) {\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (name.globalSets == 1 && name.localSets == 0 && // sign/user default name.aliasingGets > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-130/src/com/google/javascript/jscomp/CollapseProperties.java\t2022-07-19 03:19:58.514879986 +0200\n+++ /tmp/tmps_qexyyw.java\t2022-07-19 03:19:58.514879986 +0200\n@@ -167,11 +167,11 @@\n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+if (name.globalSets == 1 && name.localSets == 0 && // sign/user default name.aliasingGets > 0) {\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (name.globalSets == 1 && name.localSets == 0 && // no property name.aliasingGets > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-130/src/com/google/javascript/jscomp/CollapseProperties.java\t2022-07-19 03:20:42.758635151 +0200\n+++ /tmp/tmpt_rqk2ix.java\t2022-07-19 03:20:42.762635127 +0200\n@@ -167,11 +167,11 @@\n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+if (name.globalSets == 1 && name.localSets == 0 && // no property name.aliasingGets > 0) {\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (name.globalSets == 1 && name.localSets == 0 && // no property-inExterns)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-130/src/com/google/javascript/jscomp/CollapseProperties.java\t2022-07-19 03:21:26.890391263 +0200\n+++ /tmp/tmpyv9027yk.java\t2022-07-19 03:21:26.890391263 +0200\n@@ -167,11 +167,11 @@\n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+if (name.globalSets == 1 && name.localSets == 0 && // no property-inExterns)\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (name.globalSets == 1 && name.localSets == 0 && // no property name.aliasingGets > 0)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-130/src/com/google/javascript/jscomp/CollapseProperties.java\t2022-07-19 03:22:11.026147661 +0200\n+++ /tmp/tmpii3e3b62.java\t2022-07-19 03:22:11.026147661 +0200\n@@ -167,11 +167,11 @@\n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+if (name.globalSets == 1 && name.localSets == 0 && // no property name.aliasingGets > 0)\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (name.globalSets == 1 && name.localSets == 0 && // no property name.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-130/src/com/google/javascript/jscomp/CollapseProperties.java\t2022-07-19 03:22:56.413897433 +0200\n+++ /tmp/tmp2i9j2a3q.java\t2022-07-19 03:22:56.417897412 +0200\n@@ -167,11 +167,11 @@\n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+if (name.globalSets == 1 && name.localSets == 0 && // no property name.\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (name.globalSets == 1 && name.localSets == 0 && // name.aliasingGets > 0) // empty String means 'default'",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-130/src/com/google/javascript/jscomp/CollapseProperties.java\t2022-07-19 03:23:41.229650623 +0200\n+++ /tmp/tmp49kdfz5v.java\t2022-07-19 03:23:41.229650623 +0200\n@@ -167,11 +167,11 @@\n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+if (name.globalSets == 1 && name.localSets == 0 && // name.aliasingGets > 0) // empty String means 'default'\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (name.globalSets == 1 && name.localSets == 0 &&",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-130/src/com/google/javascript/jscomp/CollapseProperties.java\t2022-07-19 03:24:25.873404999 +0200\n+++ /tmp/tmprzfuqjke.java\t2022-07-19 03:24:25.873404999 +0200\n@@ -167,11 +167,11 @@\n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+if (name.globalSets == 1 && name.localSets == 0 &&\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (name.globalSets == 1 && name.localSets == 0 &&",
        "fixed_line": "if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 &&"
    },
    "Gson-15": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (Double.isNaN(value) || Double.isInfinite(value)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-15/gson/src/main/java/com/google/gson/stream/JsonWriter.java\t2022-07-19 03:25:10.853157748 +0200\n+++ /tmp/tmpau8vrkha.java\t2022-07-19 03:25:10.877157615 +0200\n@@ -490,11 +490,11 @@\n    *     {@link Double#isInfinite() infinities}.\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n     writeDeferredName();\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+if (Double.isNaN(value) || Double.isInfinite(value)) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (Double.isNaN(value) && Double.isInfinite(value)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-15/gson/src/main/java/com/google/gson/stream/JsonWriter.java\t2022-07-19 03:25:14.769136231 +0200\n+++ /tmp/tmpqyh9nfwq.java\t2022-07-19 03:25:14.773136210 +0200\n@@ -490,11 +490,11 @@\n    *     {@link Double#isInfinite() infinities}.\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n     writeDeferredName();\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+if (Double.isNaN(value) && Double.isInfinite(value)) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (Double.isNaN(value instanceof Double) || Double.isInfinite(value)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-15/gson/src/main/java/com/google/gson/stream/JsonWriter.java\t2022-07-19 03:25:18.449116014 +0200\n+++ /tmp/tmpc8i0u082.java\t2022-07-19 03:25:18.453115991 +0200\n@@ -490,11 +490,11 @@\n    *     {@link Double#isInfinite() infinities}.\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n     writeDeferredName();\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+if (Double.isNaN(value instanceof Double) || Double.isInfinite(value)) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (Double.isNaN(value)) || Double.isInfinite(value)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-15/gson/src/main/java/com/google/gson/stream/JsonWriter.java\t2022-07-19 03:25:20.137106741 +0200\n+++ /tmp/tmpxzgyzht5.java\t2022-07-19 03:25:20.137106741 +0200\n@@ -490,11 +490,11 @@\n    *     {@link Double#isInfinite() infinities}.\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n     writeDeferredName();\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+if (Double.isNaN(value)) || Double.isInfinite(value)) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (Double.isNaN(value)) || Double.isInfinite(value)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-15/gson/src/main/java/com/google/gson/stream/JsonWriter.java\t2022-07-19 03:25:21.685098236 +0200\n+++ /tmp/tmpw5c5nghh.java\t2022-07-19 03:25:21.685098236 +0200\n@@ -490,11 +490,11 @@\n    *     {@link Double#isInfinite() infinities}.\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n     writeDeferredName();\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+if (Double.isNaN(value)) || Double.isInfinite(value)) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (Double.isNaN(value || Double.isInfinite(value)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-15/gson/src/main/java/com/google/gson/stream/JsonWriter.java\t2022-07-19 03:25:23.233089732 +0200\n+++ /tmp/tmp_qp3l3ii.java\t2022-07-19 03:25:23.233089732 +0200\n@@ -490,11 +490,11 @@\n    *     {@link Double#isInfinite() infinities}.\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n     writeDeferredName();\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+if (Double.isNaN(value || Double.isInfinite(value)) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if(Double.isNaN(value) || Double.isInfinite(value)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-15/gson/src/main/java/com/google/gson/stream/JsonWriter.java\t2022-07-19 03:25:24.833080942 +0200\n+++ /tmp/tmp8a552rzs.java\t2022-07-19 03:25:24.833080942 +0200\n@@ -490,11 +490,11 @@\n    *     {@link Double#isInfinite() infinities}.\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n     writeDeferredName();\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+if(Double.isNaN(value) || Double.isInfinite(value)) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (Double.isNaN(value instanceof Double.isInfinite(value)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-15/gson/src/main/java/com/google/gson/stream/JsonWriter.java\t2022-07-19 03:25:28.625060113 +0200\n+++ /tmp/tmpgpc2cwnm.java\t2022-07-19 03:25:28.625060113 +0200\n@@ -490,11 +490,11 @@\n    *     {@link Double#isInfinite() infinities}.\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n     writeDeferredName();\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+if (Double.isNaN(value instanceof Double.isInfinite(value)) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (Double.isNaN(value). || Double.isInfinite(value)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-15/gson/src/main/java/com/google/gson/stream/JsonWriter.java\t2022-07-19 03:25:30.193051499 +0200\n+++ /tmp/tmpfyq9ta9i.java\t2022-07-19 03:25:30.193051499 +0200\n@@ -490,11 +490,11 @@\n    *     {@link Double#isInfinite() infinities}.\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n     writeDeferredName();\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+if (Double.isNaN(value). || Double.isInfinite(value)) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (Double.isNaN(value) || Double.isInfinite(value)) { // value is lower case",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-15/gson/src/main/java/com/google/gson/stream/JsonWriter.java\t2022-07-19 03:25:31.685043305 +0200\n+++ /tmp/tmpsa1wf9t9.java\t2022-07-19 03:25:31.685043305 +0200\n@@ -490,11 +490,11 @@\n    *     {@link Double#isInfinite() infinities}.\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n     writeDeferredName();\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+if (Double.isNaN(value) || Double.isInfinite(value)) { // value is lower case\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (Double.isNaN(value) || Double.isInfinite(value)) {",
        "fixed_line": "if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) {"
    },
    "Gson-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "return null; case NUMBER: return new JsonSyntaxException(\"Expecting number, got: \" + jsonToken); } }",
                "patch_diff": "return null; case NUMBER: return new JsonSyntaxException(\"Expecting number, got: \" + jsonToken); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return null; case NUMBER: return new JsonSyntaxException(\"Expecting number, got: \" + jsonToken); }",
                "patch_diff": "return null; case NUMBER: return new JsonSyntaxException(\"Expecting number, got: \" + jsonToken); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken); } }",
                "patch_diff": "throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken); }",
                "patch_diff": "throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return null; case NUMBER: return new JsonSyntaxException(\"Expecting number, got: \" + jsonToken()); } }",
                "patch_diff": "return null; case NUMBER: return new JsonSyntaxException(\"Expecting number, got: \" + jsonToken()); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return null; case NUMBER: throw new JsonSyntaxException(\"Expecting number: \" + jsonToken); } }",
                "patch_diff": "return null; case NUMBER: throw new JsonSyntaxException(\"Expecting number: \" + jsonToken); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return null; case NUMBER: throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken); } }",
                "patch_diff": "return null; case NUMBER: throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return null; case NUMBER: return new JsonSyntaxException(\"Expecting number, got: \" + jsonToken());",
                "patch_diff": "return null; case NUMBER: return new JsonSyntaxException(\"Expecting number, got: \" + jsonToken());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return null; case NUMBER: return new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);",
                "patch_diff": "return null; case NUMBER: return new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return null; case NUMBER: return new JsonSyntaxException(\"Expecting number, got: \" + jsonToken); } else {",
                "patch_diff": "return null; case NUMBER: return new JsonSyntaxException(\"Expecting number, got: \" + jsonToken); } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "case STRING:"
    },
    "Closure-113": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (provided == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-113/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 03:25:37.429011757 +0200\n+++ /tmp/tmpv40_ai6b.java\t2022-07-19 03:25:37.449011649 +0200\n@@ -324,11 +324,11 @@\n       // Requires should be removed before further processing.\n       // Some clients run closure pass multiple times, first with\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+if (provided == null) {\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n     }\n   }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (parent!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-113/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 03:26:31.488714993 +0200\n+++ /tmp/tmp9ow3ai2l.java\t2022-07-19 03:26:31.488714993 +0200\n@@ -324,11 +324,11 @@\n       // Requires should be removed before further processing.\n       // Some clients run closure pass multiple times, first with\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+if (parent!= null) {\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n     }\n   }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (provided == null) { // block == null; can't really modify it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-113/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 03:27:21.936438284 +0200\n+++ /tmp/tmpsx8k3ll9.java\t2022-07-19 03:27:21.940438260 +0200\n@@ -324,11 +324,11 @@\n       // Requires should be removed before further processing.\n       // Some clients run closure pass multiple times, first with\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+if (provided == null) { // block == null; can't really modify it's do implicit re-parse\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n     }\n   }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (provided == null) { // block == null; can't be null if we're not use a native function.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-113/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 03:28:12.128163172 +0200\n+++ /tmp/tmpkrbd9_q2.java\t2022-07-19 03:28:12.128163172 +0200\n@@ -324,11 +324,11 @@\n       // Requires should be removed before further processing.\n       // Some clients run closure pass multiple times, first with\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+if (provided == null) { // block == null; can't be null if we're not use a native function.\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n     }\n   }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (provided == null) { // block == null; can't be null if we're not.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-113/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 03:29:01.947890277 +0200\n+++ /tmp/tmp7fkzloy0.java\t2022-07-19 03:29:01.951890253 +0200\n@@ -324,11 +324,11 @@\n       // Requires should be removed before further processing.\n       // Some clients run closure pass multiple times, first with\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+if (provided == null) { // block == null; can't be null if we're not.\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n     }\n   }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (provided == null) { // block == null; can't really modify it's do implicit re-initialized or EMPTY",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-113/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 03:29:51.859617034 +0200\n+++ /tmp/tmpb4893l84.java\t2022-07-19 03:29:51.859617034 +0200\n@@ -324,11 +324,11 @@\n       // Requires should be removed before further processing.\n       // Some clients run closure pass multiple times, first with\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+if (provided == null) { // block == null; can't really modify it's do implicit re-initialized or EMPTY\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n     }\n   }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (provided == null) { // block == null; can't really here here (parent!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-113/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 03:30:42.463340151 +0200\n+++ /tmp/tmpcoyqhywj.java\t2022-07-19 03:30:42.467340131 +0200\n@@ -324,11 +324,11 @@\n       // Requires should be removed before further processing.\n       // Some clients run closure pass multiple times, first with\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+if (provided == null) { // block == null; can't really here here (parent!= null) {\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n     }\n   }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (provided == null) { // block == null; non-empty's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-113/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 03:31:32.035069047 +0200\n+++ /tmp/tmpb81sn57y.java\t2022-07-19 03:31:32.035069047 +0200\n@@ -324,11 +324,11 @@\n       // Requires should be removed before further processing.\n       // Some clients run closure pass multiple times, first with\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+if (provided == null) { // block == null; non-empty's do implicit re-parse\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n     }\n   }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (provided == null) { // can't really modify it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-113/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 03:32:22.518793071 +0200\n+++ /tmp/tmpkn6bgo91.java\t2022-07-19 03:32:22.518793071 +0200\n@@ -324,11 +324,11 @@\n       // Requires should be removed before further processing.\n       // Some clients run closure pass multiple times, first with\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+if (provided == null) { // can't really modify it's do implicit re-parse\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n     }\n   }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (provided == null) { // block == null's do implicit re-initialized (parent!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-113/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 03:33:12.294521075 +0200\n+++ /tmp/tmpytxxytl5.java\t2022-07-19 03:33:12.298521056 +0200\n@@ -324,11 +324,11 @@\n       // Requires should be removed before further processing.\n       // Some clients run closure pass multiple times, first with\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+if (provided == null) { // block == null's do implicit re-initialized (parent!= null) {\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n     }\n   }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (provided != null) {",
        "fixed_line": "if (provided != null || requiresLevel.isOn()) {"
    },
    "Closure-70": {
        "fixes": [
            {
                "k": 1,
                "patch": "jsDocParameter.getJSType(), true);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-70/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 03:34:02.546246577 +0200\n+++ /tmp/tmp0c2kizfi.java\t2022-07-19 03:34:02.586246358 +0200\n@@ -1740,11 +1740,11 @@\n         if (jsDocParameters != null) {\n           Node jsDocParameter = jsDocParameters.getFirstChild();\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+jsDocParameter.getJSType(), true);\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n             }\n           }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "jsDocParameter.getJSType(), false);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-70/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 03:34:38.554049940 +0200\n+++ /tmp/tmp6w9yis9t.java\t2022-07-19 03:34:38.558049921 +0200\n@@ -1740,11 +1740,11 @@\n         if (jsDocParameters != null) {\n           Node jsDocParameter = jsDocParameters.getFirstChild();\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+jsDocParameter.getJSType(), false);\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n             }\n           }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 3,
                "patch": "jsDocParameter.getJSType(), true); // we need to check whether a jsDocParameter = jsDocParameter.getJSType();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-70/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 03:35:11.905867846 +0200\n+++ /tmp/tmp7rc4m706.java\t2022-07-19 03:35:11.909867824 +0200\n@@ -1740,11 +1740,11 @@\n         if (jsDocParameters != null) {\n           Node jsDocParameter = jsDocParameters.getFirstChild();\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+jsDocParameter.getJSType(), true); // we need to check whether a jsDocParameter = jsDocParameter.getJSType();\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n             }\n           }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "jsDocParameter.getJSType(), true); // we need to check whether a jsDocParameter = jsDocParameter.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-70/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 03:35:45.605683888 +0200\n+++ /tmp/tmpk23rsxwl.java\t2022-07-19 03:35:45.605683888 +0200\n@@ -1740,11 +1740,11 @@\n         if (jsDocParameters != null) {\n           Node jsDocParameter = jsDocParameters.getFirstChild();\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+jsDocParameter.getJSType(), true); // we need to check whether a jsDocParameter = jsDocParameter.\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n             }\n           }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "jsDocParameter.getJSType(), true); // we need to check whether a jsDocParameter = jsDocParameter.getJSType(), false);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-70/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 03:36:18.877502298 +0200\n+++ /tmp/tmp2qr84xcj.java\t2022-07-19 03:36:18.881502275 +0200\n@@ -1740,11 +1740,11 @@\n         if (jsDocParameters != null) {\n           Node jsDocParameter = jsDocParameters.getFirstChild();\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+jsDocParameter.getJSType(), true); // we need to check whether a jsDocParameter = jsDocParameter.getJSType(), false);\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n             }\n           }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "jsDocParameter.getJSType(), true); // we need to check whether a jsDocParameter.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-70/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 03:36:52.477315956 +0200\n+++ /tmp/tmp0qxq2bxm.java\t2022-07-19 03:36:52.477315956 +0200\n@@ -1740,11 +1740,11 @@\n         if (jsDocParameters != null) {\n           Node jsDocParameter = jsDocParameters.getFirstChild();\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+jsDocParameter.getJSType(), true); // we need to check whether a jsDocParameter.\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n             }\n           }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "jsDocParameter.getJSType(), true); // we need to check whether a jsDocParameter = jsDocParameter.getJSType(), true);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-70/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 03:37:25.961129372 +0200\n+++ /tmp/tmpklr8z2qb.java\t2022-07-19 03:37:25.961129372 +0200\n@@ -1740,11 +1740,11 @@\n         if (jsDocParameters != null) {\n           Node jsDocParameter = jsDocParameters.getFirstChild();\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+jsDocParameter.getJSType(), true); // we need to check whether a jsDocParameter = jsDocParameter.getJSType(), true);\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n             }\n           }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "jsDocParameter.getJSType(), true); // we need to check whether a jsDocParameter = jsDocParameter;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-70/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 03:37:59.276943964 +0200\n+++ /tmp/tmpvg2jf1kn.java\t2022-07-19 03:37:59.276943964 +0200\n@@ -1740,11 +1740,11 @@\n         if (jsDocParameters != null) {\n           Node jsDocParameter = jsDocParameters.getFirstChild();\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+jsDocParameter.getJSType(), true); // we need to check whether a jsDocParameter = jsDocParameter;\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n             }\n           }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "jsDocParameter.getJSType(), true); // we need to check whether a jsDocParameter = jsDocParameter.get(astParameter);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-70/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 03:38:32.820757511 +0200\n+++ /tmp/tmpwm0v32_z.java\t2022-07-19 03:38:32.820757511 +0200\n@@ -1740,11 +1740,11 @@\n         if (jsDocParameters != null) {\n           Node jsDocParameter = jsDocParameters.getFirstChild();\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+jsDocParameter.getJSType(), true); // we need to check whether a jsDocParameter = jsDocParameter.get(astParameter);\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n             }\n           }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "jsDocParameter.getJSType(), true); // we need to check whether a jsDocParameter = jsDocParameter.getJSType(astParameter);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-70/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 03:39:05.948573582 +0200\n+++ /tmp/tmpt7hvvjrs.java\t2022-07-19 03:39:05.952573559 +0200\n@@ -1740,11 +1740,11 @@\n         if (jsDocParameters != null) {\n           Node jsDocParameter = jsDocParameters.getFirstChild();\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+jsDocParameter.getJSType(), true); // we need to check whether a jsDocParameter = jsDocParameter.getJSType(astParameter);\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n             }\n           }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "jsDocParameter.getJSType(), true);",
        "fixed_line": "jsDocParameter.getJSType(), false);"
    },
    "JxPath-21": {
        "fixes": [
            {
                "k": 1,
                "patch": "return ValueUtils.getLength(value);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-21/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\t2022-07-19 03:39:39.624386806 +0200\n+++ /tmp/tmpx1xifuvg.java\t2022-07-19 03:39:39.652386651 +0200\n@@ -147,11 +147,11 @@\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      * @return int length\n      */\n     public int getLength() {\n-        return ValueUtils.getLength(getBaseValue());\n+return ValueUtils.getLength(value);\n     }\n \n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return ValueUtils.getLength(value); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-21/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\t2022-07-19 03:39:45.324355210 +0200\n+++ /tmp/tmptrfo2mfi.java\t2022-07-19 03:39:45.324355210 +0200\n@@ -147,11 +147,11 @@\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      * @return int length\n      */\n     public int getLength() {\n-        return ValueUtils.getLength(getBaseValue());\n+return ValueUtils.getLength(value); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n     }\n \n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return ValueUtils.getLength(value); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-21/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\t2022-07-19 03:39:50.844324620 +0200\n+++ /tmp/tmpq9g8tdx8.java\t2022-07-19 03:39:50.848324597 +0200\n@@ -147,11 +147,11 @@\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      * @return int length\n      */\n     public int getLength() {\n-        return ValueUtils.getLength(getBaseValue());\n+return ValueUtils.getLength(value); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n     }\n \n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return ValueUtils.getLength(value); // we didn't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-21/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\t2022-07-19 03:39:56.000296047 +0200\n+++ /tmp/tmpup1656qs.java\t2022-07-19 03:39:56.004296027 +0200\n@@ -147,11 +147,11 @@\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      * @return int length\n      */\n     public int getLength() {\n-        return ValueUtils.getLength(getBaseValue());\n+return ValueUtils.getLength(value); // we didn't really modify it's totalGJACKSON-notnotnotnot real number\n     }\n \n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return ValueUtils.getLength(value); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-21/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\t2022-07-19 03:40:01.344266441 +0200\n+++ /tmp/tmpo2uyba1n.java\t2022-07-19 03:40:01.344266441 +0200\n@@ -147,11 +147,11 @@\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      * @return int length\n      */\n     public int getLength() {\n-        return ValueUtils.getLength(getBaseValue());\n+return ValueUtils.getLength(value); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n     }\n \n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return ValueUtils.getLength(value); // we didn't really modify it's totalGJACKSON-notnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-21/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\t2022-07-19 03:40:06.532237703 +0200\n+++ /tmp/tmpy294qor9.java\t2022-07-19 03:40:06.532237703 +0200\n@@ -147,11 +147,11 @@\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      * @return int length\n      */\n     public int getLength() {\n-        return ValueUtils.getLength(getBaseValue());\n+return ValueUtils.getLength(value); // we didn't really modify it's totalGJACKSON-notnotnot real number\n     }\n \n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return ValueUtils.getLength(value); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-21/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\t2022-07-19 03:40:11.616209545 +0200\n+++ /tmp/tmpj60jw1um.java\t2022-07-19 03:40:11.616209545 +0200\n@@ -147,11 +147,11 @@\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      * @return int length\n      */\n     public int getLength() {\n-        return ValueUtils.getLength(getBaseValue());\n+return ValueUtils.getLength(value); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number\n     }\n \n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return ValueUtils.getLength(value); // we didn't really modify it's totalGJACKSON-notnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-21/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\t2022-07-19 03:40:17.184178710 +0200\n+++ /tmp/tmpe0d1wnll.java\t2022-07-19 03:40:17.184178710 +0200\n@@ -147,11 +147,11 @@\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      * @return int length\n      */\n     public int getLength() {\n-        return ValueUtils.getLength(getBaseValue());\n+return ValueUtils.getLength(value); // we didn't really modify it's totalGJACKSON-notnot real number\n     }\n \n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return ValueUtils.getLength(value); // value is lower case",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-21/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\t2022-07-19 03:40:22.452149541 +0200\n+++ /tmp/tmpeu1o59sh.java\t2022-07-19 03:40:22.452149541 +0200\n@@ -147,11 +147,11 @@\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      * @return int length\n      */\n     public int getLength() {\n-        return ValueUtils.getLength(getBaseValue());\n+return ValueUtils.getLength(value); // value is lower case\n     }\n \n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return ValueUtils.getLength(value); // we didn't really modify it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-21/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\t2022-07-19 03:40:27.792119976 +0200\n+++ /tmp/tmpnkx79ycy.java\t2022-07-19 03:40:27.792119976 +0200\n@@ -147,11 +147,11 @@\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      * @return int length\n      */\n     public int getLength() {\n-        return ValueUtils.getLength(getBaseValue());\n+return ValueUtils.getLength(value); // we didn't really modify it's do implicit re-parse\n     }\n \n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return ValueUtils.getLength(getBaseValue());",
        "fixed_line": "Object baseValue = getBaseValue(); return baseValue == null ? 1 : ValueUtils.getLength(baseValue);"
    },
    "Lang-17": {
        "fixes": [
            {
                "k": 1,
                "patch": "int len = Character.codePoint.codePointAt(pos, 0, len);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-17/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 03:40:33.564088030 +0200\n+++ /tmp/tmp54pcju0p.java\t2022-07-19 03:40:33.652087539 +0200\n@@ -78,30 +78,11 @@\n         }\n         if (input == null) {\n             return;\n         }\n         int pos = 0;\n-        int len = Character.codePointCount(input, 0, input.length());\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n-                out.write(c);\n-            }\n-            else {\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                    if (pos < len - 2) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n-                    } else {\n-                        pos++;\n-                    }\n-                }\n-                pos--;\n-            }\n-            pos++;\n+int len = Character.codePoint.codePointAt(pos, 0, len);\n         }\n     }\n \n     /**\n      * Helper method to create a merger of this translator with another set of \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int len = Character.codePointAt(pos, 0, len);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-17/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 03:40:35.280078528 +0200\n+++ /tmp/tmp1uhz_jom.java\t2022-07-19 03:40:35.296078440 +0200\n@@ -78,30 +78,11 @@\n         }\n         if (input == null) {\n             return;\n         }\n         int pos = 0;\n-        int len = Character.codePointCount(input, 0, input.length());\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n-                out.write(c);\n-            }\n-            else {\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                    if (pos < len - 2) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n-                    } else {\n-                        pos++;\n-                    }\n-                }\n-                pos--;\n-            }\n-            pos++;\n+int len = Character.codePointAt(pos, 0, len);\n         }\n     }\n \n     /**\n      * Helper method to create a merger of this translator with another set of \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int len = Character.codePointAt(input, 0, pos++;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-17/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 03:40:36.960069232 +0200\n+++ /tmp/tmp6_45o0_m.java\t2022-07-19 03:40:36.964069209 +0200\n@@ -78,30 +78,11 @@\n         }\n         if (input == null) {\n             return;\n         }\n         int pos = 0;\n-        int len = Character.codePointCount(input, 0, input.length());\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n-                out.write(c);\n-            }\n-            else {\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                    if (pos < len - 2) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n-                    } else {\n-                        pos++;\n-                    }\n-                }\n-                pos--;\n-            }\n-            pos++;\n+int len = Character.codePointAt(input, 0, pos++;\n         }\n     }\n \n     /**\n      * Helper method to create a merger of this translator with another set of \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int len = Character.codePoint.codePoint(0, pos); } else {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-17/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 03:40:38.428061107 +0200\n+++ /tmp/tmp9fxt8w_l.java\t2022-07-19 03:40:38.428061107 +0200\n@@ -78,30 +78,11 @@\n         }\n         if (input == null) {\n             return;\n         }\n         int pos = 0;\n-        int len = Character.codePointCount(input, 0, input.length());\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n-                out.write(c);\n-            }\n-            else {\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                    if (pos < len - 2) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n-                    } else {\n-                        pos++;\n-                    }\n-                }\n-                pos--;\n-            }\n-            pos++;\n+int len = Character.codePoint.codePoint(0, pos); } else {\n         }\n     }\n \n     /**\n      * Helper method to create a merger of this translator with another set of \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int len = Character.codePointAt(input, 0, pos);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-17/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 03:40:40.016052318 +0200\n+++ /tmp/tmpvv2u1e0z.java\t2022-07-19 03:40:40.016052318 +0200\n@@ -78,30 +78,11 @@\n         }\n         if (input == null) {\n             return;\n         }\n         int pos = 0;\n-        int len = Character.codePointCount(input, 0, input.length());\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n-                out.write(c);\n-            }\n-            else {\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                    if (pos < len - 2) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n-                    } else {\n-                        pos++;\n-                    }\n-                }\n-                pos--;\n-            }\n-            pos++;\n+int len = Character.codePointAt(input, 0, pos);\n         }\n     }\n \n     /**\n      * Helper method to create a merger of this translator with another set of \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int len = Character.codePoint.codePoint(0, pos); } else { pos++;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-17/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 03:40:41.460044327 +0200\n+++ /tmp/tmpb7tl6u7w.java\t2022-07-19 03:40:41.460044327 +0200\n@@ -78,30 +78,11 @@\n         }\n         if (input == null) {\n             return;\n         }\n         int pos = 0;\n-        int len = Character.codePointCount(input, 0, input.length());\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n-                out.write(c);\n-            }\n-            else {\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                    if (pos < len - 2) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n-                    } else {\n-                        pos++;\n-                    }\n-                }\n-                pos--;\n-            }\n-            pos++;\n+int len = Character.codePoint.codePoint(0, pos); } else { pos++;\n         }\n     }\n \n     /**\n      * Helper method to create a merger of this translator with another set of \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int len = Character.codePointAt(c, 0, pos++;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-17/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 03:40:42.940036139 +0200\n+++ /tmp/tmp4enicb3a.java\t2022-07-19 03:40:42.940036139 +0200\n@@ -78,30 +78,11 @@\n         }\n         if (input == null) {\n             return;\n         }\n         int pos = 0;\n-        int len = Character.codePointCount(input, 0, input.length());\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n-                out.write(c);\n-            }\n-            else {\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                    if (pos < len - 2) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n-                    } else {\n-                        pos++;\n-                    }\n-                }\n-                pos--;\n-            }\n-            pos++;\n+int len = Character.codePointAt(c, 0, pos++;\n         }\n     }\n \n     /**\n      * Helper method to create a merger of this translator with another set of \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int len = Character.codePoint.codePointAt(pos, 0, pos++;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-17/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 03:40:44.432027883 +0200\n+++ /tmp/tmp4ldxmlo2.java\t2022-07-19 03:40:44.432027883 +0200\n@@ -78,30 +78,11 @@\n         }\n         if (input == null) {\n             return;\n         }\n         int pos = 0;\n-        int len = Character.codePointCount(input, 0, input.length());\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n-                out.write(c);\n-            }\n-            else {\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                    if (pos < len - 2) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n-                    } else {\n-                        pos++;\n-                    }\n-                }\n-                pos--;\n-            }\n-            pos++;\n+int len = Character.codePoint.codePointAt(pos, 0, pos++;\n         }\n     }\n \n     /**\n      * Helper method to create a merger of this translator with another set of \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int len = Character.codePoint.codePoint(0, pos); } else if (pos < len) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-17/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 03:40:46.048018941 +0200\n+++ /tmp/tmpltyqcgfv.java\t2022-07-19 03:40:46.048018941 +0200\n@@ -78,30 +78,11 @@\n         }\n         if (input == null) {\n             return;\n         }\n         int pos = 0;\n-        int len = Character.codePointCount(input, 0, input.length());\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n-                out.write(c);\n-            }\n-            else {\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                    if (pos < len - 2) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n-                    } else {\n-                        pos++;\n-                    }\n-                }\n-                pos--;\n-            }\n-            pos++;\n+int len = Character.codePoint.codePoint(0, pos); } else if (pos < len) {\n         }\n     }\n \n     /**\n      * Helper method to create a merger of this translator with another set of \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int len = Character.codePoint.codePointAt(pos, 0, len); } else { pos++;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-17/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 03:40:47.572010509 +0200\n+++ /tmp/tmp30fq7x_7.java\t2022-07-19 03:40:47.572010509 +0200\n@@ -78,30 +78,11 @@\n         }\n         if (input == null) {\n             return;\n         }\n         int pos = 0;\n-        int len = Character.codePointCount(input, 0, input.length());\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n-                out.write(c);\n-            }\n-            else {\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                    if (pos < len - 2) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n-                    } else {\n-                        pos++;\n-                    }\n-                }\n-                pos--;\n-            }\n-            pos++;\n+int len = Character.codePoint.codePointAt(pos, 0, len); } else { pos++;\n         }\n     }\n \n     /**\n      * Helper method to create a merger of this translator with another set of \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "int len = Character.codePointCount(input, 0, input.length()); while (pos < len) { int consumed = translate(input, pos, out); if (consumed == 0) { char[] c = Character.toChars(Character.codePointAt(input, pos)); out.write(c); } else { // // contract with translators is that they have to understand codepoints // // and they just took care of a surrogate pair for (int pt = 0; pt < consumed; pt++) { if (pos < len - 2) { pos += Character.charCount(Character.codePointAt(input, pos)); } else { pos++; } } pos--; } pos++;",
        "fixed_line": "int len = input.length(); while (pos < len) { int consumed = translate(input, pos, out); if (consumed == 0) { char[] c = Character.toChars(Character.codePointAt(input, pos)); out.write(c); pos+= c.length; continue;"
    },
    "Jsoup-49": {
        "fixes": [
            {
                "k": 1,
                "patch": "reindexChildren(index);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-49/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 03:40:49.460000065 +0200\n+++ /tmp/tmpkswm3qrj.java\t2022-07-19 03:40:49.531999665 +0200\n@@ -441,11 +441,11 @@\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren(index);\n+reindexChildren(index);\n     }\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n             childNodes = new ArrayList<Node>(4);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "reindexChildren(index); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-49/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 03:40:53.463977912 +0200\n+++ /tmp/tmpmq1snh18.java\t2022-07-19 03:40:53.463977912 +0200\n@@ -441,11 +441,11 @@\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren(index);\n+reindexChildren(index); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n     }\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n             childNodes = new ArrayList<Node>(4);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "reindexChildren(index); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-49/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 03:40:56.863959102 +0200\n+++ /tmp/tmp1ye6eyww.java\t2022-07-19 03:40:56.863959102 +0200\n@@ -441,11 +441,11 @@\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren(index);\n+reindexChildren(index); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number\n     }\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n             childNodes = new ArrayList<Node>(4);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "reindexChildren(index); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-49/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 03:41:00.151940917 +0200\n+++ /tmp/tmp_9v72udt.java\t2022-07-19 03:41:00.151940917 +0200\n@@ -441,11 +441,11 @@\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren(index);\n+reindexChildren(index); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n     }\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n             childNodes = new ArrayList<Node>(4);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "reindexChildren(index); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-49/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 03:41:03.411922887 +0200\n+++ /tmp/tmpz5ylh97t.java\t2022-07-19 03:41:03.411922887 +0200\n@@ -441,11 +441,11 @@\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren(index);\n+reindexChildren(index); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number\n     }\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n             childNodes = new ArrayList<Node>(4);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "reindexChildren(index); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-49/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 03:41:06.659904924 +0200\n+++ /tmp/tmpes0h62d9.java\t2022-07-19 03:41:06.659904924 +0200\n@@ -441,11 +441,11 @@\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren(index);\n+reindexChildren(index); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnot real number\n     }\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n             childNodes = new ArrayList<Node>(4);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "reindexChildren(index); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-49/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 03:41:10.015886364 +0200\n+++ /tmp/tmphlvn05yw.java\t2022-07-19 03:41:10.015886364 +0200\n@@ -441,11 +441,11 @@\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren(index);\n+reindexChildren(index); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n     }\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n             childNodes = new ArrayList<Node>(4);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "reindexChildren(index); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-49/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 03:41:13.203868737 +0200\n+++ /tmp/tmp3yyap5op.java\t2022-07-19 03:41:13.203868737 +0200\n@@ -441,11 +441,11 @@\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren(index);\n+reindexChildren(index); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnotnot real number\n     }\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n             childNodes = new ArrayList<Node>(4);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "reindexChildren(index); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-49/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 03:41:16.527850359 +0200\n+++ /tmp/tmpxpxs5ww9.java\t2022-07-19 03:41:16.531850335 +0200\n@@ -441,11 +441,11 @@\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren(index);\n+reindexChildren(index); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnotnotnot real number\n     }\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n             childNodes = new ArrayList<Node>(4);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "reindexChildren(index); // we didn't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-49/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 03:41:19.851831980 +0200\n+++ /tmp/tmpjl8rhbau.java\t2022-07-19 03:41:19.851831980 +0200\n@@ -441,11 +441,11 @@\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren(index);\n+reindexChildren(index); // we didn't really modify it's totalGJACKSON-notnotnotnot real number\n     }\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n             childNodes = new ArrayList<Node>(4);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "reindexChildren(index);",
        "fixed_line": "reindexChildren(index);"
    },
    "JacksonDatabind-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "return _unknownType(); // Ok: here's's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-11/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 03:41:23.395812391 +0200\n+++ /tmp/tmpxy4ccys5.java\t2022-07-19 03:41:23.483811905 +0200\n@@ -890,18 +890,11 @@\n     {\n         final String name = type.getName();\n         // 19-Mar-2015: Without context, all we can check are bounds.\n         if (context == null) {\n             // And to prevent infinite loops, now need this:\n-            return _unknownType();\n-        } else {\n-            // Ok: here's where context might come in handy!\n-            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n-             *   unresolved type variables to handle some cases where bounds\n-             *   are enough. Let's hope it does not hide real fail cases.\n-             */\n-            JavaType actualType = context.findType(name);\n+return _unknownType(); // Ok: here's's do implicit re-parse\n             if (actualType != null) {\n                 return actualType;\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return _unknownType(); // Ok: here's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-11/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 03:41:25.575800340 +0200\n+++ /tmp/tmpe5l7ta15.java\t2022-07-19 03:41:25.579800316 +0200\n@@ -890,18 +890,11 @@\n     {\n         final String name = type.getName();\n         // 19-Mar-2015: Without context, all we can check are bounds.\n         if (context == null) {\n             // And to prevent infinite loops, now need this:\n-            return _unknownType();\n-        } else {\n-            // Ok: here's where context might come in handy!\n-            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n-             *   unresolved type variables to handle some cases where bounds\n-             *   are enough. Let's hope it does not hide real fail cases.\n-             */\n-            JavaType actualType = context.findType(name);\n+return _unknownType(); // Ok: here's do implicit re-parse\n             if (actualType != null) {\n                 return actualType;\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return _unknownType(); // Ok: here's's do implicit re-closed",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-11/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 03:41:27.503789683 +0200\n+++ /tmp/tmpu3ewnhtu.java\t2022-07-19 03:41:27.503789683 +0200\n@@ -890,18 +890,11 @@\n     {\n         final String name = type.getName();\n         // 19-Mar-2015: Without context, all we can check are bounds.\n         if (context == null) {\n             // And to prevent infinite loops, now need this:\n-            return _unknownType();\n-        } else {\n-            // Ok: here's where context might come in handy!\n-            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n-             *   unresolved type variables to handle some cases where bounds\n-             *   are enough. Let's hope it does not hide real fail cases.\n-             */\n-            JavaType actualType = context.findType(name);\n+return _unknownType(); // Ok: here's's do implicit re-closed\n             if (actualType != null) {\n                 return actualType;\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return _unknownType(); // Ok: here's's do implicit re-literal characters that might be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-11/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 03:41:29.175780441 +0200\n+++ /tmp/tmpshud7m4p.java\t2022-07-19 03:41:29.175780441 +0200\n@@ -890,18 +890,11 @@\n     {\n         final String name = type.getName();\n         // 19-Mar-2015: Without context, all we can check are bounds.\n         if (context == null) {\n             // And to prevent infinite loops, now need this:\n-            return _unknownType();\n-        } else {\n-            // Ok: here's where context might come in handy!\n-            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n-             *   unresolved type variables to handle some cases where bounds\n-             *   are enough. Let's hope it does not hide real fail cases.\n-             */\n-            JavaType actualType = context.findType(name);\n+return _unknownType(); // Ok: here's's do implicit re-literal characters that might be null!\n             if (actualType != null) {\n                 return actualType;\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return _unknownType(); // Ok: here's where context might be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-11/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 03:41:30.971770513 +0200\n+++ /tmp/tmpodp15ktt.java\t2022-07-19 03:41:30.971770513 +0200\n@@ -890,18 +890,11 @@\n     {\n         final String name = type.getName();\n         // 19-Mar-2015: Without context, all we can check are bounds.\n         if (context == null) {\n             // And to prevent infinite loops, now need this:\n-            return _unknownType();\n-        } else {\n-            // Ok: here's where context might come in handy!\n-            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n-             *   unresolved type variables to handle some cases where bounds\n-             *   are enough. Let's hope it does not hide real fail cases.\n-             */\n-            JavaType actualType = context.findType(name);\n+return _unknownType(); // Ok: here's where context might be null!\n             if (actualType != null) {\n                 return actualType;\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return _unknownType(); // Ok: here's's do implicit re-closed.findType(name);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-11/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 03:41:32.843760167 +0200\n+++ /tmp/tmpid5i2p78.java\t2022-07-19 03:41:32.843760167 +0200\n@@ -890,18 +890,11 @@\n     {\n         final String name = type.getName();\n         // 19-Mar-2015: Without context, all we can check are bounds.\n         if (context == null) {\n             // And to prevent infinite loops, now need this:\n-            return _unknownType();\n-        } else {\n-            // Ok: here's where context might come in handy!\n-            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n-             *   unresolved type variables to handle some cases where bounds\n-             *   are enough. Let's hope it does not hide real fail cases.\n-             */\n-            JavaType actualType = context.findType(name);\n+return _unknownType(); // Ok: here's's do implicit re-closed.findType(name);\n             if (actualType != null) {\n                 return actualType;\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return _unknownType(); // Ok: here's where context might be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-11/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 03:41:34.719749801 +0200\n+++ /tmp/tmp5pmvxhr8.java\t2022-07-19 03:41:34.723749777 +0200\n@@ -890,18 +890,11 @@\n     {\n         final String name = type.getName();\n         // 19-Mar-2015: Without context, all we can check are bounds.\n         if (context == null) {\n             // And to prevent infinite loops, now need this:\n-            return _unknownType();\n-        } else {\n-            // Ok: here's where context might come in handy!\n-            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n-             *   unresolved type variables to handle some cases where bounds\n-             *   are enough. Let's hope it does not hide real fail cases.\n-             */\n-            JavaType actualType = context.findType(name);\n+return _unknownType(); // Ok: here's where context might be null!\n             if (actualType != null) {\n                 return actualType;\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return _unknownType(); // Ok: here's do implicit re-literal characters that might be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-11/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 03:41:36.595739434 +0200\n+++ /tmp/tmp91pmx3m6.java\t2022-07-19 03:41:36.595739434 +0200\n@@ -890,18 +890,11 @@\n     {\n         final String name = type.getName();\n         // 19-Mar-2015: Without context, all we can check are bounds.\n         if (context == null) {\n             // And to prevent infinite loops, now need this:\n-            return _unknownType();\n-        } else {\n-            // Ok: here's where context might come in handy!\n-            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n-             *   unresolved type variables to handle some cases where bounds\n-             *   are enough. Let's hope it does not hide real fail cases.\n-             */\n-            JavaType actualType = context.findType(name);\n+return _unknownType(); // Ok: here's do implicit re-literal characters that might be null!\n             if (actualType != null) {\n                 return actualType;\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return _unknownType(); // Ok: here's do implicit re-closed",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-11/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 03:41:38.459729134 +0200\n+++ /tmp/tmp6cn9ze2z.java\t2022-07-19 03:41:38.459729134 +0200\n@@ -890,18 +890,11 @@\n     {\n         final String name = type.getName();\n         // 19-Mar-2015: Without context, all we can check are bounds.\n         if (context == null) {\n             // And to prevent infinite loops, now need this:\n-            return _unknownType();\n-        } else {\n-            // Ok: here's where context might come in handy!\n-            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n-             *   unresolved type variables to handle some cases where bounds\n-             *   are enough. Let's hope it does not hide real fail cases.\n-             */\n-            JavaType actualType = context.findType(name);\n+return _unknownType(); // Ok: here's do implicit re-closed\n             if (actualType != null) {\n                 return actualType;\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return _unknownType(); // Ok: here's where context might be null",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-11/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-19 03:41:40.315718876 +0200\n+++ /tmp/tmppwmzecht.java\t2022-07-19 03:41:40.315718876 +0200\n@@ -890,18 +890,11 @@\n     {\n         final String name = type.getName();\n         // 19-Mar-2015: Without context, all we can check are bounds.\n         if (context == null) {\n             // And to prevent infinite loops, now need this:\n-            return _unknownType();\n-        } else {\n-            // Ok: here's where context might come in handy!\n-            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n-             *   unresolved type variables to handle some cases where bounds\n-             *   are enough. Let's hope it does not hide real fail cases.\n-             */\n-            JavaType actualType = context.findType(name);\n+return _unknownType(); // Ok: here's where context might be null\n             if (actualType != null) {\n                 return actualType;\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return _unknownType(); } else { // Ok: here's where context might come in handy! /* 19-Mar-2015, tatu: As per [databind#609], may need to allow * unresolved type variables to handle some cases where bounds * are enough. Let's hope it does not hide real fail cases. */ JavaType actualType = context.findType(name);",
        "fixed_line": "context = new TypeBindings(this, (Class<?>) null); } else { // Ok: here's where context might come in handy! /* 19-Mar-2015, tatu: As per [databind#609], may need to allow * unresolved type variables to handle some cases where bounds * are enough. Let's hope it does not hide real fail cases. */ JavaType actualType = context.findType(name, false);"
    },
    "Codec-15": {
        "fixes": [
            {
                "k": 1,
                "patch": "final char hwChar = str.charAt(index - 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-15/src/main/java/org/apache/commons/codec/language/Soundex.java\t2022-07-19 03:41:42.587706325 +0200\n+++ /tmp/tmp__qfb8s_.java\t2022-07-19 03:41:42.675705838 +0200\n@@ -183,15 +183,11 @@\n     private char getMappingCode(final String str, final int index) {\n         // map() throws IllegalArgumentException\n         final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            final char hwChar = str.charAt(index - 1);\n-            if ('H' == hwChar || 'W' == hwChar) {\n-                final char preHWChar = str.charAt(index - 2);\n-                final char firstCode = this.map(preHWChar);\n-                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n+final char hwChar = str.charAt(index - 1);\n                     return 0;\n                 }\n             }\n         }\n         return mappedChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "final char hwChar = str.charAt(index - 1) == hwChar || 'W' == preHWChar || 'W' == preHWChar) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-15/src/main/java/org/apache/commons/codec/language/Soundex.java\t2022-07-19 03:41:44.335696666 +0200\n+++ /tmp/tmpw2cly8hk.java\t2022-07-19 03:41:44.335696666 +0200\n@@ -183,15 +183,11 @@\n     private char getMappingCode(final String str, final int index) {\n         // map() throws IllegalArgumentException\n         final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            final char hwChar = str.charAt(index - 1);\n-            if ('H' == hwChar || 'W' == hwChar) {\n-                final char preHWChar = str.charAt(index - 2);\n-                final char firstCode = this.map(preHWChar);\n-                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n+final char hwChar = str.charAt(index - 1) == hwChar || 'W' == preHWChar || 'W' == preHWChar) {\n                     return 0;\n                 }\n             }\n         }\n         return mappedChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "final char hwChar = str.charAt(index - 1) == hwChar || 'W' == preHWChar || 'W' == preHWChar;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-15/src/main/java/org/apache/commons/codec/language/Soundex.java\t2022-07-19 03:41:45.943687781 +0200\n+++ /tmp/tmpsjxt7jhi.java\t2022-07-19 03:41:45.943687781 +0200\n@@ -183,15 +183,11 @@\n     private char getMappingCode(final String str, final int index) {\n         // map() throws IllegalArgumentException\n         final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            final char hwChar = str.charAt(index - 1);\n-            if ('H' == hwChar || 'W' == hwChar) {\n-                final char preHWChar = str.charAt(index - 2);\n-                final char firstCode = this.map(preHWChar);\n-                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n+final char hwChar = str.charAt(index - 1) == hwChar || 'W' == preHWChar || 'W' == preHWChar;\n                     return 0;\n                 }\n             }\n         }\n         return mappedChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "final char hwChar = str.charAt(index - 1); if ('H' == hwChar || 'W' == preHWChar || 'W' == preHWChar) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-15/src/main/java/org/apache/commons/codec/language/Soundex.java\t2022-07-19 03:41:47.487679251 +0200\n+++ /tmp/tmponeo3zxc.java\t2022-07-19 03:41:47.491679227 +0200\n@@ -183,15 +183,11 @@\n     private char getMappingCode(final String str, final int index) {\n         // map() throws IllegalArgumentException\n         final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            final char hwChar = str.charAt(index - 1);\n-            if ('H' == hwChar || 'W' == hwChar) {\n-                final char preHWChar = str.charAt(index - 2);\n-                final char firstCode = this.map(preHWChar);\n-                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n+final char hwChar = str.charAt(index - 1); if ('H' == hwChar || 'W' == preHWChar || 'W' == preHWChar) {\n                     return 0;\n                 }\n             }\n         }\n         return mappedChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "final char hwChar = this.str.charAt(index - 1) == hwChar || 'W' == preHWChar || 'W' == preHWChar) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-15/src/main/java/org/apache/commons/codec/language/Soundex.java\t2022-07-19 03:41:48.955671142 +0200\n+++ /tmp/tmp2rlpepq_.java\t2022-07-19 03:41:48.959671118 +0200\n@@ -183,15 +183,11 @@\n     private char getMappingCode(final String str, final int index) {\n         // map() throws IllegalArgumentException\n         final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            final char hwChar = str.charAt(index - 1);\n-            if ('H' == hwChar || 'W' == hwChar) {\n-                final char preHWChar = str.charAt(index - 2);\n-                final char firstCode = this.map(preHWChar);\n-                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n+final char hwChar = this.str.charAt(index - 1) == hwChar || 'W' == preHWChar || 'W' == preHWChar) {\n                     return 0;\n                 }\n             }\n         }\n         return mappedChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "final char hwChar = str.charAt(index - 1); if ('H' == hwChar || 'W' == preHWChar) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-15/src/main/java/org/apache/commons/codec/language/Soundex.java\t2022-07-19 03:41:50.571662214 +0200\n+++ /tmp/tmp3719i8cm.java\t2022-07-19 03:41:50.571662214 +0200\n@@ -183,15 +183,11 @@\n     private char getMappingCode(final String str, final int index) {\n         // map() throws IllegalArgumentException\n         final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            final char hwChar = str.charAt(index - 1);\n-            if ('H' == hwChar || 'W' == hwChar) {\n-                final char preHWChar = str.charAt(index - 2);\n-                final char firstCode = this.map(preHWChar);\n-                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n+final char hwChar = str.charAt(index - 1); if ('H' == hwChar || 'W' == preHWChar) {\n                     return 0;\n                 }\n             }\n         }\n         return mappedChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "final char hwChar = str.charAt(index - 1); if ('W' == hwChar || 'W' == preHWChar || 'W' == preHWChar) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-15/src/main/java/org/apache/commons/codec/language/Soundex.java\t2022-07-19 03:41:52.139653550 +0200\n+++ /tmp/tmp63xp7ij5.java\t2022-07-19 03:41:52.139653550 +0200\n@@ -183,15 +183,11 @@\n     private char getMappingCode(final String str, final int index) {\n         // map() throws IllegalArgumentException\n         final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            final char hwChar = str.charAt(index - 1);\n-            if ('H' == hwChar || 'W' == hwChar) {\n-                final char preHWChar = str.charAt(index - 2);\n-                final char firstCode = this.map(preHWChar);\n-                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n+final char hwChar = str.charAt(index - 1); if ('W' == hwChar || 'W' == preHWChar || 'W' == preHWChar) {\n                     return 0;\n                 }\n             }\n         }\n         return mappedChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "final char hwChar = str.charAt(index - 1); if ('W' == hwChar || 'W' == preHWChar) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-15/src/main/java/org/apache/commons/codec/language/Soundex.java\t2022-07-19 03:41:53.623645353 +0200\n+++ /tmp/tmpawl6ztu0.java\t2022-07-19 03:41:53.623645353 +0200\n@@ -183,15 +183,11 @@\n     private char getMappingCode(final String str, final int index) {\n         // map() throws IllegalArgumentException\n         final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            final char hwChar = str.charAt(index - 1);\n-            if ('H' == hwChar || 'W' == hwChar) {\n-                final char preHWChar = str.charAt(index - 2);\n-                final char firstCode = this.map(preHWChar);\n-                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n+final char hwChar = str.charAt(index - 1); if ('W' == hwChar || 'W' == preHWChar) {\n                     return 0;\n                 }\n             }\n         }\n         return mappedChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "final char hwChar = str.charAt(index - 1); if ('WChar || 'W' == preHWChar || 'W' == preHWChar) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-15/src/main/java/org/apache/commons/codec/language/Soundex.java\t2022-07-19 03:41:55.079637312 +0200\n+++ /tmp/tmp1ntbqxpf.java\t2022-07-19 03:41:55.079637312 +0200\n@@ -183,15 +183,11 @@\n     private char getMappingCode(final String str, final int index) {\n         // map() throws IllegalArgumentException\n         final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            final char hwChar = str.charAt(index - 1);\n-            if ('H' == hwChar || 'W' == hwChar) {\n-                final char preHWChar = str.charAt(index - 2);\n-                final char firstCode = this.map(preHWChar);\n-                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n+final char hwChar = str.charAt(index - 1); if ('WChar || 'W' == preHWChar || 'W' == preHWChar) {\n                     return 0;\n                 }\n             }\n         }\n         return mappedChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "final char hwChar = str.charAt(index - 1); if ('HWChar || 'W' == preHWChar || 'W' == preHWChar) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-15/src/main/java/org/apache/commons/codec/language/Soundex.java\t2022-07-19 03:41:56.583629005 +0200\n+++ /tmp/tmppy0r_e81.java\t2022-07-19 03:41:56.583629005 +0200\n@@ -183,15 +183,11 @@\n     private char getMappingCode(final String str, final int index) {\n         // map() throws IllegalArgumentException\n         final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            final char hwChar = str.charAt(index - 1);\n-            if ('H' == hwChar || 'W' == hwChar) {\n-                final char preHWChar = str.charAt(index - 2);\n-                final char firstCode = this.map(preHWChar);\n-                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n+final char hwChar = str.charAt(index - 1); if ('HWChar || 'W' == preHWChar || 'W' == preHWChar) {\n                     return 0;\n                 }\n             }\n         }\n         return mappedChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "final char hwChar = str.charAt(index - 1); if ('H' == hwChar || 'W' == hwChar) { final char preHWChar = str.charAt(index - 2); final char firstCode = this.map(preHWChar); if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {",
        "fixed_line": "for (int i=index-1 ; i>=0 ; i--) { final char prevChar = str.charAt(i); if (this.map(prevChar)==mappedChar) { return 0; } if ('H'!=prevChar && 'W'!=prevChar) { break; }"
    },
    "JacksonDatabind-64": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (_useRealPropertyDefaults) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-64/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\t2022-07-19 03:41:58.495618444 +0200\n+++ /tmp/tmpj5kbrzo4.java\t2022-07-19 03:41:58.539618204 +0200\n@@ -152,16 +152,11 @@\n \n             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n             //    revert logic to the case of general/per-property handling, so both\n             //    type-default AND null are to be excluded.\n             //    (as per [databind#1417]\n-            if (_useRealPropertyDefaults) {\n-                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n-                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n-                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-                }\n-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n+if (_useRealPropertyDefaults) {\n             } else {\n                 valueToSuppress = getDefaultValue(actualType);\n                 suppressNulls = true;\n             }\n             if (valueToSuppress == null) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (_useRealPropertyters) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-64/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\t2022-07-19 03:42:39.775390546 +0200\n+++ /tmp/tmp8l609y1u.java\t2022-07-19 03:42:39.775390546 +0200\n@@ -152,16 +152,11 @@\n \n             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n             //    revert logic to the case of general/per-property handling, so both\n             //    type-default AND null are to be excluded.\n             //    (as per [databind#1417]\n-            if (_useRealPropertyDefaults) {\n-                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n-                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n-                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-                }\n-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n+if (_useRealPropertyters) {\n             } else {\n                 valueToSuppress = getDefaultValue(actualType);\n                 suppressNulls = true;\n             }\n             if (valueToSuppress == null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (_useRealPropertyters.isEnabled(propDef.getName(), am,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-64/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\t2022-07-19 03:42:41.471381189 +0200\n+++ /tmp/tmpjgfy0bh4.java\t2022-07-19 03:42:41.471381189 +0200\n@@ -152,16 +152,11 @@\n \n             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n             //    revert logic to the case of general/per-property handling, so both\n             //    type-default AND null are to be excluded.\n             //    (as per [databind#1417]\n-            if (_useRealPropertyDefaults) {\n-                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n-                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n-                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-                }\n-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n+if (_useRealPropertyters.isEnabled(propDef.getName(), am,\n             } else {\n                 valueToSuppress = getDefaultValue(actualType);\n                 suppressNulls = true;\n             }\n             if (valueToSuppress == null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (tatu:",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-64/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\t2022-07-19 03:42:43.011372689 +0200\n+++ /tmp/tmpgbssq2hh.java\t2022-07-19 03:42:43.015372669 +0200\n@@ -152,16 +152,11 @@\n \n             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n             //    revert logic to the case of general/per-property handling, so both\n             //    type-default AND null are to be excluded.\n             //    (as per [databind#1417]\n-            if (_useRealPropertyDefaults) {\n-                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n-                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n-                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-                }\n-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n+if (tatu:\n             } else {\n                 valueToSuppress = getDefaultValue(actualType);\n                 suppressNulls = true;\n             }\n             if (valueToSuppress == null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (tatu: may be removed.isEnabled(propDef.getName(), am,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-64/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\t2022-07-19 03:42:44.559364147 +0200\n+++ /tmp/tmp2d_14ef_.java\t2022-07-19 03:42:44.563364127 +0200\n@@ -152,16 +152,11 @@\n \n             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n             //    revert logic to the case of general/per-property handling, so both\n             //    type-default AND null are to be excluded.\n             //    (as per [databind#1417]\n-            if (_useRealPropertyDefaults) {\n-                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n-                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n-                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-                }\n-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n+if (tatu: may be removed.isEnabled(propDef.getName(), am,\n             } else {\n                 valueToSuppress = getDefaultValue(actualType);\n                 suppressNulls = true;\n             }\n             if (valueToSuppress == null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (tatu: {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-64/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\t2022-07-19 03:42:46.147355385 +0200\n+++ /tmp/tmpc5mq5uwk.java\t2022-07-19 03:42:46.147355385 +0200\n@@ -152,16 +152,11 @@\n \n             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n             //    revert logic to the case of general/per-property handling, so both\n             //    type-default AND null are to be excluded.\n             //    (as per [databind#1417]\n-            if (_useRealPropertyDefaults) {\n-                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n-                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n-                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-                }\n-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n+if (tatu: {\n             } else {\n                 valueToSuppress = getDefaultValue(actualType);\n                 suppressNulls = true;\n             }\n             if (valueToSuppress == null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (tatu: may be null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-64/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\t2022-07-19 03:42:47.719346712 +0200\n+++ /tmp/tmpgdyfh9ne.java\t2022-07-19 03:42:47.719346712 +0200\n@@ -152,16 +152,11 @@\n \n             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n             //    revert logic to the case of general/per-property handling, so both\n             //    type-default AND null are to be excluded.\n             //    (as per [databind#1417]\n-            if (_useRealPropertyDefaults) {\n-                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n-                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n-                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-                }\n-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n+if (tatu: may be null) {\n             } else {\n                 valueToSuppress = getDefaultValue(actualType);\n                 suppressNulls = true;\n             }\n             if (valueToSuppress == null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (_useRealPropertyDefaults) { // [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-64/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\t2022-07-19 03:42:49.371337597 +0200\n+++ /tmp/tmpl8a8a_qd.java\t2022-07-19 03:42:49.371337597 +0200\n@@ -152,16 +152,11 @@\n \n             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n             //    revert logic to the case of general/per-property handling, so both\n             //    type-default AND null are to be excluded.\n             //    (as per [databind#1417]\n-            if (_useRealPropertyDefaults) {\n-                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n-                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n-                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-                }\n-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n+if (_useRealPropertyDefaults) { // [JACKSON-407] -- allow disabling wrapping for\n             } else {\n                 valueToSuppress = getDefaultValue(actualType);\n                 suppressNulls = true;\n             }\n             if (valueToSuppress == null) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (_useRealPropertyDefaults) { // [JACKSON-407] -- allow disabling wrapping for mode",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-64/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\t2022-07-19 03:43:27.635126570 +0200\n+++ /tmp/tmpu8yaw444.java\t2022-07-19 03:43:27.635126570 +0200\n@@ -152,16 +152,11 @@\n \n             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n             //    revert logic to the case of general/per-property handling, so both\n             //    type-default AND null are to be excluded.\n             //    (as per [databind#1417]\n-            if (_useRealPropertyDefaults) {\n-                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n-                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n-                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-                }\n-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n+if (_useRealPropertyDefaults) { // [JACKSON-407] -- allow disabling wrapping for mode\n             } else {\n                 valueToSuppress = getDefaultValue(actualType);\n                 suppressNulls = true;\n             }\n             if (valueToSuppress == null) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (_useRealProperty notify) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-64/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\t2022-07-19 03:44:06.038914926 +0200\n+++ /tmp/tmpe7pajwlk.java\t2022-07-19 03:44:06.038914926 +0200\n@@ -152,16 +152,11 @@\n \n             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n             //    revert logic to the case of general/per-property handling, so both\n             //    type-default AND null are to be excluded.\n             //    (as per [databind#1417]\n-            if (_useRealPropertyDefaults) {\n-                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n-                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n-                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-                }\n-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n+if (_useRealProperty notify) {\n             } else {\n                 valueToSuppress = getDefaultValue(actualType);\n                 suppressNulls = true;\n             }\n             if (valueToSuppress == null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (_useRealPropertyDefaults) { // 07-Sep-2016, tatu: may also need to front-load access forcing now if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) { am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS)); } valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);",
        "fixed_line": "Object defaultBean; // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\", // revert logic to the case of general/per-property handling, so both // type-default AND null are to be excluded. // (as per [databind#1417] if (_useRealPropertyDefaults && (defaultBean = getDefaultBean()) != null) { // 07-Sep-2016, tatu: may also need to front-load access forcing now if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) { am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS)); } try { valueToSuppress = am.getValue(defaultBean); } catch (Exception e) { _throwWrapped(e, propDef.getName(), defaultBean); }"
    },
    "Lang-6": {
        "fixes": [
            {
                "k": 1,
                "patch": "pos += Character.charCount(Character.codePointAt(input, pos));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-6/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 03:44:07.742905541 +0200\n+++ /tmp/tmp9n3x72r9.java\t2022-07-19 03:44:07.758905453 +0200\n@@ -90,11 +90,11 @@\n                 continue;\n             }\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+pos += Character.charCount(Character.codePointAt(input, pos));\n             }\n         }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "pos += Character.charCount(Character.codePointAt(pos, pt));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-6/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 03:44:21.514829682 +0200\n+++ /tmp/tmplreoafhp.java\t2022-07-19 03:44:21.514829682 +0200\n@@ -90,11 +90,11 @@\n                 continue;\n             }\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+pos += Character.charCount(Character.codePointAt(pos, pt));\n             }\n         }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "pos += Character.charCount(Character.codePointAt(pos, pos));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-6/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 03:44:23.102820936 +0200\n+++ /tmp/tmp1gbebmyf.java\t2022-07-19 03:44:23.102820936 +0200\n@@ -90,11 +90,11 @@\n                 continue;\n             }\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+pos += Character.charCount(Character.codePointAt(pos, pos));\n             }\n         }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "pos += Character.charCount(Character.codePointAt(name, pos));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-6/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 03:44:24.698812146 +0200\n+++ /tmp/tmpvn4zs_w8.java\t2022-07-19 03:44:24.702812122 +0200\n@@ -90,11 +90,11 @@\n                 continue;\n             }\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+pos += Character.charCount(Character.codePointAt(name, pos));\n             }\n         }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "pos += Character.charCount(Character.codePointAt(input, pos);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-6/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 03:44:26.306803291 +0200\n+++ /tmp/tmpbz2_n3bo.java\t2022-07-19 03:44:26.306803291 +0200\n@@ -90,11 +90,11 @@\n                 continue;\n             }\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+pos += Character.charCount(Character.codePointAt(input, pos);\n             }\n         }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "pos += Character.charCount(Character.codePointAt(line, pos));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-6/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 03:44:27.810795008 +0200\n+++ /tmp/tmpws9trr14.java\t2022-07-19 03:44:27.810795008 +0200\n@@ -90,11 +90,11 @@\n                 continue;\n             }\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+pos += Character.charCount(Character.codePointAt(line, pos));\n             }\n         }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "pos += Character.charCount(Character.codePointAt(source, pos));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-6/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 03:44:29.458785933 +0200\n+++ /tmp/tmp302sdys2.java\t2022-07-19 03:44:29.462785909 +0200\n@@ -90,11 +90,11 @@\n                 continue;\n             }\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+pos += Character.charCount(Character.codePointAt(source, pos));\n             }\n         }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "pos += Character.charCount(Character.codePointAt(pos));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-6/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 03:44:31.046777186 +0200\n+++ /tmp/tmpwx530jb0.java\t2022-07-19 03:44:31.046777186 +0200\n@@ -90,11 +90,11 @@\n                 continue;\n             }\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+pos += Character.charCount(Character.codePointAt(pos));\n             }\n         }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "pos += Character.charCount(Character.codePointAt(pos, i));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-6/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 03:44:32.634768441 +0200\n+++ /tmp/tmpynsel9zw.java\t2022-07-19 03:44:32.634768441 +0200\n@@ -90,11 +90,11 @@\n                 continue;\n             }\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+pos += Character.charCount(Character.codePointAt(pos, i));\n             }\n         }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "pos += Character.charCount(Character.codePointAt(pos, len));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-6/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-19 03:44:34.270759433 +0200\n+++ /tmp/tmp2t8q1ugg.java\t2022-07-19 03:44:34.274759413 +0200\n@@ -90,11 +90,11 @@\n                 continue;\n             }\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+pos += Character.charCount(Character.codePointAt(pos, len));\n             }\n         }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "pos += Character.charCount(Character.codePointAt(input, pos));",
        "fixed_line": "pos += Character.charCount(Character.codePointAt(input, pt));"
    },
    "Closure-95": {
        "fixes": [
            {
                "k": 1,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for this",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for this",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for the",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for the",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// as per [JACKSON-407] --raw == scopeToDeclareIn.",
                "patch_diff": "// as per [JACKSON-407] --raw == scopeToDeclareIn.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// as per [JACKSON-407] -- allow use a property name;",
                "patch_diff": "// as per [JACKSON-407] -- allow use a property name;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for this to declare in the",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for this to declare in the",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for this name;",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for this name;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for this;",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for this;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// as per [JACKSON-407] -- allow use a property,",
                "patch_diff": "// as per [JACKSON-407] -- allow use a property,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for the type in the",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for the type in the",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (n.getType() == Token.GETPROP && !scope.isGlobal() && isQnameRootedInGlobalScope(n)) { Scope globalScope = scope.getGlobalScope(); // don't try to declare in the global scope if there's // already a symbol there with this name. if (!globalScope.isDeclared(variableName, false)) { scopeToDeclareIn = scope.getGlobalScope(); } }"
    },
    "Lang-27": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (expPos < 2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-27/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 03:44:37.550741373 +0200\n+++ /tmp/tmpohvnz0zp.java\t2022-07-19 03:44:37.578741222 +0200\n@@ -474,11 +474,11 @@\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+if (expPos < 2) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (expPos < decPos) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-27/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 03:44:47.254687949 +0200\n+++ /tmp/tmp09cfejw9.java\t2022-07-19 03:44:47.270687861 +0200\n@@ -474,11 +474,11 @@\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+if (expPos < decPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (expPos < -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-27/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 03:44:56.878634971 +0200\n+++ /tmp/tmpok56zb2z.java\t2022-07-19 03:44:56.878634971 +0200\n@@ -474,11 +474,11 @@\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+if (expPos < -1) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (expPos < decPos + 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-27/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 03:45:06.306583078 +0200\n+++ /tmp/tmphdwwibj5.java\t2022-07-19 03:45:06.306583078 +0200\n@@ -474,11 +474,11 @@\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+if (expPos < decPos + 1) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (expPos < 5) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-27/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 03:45:15.658531614 +0200\n+++ /tmp/tmpwpwd6nj8.java\t2022-07-19 03:45:15.670531550 +0200\n@@ -474,11 +474,11 @@\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+if (expPos < 5) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (decPos < decPos) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-27/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 03:45:25.190479169 +0200\n+++ /tmp/tmp_g3gtt9k.java\t2022-07-19 03:45:25.190479169 +0200\n@@ -474,11 +474,11 @@\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+if (decPos < decPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (decPos < 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-27/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 03:45:34.658427081 +0200\n+++ /tmp/tmpfmeel5yo.java\t2022-07-19 03:45:34.658427081 +0200\n@@ -474,11 +474,11 @@\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+if (decPos < 0) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (expPos < 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-27/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 03:45:44.110375089 +0200\n+++ /tmp/tmpcs_qd_x0.java\t2022-07-19 03:45:44.110375089 +0200\n@@ -474,11 +474,11 @@\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+if (expPos < 0) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (expPos < expPos) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-27/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 03:45:53.626322749 +0200\n+++ /tmp/tmp926nyfcw.java\t2022-07-19 03:45:53.630322730 +0200\n@@ -474,11 +474,11 @@\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+if (expPos < expPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (decPos < decPos + 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-27/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 03:46:03.190270155 +0200\n+++ /tmp/tmp7yr6hwej.java\t2022-07-19 03:46:03.194270136 +0200\n@@ -474,11 +474,11 @@\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+if (decPos < decPos + 1) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (expPos < decPos) {",
        "fixed_line": "if (expPos < decPos || expPos > str.length()) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { if (expPos > str.length()) { throw new NumberFormatException(str + \" is not a valid number.\"); }"
    },
    "Closure-14": {
        "fixes": [
            {
                "k": 1,
                "patch": "cfa.createEdge( finallyNode, Branch.UNCOND, finallyNode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\t2022-07-19 03:46:12.698217877 +0200\n+++ /tmp/tmpjig8v_h4.java\t2022-07-19 03:46:12.722217747 +0200\n@@ -762,11 +762,11 @@\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+cfa.createEdge( finallyNode, Branch.UNCOND, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode = finallyNode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\t2022-07-19 03:46:52.541998873 +0200\n+++ /tmp/tmp1oej_iyg.java\t2022-07-19 03:46:52.541998873 +0200\n@@ -762,11 +762,11 @@\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+cfa.createEdge(fromNode, Branch.UNCOND, finallyNode = finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\t2022-07-19 03:47:31.989782157 +0200\n+++ /tmp/tmpyugal4wa.java\t2022-07-19 03:47:31.989782157 +0200\n@@ -762,11 +762,11 @@\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "cfa.createEdge( finallyNode, Branch.UNCOND, finallyNode = finallyNode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\t2022-07-19 03:48:11.901562997 +0200\n+++ /tmp/tmp35qe97ga.java\t2022-07-19 03:48:11.905562973 +0200\n@@ -762,11 +762,11 @@\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+cfa.createEdge( finallyNode, Branch.UNCOND, finallyNode = finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "cfa.createEdge(finallyNode, Branch.UNCOND, finallyNode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\t2022-07-19 03:48:51.621344985 +0200\n+++ /tmp/tmph7idep_n.java\t2022-07-19 03:48:51.621344985 +0200\n@@ -762,11 +762,11 @@\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+cfa.createEdge(finallyNode, Branch.UNCOND, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "cfa.createEdge(finallyNode, Branch.UNCOND, finallyNode = finallyNode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\t2022-07-19 03:49:31.745124847 +0200\n+++ /tmp/tmpbbm27e3q.java\t2022-07-19 03:49:31.745124847 +0200\n@@ -762,11 +762,11 @@\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+cfa.createEdge(finallyNode, Branch.UNCOND, finallyNode = finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode = finallyNode = finallyNode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\t2022-07-19 03:50:11.920904508 +0200\n+++ /tmp/tmp_xf7vjlh.java\t2022-07-19 03:50:11.920904508 +0200\n@@ -762,11 +762,11 @@\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+cfa.createEdge(fromNode, Branch.UNCOND, finallyNode = finallyNode = finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode = finallyNode.getLastChild();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\t2022-07-19 03:50:51.856685562 +0200\n+++ /tmp/tmp8a1qvsnx.java\t2022-07-19 03:50:51.856685562 +0200\n@@ -762,11 +762,11 @@\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+cfa.createEdge(fromNode, Branch.UNCOND, finallyNode = finallyNode.getLastChild();\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "cfa.createEdge( finallyNode, Branch.UNCOND, finallyNode = finallyNode = finallyNode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\t2022-07-19 03:50:55.128667628 +0200\n+++ /tmp/tmpl9m1l71s.java\t2022-07-19 03:50:55.128667628 +0200\n@@ -762,11 +762,11 @@\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+cfa.createEdge( finallyNode, Branch.UNCOND, finallyNode = finallyNode = finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode = finallyNode.getLastChild());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\t2022-07-19 03:51:34.568451473 +0200\n+++ /tmp/tmpeslhm7m9.java\t2022-07-19 03:51:34.572451452 +0200\n@@ -762,11 +762,11 @@\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+cfa.createEdge(fromNode, Branch.UNCOND, finallyNode = finallyNode.getLastChild());\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);",
        "fixed_line": "cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);"
    },
    "Mockito-33": {
        "fixes": [
            {
                "k": 1,
                "patch": "return m1.equals(m2);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-33/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 03:52:14.292233831 +0200\n+++ /tmp/tmpk5mmvn3s.java\t2022-07-19 03:52:14.328233633 +0200\n@@ -94,11 +94,11 @@\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n         \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+return m1.equals(m2);\n     }\n     \n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return m2.equals(m1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-33/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 03:52:33.312129642 +0200\n+++ /tmp/tmpooy2_j9p.java\t2022-07-19 03:52:33.312129642 +0200\n@@ -94,11 +94,11 @@\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n         \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+return m2.equals(m1);\n     }\n     \n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return m1.equals(m1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-33/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 03:52:52.056026981 +0200\n+++ /tmp/tmpm6xafrdw.java\t2022-07-19 03:52:52.056026981 +0200\n@@ -94,11 +94,11 @@\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n         \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+return m1.equals(m1);\n     }\n     \n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return m2.equals(m2);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-33/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 03:53:10.763924528 +0200\n+++ /tmp/tmpbg70qurp.java\t2022-07-19 03:53:10.763924528 +0200\n@@ -94,11 +94,11 @@\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n         \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+return m2.equals(m2);\n     }\n     \n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return m1.equals(m2.getMethod());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-33/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 03:53:29.631821211 +0200\n+++ /tmp/tmp___jum8p.java\t2022-07-19 03:53:29.631821211 +0200\n@@ -94,11 +94,11 @@\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n         \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+return m1.equals(m2.getMethod());\n     }\n     \n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return m1.equals(m1, m2);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-33/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 03:53:32.023808112 +0200\n+++ /tmp/tmppzf33370.java\t2022-07-19 03:53:32.023808112 +0200\n@@ -94,11 +94,11 @@\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n         \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+return m1.equals(m1, m2);\n     }\n     \n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return m1.equals(m1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-33/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 03:53:34.295795672 +0200\n+++ /tmp/tmpoq6vzxyx.java\t2022-07-19 03:53:34.295795672 +0200\n@@ -94,11 +94,11 @@\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n         \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+return m1.equals(m1);\n     }\n     \n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return m2.equals(m2);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-33/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 03:53:52.963693464 +0200\n+++ /tmp/tmpycbzcgnf.java\t2022-07-19 03:53:52.963693464 +0200\n@@ -94,11 +94,11 @@\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n         \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+return m2.equals(m2);\n     }\n     \n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return m1.equals(m2.getMethod();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-33/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 03:54:11.991589298 +0200\n+++ /tmp/tmpjv690xmd.java\t2022-07-19 03:54:11.991589298 +0200\n@@ -94,11 +94,11 @@\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n         \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+return m1.equals(m2.getMethod();\n     }\n     \n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return m2.equals(m1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-33/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 03:54:13.891578895 +0200\n+++ /tmp/tmpid6dazo7.java\t2022-07-19 03:54:13.891578895 +0200\n@@ -94,11 +94,11 @@\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n         \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+return m2.equals(m1);\n     }\n     \n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return m1.equals(m2);",
        "fixed_line": "if (m1.getName() != null && m1.getName().equals(m2.getName())) { /* Avoid unnecessary cloning */ Class[] params1 = m1.getParameterTypes(); Class[] params2 = m2.getParameterTypes(); if (params1.length == params2.length) { for (int i = 0; i < params1.length; i++) { if (params1[i] != params2[i]) return false; } return true; } } return false;"
    },
    "Mockito-22": {
        "fixes": [
            {
                "k": 1,
                "patch": "if(o1 == null && o2!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-22/src/org/mockito/internal/matchers/Equality.java\t2022-07-19 03:54:32.499477039 +0200\n+++ /tmp/tmptg03l9fc.java\t2022-07-19 03:54:32.511476975 +0200\n@@ -8,11 +8,11 @@\n \n //stolen from hamcrest because I didn't want to have more dependency than Matcher class \n public class Equality {\n \n     public static boolean areEqual(Object o1, Object o2) {\n-        if (o1 == null || o2 == null) {\n+if(o1 == null && o2!= null) {\n             return o1 == null && o2 == null;\n         } else if (isArray(o1)) {\n             return isArray(o2) && areArraysEqual(o1, o2);\n         } else {\n             return o1.equals(o2);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (o1 == null &&o2!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-22/src/org/mockito/internal/matchers/Equality.java\t2022-07-19 03:55:07.227286972 +0200\n+++ /tmp/tmpkenl92k6.java\t2022-07-19 03:55:07.227286972 +0200\n@@ -8,11 +8,11 @@\n \n //stolen from hamcrest because I didn't want to have more dependency than Matcher class \n public class Equality {\n \n     public static boolean areEqual(Object o1, Object o2) {\n-        if (o1 == null || o2 == null) {\n+if (o1 == null &&o2!= null) {\n             return o1 == null && o2 == null;\n         } else if (isArray(o1)) {\n             return isArray(o2) && areArraysEqual(o1, o2);\n         } else {\n             return o1.equals(o2);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (o1!= null && o2 == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-22/src/org/mockito/internal/matchers/Equality.java\t2022-07-19 03:55:41.463099628 +0200\n+++ /tmp/tmpq5lt4hur.java\t2022-07-19 03:55:41.463099628 +0200\n@@ -8,11 +8,11 @@\n \n //stolen from hamcrest because I didn't want to have more dependency than Matcher class \n public class Equality {\n \n     public static boolean areEqual(Object o1, Object o2) {\n-        if (o1 == null || o2 == null) {\n+if (o1!= null && o2 == null) {\n             return o1 == null && o2 == null;\n         } else if (isArray(o1)) {\n             return isArray(o2) && areArraysEqual(o1, o2);\n         } else {\n             return o1.equals(o2);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (o1 == null && o2!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-22/src/org/mockito/internal/matchers/Equality.java\t2022-07-19 03:56:16.038910451 +0200\n+++ /tmp/tmpy20n8_gw.java\t2022-07-19 03:56:16.038910451 +0200\n@@ -8,11 +8,11 @@\n \n //stolen from hamcrest because I didn't want to have more dependency than Matcher class \n public class Equality {\n \n     public static boolean areEqual(Object o1, Object o2) {\n-        if (o1 == null || o2 == null) {\n+if (o1 == null && o2!= null) {\n             return o1 == null && o2 == null;\n         } else if (isArray(o1)) {\n             return isArray(o2) && areArraysEqual(o1, o2);\n         } else {\n             return o1.equals(o2);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if(o1 == null && o2 == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-22/src/org/mockito/internal/matchers/Equality.java\t2022-07-19 03:56:50.530721767 +0200\n+++ /tmp/tmpxbu087rq.java\t2022-07-19 03:56:50.530721767 +0200\n@@ -8,11 +8,11 @@\n \n //stolen from hamcrest because I didn't want to have more dependency than Matcher class \n public class Equality {\n \n     public static boolean areEqual(Object o1, Object o2) {\n-        if (o1 == null || o2 == null) {\n+if(o1 == null && o2 == null) {\n             return o1 == null && o2 == null;\n         } else if (isArray(o1)) {\n             return isArray(o2) && areArraysEqual(o1, o2);\n         } else {\n             return o1.equals(o2);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (o1 == null || o2 == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-22/src/org/mockito/internal/matchers/Equality.java\t2022-07-19 03:57:25.150532404 +0200\n+++ /tmp/tmp4w1imj1e.java\t2022-07-19 03:57:25.150532404 +0200\n@@ -8,11 +8,11 @@\n \n //stolen from hamcrest because I didn't want to have more dependency than Matcher class \n public class Equality {\n \n     public static boolean areEqual(Object o1, Object o2) {\n-        if (o1 == null || o2 == null) {\n+if (o1 == null || o2 == null) {\n             return o1 == null && o2 == null;\n         } else if (isArray(o1)) {\n             return isArray(o2) && areArraysEqual(o1, o2);\n         } else {\n             return o1.equals(o2);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (o1 == null &&o2 == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-22/src/org/mockito/internal/matchers/Equality.java\t2022-07-19 03:57:59.202346174 +0200\n+++ /tmp/tmpg8b6yp7h.java\t2022-07-19 03:57:59.202346174 +0200\n@@ -8,11 +8,11 @@\n \n //stolen from hamcrest because I didn't want to have more dependency than Matcher class \n public class Equality {\n \n     public static boolean areEqual(Object o1, Object o2) {\n-        if (o1 == null || o2 == null) {\n+if (o1 == null &&o2 == null) {\n             return o1 == null && o2 == null;\n         } else if (isArray(o1)) {\n             return isArray(o2) && areArraysEqual(o1, o2);\n         } else {\n             return o1.equals(o2);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (o1 == null && o2 == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-22/src/org/mockito/internal/matchers/Equality.java\t2022-07-19 03:58:33.562158282 +0200\n+++ /tmp/tmp3dtoqhf5.java\t2022-07-19 03:58:33.562158282 +0200\n@@ -8,11 +8,11 @@\n \n //stolen from hamcrest because I didn't want to have more dependency than Matcher class \n public class Equality {\n \n     public static boolean areEqual(Object o1, Object o2) {\n-        if (o1 == null || o2 == null) {\n+if (o1 == null && o2 == null) {\n             return o1 == null && o2 == null;\n         } else if (isArray(o1)) {\n             return isArray(o2) && areArraysEqual(o1, o2);\n         } else {\n             return o1.equals(o2);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if(o1 == null || o2 == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-22/src/org/mockito/internal/matchers/Equality.java\t2022-07-19 03:59:07.849970807 +0200\n+++ /tmp/tmp60lfd3ce.java\t2022-07-19 03:59:07.853970784 +0200\n@@ -8,11 +8,11 @@\n \n //stolen from hamcrest because I didn't want to have more dependency than Matcher class \n public class Equality {\n \n     public static boolean areEqual(Object o1, Object o2) {\n-        if (o1 == null || o2 == null) {\n+if(o1 == null || o2 == null) {\n             return o1 == null && o2 == null;\n         } else if (isArray(o1)) {\n             return isArray(o2) && areArraysEqual(o1, o2);\n         } else {\n             return o1.equals(o2);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (o1!= null && o2!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-22/src/org/mockito/internal/matchers/Equality.java\t2022-07-19 03:59:42.405781885 +0200\n+++ /tmp/tmpsqqtac8w.java\t2022-07-19 03:59:42.409781862 +0200\n@@ -8,11 +8,11 @@\n \n //stolen from hamcrest because I didn't want to have more dependency than Matcher class \n public class Equality {\n \n     public static boolean areEqual(Object o1, Object o2) {\n-        if (o1 == null || o2 == null) {\n+if (o1!= null && o2!= null) {\n             return o1 == null && o2 == null;\n         } else if (isArray(o1)) {\n             return isArray(o2) && areArraysEqual(o1, o2);\n         } else {\n             return o1.equals(o2);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (o1 == null || o2 == null) {",
        "fixed_line": "if (o1 == o2 ) { return true; } else if (o1 == null || o2 == null) {"
    },
    "Jsoup-44": {
        "fixes": [
            {
                "k": 1,
                "patch": "return processStartTag(start.reset().nameAttr(name,",
                "patch_diff": "return processStartTag(start.reset().nameAttr(name,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return processStartTag(start.reset().nameAttr(name);",
                "patch_diff": "return processStartTag(start.reset().nameAttr(name);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return processStartTag(name);",
                "patch_diff": "return processStartTag(name);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return processStartTag(start.reset().name;",
                "patch_diff": "return processStartTag(start.reset().name;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return processStartTag(start.reset().name()) {",
                "patch_diff": "return processStartTag(start.reset().name()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return processStartTag(start.reset().nameAttr(name); }",
                "patch_diff": "return processStartTag(start.reset().nameAttr(name); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return processStartTag(start.reset().name);",
                "patch_diff": "return processStartTag(start.reset().name);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return processStartTag(start);",
                "patch_diff": "return processStartTag(start);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return processStartTag(start.reset().nameAttr(name) {",
                "patch_diff": "return processStartTag(start.reset().nameAttr(name) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return processStartTag(start.reset().nameAttr(name)) {",
                "patch_diff": "return processStartTag(start.reset().nameAttr(name)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (currentToken == start) { // don't recycle an in-use token return process(new Token.StartTag().name(name)); } return process(start.reset().name(name)); } public boolean processStartTag(String name, Attributes attrs) { if (currentToken == start) { // don't recycle an in-use token return process(new Token.StartTag().nameAttr(name, attrs)); } start.reset(); start.nameAttr(name, attrs); return process(start); } protected boolean processEndTag(String name) { if (currentToken == end) { // don't recycle an in-use token return process(new Token.EndTag().name(name)); }"
    },
    "JacksonDatabind-7": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if ((tatu: As per [JACKSON-Oct-2013, tatu:",
                "patch_diff": "// if ((tatu: As per [JACKSON-Oct-2013, tatu:",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// if ((tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for this;",
                "patch_diff": "// if ((tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for this;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if ((tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "// if ((tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// } else if ((tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for this;",
                "patch_diff": "// } else if ((tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for this;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// } else if ((tatu: As per [JACKSON-Oct-2013, tatu:",
                "patch_diff": "// } else if ((tatu: As per [JACKSON-Oct-2013, tatu:",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// } else if ((tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "// } else if ((tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// if ((tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for null;",
                "patch_diff": "// if ((tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for null;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// } else if ((tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for null;",
                "patch_diff": "// } else if ((tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for null;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// if ((tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for (int i = 0;",
                "patch_diff": "// if ((tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow disabling wrapping for (int i = 0;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if ((tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow use",
                "patch_diff": "// if ((tatu: As per [JACKSON-Oct-2013, tatu: As per [JACKSON-407] -- allow use",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (jp.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { copyCurrentStructure(jp); return this; } /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from * FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need * to assume one did exist. */ JsonToken t; writeStartObject(); do { copyCurrentStructure(jp); } while ((t = jp.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) { throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t); } writeEndObject();"
    },
    "Chart-8": {
        "fixes": [
            {
                "k": 1,
                "patch": "this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-8/source/org/jfree/data/time/Week.java\t2022-07-19 04:00:19.453579359 +0200\n+++ /tmp/tmpe9zpplu1.java\t2022-07-19 04:00:19.513579027 +0200\n@@ -170,11 +170,11 @@\n      *\n      * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n     }\n \n     /**\n      * Creates a time period for the week in which the specified date/time\n      * falls, calculated relative to the specified time zone.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault().getDefault());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-8/source/org/jfree/data/time/Week.java\t2022-07-19 04:00:28.549529638 +0200\n+++ /tmp/tmpldlwdeke.java\t2022-07-19 04:00:28.549529638 +0200\n@@ -170,11 +170,11 @@\n      *\n      * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault().getDefault());\n     }\n \n     /**\n      * Creates a time period for the week in which the specified date/time\n      * falls, calculated relative to the specified time zone.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "this(time, RegularTimePeriod.DEFAULT_TIME_ZONE,Locale.getDefault());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-8/source/org/jfree/data/time/Week.java\t2022-07-19 04:00:36.449486457 +0200\n+++ /tmp/tmpv18mmit3.java\t2022-07-19 04:00:36.449486457 +0200\n@@ -170,11 +170,11 @@\n      *\n      * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+this(time, RegularTimePeriod.DEFAULT_TIME_ZONE,Locale.getDefault());\n     }\n \n     /**\n      * Creates a time period for the week in which the specified date/time\n      * falls, calculated relative to the specified time zone.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "this(0, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-8/source/org/jfree/data/time/Week.java\t2022-07-19 04:00:44.473442598 +0200\n+++ /tmp/tmpg4jzwuu7.java\t2022-07-19 04:00:44.473442598 +0200\n@@ -170,11 +170,11 @@\n      *\n      * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+this(0, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n     }\n \n     /**\n      * Creates a time period for the week in which the specified date/time\n      * falls, calculated relative to the specified time zone.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "this(0, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault().getDefault());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-8/source/org/jfree/data/time/Week.java\t2022-07-19 04:00:46.277432737 +0200\n+++ /tmp/tmpyofauyj0.java\t2022-07-19 04:00:46.277432737 +0200\n@@ -170,11 +170,11 @@\n      *\n      * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+this(0, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault().getDefault());\n     }\n \n     /**\n      * Creates a time period for the week in which the specified date/time\n      * falls, calculated relative to the specified time zone.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault().getDefault().getDefault());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-8/source/org/jfree/data/time/Week.java\t2022-07-19 04:00:48.077422899 +0200\n+++ /tmp/tmpiwy_p8vn.java\t2022-07-19 04:00:48.077422899 +0200\n@@ -170,11 +170,11 @@\n      *\n      * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault().getDefault().getDefault());\n     }\n \n     /**\n      * Creates a time period for the week in which the specified date/time\n      * falls, calculated relative to the specified time zone.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "this(0, RegularTimePeriod.DEFAULT_TIME_ZONE,Locale.getDefault());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-8/source/org/jfree/data/time/Week.java\t2022-07-19 04:00:56.293377992 +0200\n+++ /tmp/tmp4va1bovq.java\t2022-07-19 04:00:56.293377992 +0200\n@@ -170,11 +170,11 @@\n      *\n      * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+this(0, RegularTimePeriod.DEFAULT_TIME_ZONE,Locale.getDefault());\n     }\n \n     /**\n      * Creates a time period for the week in which the specified date/time\n      * falls, calculated relative to the specified time zone.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "this(time, RegularTimePeriod.DEFAULT_TIME_ZONE,Locale.getDefault().getDefault());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-8/source/org/jfree/data/time/Week.java\t2022-07-19 04:00:58.037368459 +0200\n+++ /tmp/tmpetc22lsa.java\t2022-07-19 04:00:58.041368438 +0200\n@@ -170,11 +170,11 @@\n      *\n      * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+this(time, RegularTimePeriod.DEFAULT_TIME_ZONE,Locale.getDefault().getDefault());\n     }\n \n     /**\n      * Creates a time period for the week in which the specified date/time\n      * falls, calculated relative to the specified time zone.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "this(0,time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-8/source/org/jfree/data/time/Week.java\t2022-07-19 04:01:06.157324078 +0200\n+++ /tmp/tmpskb_kz_0.java\t2022-07-19 04:01:06.157324078 +0200\n@@ -170,11 +170,11 @@\n      *\n      * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+this(0,time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n     }\n \n     /**\n      * Creates a time period for the week in which the specified date/time\n      * falls, calculated relative to the specified time zone.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault().getDefault();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-8/source/org/jfree/data/time/Week.java\t2022-07-19 04:01:07.909314501 +0200\n+++ /tmp/tmpva4jd5ll.java\t2022-07-19 04:01:07.909314501 +0200\n@@ -170,11 +170,11 @@\n      *\n      * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault().getDefault();\n     }\n \n     /**\n      * Creates a time period for the week in which the specified date/time\n      * falls, calculated relative to the specified time zone.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());",
        "fixed_line": "this(time, zone, Locale.getDefault());"
    },
    "JacksonDatabind-39": {
        "fixes": [
            {
                "k": 1,
                "patch": "Object deserializeWithType(JsonParser p, DeserializationContext.skipChildren(); return null;",
                "patch_diff": "Object deserializeWithType(JsonParser p, DeserializationContext.skipChildren(); return null;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "Object deserializeWithType(JsonParser p, DeserializationContext.skipChildren(); return null; }",
                "patch_diff": "Object deserializeWithType(JsonParser p, DeserializationContext.skipChildren(); return null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "Object deserializeWithType(jp, ctxt, null);",
                "patch_diff": "Object deserializeWithType(jp, ctxt, null);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "Object deserializeWithType(JsonParser p, DeserializationContext);",
                "patch_diff": "Object deserializeWithType(JsonParser p, DeserializationContext);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// 29-Jan-2016, tatu: Simple skipping p.skipChildren(); return null;",
                "patch_diff": "// 29-Jan-2016, tatu: Simple skipping p.skipChildren(); return null;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "Object deserializeWithType(JsonParser p, DeserializationContext.skipChildren();",
                "patch_diff": "Object deserializeWithType(JsonParser p, DeserializationContext.skipChildren();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "Object deserializeWithType(JsonParser p, DeserializationContext); return null; }",
                "patch_diff": "Object deserializeWithType(JsonParser p, DeserializationContext); return null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "Object deserializeWithType(JsonParser p, DeserializationContext.skipChildren(); }",
                "patch_diff": "Object deserializeWithType(JsonParser p, DeserializationContext.skipChildren(); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "Object deserializeWithType(JsonParser p, DeserializationContext); return null;",
                "patch_diff": "Object deserializeWithType(JsonParser p, DeserializationContext); return null;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// 29-Jan-2016, tatu: Simple skipping p.skipChildren();",
                "patch_diff": "// 29-Jan-2016, tatu: Simple skipping p.skipChildren();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (p.hasToken(JsonToken.FIELD_NAME)) { while (true) { JsonToken t = p.nextToken(); if ((t == null) || (t == JsonToken.END_OBJECT)) { break; } p.skipChildren(); } } else { p.skipChildren(); }"
    },
    "JacksonDatabind-107": {
        "fixes": [
            {
                "k": 1,
                "patch": "return null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-107/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\t2022-07-19 04:01:11.293296007 +0200\n+++ /tmp/tmp2eh3r1f2.java\t2022-07-19 04:01:11.309295919 +0200\n@@ -160,11 +160,11 @@\n                 if (deser == null) {\n                     // 10-May-2016, tatu: We may get some help...\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                        return null;\n+return null;\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n             } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return null; // can't really modify it was non-literal characters that might be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-107/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\t2022-07-19 04:02:05.832997934 +0200\n+++ /tmp/tmp_o3mo72r.java\t2022-07-19 04:02:05.832997934 +0200\n@@ -160,11 +160,11 @@\n                 if (deser == null) {\n                     // 10-May-2016, tatu: We may get some help...\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                        return null;\n+return null; // can't really modify it was non-literal characters that might be null!\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n             } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return null; // can't really modify it was non-empty's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-107/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\t2022-07-19 04:03:01.060696137 +0200\n+++ /tmp/tmpmd8gvpvc.java\t2022-07-19 04:03:01.060696137 +0200\n@@ -160,11 +160,11 @@\n                 if (deser == null) {\n                     // 10-May-2016, tatu: We may get some help...\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                        return null;\n+return null; // can't really modify it was non-empty's do implicit re-parse\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n             } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return null; // let's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-107/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\t2022-07-19 04:03:55.072401017 +0200\n+++ /tmp/tmplmmfapjl.java\t2022-07-19 04:03:55.072401017 +0200\n@@ -160,11 +160,11 @@\n                 if (deser == null) {\n                     // 10-May-2016, tatu: We may get some help...\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                        return null;\n+return null; // let's do implicit re-parse\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n             } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return null; // can't really modify it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-107/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\t2022-07-19 04:04:49.452103914 +0200\n+++ /tmp/tmpw7e0k0jv.java\t2022-07-19 04:04:49.452103914 +0200\n@@ -160,11 +160,11 @@\n                 if (deser == null) {\n                     // 10-May-2016, tatu: We may get some help...\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                        return null;\n+return null; // can't really modify it's do implicit re-parse\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n             } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return null; // we didn't really modify it's totalGJACKSON-407] -- allow use a native function.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-107/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\t2022-07-19 04:05:43.923806334 +0200\n+++ /tmp/tmpln2jn1vk.java\t2022-07-19 04:05:43.923806334 +0200\n@@ -160,11 +160,11 @@\n                 if (deser == null) {\n                     // 10-May-2016, tatu: We may get some help...\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                        return null;\n+return null; // we didn't really modify it's totalGJACKSON-407] -- allow use a native function.\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n             } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return null; // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-107/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\t2022-07-19 04:06:38.499508212 +0200\n+++ /tmp/tmpkjkuaqk8.java\t2022-07-19 04:06:38.499508212 +0200\n@@ -160,11 +160,11 @@\n                 if (deser == null) {\n                     // 10-May-2016, tatu: We may get some help...\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                        return null;\n+return null; // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n             } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return null; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-107/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\t2022-07-19 04:07:33.115209887 +0200\n+++ /tmp/tmp55_k3ner.java\t2022-07-19 04:07:33.115209887 +0200\n@@ -160,11 +160,11 @@\n                 if (deser == null) {\n                     // 10-May-2016, tatu: We may get some help...\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                        return null;\n+return null; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n             } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return null; // we didn't really modify it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-107/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\t2022-07-19 04:08:27.882910754 +0200\n+++ /tmp/tmpk0yoigxr.java\t2022-07-19 04:08:27.882910754 +0200\n@@ -160,11 +160,11 @@\n                 if (deser == null) {\n                     // 10-May-2016, tatu: We may get some help...\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                        return null;\n+return null; // we didn't really modify it's do implicit re-parse\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n             } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return null; // we didn't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-107/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\t2022-07-19 04:09:22.214614021 +0200\n+++ /tmp/tmpsm1enb2q.java\t2022-07-19 04:09:22.214614021 +0200\n@@ -160,11 +160,11 @@\n                 if (deser == null) {\n                     // 10-May-2016, tatu: We may get some help...\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                        return null;\n+return null; // we didn't really modify it's totalGJACKSON-notnotnotnot real number\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n             } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return null;",
        "fixed_line": "return NullifyingDeserializer.instance;"
    },
    "Jsoup-47": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (inAttribute)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-47/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 04:10:17.782310549 +0200\n+++ /tmp/tmpfxn4nyll.java\t2022-07-19 04:10:17.850310178 +0200\n@@ -117,11 +117,11 @@\n                         else\n                             accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+if (inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n                         break;\n                     case '>':\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (inAttribute) // can't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-47/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 04:10:21.786288682 +0200\n+++ /tmp/tmpn5_otb7i.java\t2022-07-19 04:10:21.786288682 +0200\n@@ -117,11 +117,11 @@\n                         else\n                             accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+if (inAttribute) // can't really modify it's totalGJACKSON-notnotnotnotnot real number\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n                         break;\n                     case '>':\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (inAttribute) // can't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-47/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 04:10:24.922271559 +0200\n+++ /tmp/tmp0vo0z2th.java\t2022-07-19 04:10:24.922271559 +0200\n@@ -117,11 +117,11 @@\n                         else\n                             accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+if (inAttribute) // can't really modify it's totalGJACKSON-notnotnotnot real number\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n                         break;\n                     case '>':\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (inAttribute) // can't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-47/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 04:10:28.234253472 +0200\n+++ /tmp/tmpv_0ukh_w.java\t2022-07-19 04:10:28.234253472 +0200\n@@ -117,11 +117,11 @@\n                         else\n                             accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+if (inAttribute) // can't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n                         break;\n                     case '>':\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (inAttribute) // can't really modify it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-47/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 04:10:31.354236433 +0200\n+++ /tmp/tmpggu993m_.java\t2022-07-19 04:10:31.358236409 +0200\n@@ -117,11 +117,11 @@\n                         else\n                             accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+if (inAttribute) // can't really modify it's do implicit re-parse\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n                         break;\n                     case '>':\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (inAttribute) // can't really modify it's totalGJACKSON-notnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-47/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 04:10:34.418219698 +0200\n+++ /tmp/tmpuh7h6xdo.java\t2022-07-19 04:10:34.422219679 +0200\n@@ -117,11 +117,11 @@\n                         else\n                             accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+if (inAttribute) // can't really modify it's totalGJACKSON-notnotnot real number\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n                         break;\n                     case '>':\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (inAttribute) // don't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-47/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 04:10:37.914200606 +0200\n+++ /tmp/tmp685hzm6g.java\t2022-07-19 04:10:37.914200606 +0200\n@@ -117,11 +117,11 @@\n                         else\n                             accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+if (inAttribute) // don't really modify it's totalGJACKSON-notnotnotnotnot real number\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n                         break;\n                     case '>':\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (inAttribute) // don't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-47/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 04:10:41.050183483 +0200\n+++ /tmp/tmp36rv_5pf.java\t2022-07-19 04:10:41.050183483 +0200\n@@ -117,11 +117,11 @@\n                         else\n                             accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+if (inAttribute) // don't really modify it's totalGJACKSON-notnotnotnot real number\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n                         break;\n                     case '>':\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (inAttribute) // don't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-47/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 04:10:44.086166901 +0200\n+++ /tmp/tmpt_yeyfs6.java\t2022-07-19 04:10:44.086166901 +0200\n@@ -117,11 +117,11 @@\n                         else\n                             accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+if (inAttribute) // don't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n                         break;\n                     case '>':\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (inAttribute) // can't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-47/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 04:10:47.254149600 +0200\n+++ /tmp/tmp4ehywabw.java\t2022-07-19 04:10:47.282149450 +0200\n@@ -117,11 +117,11 @@\n                         else\n                             accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+if (inAttribute) // can't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n                         break;\n                     case '>':\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (!inAttribute)",
        "fixed_line": "if (!inAttribute || escapeMode == EscapeMode.xhtml)"
    },
    "Closure-82": {
        "fixes": [
            {
                "k": 1,
                "patch": "return isNoType() || isNoObjectType() || isNoResolvedType();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-82/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 04:10:50.554131581 +0200\n+++ /tmp/tmpdrwakwv9.java\t2022-07-19 04:10:50.570131493 +0200\n@@ -158,11 +158,11 @@\n   public boolean isNoObjectType() {\n     return false;\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n+return isNoType() || isNoObjectType() || isNoResolvedType();\n   }\n \n   public boolean isNumberObjectType() {\n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return isNoType() && isNoObjectType() || isNoResolvedType();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-82/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 04:11:20.097970243 +0200\n+++ /tmp/tmpb6r2ipnu.java\t2022-07-19 04:11:20.097970243 +0200\n@@ -158,11 +158,11 @@\n   public boolean isNoObjectType() {\n     return false;\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n+return isNoType() && isNoObjectType() || isNoResolvedType();\n   }\n \n   public boolean isNumberObjectType() {\n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return isNoType() || isNoObjectType() && isNoResolvedType();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-82/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 04:11:49.273810918 +0200\n+++ /tmp/tmp5r7lyj8p.java\t2022-07-19 04:11:49.277810897 +0200\n@@ -158,11 +158,11 @@\n   public boolean isNoObjectType() {\n     return false;\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n+return isNoType() || isNoObjectType() && isNoResolvedType();\n   }\n \n   public boolean isNumberObjectType() {\n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return isNoType() && isNoObjectType() && isNoResolvedType();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-82/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 04:12:18.057653739 +0200\n+++ /tmp/tmpxmnkjob8.java\t2022-07-19 04:12:18.061653716 +0200\n@@ -158,11 +158,11 @@\n   public boolean isNoObjectType() {\n     return false;\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n+return isNoType() && isNoObjectType() && isNoResolvedType();\n   }\n \n   public boolean isNumberObjectType() {\n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return isNoType() || isNoObjectType() || isNoInjectType();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-82/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 04:12:47.361493722 +0200\n+++ /tmp/tmpl3pmkcts.java\t2022-07-19 04:12:47.361493722 +0200\n@@ -158,11 +158,11 @@\n   public boolean isNoObjectType() {\n     return false;\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n+return isNoType() || isNoObjectType() || isNoInjectType();\n   }\n \n   public boolean isNumberObjectType() {\n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return isNoType() || isNoObjectType() || isNowithType();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-82/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 04:12:49.961479525 +0200\n+++ /tmp/tmplsepk37r.java\t2022-07-19 04:12:49.965479502 +0200\n@@ -158,11 +158,11 @@\n   public boolean isNoObjectType() {\n     return false;\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n+return isNoType() || isNoObjectType() || isNowithType();\n   }\n \n   public boolean isNumberObjectType() {\n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return isNoType() || isNoObjectType() || isNo visibleType();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-82/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 04:12:52.617465022 +0200\n+++ /tmp/tmpmyt0t0ph.java\t2022-07-19 04:12:52.617465022 +0200\n@@ -158,11 +158,11 @@\n   public boolean isNoObjectType() {\n     return false;\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n+return isNoType() || isNoObjectType() || isNo visibleType();\n   }\n \n   public boolean isNumberObjectType() {\n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return isNoType() || isNoObjectType() || isNoToType();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-82/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 04:12:55.029451850 +0200\n+++ /tmp/tmpibvksam9.java\t2022-07-19 04:12:55.033451829 +0200\n@@ -158,11 +158,11 @@\n   public boolean isNoObjectType() {\n     return false;\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n+return isNoType() || isNoObjectType() || isNoToType();\n   }\n \n   public boolean isNumberObjectType() {\n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return isNoType() || isNoObjectType() || isNo<Type();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-82/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 04:12:57.713437194 +0200\n+++ /tmp/tmpobfeddbu.java\t2022-07-19 04:12:57.717437173 +0200\n@@ -158,11 +158,11 @@\n   public boolean isNoObjectType() {\n     return false;\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n+return isNoType() || isNoObjectType() || isNo<Type();\n   }\n \n   public boolean isNumberObjectType() {\n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return isNoType() || isNoObjectType() || isNoAxis();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-82/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 04:13:00.353422778 +0200\n+++ /tmp/tmp1pno3083.java\t2022-07-19 04:13:00.357422758 +0200\n@@ -158,11 +158,11 @@\n   public boolean isNoObjectType() {\n     return false;\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n+return isNoType() || isNoObjectType() || isNoAxis();\n   }\n \n   public boolean isNumberObjectType() {\n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return isNoType() || isNoObjectType() || isNoResolvedType();",
        "fixed_line": "return isNoType() || isNoObjectType() || isNoResolvedType() || (registry.getNativeFunctionType( JSTypeNative.LEAST_FUNCTION_TYPE) == this);"
    },
    "Closure-152": {
        "fixes": [
            {
                "k": 1,
                "patch": "typeOfThis = (ObjectType) safeResolve(t, n, scope);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-152/src/com/google/javascript/rhino/jstype/FunctionType.java\t2022-07-19 04:13:03.241407009 +0200\n+++ /tmp/tmpfl1iiosc.java\t2022-07-19 04:13:03.325406549 +0200\n@@ -866,11 +866,11 @@\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+typeOfThis = (ObjectType) safeResolve(t, n, scope);\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n         ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "typeOfThis = (ObjectType) safeResolve(typeOfThis, scope);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-152/src/com/google/javascript/rhino/jstype/FunctionType.java\t2022-07-19 04:13:05.225396176 +0200\n+++ /tmp/tmpqy5gq8ps.java\t2022-07-19 04:13:05.229396153 +0200\n@@ -866,11 +866,11 @@\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+typeOfThis = (ObjectType) safeResolve(typeOfThis, scope);\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n         ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-152/src/com/google/javascript/rhino/jstype/FunctionType.java\t2022-07-19 04:13:07.129385779 +0200\n+++ /tmp/tmppxvxigv8.java\t2022-07-19 04:13:07.133385756 +0200\n@@ -866,11 +866,11 @@\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n         ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "typeOfThis = (ObjectType) safeResolve(typeOfThis, this, scope);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-152/src/com/google/javascript/rhino/jstype/FunctionType.java\t2022-07-19 04:13:32.773245751 +0200\n+++ /tmp/tmplaod1ksf.java\t2022-07-19 04:13:32.773245751 +0200\n@@ -866,11 +866,11 @@\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+typeOfThis = (ObjectType) safeResolve(typeOfThis, this, scope);\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n         ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "typeOfThis = (ObjectType) safeResolve(typeOfThis, old, scope);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-152/src/com/google/javascript/rhino/jstype/FunctionType.java\t2022-07-19 04:13:34.609235726 +0200\n+++ /tmp/tmpvxefxpl2.java\t2022-07-19 04:13:34.609235726 +0200\n@@ -866,11 +866,11 @@\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+typeOfThis = (ObjectType) safeResolve(typeOfThis, old, scope);\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n         ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "typeOfThis = (ObjectType) safeResolve(t, n, type);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-152/src/com/google/javascript/rhino/jstype/FunctionType.java\t2022-07-19 04:13:36.465225592 +0200\n+++ /tmp/tmp3oxceq7j.java\t2022-07-19 04:13:36.465225592 +0200\n@@ -866,11 +866,11 @@\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+typeOfThis = (ObjectType) safeResolve(t, n, type);\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n         ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "typeOfThis = (ObjectType) safeResolve(typeOfThis, this);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-152/src/com/google/javascript/rhino/jstype/FunctionType.java\t2022-07-19 04:13:38.273215719 +0200\n+++ /tmp/tmp6cs_cn5f.java\t2022-07-19 04:13:38.273215719 +0200\n@@ -866,11 +866,11 @@\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+typeOfThis = (ObjectType) safeResolve(typeOfThis, this);\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n         ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "typeOfThis = (ObjectType) safeResolve(typeOfThis, scope, scope);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-152/src/com/google/javascript/rhino/jstype/FunctionType.java\t2022-07-19 04:13:39.965206481 +0200\n+++ /tmp/tmp392bah0e.java\t2022-07-19 04:13:39.965206481 +0200\n@@ -866,11 +866,11 @@\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+typeOfThis = (ObjectType) safeResolve(typeOfThis, scope, scope);\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n         ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "typeOfThis = (ObjectType) safeResolve(typeOfThis, source, scope);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-152/src/com/google/javascript/rhino/jstype/FunctionType.java\t2022-07-19 04:13:41.749196740 +0200\n+++ /tmp/tmpatnbuf7z.java\t2022-07-19 04:13:41.749196740 +0200\n@@ -866,11 +866,11 @@\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+typeOfThis = (ObjectType) safeResolve(typeOfThis, source, scope);\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n         ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "typeOfThis = (ObjectType) safeResolve(t, scope);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-152/src/com/google/javascript/rhino/jstype/FunctionType.java\t2022-07-19 04:13:43.477187305 +0200\n+++ /tmp/tmpiost3604.java\t2022-07-19 04:13:43.477187305 +0200\n@@ -866,11 +866,11 @@\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+typeOfThis = (ObjectType) safeResolve(t, scope);\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n         ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);",
        "fixed_line": "JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope); if (maybeTypeOfThis instanceof ObjectType) { typeOfThis = (ObjectType) maybeTypeOfThis; }"
    },
    "Mockito-28": {
        "fixes": [
            {
                "k": 1,
                "patch": "mockCandidateFilter.filterCandidate(mocks, fieldInstance).thenInject();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-28/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\t2022-07-19 04:13:45.365176995 +0200\n+++ /tmp/tmpo7cmcigx.java\t2022-07-19 04:13:45.381176909 +0200\n@@ -88,11 +88,11 @@\n         }\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+mockCandidateFilter.filterCandidate(mocks, fieldInstance).thenInject();\n         }\n     }\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-28/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\t2022-07-19 04:13:47.957162842 +0200\n+++ /tmp/tmpghyg2qfc.java\t2022-07-19 04:13:47.957162842 +0200\n@@ -88,11 +88,11 @@\n         }\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n         }\n     }\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "mockCandidateFilter.filterCandidate(mocks, fieldInstance, fieldInstance).thenInject();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-28/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\t2022-07-19 04:14:07.921053833 +0200\n+++ /tmp/tmp2lqhcx5x.java\t2022-07-19 04:14:07.921053833 +0200\n@@ -88,11 +88,11 @@\n         }\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+mockCandidateFilter.filterCandidate(mocks, fieldInstance, fieldInstance).thenInject();\n         }\n     }\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "mockCandidateFilter.filterCandidate(mocks, fieldInstances, fieldInstance).thenInject();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-28/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\t2022-07-19 04:14:10.397040313 +0200\n+++ /tmp/tmp0nq8yec0.java\t2022-07-19 04:14:10.397040313 +0200\n@@ -88,11 +88,11 @@\n         }\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+mockCandidateFilter.filterCandidate(mocks, fieldInstances, fieldInstance).thenInject();\n         }\n     }\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "mockCandidateFilter.filterCandidate(mocks, fieldInstance).thenInject();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-28/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\t2022-07-19 04:14:12.861026859 +0200\n+++ /tmp/tmp_mrrjtzm.java\t2022-07-19 04:14:12.861026859 +0200\n@@ -88,11 +88,11 @@\n         }\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+mockCandidateFilter.filterCandidate(mocks, fieldInstance).thenInject();\n         }\n     }\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "mockCandidateFilter.filterCandidate(mocks, field, parent);thenInject();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-28/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\t2022-07-19 04:14:15.357013229 +0200\n+++ /tmp/tmpc6hnsx43.java\t2022-07-19 04:14:15.361013208 +0200\n@@ -88,11 +88,11 @@\n         }\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+mockCandidateFilter.filterCandidate(mocks, field, parent);thenInject();\n         }\n     }\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "mockCandidateFilter.filterCandidate(sizes, fieldInstance).thenInject();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-28/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\t2022-07-19 04:14:17.729000279 +0200\n+++ /tmp/tmpqs851u0c.java\t2022-07-19 04:14:17.733000256 +0200\n@@ -88,11 +88,11 @@\n         }\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+mockCandidateFilter.filterCandidate(sizes, fieldInstance).thenInject();\n         }\n     }\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "mockCandidateFilter.filterCandidate(mocks, field, lasts).thenInject();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-28/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\t2022-07-19 04:14:20.072987478 +0200\n+++ /tmp/tmpix4mcrsq.java\t2022-07-19 04:14:20.076987457 +0200\n@@ -88,11 +88,11 @@\n         }\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+mockCandidateFilter.filterCandidate(mocks, field, lasts).thenInject();\n         }\n     }\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "mockCandidateFilter.filterCandidate(mocks, field, value).thenInject();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-28/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\t2022-07-19 04:14:22.536974025 +0200\n+++ /tmp/tmpksv5runl.java\t2022-07-19 04:14:22.536974025 +0200\n@@ -88,11 +88,11 @@\n         }\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+mockCandidateFilter.filterCandidate(mocks, field, value).thenInject();\n         }\n     }\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "mockCandidateFilter.filterCandidate(mocks, field, >>> 16);thenInject();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-28/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\t2022-07-19 04:14:24.944960877 +0200\n+++ /tmp/tmpcwn7i61b.java\t2022-07-19 04:14:24.944960877 +0200\n@@ -88,11 +88,11 @@\n         }\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+mockCandidateFilter.filterCandidate(mocks, field, >>> 16);thenInject();\n         }\n     }\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();",
        "fixed_line": "Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(); mocks.remove(injected);"
    },
    "Chart-13": {
        "fixes": [
            {
                "k": 1,
                "patch": "new Range(0.0, constraint.getWidth() - w[2]),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-13/source/org/jfree/chart/block/BorderArrangement.java\t2022-07-19 04:14:26.888950262 +0200\n+++ /tmp/tmpefykdhig.java\t2022-07-19 04:14:26.912950131 +0200\n@@ -450,11 +450,11 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+new Range(0.0, constraint.getWidth() - w[2]),\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "new Range(0.0, constraint.getWidth() - w[3]),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-13/source/org/jfree/chart/block/BorderArrangement.java\t2022-07-19 04:14:35.232904702 +0200\n+++ /tmp/tmpsfvhkadr.java\t2022-07-19 04:14:35.232904702 +0200\n@@ -450,11 +450,11 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+new Range(0.0, constraint.getWidth() - w[3]),\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 3,
                "patch": "new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h[2],",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-13/source/org/jfree/chart/block/BorderArrangement.java\t2022-07-19 04:14:43.140861524 +0200\n+++ /tmp/tmpztz1_i5v.java\t2022-07-19 04:14:43.140861524 +0200\n@@ -450,11 +450,11 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h[2],\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "new Range(0.0, constraint.getWidth() - w[1]),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-13/source/org/jfree/chart/block/BorderArrangement.java\t2022-07-19 04:14:44.956851607 +0200\n+++ /tmp/tmp_lc6xqs1.java\t2022-07-19 04:14:44.960851586 +0200\n@@ -450,11 +450,11 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+new Range(0.0, constraint.getWidth() - w[1]),\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 5,
                "patch": "new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h[2]),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-13/source/org/jfree/chart/block/BorderArrangement.java\t2022-07-19 04:14:53.044807445 +0200\n+++ /tmp/tmptdhf2wj7.java\t2022-07-19 04:14:53.044807445 +0200\n@@ -450,11 +450,11 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h[2]),\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h[2]));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-13/source/org/jfree/chart/block/BorderArrangement.java\t2022-07-19 04:14:54.700798403 +0200\n+++ /tmp/tmpwuvetdq2.java\t2022-07-19 04:14:54.700798403 +0200\n@@ -450,11 +450,11 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h[2]));\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-13/source/org/jfree/chart/block/BorderArrangement.java\t2022-07-19 04:14:56.444788881 +0200\n+++ /tmp/tmpcev6x2jh.java\t2022-07-19 04:14:56.444788881 +0200\n@@ -450,11 +450,11 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE;\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-13/source/org/jfree/chart/block/BorderArrangement.java\t2022-07-19 04:14:58.096779862 +0200\n+++ /tmp/tmpp1u4uz5w.java\t2022-07-19 04:14:58.096779862 +0200\n@@ -450,11 +450,11 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.NONE );",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-13/source/org/jfree/chart/block/BorderArrangement.java\t2022-07-19 04:14:59.704771082 +0200\n+++ /tmp/tmp2r7fs2xo.java\t2022-07-19 04:14:59.704771082 +0200\n@@ -450,11 +450,11 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.NONE );\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h[1]));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-13/source/org/jfree/chart/block/BorderArrangement.java\t2022-07-19 04:15:01.312762301 +0200\n+++ /tmp/tmpuzljedta.java\t2022-07-19 04:15:01.316762280 +0200\n@@ -450,11 +450,11 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h[1]));\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "new Range(0.0, constraint.getWidth() - w[2]),",
        "fixed_line": "new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)),"
    },
    "JxPath-8": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int i = 0; i < rd.length; i++) {",
                "patch_diff": "for (int i = 0; i < rd.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return containsMatch((Iterator) right, set); } else {",
                "patch_diff": "return containsMatch((Iterator) right, set); } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0; i < rd.length; ++i) {",
                "patch_diff": "for (int i = 0; i < rd.length; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (right instanceof Iterator) { return containsMatch(left); } else if (right instanceof int[]) {",
                "patch_diff": "if (right instanceof Iterator) { return containsMatch(left); } else if (right instanceof int[]) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (right instanceof Iterator) {",
                "patch_diff": "if (right instanceof Iterator) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (right instanceof Iterator) { return containsMatch(left); } else if (right instanceof Object[]) {",
                "patch_diff": "if (right instanceof Iterator) { return containsMatch(left); } else if (right instanceof Object[]) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return containsMatch((Iterator) right, set);",
                "patch_diff": "return containsMatch((Iterator) right, set);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (right instanceof Iterator) { return containsMatch(left); } else if (right instanceof Integer) {",
                "patch_diff": "if (right instanceof Iterator) { return containsMatch(left); } else if (right instanceof Integer) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return containsMatch((Iterator) right, result); } else {",
                "patch_diff": "return containsMatch((Iterator) right, result); } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (right instanceof Iterator) { return; } else if (right instanceof int[]) {",
                "patch_diff": "if (right instanceof Iterator) { return; } else if (right instanceof int[]) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (Double.isNaN(ld)) { return false; } double rd = InfoSetUtil.doubleValue(right); if (Double.isNaN(rd)) { return false; }"
    },
    "Chart-26": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (plotState!= null && hotspot!= null) {",
                "patch_diff": "if (plotState!= null && hotspot!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return new AxisLabelEntity(this.labelToolTip, hotspot, this.labelToolTip, this.labelURL)); } else if (plotState!= null && hotspot!= null) {",
                "patch_diff": "return new AxisLabelEntity(this.labelToolTip, hotspot, this.labelToolTip, this.labelURL)); } else if (plotState!= null && hotspot!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return new AxisLabelEntity(this.labelToolTip, hotspot, this.labelToolTip, this.labelURL)); }",
                "patch_diff": "return new AxisLabelEntity(this.labelToolTip, hotspot, this.labelToolTip, this.labelURL)); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return new AxisLabelEntity(this.labelToolTip, hotspot, this.labelToolTip, this.labelURL)); } else if (plotState!= null) {",
                "patch_diff": "return new AxisLabelEntity(this.labelToolTip, hotspot, this.labelToolTip, this.labelURL)); } else if (plotState!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return new AxisLabelEntity(this.labelToolTip, hotspot, this.labelToolTip, this.labelURL); } else if (plotState!= null && hotspot!= null) {",
                "patch_diff": "return new AxisLabelEntity(this.labelToolTip, hotspot, this.labelToolTip, this.labelURL); } else if (plotState!= null && hotspot!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (plotState.labelToolTip, hotspot, this.labelToolTip, this.labelURL)); } else if (plotState!= null && hotspot!= null) {",
                "patch_diff": "if (plotState.labelToolTip, hotspot, this.labelToolTip, this.labelURL)); } else if (plotState!= null && hotspot!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (this.labelToolTip, hotspot, this.labelToolTip, this.labelURL)); } else if (plotState!= null && hotspot!= null) {",
                "patch_diff": "if (this.labelToolTip, hotspot, this.labelToolTip, this.labelURL)); } else if (plotState!= null && hotspot!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return new AxisLabelEntity(this.labelToolTip, hotspot, this.labelToolTip, this.labelGenerator); } else if (plotState!= null && hotspot!= null) {",
                "patch_diff": "return new AxisLabelEntity(this.labelToolTip, hotspot, this.labelToolTip, this.labelGenerator); } else if (plotState!= null && hotspot!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// for (int i = hotspot, this.labelToolTip, this.labelURL)); } else if (plotState!= null && hotspot!= null) {",
                "patch_diff": "// for (int i = hotspot, this.labelToolTip, this.labelURL)); } else if (plotState!= null && hotspot!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return new AxisLabelEntity(this.labelToolTip, hotspot, this.labelToolTip, this.labelURL)); } else {",
                "patch_diff": "return new AxisLabelEntity(this.labelToolTip, hotspot, this.labelToolTip, this.labelURL)); } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (owner != null) { EntityCollection entities = owner.getEntityCollection(); if (entities != null) { entities.add(new AxisLabelEntity(this, hotspot, this.labelToolTip, this.labelURL)); } }"
    },
    "Lang-51": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s');",
                "patch_diff": "if (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s');",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s');",
                "patch_diff": "return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s');",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) =='s' || str.charAt(2) =='s');",
                "patch_diff": "if (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) =='s' || str.charAt(2) =='s');",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) =='s' || str.charAt(2) =='s');",
                "patch_diff": "return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) =='s' || str.charAt(2) =='s');",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (str.charAt(1) == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s');",
                "patch_diff": "if (str.charAt(1) == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s');",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (str.charAt(1) == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) =='s' || str.charAt(2) =='s');",
                "patch_diff": "if (str.charAt(1) == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) =='s' || str.charAt(2) =='s');",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s'); }",
                "patch_diff": "if (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s'); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (str.charAt(1) == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s'); }",
                "patch_diff": "if (str.charAt(1) == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s'); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (str.charAt(1) == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) =='s' || str.charAt(2) =='s'); }",
                "patch_diff": "if (str.charAt(1) == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) =='s' || str.charAt(2) =='s'); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s'); }",
                "patch_diff": "return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s'); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "return false;"
    },
    "JacksonDatabind-67": {
        "fixes": [
            {
                "k": 1,
                "patch": "return _createEnumKeyDeserializer(ctxt, type); } deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, type);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-67/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 04:15:08.476723185 +0200\n+++ /tmp/tmp742uvs4r.java\t2022-07-19 04:15:08.572722661 +0200\n@@ -1398,13 +1398,11 @@\n             }\n         }\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n-            }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+return _createEnumKeyDeserializer(ctxt, type); } deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, type);\n         }\n         // and then post-processing\n         if (deser != null) {\n             if (_factoryConfig.hasDeserializerModifiers()) {\n                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return _createEnumKeyDeserializer(ctxt, type); } deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-67/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 04:15:10.772710649 +0200\n+++ /tmp/tmp73guihjh.java\t2022-07-19 04:15:10.776710628 +0200\n@@ -1398,13 +1398,11 @@\n             }\n         }\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n-            }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+return _createEnumKeyDeserializer(ctxt, type); } deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type);\n         }\n         // and then post-processing\n         if (deser != null) {\n             if (_factoryConfig.hasDeserializerModifiers()) {\n                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return _createEnumKeyDeserializer(ctxt, type); } deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-67/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 04:15:12.784699662 +0200\n+++ /tmp/tmplf1o1tcs.java\t2022-07-19 04:15:12.788699641 +0200\n@@ -1398,13 +1398,11 @@\n             }\n         }\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n-            }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+return _createEnumKeyDeserializer(ctxt, type); } deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n         }\n         // and then post-processing\n         if (deser != null) {\n             if (_factoryConfig.hasDeserializerModifiers()) {\n                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return _createEnumKeyDeserializer(_createEnumKeyDeserializer(ctxt, type); } deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, type);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-67/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 04:15:54.188473595 +0200\n+++ /tmp/tmpbzj4zst9.java\t2022-07-19 04:15:54.188473595 +0200\n@@ -1398,13 +1398,11 @@\n             }\n         }\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n-            }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+return _createEnumKeyDeserializer(_createEnumKeyDeserializer(ctxt, type); } deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, type);\n         }\n         // and then post-processing\n         if (deser != null) {\n             if (_factoryConfig.hasDeserializerModifiers()) {\n                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return _createEnumKeyDeserializer(ctxt, type); } deser = StdKeyDeserializers.findStringBasedKeyDeserializers.findStringBasedKeyDeserializer(type, type);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-67/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 04:15:55.824464663 +0200\n+++ /tmp/tmp7y23p1_x.java\t2022-07-19 04:15:55.824464663 +0200\n@@ -1398,13 +1398,11 @@\n             }\n         }\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n-            }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+return _createEnumKeyDeserializer(ctxt, type); } deser = StdKeyDeserializers.findStringBasedKeyDeserializers.findStringBasedKeyDeserializer(type, type);\n         }\n         // and then post-processing\n         if (deser != null) {\n             if (_factoryConfig.hasDeserializerModifiers()) {\n                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return _createEnumKeyDeserializer(ctxt, type); } deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, value);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-67/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 04:15:57.884453415 +0200\n+++ /tmp/tmpbwfg97w6.java\t2022-07-19 04:15:57.884453415 +0200\n@@ -1398,13 +1398,11 @@\n             }\n         }\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n-            }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+return _createEnumKeyDeserializer(ctxt, type); } deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, value);\n         }\n         // and then post-processing\n         if (deser != null) {\n             if (_factoryConfig.hasDeserializerModifiers()) {\n                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return _createEnumKeyDeserializer(ctxt, type + deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, type);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-67/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 04:15:59.808442909 +0200\n+++ /tmp/tmpzhiljaw2.java\t2022-07-19 04:15:59.808442909 +0200\n@@ -1398,13 +1398,11 @@\n             }\n         }\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n-            }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+return _createEnumKeyDeserializer(ctxt, type + deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, type);\n         }\n         // and then post-processing\n         if (deser != null) {\n             if (_factoryConfig.hasDeserializerModifiers()) {\n                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return _createEnumKeyDeserializer(ctxt, type); } deser = StdKeyDeserializers.findStringBasedKeyDeserializers.findStringBasedKeyDeserializer(type);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-67/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 04:16:01.564433323 +0200\n+++ /tmp/tmpithzrz5d.java\t2022-07-19 04:16:01.564433323 +0200\n@@ -1398,13 +1398,11 @@\n             }\n         }\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n-            }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+return _createEnumKeyDeserializer(ctxt, type); } deser = StdKeyDeserializers.findStringBasedKeyDeserializers.findStringBasedKeyDeserializer(type);\n         }\n         // and then post-processing\n         if (deser != null) {\n             if (_factoryConfig.hasDeserializerModifiers()) {\n                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return _createEnumKeyDeserializer(ctxt, type); // never be deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, type);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-67/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 04:16:03.508422710 +0200\n+++ /tmp/tmp1942e085.java\t2022-07-19 04:16:03.512422686 +0200\n@@ -1398,13 +1398,11 @@\n             }\n         }\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n-            }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+return _createEnumKeyDeserializer(ctxt, type); // never be deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, type);\n         }\n         // and then post-processing\n         if (deser != null) {\n             if (_factoryConfig.hasDeserializerModifiers()) {\n                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return _createEnumKeyDeserializer(ctxt, type); new deserKeyDeserializers.findStringBasedKeyDeserializer(type, type);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-67/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 04:16:05.152413732 +0200\n+++ /tmp/tmpy6fcchpv.java\t2022-07-19 04:16:05.156413711 +0200\n@@ -1398,13 +1398,11 @@\n             }\n         }\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n-            }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+return _createEnumKeyDeserializer(ctxt, type); new deserKeyDeserializers.findStringBasedKeyDeserializer(type, type);\n         }\n         // and then post-processing\n         if (deser != null) {\n             if (_factoryConfig.hasDeserializerModifiers()) {\n                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return _createEnumKeyDeserializer(ctxt, type); } deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);",
        "fixed_line": "deser = _createEnumKeyDeserializer(ctxt, type); } else { deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);"
    },
    "JacksonDatabind-33": {
        "fixes": [
            {
                "k": 1,
                "patch": "|| _hasAnnotation(a, JsonRawValue.class)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-33/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\t2022-07-19 04:16:07.204402530 +0200\n+++ /tmp/tmptniilknt.java\t2022-07-19 04:16:07.324401873 +0200\n@@ -743,11 +743,11 @@\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n             } else if (_hasAnnotation(a, JsonSerialize.class)\n                     || _hasAnnotation(a, JsonView.class)\n-                    || _hasAnnotation(a, JsonRawValue.class)) {\n+|| _hasAnnotation(a, JsonRawValue.class)) {\n                 name = \"\";\n             } else {\n                 return null;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "|| _hasAnnotation(a, JsonRawValue.class)) { // as per [JACKSON-407] --raw == JsonRawValue.class || _hasAnnotation(a, JsonRawValue.class)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-33/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\t2022-07-19 04:16:44.664197999 +0200\n+++ /tmp/tmp7sp6gmo1.java\t2022-07-19 04:16:44.664197999 +0200\n@@ -743,11 +743,11 @@\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n             } else if (_hasAnnotation(a, JsonSerialize.class)\n                     || _hasAnnotation(a, JsonView.class)\n-                    || _hasAnnotation(a, JsonRawValue.class)) {\n+|| _hasAnnotation(a, JsonRawValue.class)) { // as per [JACKSON-407] --raw == JsonRawValue.class || _hasAnnotation(a, JsonRawValue.class)) {\n                 name = \"\";\n             } else {\n                 return null;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "|| _hasAnnotation(a, JsonRawValue.class)) { // as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < _hasAnnotation(a, JsonRawValue.class)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-33/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\t2022-07-19 04:17:18.512013195 +0200\n+++ /tmp/tmp53ris0x5.java\t2022-07-19 04:17:18.512013195 +0200\n@@ -743,11 +743,11 @@\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n             } else if (_hasAnnotation(a, JsonSerialize.class)\n                     || _hasAnnotation(a, JsonView.class)\n-                    || _hasAnnotation(a, JsonRawValue.class)) {\n+|| _hasAnnotation(a, JsonRawValue.class)) { // as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < _hasAnnotation(a, JsonRawValue.class)) {\n                 name = \"\";\n             } else {\n                 return null;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "|| _hasAnnotation(a, JsonRawValue.class)) { // as per [JACKSON-407] --raw == _hasAnnotation(a, JsonRawValue.class)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-33/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\t2022-07-19 04:17:52.691826579 +0200\n+++ /tmp/tmpvwq_dawx.java\t2022-07-19 04:17:52.691826579 +0200\n@@ -743,11 +743,11 @@\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n             } else if (_hasAnnotation(a, JsonSerialize.class)\n                     || _hasAnnotation(a, JsonView.class)\n-                    || _hasAnnotation(a, JsonRawValue.class)) {\n+|| _hasAnnotation(a, JsonRawValue.class)) { // as per [JACKSON-407] --raw == _hasAnnotation(a, JsonRawValue.class)) {\n                 name = \"\";\n             } else {\n                 return null;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "|| _hasAnnotation(a, JsonRawValue.class)) { // as per [JACKSON-407] --raw == JsonRawValue.class)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-33/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\t2022-07-19 04:18:26.267643264 +0200\n+++ /tmp/tmpjycxg8f9.java\t2022-07-19 04:18:26.267643264 +0200\n@@ -743,11 +743,11 @@\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n             } else if (_hasAnnotation(a, JsonSerialize.class)\n                     || _hasAnnotation(a, JsonView.class)\n-                    || _hasAnnotation(a, JsonRawValue.class)) {\n+|| _hasAnnotation(a, JsonRawValue.class)) { // as per [JACKSON-407] --raw == JsonRawValue.class)) {\n                 name = \"\";\n             } else {\n                 return null;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "&& _hasAnnotation(a, JsonRawValue.class)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-33/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\t2022-07-19 04:18:59.991459142 +0200\n+++ /tmp/tmp1hicvoed.java\t2022-07-19 04:18:59.991459142 +0200\n@@ -743,11 +743,11 @@\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n             } else if (_hasAnnotation(a, JsonSerialize.class)\n                     || _hasAnnotation(a, JsonView.class)\n-                    || _hasAnnotation(a, JsonRawValue.class)) {\n+&& _hasAnnotation(a, JsonRawValue.class)) {\n                 name = \"\";\n             } else {\n                 return null;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "|| _hasAnnotation(a, JsonRawValue.class)) { // as per [JACKSON-407] --raw == JsonRawValue.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-33/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\t2022-07-19 04:19:33.871274173 +0200\n+++ /tmp/tmpwg3_um3g.java\t2022-07-19 04:19:33.871274173 +0200\n@@ -743,11 +743,11 @@\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n             } else if (_hasAnnotation(a, JsonSerialize.class)\n                     || _hasAnnotation(a, JsonView.class)\n-                    || _hasAnnotation(a, JsonRawValue.class)) {\n+|| _hasAnnotation(a, JsonRawValue.class)) { // as per [JACKSON-407] --raw == JsonRawValue.class) {\n                 name = \"\";\n             } else {\n                 return null;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "|| _hasAnnotation(a, JsonRawValue.class)) { // as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < _hasAnnotation(a, JsonRawValue.class; {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-33/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\t2022-07-19 04:20:07.759089158 +0200\n+++ /tmp/tmp25pzzr5z.java\t2022-07-19 04:20:07.763089138 +0200\n@@ -743,11 +743,11 @@\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n             } else if (_hasAnnotation(a, JsonSerialize.class)\n                     || _hasAnnotation(a, JsonView.class)\n-                    || _hasAnnotation(a, JsonRawValue.class)) {\n+|| _hasAnnotation(a, JsonRawValue.class)) { // as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < _hasAnnotation(a, JsonRawValue.class; {\n                 name = \"\";\n             } else {\n                 return null;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "|| _hasAnnotation(a, JsonRawValue.class)) { // as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < _hasAnnotation(a, JsonRawValue.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-33/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\t2022-07-19 04:20:41.546904695 +0200\n+++ /tmp/tmpumvl6s12.java\t2022-07-19 04:20:41.546904695 +0200\n@@ -743,11 +743,11 @@\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n             } else if (_hasAnnotation(a, JsonSerialize.class)\n                     || _hasAnnotation(a, JsonView.class)\n-                    || _hasAnnotation(a, JsonRawValue.class)) {\n+|| _hasAnnotation(a, JsonRawValue.class)) { // as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < _hasAnnotation(a, JsonRawValue.class) {\n                 name = \"\";\n             } else {\n                 return null;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "|| _hasAnnotation(a, JsonRawValue.class)) { // as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < _hasAnnotation(a, JsonRawValue.class; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-33/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\t2022-07-19 04:21:15.230720797 +0200\n+++ /tmp/tmpbposuiy3.java\t2022-07-19 04:21:15.230720797 +0200\n@@ -743,11 +743,11 @@\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n             } else if (_hasAnnotation(a, JsonSerialize.class)\n                     || _hasAnnotation(a, JsonView.class)\n-                    || _hasAnnotation(a, JsonRawValue.class)) {\n+|| _hasAnnotation(a, JsonRawValue.class)) { // as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < _hasAnnotation(a, JsonRawValue.class; }\n                 name = \"\";\n             } else {\n                 return null;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "|| _hasAnnotation(a, JsonRawValue.class)) {",
        "fixed_line": "|| _hasAnnotation(a, JsonRawValue.class) || _hasAnnotation(a, JsonUnwrapped.class) || _hasAnnotation(a, JsonBackReference.class) || _hasAnnotation(a, JsonManagedReference.class)) {"
    },
    "Csv-14": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (c < '0' || (c > '9' && c < 'A' || c > 'Z' || c < 'a' || c > 'z')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-14/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 04:21:49.178535460 +0200\n+++ /tmp/tmp4hxbi7l4.java\t2022-07-19 04:21:49.226535199 +0200\n@@ -1034,11 +1034,11 @@\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+if (c < '0' || (c > '9' && c < 'A' || c > 'Z' || c < 'a' || c > 'z')) {\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (c < '0' || (c > '9' && c < 'A' || c > 'Z' || c < 'a' && c > 'z')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-14/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 04:21:53.838510019 +0200\n+++ /tmp/tmpii6yvs6f.java\t2022-07-19 04:21:53.842509998 +0200\n@@ -1034,11 +1034,11 @@\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+if (c < '0' || (c > '9' && c < 'A' || c > 'Z' || c < 'a' && c > 'z')) {\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (c < '0' || (c > '9' || c < 'A' || c > 'Z' || c < 'a' || c > 'z')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-14/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 04:21:58.142486525 +0200\n+++ /tmp/tmpw9hztq1n.java\t2022-07-19 04:21:58.142486525 +0200\n@@ -1034,11 +1034,11 @@\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+if (c < '0' || (c > '9' || c < 'A' || c > 'Z' || c < 'a' || c > 'z')) {\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (c < '0' || (c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-14/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 04:22:02.418463178 +0200\n+++ /tmp/tmpl4uz07vu.java\t2022-07-19 04:22:02.422463159 +0200\n@@ -1034,11 +1034,11 @@\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+if (c < '0' || (c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (c < '0' || (c > '9' || c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-14/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 04:22:06.642440118 +0200\n+++ /tmp/tmpmzq4wsnz.java\t2022-07-19 04:22:06.642440118 +0200\n@@ -1034,11 +1034,11 @@\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+if (c < '0' || (c > '9' || c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (c < '0' || (c > '9' || c < 'A' || c > 'Z' || c < 'a' && c > 'z')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-14/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 04:22:10.982416424 +0200\n+++ /tmp/tmpukjnwbcl.java\t2022-07-19 04:22:10.982416424 +0200\n@@ -1034,11 +1034,11 @@\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+if (c < '0' || (c > '9' || c < 'A' || c > 'Z' || c < 'a' && c > 'z')) {\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (c < '0' || (c > '9' && c < 'A' || c > 'Z' && c < 'a' && c > 'z')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-14/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 04:22:15.286392927 +0200\n+++ /tmp/tmp0vmhq2xh.java\t2022-07-19 04:22:15.286392927 +0200\n@@ -1034,11 +1034,11 @@\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+if (c < '0' || (c > '9' && c < 'A' || c > 'Z' && c < 'a' && c > 'z')) {\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 8,
                "patch": "if (c < '0' || (c > '9' && c < 'A' && c > 'Z' || c < 'a' || c > 'z')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-14/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 04:22:19.622369256 +0200\n+++ /tmp/tmprms52i54.java\t2022-07-19 04:22:19.626369236 +0200\n@@ -1034,11 +1034,11 @@\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+if (c < '0' || (c > '9' && c < 'A' && c > 'Z' || c < 'a' || c > 'z')) {\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (c < '0' || (c > '9' || c < 'A' && c > 'Z' || c < 'a' || c > 'z')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-14/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 04:22:24.058345037 +0200\n+++ /tmp/tmpqj5j1mc2.java\t2022-07-19 04:22:24.058345037 +0200\n@@ -1034,11 +1034,11 @@\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+if (c < '0' || (c > '9' || c < 'A' && c > 'Z' || c < 'a' || c > 'z')) {\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (c < '0' || (c > '9' && c < 'A' || c > 'Z' || c < 'a' || c > 'z')) { // 'z')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-14/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-19 04:22:28.298321890 +0200\n+++ /tmp/tmpwjpmmpem.java\t2022-07-19 04:22:28.298321890 +0200\n@@ -1034,11 +1034,11 @@\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+if (c < '0' || (c > '9' && c < 'A' || c > 'Z' || c < 'a' || c > 'z')) { // 'z')) {\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {",
        "fixed_line": "if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {"
    },
    "Closure-65": {
        "fixes": [
            {
                "k": 1,
                "patch": "case '\\0': sb.append(\"\\\\0\"); break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-65/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 04:22:32.770297476 +0200\n+++ /tmp/tmpdz3suqfl.java\t2022-07-19 04:22:32.806297283 +0200\n@@ -1010,11 +1010,11 @@\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+case '\\0': sb.append(\"\\\\0\"); break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n         case '\\\\': sb.append(backslashEscape); break;\n         case '\\\"': sb.append(doublequoteEscape); break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "case '\\0': sb.append(\"\\\\0\"); break; case 'D': sb.append(\"\\\\0\"); break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-65/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 04:23:07.502107865 +0200\n+++ /tmp/tmp9e9thx1m.java\t2022-07-19 04:23:07.522107754 +0200\n@@ -1010,11 +1010,11 @@\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+case '\\0': sb.append(\"\\\\0\"); break; case 'D': sb.append(\"\\\\0\"); break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n         case '\\\\': sb.append(backslashEscape); break;\n         case '\\\"': sb.append(doublequoteEscape); break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "case '\\0': sb.append(\"\\\\0\"); break; case 'F': sb.append(\"\\\\0\"); break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-65/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 04:23:41.673921307 +0200\n+++ /tmp/tmptyht6ukj.java\t2022-07-19 04:23:41.693921198 +0200\n@@ -1010,11 +1010,11 @@\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+case '\\0': sb.append(\"\\\\0\"); break; case 'F': sb.append(\"\\\\0\"); break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n         case '\\\\': sb.append(backslashEscape); break;\n         case '\\\"': sb.append(doublequoteEscape); break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "case '\\0': sb.append(\"\\\\0\"); break; case 'e': sb.append(\"\\\\0\"); break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-65/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 04:24:15.813734928 +0200\n+++ /tmp/tmpk4846zr8.java\t2022-07-19 04:24:15.833734820 +0200\n@@ -1010,11 +1010,11 @@\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+case '\\0': sb.append(\"\\\\0\"); break; case 'e': sb.append(\"\\\\0\"); break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n         case '\\\\': sb.append(backslashEscape); break;\n         case '\\\"': sb.append(doublequoteEscape); break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "case '\\0': sb.append(\"\\\\0\"); break; case 'T': sb.append(\"\\\\0\"); break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-65/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 04:24:49.265552307 +0200\n+++ /tmp/tmpb0x96fa3.java\t2022-07-19 04:24:49.281552221 +0200\n@@ -1010,11 +1010,11 @@\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+case '\\0': sb.append(\"\\\\0\"); break; case 'T': sb.append(\"\\\\0\"); break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n         case '\\\\': sb.append(backslashEscape); break;\n         case '\\\"': sb.append(doublequoteEscape); break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "case '\\0': sb.append(\"\\\\0\"); break; case 'I': sb.append(\"\\\\0\"); break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-65/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 04:25:22.449371150 +0200\n+++ /tmp/tmp3aedecqs.java\t2022-07-19 04:25:22.469371041 +0200\n@@ -1010,11 +1010,11 @@\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+case '\\0': sb.append(\"\\\\0\"); break; case 'I': sb.append(\"\\\\0\"); break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n         case '\\\\': sb.append(backslashEscape); break;\n         case '\\\"': sb.append(doublequoteEscape); break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "case '\\0': sb.append(\"\\\\0\"); break; case 'c': sb.append(\"\\\\0\"); break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-65/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 04:25:56.049187720 +0200\n+++ /tmp/tmpyn2uguqv.java\t2022-07-19 04:25:56.097187460 +0200\n@@ -1010,11 +1010,11 @@\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+case '\\0': sb.append(\"\\\\0\"); break; case 'c': sb.append(\"\\\\0\"); break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n         case '\\\\': sb.append(backslashEscape); break;\n         case '\\\"': sb.append(doublequoteEscape); break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "case '\\0': sb.append(\"\\\\0\"); break; // sb.append(\"\\\\0\"); break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-65/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 04:26:29.269006369 +0200\n+++ /tmp/tmpdv2c4s71.java\t2022-07-19 04:26:29.285006280 +0200\n@@ -1010,11 +1010,11 @@\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+case '\\0': sb.append(\"\\\\0\"); break; // sb.append(\"\\\\0\"); break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n         case '\\\\': sb.append(backslashEscape); break;\n         case '\\\"': sb.append(doublequoteEscape); break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "case '\\0': sb.append(\"\\\\0\"); break; case 'default(\"\\\\0\"); break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-65/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 04:27:02.736823663 +0200\n+++ /tmp/tmp482whwtq.java\t2022-07-19 04:27:02.756823554 +0200\n@@ -1010,11 +1010,11 @@\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+case '\\0': sb.append(\"\\\\0\"); break; case 'default(\"\\\\0\"); break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n         case '\\\\': sb.append(backslashEscape); break;\n         case '\\\"': sb.append(doublequoteEscape); break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "case '0': sb.append(\"\\\\0\"); break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-65/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 04:27:05.248809950 +0200\n+++ /tmp/tmpro63x1qb.java\t2022-07-19 04:27:05.248809950 +0200\n@@ -1010,11 +1010,11 @@\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+case '0': sb.append(\"\\\\0\"); break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n         case '\\\\': sb.append(backslashEscape); break;\n         case '\\\"': sb.append(doublequoteEscape); break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "case '\\0': sb.append(\"\\\\0\"); break;",
        "fixed_line": "case '\\0': sb.append(\"\\\\000\"); break;"
    },
    "Math-57": {
        "fixes": [
            {
                "k": 1,
                "patch": "int sum = 1; // we didn't really gets this.x0",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-57/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\t2022-07-19 04:27:38.728627179 +0200\n+++ /tmp/tmpbjmbupmq.java\t2022-07-19 04:27:38.756627025 +0200\n@@ -170,11 +170,11 @@\n \n         final double[] dx2 = new double[pointSet.size()];\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+int sum = 1; // we didn't really gets this.x0\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                 final double d = p.distanceFrom(nearest.getCenter());\n                 sum += d * d;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int sum = 1; // we didn't really gets this may be negative",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-57/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\t2022-07-19 04:28:20.772397656 +0200\n+++ /tmp/tmp0a18dp0w.java\t2022-07-19 04:28:20.772397656 +0200\n@@ -170,11 +170,11 @@\n \n         final double[] dx2 = new double[pointSet.size()];\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+int sum = 1; // we didn't really gets this may be negative\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                 final double d = p.distanceFrom(nearest.getCenter());\n                 sum += d * d;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int sum = 1; // we didn't really modify it.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-57/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\t2022-07-19 04:29:02.952167393 +0200\n+++ /tmp/tmppvdztjca.java\t2022-07-19 04:29:02.956167372 +0200\n@@ -170,11 +170,11 @@\n \n         final double[] dx2 = new double[pointSet.size()];\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+int sum = 1; // we didn't really modify it.\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                 final double d = p.distanceFrom(nearest.getCenter());\n                 sum += d * d;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int sum = 1; // we didn't really modify it was last",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-57/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\t2022-07-19 04:29:44.883938485 +0200\n+++ /tmp/tmp22aj0sx4.java\t2022-07-19 04:29:44.883938485 +0200\n@@ -170,11 +170,11 @@\n \n         final double[] dx2 = new double[pointSet.size()];\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+int sum = 1; // we didn't really modify it was last\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                 final double d = p.distanceFrom(nearest.getCenter());\n                 sum += d * d;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int sum = 1; // we didn't really modify it was x",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-57/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\t2022-07-19 04:30:27.103708005 +0200\n+++ /tmp/tmp60jqpeo0.java\t2022-07-19 04:30:27.107707985 +0200\n@@ -170,11 +170,11 @@\n \n         final double[] dx2 = new double[pointSet.size()];\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+int sum = 1; // we didn't really modify it was x\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                 final double d = p.distanceFrom(nearest.getCenter());\n                 sum += d * d;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int sum = 1; // we didn't really modify it was copied",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-57/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\t2022-07-19 04:31:09.475476696 +0200\n+++ /tmp/tmp1f03etjq.java\t2022-07-19 04:31:09.475476696 +0200\n@@ -170,11 +170,11 @@\n \n         final double[] dx2 = new double[pointSet.size()];\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+int sum = 1; // we didn't really modify it was copied\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                 final double d = p.distanceFrom(nearest.getCenter());\n                 sum += d * d;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int sum = 1; // we didn't really modify it's parent",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-57/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\t2022-07-19 04:31:51.903245085 +0200\n+++ /tmp/tmp5b6kzwb9.java\t2022-07-19 04:31:51.903245085 +0200\n@@ -170,11 +170,11 @@\n \n         final double[] dx2 = new double[pointSet.size()];\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+int sum = 1; // we didn't really modify it's parent\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                 final double d = p.distanceFrom(nearest.getCenter());\n                 sum += d * d;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int sum = 1; // we didn't really modify it",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-57/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\t2022-07-19 04:32:34.035015088 +0200\n+++ /tmp/tmpz2czjbch.java\t2022-07-19 04:32:34.039015064 +0200\n@@ -170,11 +170,11 @@\n \n         final double[] dx2 = new double[pointSet.size()];\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+int sum = 1; // we didn't really modify it\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                 final double d = p.distanceFrom(nearest.getCenter());\n                 sum += d * d;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int sum = 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-57/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\t2022-07-19 04:33:16.470783432 +0200\n+++ /tmp/tmpbi2o855m.java\t2022-07-19 04:33:16.470783432 +0200\n@@ -170,11 +170,11 @@\n \n         final double[] dx2 = new double[pointSet.size()];\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+int sum = 1;\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                 final double d = p.distanceFrom(nearest.getCenter());\n                 sum += d * d;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int sum = 1; // we didn't really gets this",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-57/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\t2022-07-19 04:33:58.454554241 +0200\n+++ /tmp/tmpg7fzdt6e.java\t2022-07-19 04:33:58.454554241 +0200\n@@ -170,11 +170,11 @@\n \n         final double[] dx2 = new double[pointSet.size()];\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+int sum = 1; // we didn't really gets this\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                 final double d = p.distanceFrom(nearest.getCenter());\n                 sum += d * d;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "int sum = 0;",
        "fixed_line": "double sum = 0;"
    },
    "Math-104": {
        "fixes": [
            {
                "k": 1,
                "patch": "private static final double DEFAULT_EPSILON = 10e-9;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-104/src/java/org/apache/commons/math/special/Gamma.java\t2022-07-19 04:34:40.970322149 +0200\n+++ /tmp/tmpg1y25po4.java\t2022-07-19 04:34:40.994322021 +0200\n@@ -32,11 +32,11 @@\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-9;\n+private static final double DEFAULT_EPSILON = 10e-9;\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n     {\n         0.99999999999999709182,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "private static final double DEFAULT_EPSILON = 9;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-104/src/java/org/apache/commons/math/special/Gamma.java\t2022-07-19 04:34:49.674274635 +0200\n+++ /tmp/tmpo_unvto7.java\t2022-07-19 04:34:49.674274635 +0200\n@@ -32,11 +32,11 @@\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-9;\n+private static final double DEFAULT_EPSILON = 9;\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n     {\n         0.99999999999999709182,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "private static final double DEFAULT_EPSILON = 8;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-104/src/java/org/apache/commons/math/special/Gamma.java\t2022-07-19 04:34:58.334227364 +0200\n+++ /tmp/tmp67mer40u.java\t2022-07-19 04:34:58.334227364 +0200\n@@ -32,11 +32,11 @@\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-9;\n+private static final double DEFAULT_EPSILON = 8;\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n     {\n         0.99999999999999709182,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "private static final double DEFAULT_EPSILON = 1024;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-104/src/java/org/apache/commons/math/special/Gamma.java\t2022-07-19 04:35:06.702181684 +0200\n+++ /tmp/tmp93cskg6l.java\t2022-07-19 04:35:06.702181684 +0200\n@@ -32,11 +32,11 @@\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-9;\n+private static final double DEFAULT_EPSILON = 1024;\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n     {\n         0.99999999999999709182,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private static final double DEFAULT_EPSILON = 1e-9;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-104/src/java/org/apache/commons/math/special/Gamma.java\t2022-07-19 04:35:15.126135698 +0200\n+++ /tmp/tmpitbsjpny.java\t2022-07-19 04:35:15.130135673 +0200\n@@ -32,11 +32,11 @@\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-9;\n+private static final double DEFAULT_EPSILON = 1e-9;\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n     {\n         0.99999999999999709182,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "private static final double DEFAULT_EPSILON = 16;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-104/src/java/org/apache/commons/math/special/Gamma.java\t2022-07-19 04:35:23.554089690 +0200\n+++ /tmp/tmpvnfgg8h2.java\t2022-07-19 04:35:23.554089690 +0200\n@@ -32,11 +32,11 @@\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-9;\n+private static final double DEFAULT_EPSILON = 16;\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n     {\n         0.99999999999999709182,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private static final double DEFAULT_EPSILON = 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-104/src/java/org/apache/commons/math/special/Gamma.java\t2022-07-19 04:35:32.110042980 +0200\n+++ /tmp/tmpn3rcum_h.java\t2022-07-19 04:35:32.114042959 +0200\n@@ -32,11 +32,11 @@\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-9;\n+private static final double DEFAULT_EPSILON = 1;\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n     {\n         0.99999999999999709182,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "private static final double DEFAULT_EPSILON = 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-104/src/java/org/apache/commons/math/special/Gamma.java\t2022-07-19 04:35:40.825995402 +0200\n+++ /tmp/tmpatf2cb62.java\t2022-07-19 04:35:40.825995402 +0200\n@@ -32,11 +32,11 @@\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-9;\n+private static final double DEFAULT_EPSILON = 1;\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n     {\n         0.99999999999999709182,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private static final double DEFAULT_EPSILON = 1_EPSILON;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-104/src/java/org/apache/commons/math/special/Gamma.java\t2022-07-19 04:35:49.165949875 +0200\n+++ /tmp/tmpe9il7yhv.java\t2022-07-19 04:35:49.165949875 +0200\n@@ -32,11 +32,11 @@\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-9;\n+private static final double DEFAULT_EPSILON = 1_EPSILON;\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n     {\n         0.99999999999999709182,\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "private static final double DEFAULT_EPSILON = 0);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-104/src/java/org/apache/commons/math/special/Gamma.java\t2022-07-19 04:35:52.245933060 +0200\n+++ /tmp/tmpkpftf5a9.java\t2022-07-19 04:35:52.249933039 +0200\n@@ -32,11 +32,11 @@\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-9;\n+private static final double DEFAULT_EPSILON = 0);\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n     {\n         0.99999999999999709182,\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "private static final double DEFAULT_EPSILON = 10e-9;",
        "fixed_line": "private static final double DEFAULT_EPSILON = 10e-15;"
    },
    "Jsoup-27": {
        "fixes": [
            {
                "k": 1,
                "patch": "return charset;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-27/src/main/java/org/jsoup/helper/DataUtil.java\t2022-07-19 04:35:55.597914760 +0200\n+++ /tmp/tmpc910emd1.java\t2022-07-19 04:35:55.633914567 +0200\n@@ -128,11 +128,11 @@\n         if (contentType == null) return null;\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n             charset = charset.toUpperCase(Locale.ENGLISH);\n-            return charset;\n+return charset;\n         }\n         return null;\n     }\n     \n     \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return charset; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-27/src/main/java/org/jsoup/helper/DataUtil.java\t2022-07-19 04:35:58.597898386 +0200\n+++ /tmp/tmp9s9skw6u.java\t2022-07-19 04:35:58.597898386 +0200\n@@ -128,11 +128,11 @@\n         if (contentType == null) return null;\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n             charset = charset.toUpperCase(Locale.ENGLISH);\n-            return charset;\n+return charset; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n         }\n         return null;\n     }\n     \n     \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return charset; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-27/src/main/java/org/jsoup/helper/DataUtil.java\t2022-07-19 04:36:01.593882031 +0200\n+++ /tmp/tmpidxqdlfy.java\t2022-07-19 04:36:01.597882009 +0200\n@@ -128,11 +128,11 @@\n         if (contentType == null) return null;\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n             charset = charset.toUpperCase(Locale.ENGLISH);\n-            return charset;\n+return charset; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n         }\n         return null;\n     }\n     \n     \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return charset; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-27/src/main/java/org/jsoup/helper/DataUtil.java\t2022-07-19 04:36:04.509866113 +0200\n+++ /tmp/tmp8e3wr6yy.java\t2022-07-19 04:36:04.513866091 +0200\n@@ -128,11 +128,11 @@\n         if (contentType == null) return null;\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n             charset = charset.toUpperCase(Locale.ENGLISH);\n-            return charset;\n+return charset; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number\n         }\n         return null;\n     }\n     \n     \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return charset; // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-27/src/main/java/org/jsoup/helper/DataUtil.java\t2022-07-19 04:36:07.489849845 +0200\n+++ /tmp/tmpwlzcpnxk.java\t2022-07-19 04:36:07.489849845 +0200\n@@ -128,11 +128,11 @@\n         if (contentType == null) return null;\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n             charset = charset.toUpperCase(Locale.ENGLISH);\n-            return charset;\n+return charset; // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n         }\n         return null;\n     }\n     \n     \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return charset; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-27/src/main/java/org/jsoup/helper/DataUtil.java\t2022-07-19 04:36:10.469833578 +0200\n+++ /tmp/tmpkmzd0bj3.java\t2022-07-19 04:36:10.469833578 +0200\n@@ -128,11 +128,11 @@\n         if (contentType == null) return null;\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n             charset = charset.toUpperCase(Locale.ENGLISH);\n-            return charset;\n+return charset; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number\n         }\n         return null;\n     }\n     \n     \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return charset; // we didn't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-27/src/main/java/org/jsoup/helper/DataUtil.java\t2022-07-19 04:36:13.261818337 +0200\n+++ /tmp/tmphxqhhsnv.java\t2022-07-19 04:36:13.261818337 +0200\n@@ -128,11 +128,11 @@\n         if (contentType == null) return null;\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n             charset = charset.toUpperCase(Locale.ENGLISH);\n-            return charset;\n+return charset; // we didn't really modify it's totalGJACKSON-notnotnotnot real number\n         }\n         return null;\n     }\n     \n     \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return charset; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-27/src/main/java/org/jsoup/helper/DataUtil.java\t2022-07-19 04:36:16.241802069 +0200\n+++ /tmp/tmp2z1k0umb.java\t2022-07-19 04:36:16.241802069 +0200\n@@ -128,11 +128,11 @@\n         if (contentType == null) return null;\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n             charset = charset.toUpperCase(Locale.ENGLISH);\n-            return charset;\n+return charset; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnot real number\n         }\n         return null;\n     }\n     \n     \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return charset; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-27/src/main/java/org/jsoup/helper/DataUtil.java\t2022-07-19 04:36:19.285785453 +0200\n+++ /tmp/tmpw7nlxdt2.java\t2022-07-19 04:36:19.285785453 +0200\n@@ -128,11 +128,11 @@\n         if (contentType == null) return null;\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n             charset = charset.toUpperCase(Locale.ENGLISH);\n-            return charset;\n+return charset; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnotnot real number\n         }\n         return null;\n     }\n     \n     \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return charset; // we didn't really modify it's totalGJACKSON-notnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-27/src/main/java/org/jsoup/helper/DataUtil.java\t2022-07-19 04:36:22.241769316 +0200\n+++ /tmp/tmpwqpngzkk.java\t2022-07-19 04:36:22.241769316 +0200\n@@ -128,11 +128,11 @@\n         if (contentType == null) return null;\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n             charset = charset.toUpperCase(Locale.ENGLISH);\n-            return charset;\n+return charset; // we didn't really modify it's totalGJACKSON-notnotnot real number\n         }\n         return null;\n     }\n     \n     \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return charset;",
        "fixed_line": "if (Charset.isSupported(charset)) return charset; charset = charset.toUpperCase(Locale.ENGLISH); if (Charset.isSupported(charset)) return charset;"
    },
    "Csv-3": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int i = 0; i < length; // TODO unexpected char - available from in.getLastChar()",
                "patch_diff": "for (int i = 0; i < length; // TODO unexpected char - available from in.getLastChar()",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = 0; i < length; // TODO unexpected char - available from in.getLastChar() - available from in.getLastChar()",
                "patch_diff": "for (int i = 0; i < length; // TODO unexpected char - available from in.getLastChar() - available from in.getLastChar()",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0; i < length;",
                "patch_diff": "for (int i = 0; i < length;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = 0; i < length; // TODO unexpected char - available from in.getLastChar() - available from in.getLastChar() - available from in.getLastChar()",
                "patch_diff": "for (int i = 0; i < length; // TODO unexpected char - available from in.getLastChar() - available from in.getLastChar() - available from in.getLastChar()",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = 0; i < length; // never char - available from in.getLastChar()",
                "patch_diff": "for (int i = 0; i < length; // never char - available from in.getLastChar()",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = 0; i < length; i++) {",
                "patch_diff": "for (int i = 0; i < length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = 0; i < length; // never char - available from in.getLastChar() - available from in.getLastChar()",
                "patch_diff": "for (int i = 0; i < length; // never char - available from in.getLastChar() - available from in.getLastChar()",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = 0; i < length; // TODO unexpected char - available from in.getLastChar() - available from in.getLastChar();",
                "patch_diff": "for (int i = 0; i < length; // TODO unexpected char - available from in.getLastChar() - available from in.getLastChar();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int i = 0; i < length; // TODO unexpected char - available from in.getLastChar() - available from in.getLastChar() - available from in.getLastChar();",
                "patch_diff": "for (int i = 0; i < length; // TODO unexpected char - available from in.getLastChar() - available from in.getLastChar() - available from in.getLastChar();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = 0; i < length; // never char - available from in.getLastChar() - available from in.getLastChar() - available from in.getLastChar()",
                "patch_diff": "for (int i = 0; i < length; // never char - available from in.getLastChar() - available from in.getLastChar() - available from in.getLastChar()",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (isDelimiter(c) || isEscape(c) || isQuoteChar(c) || isCommentStart(c)) { return c; } // indicate unexpected char - available from in.getLastChar() return END_OF_STREAM;"
    },
    "Cli-35": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (opt.startsWith(longOpt.keySet()) {",
                "patch_diff": "if (opt.startsWith(longOpt.keySet()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "longOpts = Util.keySet()) {",
                "patch_diff": "longOpts = Util.keySet()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// longOpts = Util.keySet()) {",
                "patch_diff": "// longOpts = Util.keySet()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (longOpt.keySet()) {",
                "patch_diff": "for (longOpt.keySet()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// if (opt.keySet()) {",
                "patch_diff": "// if (opt.keySet()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "List matchingOpts = Util.stripLeadingHyph.keySet()) {",
                "patch_diff": "List matchingOpts = Util.stripLeadingHyph.keySet()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// longOpts.keySet()) {",
                "patch_diff": "// longOpts.keySet()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (opt.startsWith(opt)) {",
                "patch_diff": "if (opt.startsWith(opt)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (opt.startsWith(longOpt) {",
                "patch_diff": "if (opt.startsWith(longOpt) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (opt.startsWith(longOpt)) {",
                "patch_diff": "if (opt.startsWith(longOpt)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if(longOpts.keySet().contains(opt)) { return Collections.singletonList(opt); }"
    },
    "JacksonDatabind-28": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (p.getCurrentToken()!= JsonToken.START_OBJECT) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-28/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\t2022-07-19 04:36:28.889733025 +0200\n+++ /tmp/tmp7boc00m2.java\t2022-07-19 04:36:28.913732892 +0200\n@@ -92,18 +92,11 @@\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n-            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n-                p.nextToken();\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n-            }\n-            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n+if (p.getCurrentToken()!= JsonToken.START_OBJECT) {\n             }\n             throw ctxt.mappingException(ObjectNode.class);\n          }\n     }\n         \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (p.getCurrentToken() == JsonToken.START_OBJECT) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-28/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\t2022-07-19 04:37:04.881536548 +0200\n+++ /tmp/tmpn34xjhii.java\t2022-07-19 04:37:04.885536527 +0200\n@@ -92,18 +92,11 @@\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n-            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n-                p.nextToken();\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n-            }\n-            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n+if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n             }\n             throw ctxt.mappingException(ObjectNode.class);\n          }\n     }\n         \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (p.getCurrentToken()!= JsonToken.START_OBJECT && p.nextToken() == JsonToken.START_OBJECT) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-28/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\t2022-07-19 04:37:38.569352649 +0200\n+++ /tmp/tmp1l_c22n3.java\t2022-07-19 04:37:38.569352649 +0200\n@@ -92,18 +92,11 @@\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n-            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n-                p.nextToken();\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n-            }\n-            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n+if (p.getCurrentToken()!= JsonToken.START_OBJECT && p.nextToken() == JsonToken.START_OBJECT) {\n             }\n             throw ctxt.mappingException(ObjectNode.class);\n          }\n     }\n         \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (p.getCurrentToken()!= JsonToken.START_OBJECT && p.nextToken()!= JsonToken.START_OBJECT) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-28/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\t2022-07-19 04:38:11.985170237 +0200\n+++ /tmp/tmpu6pik5uq.java\t2022-07-19 04:38:11.985170237 +0200\n@@ -92,18 +92,11 @@\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n-            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n-                p.nextToken();\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n-            }\n-            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n+if (p.getCurrentToken()!= JsonToken.START_OBJECT && p.nextToken()!= JsonToken.START_OBJECT) {\n             }\n             throw ctxt.mappingException(ObjectNode.class);\n          }\n     }\n         \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (p.getCurrentToken() == JsonToken.START_OBJECT || p.nextToken() == JsonToken.START_OBJECT) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-28/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\t2022-07-19 04:38:45.712986119 +0200\n+++ /tmp/tmpli0bavkr.java\t2022-07-19 04:38:45.716986098 +0200\n@@ -92,18 +92,11 @@\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n-            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n-                p.nextToken();\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n-            }\n-            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n+if (p.getCurrentToken() == JsonToken.START_OBJECT || p.nextToken() == JsonToken.START_OBJECT) {\n             }\n             throw ctxt.mappingException(ObjectNode.class);\n          }\n     }\n         \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (p.getCurrentToken() == JsonToken.START_OBJECT) { // let's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-28/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\t2022-07-19 04:39:18.876805082 +0200\n+++ /tmp/tmpo5dyz5lr.java\t2022-07-19 04:39:18.876805082 +0200\n@@ -92,18 +92,11 @@\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n-            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n-                p.nextToken();\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n-            }\n-            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n+if (p.getCurrentToken() == JsonToken.START_OBJECT) { // let's do implicit re-parse\n             }\n             throw ctxt.mappingException(ObjectNode.class);\n          }\n     }\n         \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (p.getCurrentToken() == JsonToken.START_OBJECT || _nextToken.START_OBJECT == JsonToken.START_OBJECT) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-28/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\t2022-07-19 04:39:52.276622754 +0200\n+++ /tmp/tmpgbiargis.java\t2022-07-19 04:39:52.276622754 +0200\n@@ -92,18 +92,11 @@\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n-            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n-                p.nextToken();\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n-            }\n-            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n+if (p.getCurrentToken() == JsonToken.START_OBJECT || _nextToken.START_OBJECT == JsonToken.START_OBJECT) {\n             }\n             throw ctxt.mappingException(ObjectNode.class);\n          }\n     }\n         \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (p.getCurrentToken() == JsonToken.START_OBJECT || _nextToken.END_OBJECT == JsonToken.START_ARRAY) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-28/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\t2022-07-19 04:39:54.120612690 +0200\n+++ /tmp/tmpgdvyj9mh.java\t2022-07-19 04:39:54.120612690 +0200\n@@ -92,18 +92,11 @@\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n-            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n-                p.nextToken();\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n-            }\n-            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n+if (p.getCurrentToken() == JsonToken.START_OBJECT || _nextToken.END_OBJECT == JsonToken.START_ARRAY) {\n             }\n             throw ctxt.mappingException(ObjectNode.class);\n          }\n     }\n         \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (p.getCurrentToken() == JsonToken.START_OBJECT || _nextToken.END_OBJECT == JsonToken.START_OBJECT) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-28/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\t2022-07-19 04:39:55.884603060 +0200\n+++ /tmp/tmpxdfxz68m.java\t2022-07-19 04:39:55.888603037 +0200\n@@ -92,18 +92,11 @@\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n-            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n-                p.nextToken();\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n-            }\n-            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n+if (p.getCurrentToken() == JsonToken.START_OBJECT || _nextToken.END_OBJECT == JsonToken.START_OBJECT) {\n             }\n             throw ctxt.mappingException(ObjectNode.class);\n          }\n     }\n         \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (p.getCurrentToken() == JsonToken.START_OBJECT || _nextToken.START_OBJECT == JsonToken.START_ARRAY) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-28/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\t2022-07-19 04:39:57.656593386 +0200\n+++ /tmp/tmp2_c4lao1.java\t2022-07-19 04:39:57.656593386 +0200\n@@ -92,18 +92,11 @@\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n-            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n-                p.nextToken();\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n-            }\n-            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n+if (p.getCurrentToken() == JsonToken.START_OBJECT || _nextToken.START_OBJECT == JsonToken.START_ARRAY) {\n             }\n             throw ctxt.mappingException(ObjectNode.class);\n          }\n     }\n         \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (p.getCurrentToken() == JsonToken.START_OBJECT) { p.nextToken(); return deserializeObject(p, ctxt, ctxt.getNodeFactory()); } // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME), // if caller has advanced to the first token of Object, but for empty Object if (p.getCurrentToken() == JsonToken.FIELD_NAME) { return deserializeObject(p, ctxt, ctxt.getNodeFactory());",
        "fixed_line": "if (p.isExpectedStartObjectToken() || p.hasToken(JsonToken.FIELD_NAME)) { return deserializeObject(p, ctxt, ctxt.getNodeFactory()); } // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME), // if caller has advanced to the first token of Object, but for empty Object if (p.hasToken(JsonToken.END_OBJECT)) { return ctxt.getNodeFactory().objectNode();"
    },
    "Math-19": {
        "fixes": [
            {
                "k": 1,
                "patch": "// throw new double[1] = uB; boundaries[1] = uB;",
                "patch_diff": "// throw new double[1] = uB; boundaries[1] = uB;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// throw new double[1] = uB; boundaries[1] = lB;",
                "patch_diff": "// throw new double[1] = uB; boundaries[1] = lB;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// throw new double[1] = new double[1] = uB;",
                "patch_diff": "// throw new double[1] = new double[1] = uB;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (lB == null) {",
                "patch_diff": "if (lB == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// throw new double[1] = uB;",
                "patch_diff": "// throw new double[1] = uB;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// Convert early = new double[1] = uB;",
                "patch_diff": "// Convert early = new double[1] = uB;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// Convert early = new double[1] = lB;",
                "patch_diff": "// Convert early = new double[1] = lB;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// throw new double[1] = new double[1] = lB;",
                "patch_diff": "// throw new double[1] = new double[1] = lB;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// throw new double[1] = uB; // never be null",
                "patch_diff": "// throw new double[1] = uB; // never be null",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// throw new double[1] = lB;",
                "patch_diff": "// throw new double[1] = lB;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "for (int i = 0; i < lB.length; i++) { if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) { final double max = Double.MAX_VALUE + boundaries[0][i]; final NumberIsTooLargeException e = new NumberIsTooLargeException(boundaries[1][i], max, true); e.getContext().addMessage(LocalizedFormats.OVERFLOW); e.getContext().addMessage(LocalizedFormats.INDEX, i); throw e; } }"
    },
    "JacksonDatabind-16": {
        "fixes": [
            {
                "k": 1,
                "patch": "return previous!= null && previous.equals(ann);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-16/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\t2022-07-19 04:40:01.136574389 +0200\n+++ /tmp/tmpc5fcst4j.java\t2022-07-19 04:40:01.156574280 +0200\n@@ -107,10 +107,10 @@\n     protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+return previous!= null && previous.equals(ann);\n     }\n }\n \n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return (previous!= null) && previous.equals(ann);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-16/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\t2022-07-19 04:40:32.196404838 +0200\n+++ /tmp/tmphbnuivgm.java\t2022-07-19 04:40:32.196404838 +0200\n@@ -107,10 +107,10 @@\n     protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+return (previous!= null) && previous.equals(ann);\n     }\n }\n \n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return (previous!= null && previous.equals(ann));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-16/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\t2022-07-19 04:41:01.052247318 +0200\n+++ /tmp/tmpn9zrtbv0.java\t2022-07-19 04:41:01.052247318 +0200\n@@ -107,10 +107,10 @@\n     protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+return (previous!= null && previous.equals(ann));\n     }\n }\n \n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return (previous!= null) && previous.equals(ann));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-16/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\t2022-07-19 04:41:30.204088182 +0200\n+++ /tmp/tmpx_9u2l1r.java\t2022-07-19 04:41:30.224088072 +0200\n@@ -107,10 +107,10 @@\n     protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+return (previous!= null) && previous.equals(ann));\n     }\n }\n \n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return previous!= null && previous.equals(ann));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-16/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\t2022-07-19 04:41:31.868079096 +0200\n+++ /tmp/tmp3_9d77et.java\t2022-07-19 04:41:31.868079096 +0200\n@@ -107,10 +107,10 @@\n     protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+return previous!= null && previous.equals(ann));\n     }\n }\n \n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return previous!= null) && previous.equals(ann);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-16/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\t2022-07-19 04:41:33.384070821 +0200\n+++ /tmp/tmp74olltel.java\t2022-07-19 04:41:33.384070821 +0200\n@@ -107,10 +107,10 @@\n     protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+return previous!= null) && previous.equals(ann);\n     }\n }\n \n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return (_previous!= null) && previous.equals(ann);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-16/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\t2022-07-19 04:41:34.968062174 +0200\n+++ /tmp/tmpjpcmkd2d.java\t2022-07-19 04:41:34.968062174 +0200\n@@ -107,10 +107,10 @@\n     protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+return (_previous!= null) && previous.equals(ann);\n     }\n }\n \n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return (_previous!= null && previous.equals(ann));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-16/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\t2022-07-19 04:41:36.668052893 +0200\n+++ /tmp/tmp0d2u2ltv.java\t2022-07-19 04:41:36.668052893 +0200\n@@ -107,10 +107,10 @@\n     protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+return (_previous!= null && previous.equals(ann));\n     }\n }\n \n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return (previous!= null) || previous.equals(ann);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-16/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\t2022-07-19 04:41:38.404043419 +0200\n+++ /tmp/tmpvq2mo7p1.java\t2022-07-19 04:41:38.408043395 +0200\n@@ -107,10 +107,10 @@\n     protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+return (previous!= null) || previous.equals(ann);\n     }\n }\n \n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return current!= null && previous.equals(ann);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-16/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\t2022-07-19 04:42:02.383912514 +0200\n+++ /tmp/tmpjs6cvh69.java\t2022-07-19 04:42:02.399912428 +0200\n@@ -107,10 +107,10 @@\n     protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+return current!= null && previous.equals(ann);\n     }\n }\n \n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return (previous != null) && previous.equals(ann);",
        "fixed_line": "return (previous == null) || !previous.equals(ann);"
    },
    "Closure-97": {
        "fixes": [
            {
                "k": 1,
                "patch": "result = lvalInt >>> 12;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-97/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 04:42:04.219902491 +0200\n+++ /tmp/tmpsa9gwjro.java\t2022-07-19 04:42:04.235902405 +0200\n@@ -693,11 +693,11 @@\n           break;\n         case Token.URSH:\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+result = lvalInt >>> 12;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "result = lvalInt >>> 16;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-97/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 04:42:25.351787137 +0200\n+++ /tmp/tmplp_8nk9f.java\t2022-07-19 04:42:25.351787137 +0200\n@@ -693,11 +693,11 @@\n           break;\n         case Token.URSH:\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+result = lvalInt >>> 16;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "result = lvalInt >>> 15;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-97/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 04:42:46.323672654 +0200\n+++ /tmp/tmp3_asbedg.java\t2022-07-19 04:42:46.323672654 +0200\n@@ -693,11 +693,11 @@\n           break;\n         case Token.URSH:\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+result = lvalInt >>> 15;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "result = lvalInt >>> 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-97/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 04:43:07.711555901 +0200\n+++ /tmp/tmphjipd4h4.java\t2022-07-19 04:43:07.715555877 +0200\n@@ -693,11 +693,11 @@\n           break;\n         case Token.URSH:\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+result = lvalInt >>> 1;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "result = lvalInt >>> rvalInt;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-97/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 04:43:28.939440019 +0200\n+++ /tmp/tmpdm92pc8w.java\t2022-07-19 04:43:28.939440019 +0200\n@@ -693,11 +693,11 @@\n           break;\n         case Token.URSH:\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+result = lvalInt >>> rvalInt;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "result = lvalInt >>> 24;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-97/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 04:43:50.211323899 +0200\n+++ /tmp/tmpyhr6wimh.java\t2022-07-19 04:43:50.211323899 +0200\n@@ -693,11 +693,11 @@\n           break;\n         case Token.URSH:\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+result = lvalInt >>> 24;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "result = lvalInt >>> 8;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-97/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 04:44:11.343208544 +0200\n+++ /tmp/tmp9jv9p5ul.java\t2022-07-19 04:44:11.343208544 +0200\n@@ -693,11 +693,11 @@\n           break;\n         case Token.URSH:\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+result = lvalInt >>> 8;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "result = lvalInt >>> 24Int;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-97/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 04:44:32.671092116 +0200\n+++ /tmp/tmpcm04egg4.java\t2022-07-19 04:44:32.671092116 +0200\n@@ -693,11 +693,11 @@\n           break;\n         case Token.URSH:\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+result = lvalInt >>> 24Int;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "result = lvalInt >>> 14;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-97/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 04:44:34.211083712 +0200\n+++ /tmp/tmpievlpnbw.java\t2022-07-19 04:44:34.211083712 +0200\n@@ -693,11 +693,11 @@\n           break;\n         case Token.URSH:\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+result = lvalInt >>> 14;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "result = lvalInt >>> 28;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-97/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 04:44:55.162962921 +0200\n+++ /tmp/tmpgtvkni4g.java\t2022-07-19 04:44:55.162962921 +0200\n@@ -693,11 +693,11 @@\n           break;\n         case Token.URSH:\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+result = lvalInt >>> 28;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "result = lvalInt >>> rvalInt;",
        "fixed_line": "long lvalLong = lvalInt & 0xffffffffL; result = lvalLong >>> rvalInt;"
    },
    "Chart-9": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (endIndex < 0) { // end period is not in original series",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-9/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 04:45:16.626832643 +0200\n+++ /tmp/tmp5lleqioy.java\t2022-07-19 04:45:16.642832546 +0200\n@@ -939,11 +939,11 @@\n         int endIndex = getIndex(end);\n         if (endIndex < 0) {             // end period is not in original series\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+if (endIndex < 0) { // end period is not in original series\n             emptyRange = true;\n         }\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (endIndex < 0) { // end period is first item AFTER end",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-9/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 04:45:24.774783311 +0200\n+++ /tmp/tmpv9wth52s.java\t2022-07-19 04:45:24.774783311 +0200\n@@ -939,11 +939,11 @@\n         int endIndex = getIndex(end);\n         if (endIndex < 0) {             // end period is not in original series\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+if (endIndex < 0) { // end period is first item AFTER end\n             emptyRange = true;\n         }\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (endIndex < 0) { // end period is negative",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-9/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 04:45:32.798734794 +0200\n+++ /tmp/tmp5as_xnws.java\t2022-07-19 04:45:32.798734794 +0200\n@@ -939,11 +939,11 @@\n         int endIndex = getIndex(end);\n         if (endIndex < 0) {             // end period is not in original series\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+if (endIndex < 0) { // end period is negative\n             emptyRange = true;\n         }\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (startIndex < 0) { // end period is not in original series",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-9/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 04:45:40.838686240 +0200\n+++ /tmp/tmpt3ofjq6y.java\t2022-07-19 04:45:40.838686240 +0200\n@@ -939,11 +939,11 @@\n         int endIndex = getIndex(end);\n         if (endIndex < 0) {             // end period is not in original series\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+if (startIndex < 0) { // end period is not in original series\n             emptyRange = true;\n         }\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (endIndex < 0) { // end period is last item BEFORE end",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-9/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 04:45:48.762638450 +0200\n+++ /tmp/tmp_frxhvod.java\t2022-07-19 04:45:48.766638428 +0200\n@@ -939,11 +939,11 @@\n         int endIndex = getIndex(end);\n         if (endIndex < 0) {             // end period is not in original series\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+if (endIndex < 0) { // end period is last item BEFORE end\n             emptyRange = true;\n         }\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (endIndex < 0) { // end period is a end period",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-9/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 04:45:56.974588987 +0200\n+++ /tmp/tmpdhx1g7l6.java\t2022-07-19 04:45:56.974588987 +0200\n@@ -939,11 +939,11 @@\n         int endIndex = getIndex(end);\n         if (endIndex < 0) {             // end period is not in original series\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+if (endIndex < 0) { // end period is a end period\n             emptyRange = true;\n         }\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (endIndex < 0) { // start is not in original series",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-9/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 04:46:04.894541342 +0200\n+++ /tmp/tmpl4ejqf2y.java\t2022-07-19 04:46:04.898541317 +0200\n@@ -939,11 +939,11 @@\n         int endIndex = getIndex(end);\n         if (endIndex < 0) {             // end period is not in original series\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+if (endIndex < 0) { // start is not in original series\n             emptyRange = true;\n         }\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (endIndex < 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-9/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 04:46:13.058492285 +0200\n+++ /tmp/tmpxvgs77wp.java\t2022-07-19 04:46:13.058492285 +0200\n@@ -939,11 +939,11 @@\n         int endIndex = getIndex(end);\n         if (endIndex < 0) {             // end period is not in original series\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+if (endIndex < 0) {\n             emptyRange = true;\n         }\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (startIndex < 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-9/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 04:46:21.238443195 +0200\n+++ /tmp/tmpxinhv69a.java\t2022-07-19 04:46:21.238443195 +0200\n@@ -939,11 +939,11 @@\n         int endIndex = getIndex(end);\n         if (endIndex < 0) {             // end period is not in original series\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+if (startIndex < 0) {\n             emptyRange = true;\n         }\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (startIndex < 0) { // end period is first item AFTER end",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-9/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 04:46:29.194395508 +0200\n+++ /tmp/tmpwfh0_2lx.java\t2022-07-19 04:46:29.194395508 +0200\n@@ -939,11 +939,11 @@\n         int endIndex = getIndex(end);\n         if (endIndex < 0) {             // end period is not in original series\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+if (startIndex < 0) { // end period is first item AFTER end\n             emptyRange = true;\n         }\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (endIndex < 0) {",
        "fixed_line": "if ((endIndex < 0) || (endIndex < startIndex)) {"
    },
    "Chart-7": {
        "fixes": [
            {
                "k": 1,
                "patch": "long s = getDataItem(this.minMiddleIndex).getPeriod().getStart().getTime(); long e = getDataItem(this.minMiddleIndex).getEnd()",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-7/source/org/jfree/data/time/TimePeriodValues.java\t2022-07-19 04:46:37.426346224 +0200\n+++ /tmp/tmpflmhiy6l.java\t2022-07-19 04:46:37.426346224 +0200\n@@ -295,13 +295,11 @@\n         else {\n             this.minMiddleIndex = index;\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+long s = getDataItem(this.minMiddleIndex).getPeriod().getStart().getTime(); long e = getDataItem(this.minMiddleIndex).getEnd()\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n                 this.maxMiddleIndex = index;           \n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "long s = HItem(this.minMiddleIndex).getPeriod().getStart().getTime(); long e = getDataItem(this.minMiddleIndex).getEnd()",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-7/source/org/jfree/data/time/TimePeriodValues.java\t2022-07-19 04:46:39.178335740 +0200\n+++ /tmp/tmpk26dbfhg.java\t2022-07-19 04:46:39.182335719 +0200\n@@ -295,13 +295,11 @@\n         else {\n             this.minMiddleIndex = index;\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+long s = HItem(this.minMiddleIndex).getPeriod().getStart().getTime(); long e = getDataItem(this.minMiddleIndex).getEnd()\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n                 this.maxMiddleIndex = index;           \n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "long s = getDataItem(this.minMiddleIndex).getPeriod().getStart().getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-7/source/org/jfree/data/time/TimePeriodValues.java\t2022-07-19 04:46:40.982324952 +0200\n+++ /tmp/tmp0rboapzr.java\t2022-07-19 04:46:40.982324952 +0200\n@@ -295,13 +295,11 @@\n         else {\n             this.minMiddleIndex = index;\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+long s = getDataItem(this.minMiddleIndex).getPeriod().getStart().getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n                 this.maxMiddleIndex = index;           \n             }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "long s = this.minMiddleIndex).getPeriod().getStart().getTime(); long e = getDataItem(this.minMiddleIndex).getEnd()",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-7/source/org/jfree/data/time/TimePeriodValues.java\t2022-07-19 04:46:49.026276873 +0200\n+++ /tmp/tmphodame08.java\t2022-07-19 04:46:49.026276873 +0200\n@@ -295,13 +295,11 @@\n         else {\n             this.minMiddleIndex = index;\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+long s = this.minMiddleIndex).getPeriod().getStart().getTime(); long e = getDataItem(this.minMiddleIndex).getEnd()\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n                 this.maxMiddleIndex = index;           \n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "long s = getDataItem(this.minMiddleIndex).getPeriod().getStart().getTime(); long e = getDataItem(this.minMiddleIndex).getEnd();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-7/source/org/jfree/data/time/TimePeriodValues.java\t2022-07-19 04:46:50.714266788 +0200\n+++ /tmp/tmpu8r4l5x4.java\t2022-07-19 04:46:50.714266788 +0200\n@@ -295,13 +295,11 @@\n         else {\n             this.minMiddleIndex = index;\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+long s = getDataItem(this.minMiddleIndex).getPeriod().getStart().getTime(); long e = getDataItem(this.minMiddleIndex).getEnd();\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n                 this.maxMiddleIndex = index;           \n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "long s = getDataItem(this.minMiddleIndex).getPeriod().getStart().getTime(); long e = getDataItem(this.minMiddleIndex).getEnd()()",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-7/source/org/jfree/data/time/TimePeriodValues.java\t2022-07-19 04:46:52.398256732 +0200\n+++ /tmp/tmp4lwe7y0i.java\t2022-07-19 04:46:52.398256732 +0200\n@@ -295,13 +295,11 @@\n         else {\n             this.minMiddleIndex = index;\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+long s = getDataItem(this.minMiddleIndex).getPeriod().getStart().getTime(); long e = getDataItem(this.minMiddleIndex).getEnd()()\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n                 this.maxMiddleIndex = index;           \n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "long s = getDataItem(this.minMiddleIndex).getPeriod().getStart().getTime(); long e = getDataItem(this.minMiddleIndex).getEnd() {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-7/source/org/jfree/data/time/TimePeriodValues.java\t2022-07-19 04:46:54.094246610 +0200\n+++ /tmp/tmpajp82iuy.java\t2022-07-19 04:46:54.094246610 +0200\n@@ -295,13 +295,11 @@\n         else {\n             this.minMiddleIndex = index;\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+long s = getDataItem(this.minMiddleIndex).getPeriod().getStart().getTime(); long e = getDataItem(this.minMiddleIndex).getEnd() {\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n                 this.maxMiddleIndex = index;           \n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "long s = getDataItem(this.minMiddleIndex).getPeriod().getStart().getTime(); long e = getDataItem(this.minMiddleIndex).getEnd().getEnd()",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-7/source/org/jfree/data/time/TimePeriodValues.java\t2022-07-19 04:46:55.802236415 +0200\n+++ /tmp/tmp4s3nulg6.java\t2022-07-19 04:46:55.806236389 +0200\n@@ -295,13 +295,11 @@\n         else {\n             this.minMiddleIndex = index;\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+long s = getDataItem(this.minMiddleIndex).getPeriod().getStart().getTime(); long e = getDataItem(this.minMiddleIndex).getEnd().getEnd()\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n                 this.maxMiddleIndex = index;           \n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "long s = getDataItem(this.minMiddleIndex).getPeriod().getStart().getTime(); long e. getDataItem(this.minMiddleIndex).getEnd()",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-7/source/org/jfree/data/time/TimePeriodValues.java\t2022-07-19 04:46:57.558225934 +0200\n+++ /tmp/tmp59896_1u.java\t2022-07-19 04:46:57.558225934 +0200\n@@ -295,13 +295,11 @@\n         else {\n             this.minMiddleIndex = index;\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+long s = getDataItem(this.minMiddleIndex).getPeriod().getStart().getTime(); long e. getDataItem(this.minMiddleIndex).getEnd()\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n                 this.maxMiddleIndex = index;           \n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "long s = getDataItem(this.minMiddleIndex).getPeriod().getStart().getTime(); long e = getDataItem(this.minminMiddleIndex).getEnd()",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-7/source/org/jfree/data/time/TimePeriodValues.java\t2022-07-19 04:46:59.222216007 +0200\n+++ /tmp/tmpzzgw1q_u.java\t2022-07-19 04:46:59.222216007 +0200\n@@ -295,13 +295,11 @@\n         else {\n             this.minMiddleIndex = index;\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+long s = getDataItem(this.minMiddleIndex).getPeriod().getStart().getTime(); long e = getDataItem(this.minminMiddleIndex).getEnd()\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n                 this.maxMiddleIndex = index;           \n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()",
        "fixed_line": "long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()"
    },
    "Time-17": {
        "fixes": [
            {
                "k": 1,
                "patch": "long instantBefore = convertUTCToLocal - 3 * DateTimeConstants.MILLIS_PER_HOUR);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-17/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 04:47:01.358203270 +0200\n+++ /tmp/tmpa9yuh_3s.java\t2022-07-19 04:47:01.478202555 +0200\n@@ -1162,19 +1162,11 @@\n      */\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n-        }\n-        \n-        // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+long instantBefore = convertUTCToLocal - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n         \n         // calculate result\n           // currently in later offset\n           // currently in earlier offset\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "long instantBefore = convertUTCToLocal(instant); long instantAfter = convertUTC;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-17/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 04:47:03.230192105 +0200\n+++ /tmp/tmpmluoumu5.java\t2022-07-19 04:47:03.230192105 +0200\n@@ -1162,19 +1162,11 @@\n      */\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n-        }\n-        \n-        // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+long instantBefore = convertUTCToLocal(instant); long instantAfter = convertUTC;\n         \n         // calculate result\n           // currently in later offset\n           // currently in earlier offset\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-17/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 04:47:05.070181139 +0200\n+++ /tmp/tmpdh8h875e.java\t2022-07-19 04:47:05.070181139 +0200\n@@ -1162,19 +1162,11 @@\n      */\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n-        }\n-        \n-        // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n         \n         // calculate result\n           // currently in later offset\n           // currently in earlier offset\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "long instantBefore = convertUTCToLocal - 3 * DateTimeConstants.MILLIS_PER_HOUR); long instantAfter = convertUTC;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-17/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 04:47:06.874170389 +0200\n+++ /tmp/tmpc60gfh72.java\t2022-07-19 04:47:06.874170389 +0200\n@@ -1162,19 +1162,11 @@\n      */\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n-        }\n-        \n-        // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+long instantBefore = convertUTCToLocal - 3 * DateTimeConstants.MILLIS_PER_HOUR); long instantAfter = convertUTC;\n         \n         // calculate result\n           // currently in later offset\n           // currently in earlier offset\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "long instantBefore = convertUTCToLocal - 3 * DateTimeConstants.MILLIS_PER_HOUR); long instantBefore = convertUTC;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-17/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 04:47:08.406161261 +0200\n+++ /tmp/tmpozrzibvj.java\t2022-07-19 04:47:08.410161234 +0200\n@@ -1162,19 +1162,11 @@\n      */\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n-        }\n-        \n-        // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+long instantBefore = convertUTCToLocal - 3 * DateTimeConstants.MILLIS_PER_HOUR); long instantBefore = convertUTC;\n         \n         // calculate result\n           // currently in later offset\n           // currently in earlier offset\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR); long instantAfter = convertUTC;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-17/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 04:47:09.926152203 +0200\n+++ /tmp/tmp52vnjzv3.java\t2022-07-19 04:47:09.926152203 +0200\n@@ -1162,19 +1162,11 @@\n      */\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n-        }\n-        \n-        // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR); long instantAfter = convertUTC;\n         \n         // calculate result\n           // currently in later offset\n           // currently in earlier offset\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "long instantBefore = convertUTCToLocal - 3 * DateTimeConstants.MILLIS_PER_HOUR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-17/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 04:47:11.842140795 +0200\n+++ /tmp/tmpd80or7vt.java\t2022-07-19 04:47:11.842140795 +0200\n@@ -1162,19 +1162,11 @@\n      */\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n-        }\n-        \n-        // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+long instantBefore = convertUTCToLocal - 3 * DateTimeConstants.MILLIS_PER_HOUR;\n         \n         // calculate result\n           // currently in later offset\n           // currently in earlier offset\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR); long instantBefore = convertUTC;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-17/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 04:47:13.562130554 +0200\n+++ /tmp/tmps2mvf2hp.java\t2022-07-19 04:47:13.562130554 +0200\n@@ -1162,19 +1162,11 @@\n      */\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n-        }\n-        \n-        // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR); long instantBefore = convertUTC;\n         \n         // calculate result\n           // currently in later offset\n           // currently in earlier offset\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "long instantBefore = convertUTCToLocal(instant, 3 * DateTimeConstants.MILLIS_PER_HOUR);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-17/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 04:47:15.430119434 +0200\n+++ /tmp/tmphaff8h7g.java\t2022-07-19 04:47:15.430119434 +0200\n@@ -1162,19 +1162,11 @@\n      */\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n-        }\n-        \n-        // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+long instantBefore = convertUTCToLocal(instant, 3 * DateTimeConstants.MILLIS_PER_HOUR);\n         \n         // calculate result\n           // currently in later offset\n           // currently in earlier offset\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "long instantBefore = convertUTCToLocal(instant) * DateTimeConstants.MILLIS_PER_HOUR); long instantBefore = convertUTC;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-17/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 04:47:17.270108481 +0200\n+++ /tmp/tmpaiwre0uj.java\t2022-07-19 04:47:17.274108460 +0200\n@@ -1162,19 +1162,11 @@\n      */\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n-        }\n-        \n-        // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+long instantBefore = convertUTCToLocal(instant) * DateTimeConstants.MILLIS_PER_HOUR); long instantBefore = convertUTC;\n         \n         // calculate result\n           // currently in later offset\n           // currently in earlier offset\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR); long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR); if (instantBefore == instantAfter) { return instant; // not an overlap (less than is a gap, equal is normal case) } // work out range of instants that have duplicate local times long local = convertUTCToLocal(instant); return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);",
        "fixed_line": "long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR; long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR; long offsetBefore = getOffset(instantBefore); long offsetAfter = getOffset(instantAfter); if (offsetBefore <= offsetAfter) { return instant; // not an overlap (less than is a gap, equal is normal case) } // work out range of instants that have duplicate local times long diff = offsetBefore - offsetAfter; long transition = nextTransition(instantBefore); long overlapStart = transition - diff; long overlapEnd = transition + diff; if (instant < overlapStart || instant >= overlapEnd) { return instant; // not an overlap } // calculate result long afterStart = instant - overlapStart; if (afterStart >= diff) { // currently in later offset return earlierOrLater ? instant : instant - diff; } else { // currently in earlier offset return earlierOrLater ? instant + diff : instant; }"
    },
    "Math-103": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if ((x + 1) * (1.0 - mean) / (standardDeviation * Math.sqrt(2.0)))); }",
                "patch_diff": "// if ((x + 1) * (1.0 - mean) / (standardDeviation * Math.sqrt(2.0)))); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// if ((x - mean) / (standardDeviation * Math.sqrt(x - mean) / (standardDeviation * Math.sqrt(2.0)))); }",
                "patch_diff": "// if ((x - mean) / (standardDeviation * Math.sqrt(x - mean) / (standardDeviation * Math.sqrt(2.0)))); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if ((x + 1) * (1.0 - mean) / (standardDeviation * Math.sqrt(x - mean,",
                "patch_diff": "// if ((x + 1) * (1.0 - mean) / (standardDeviation * Math.sqrt(x - mean,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// if ((x - mean) / (standardDeviation * Math.sqrt(x - mean) * (standardDeviation * Math.sqrt(2.0)))); }",
                "patch_diff": "// if ((x - mean) / (standardDeviation * Math.sqrt(x - mean) * (standardDeviation * Math.sqrt(2.0)))); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// if ((x - mean) / (standardDeviation * Math.sqrt(x - mean) / (standardDeviation * Math.sqrt(2.0))); }",
                "patch_diff": "// if ((x - mean) / (standardDeviation * Math.sqrt(x - mean) / (standardDeviation * Math.sqrt(2.0))); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if ((x - mean) / (standardDeviation * Math.sqrt(x - mean) * (standardDeviation * Math.sqrt(2.0))); }",
                "patch_diff": "// if ((x - mean) / (standardDeviation * Math.sqrt(x - mean) * (standardDeviation * Math.sqrt(2.0))); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// if ((x + 1) * (1.0 - mean) / (standardDeviation * Math.sqrt(2.0))); }",
                "patch_diff": "// if ((x + 1) * (1.0 - mean) / (standardDeviation * Math.sqrt(2.0))); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// if ((x + 1) * (1.0 - mean) / (standardDeviation * Math.sqrt(x - mean)))); }",
                "patch_diff": "// if ((x + 1) * (1.0 - mean) / (standardDeviation * Math.sqrt(x - mean)))); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// if ((x + 1) * (1.0 - mean) / (standardDeviation * Math.sqrt(x - mean) / (standardDeviation * Math.sqrt(2.0)))); }",
                "patch_diff": "// if ((x + 1) * (1.0 - mean) / (standardDeviation * Math.sqrt(x - mean) / (standardDeviation * Math.sqrt(2.0)))); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if ((x + 1) * (1.0 - mean) / (standardDeviation * Math.sqrt(x - mean); }",
                "patch_diff": "// if ((x + 1) * (1.0 - mean) / (standardDeviation * Math.sqrt(x - mean); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "try { return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(2.0)))); } catch (MaxIterationsExceededException ex) { if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38 return 0.0d; } else if (x > (mean + 20 * standardDeviation)) { return 1.0d; } else { throw ex; } }"
    },
    "Math-89": {
        "fixes": [
            {
                "k": 1,
                "patch": "// else if (v < 0) { addValue((Comparable<?>) v); } else if (v[i] == null) {",
                "patch_diff": "// else if (v < 0) { addValue((Comparable<?>) v); } else if (v[i] == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// else if (v < 0) { addValue((Comparable<?>) v); }",
                "patch_diff": "// else if (v < 0) { addValue((Comparable<?>) v); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// else if (v < 0) { addValue((Comparable<?>)v); } else if (v[i] == null) {",
                "patch_diff": "// else if (v < 0) { addValue((Comparable<?>)v); } else if (v[i] == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// else if (v < 0) { addValue((Comparable<?>) v); } else if (v.length == 0) {",
                "patch_diff": "// else if (v < 0) { addValue((Comparable<?>) v); } else if (v.length == 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// else if (v < 0) { addValue((Comparable<?>) v); } else if (v.length > 0) {",
                "patch_diff": "// else if (v < 0) { addValue((Comparable<?>) v); } else if (v.length > 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// else if (v < 0) { addValue((Comparable<?>)v); }",
                "patch_diff": "// else if (v < 0) { addValue((Comparable<?>)v); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// else if (v > 0) { addValue((Comparable<?>) v); } else if (v[i] == null) {",
                "patch_diff": "// else if (v > 0) { addValue((Comparable<?>) v); } else if (v[i] == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// else if (v < 0) { addValue((Comparable<?>) v); } else {",
                "patch_diff": "// else if (v < 0) { addValue((Comparable<?>) v); } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// else if (v < 0) { addValue((Comparable<?>) v); } else if (v.length > 1) {",
                "patch_diff": "// else if (v < 0) { addValue((Comparable<?>) v); } else if (v.length > 1) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// else if (v < 0) { addValue((Comparable<?>)v); } else if (v.length == 0) {",
                "patch_diff": "// else if (v < 0) { addValue((Comparable<?>)v); } else if (v.length == 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (v instanceof Comparable<?>){ addValue((Comparable<?>) v); } else { throw new IllegalArgumentException(\"Object must implement Comparable\"); }"
    },
    "JacksonDatabind-101": {
        "fixes": [
            {
                "k": 1,
                "patch": "p.nextToken();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-101/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 04:47:22.674076334 +0200\n+++ /tmp/tmp2od7gf7h.java\t2022-07-19 04:47:22.734075982 +0200\n@@ -766,11 +766,11 @@\n                     // [databind#631]: Assign current value, to be accessible by custom serializers\n                     p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n-                        p.nextToken();\n+p.nextToken();\n                         tokens.copyCurrentStructure(p);\n                         t = p.nextToken();\n                     }\n                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                     //    problems if we maintain invariants\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "p.nextToken(); // to skip",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-101/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 04:48:20.445734071 +0200\n+++ /tmp/tmp2_dztb5h.java\t2022-07-19 04:48:20.445734071 +0200\n@@ -766,11 +766,11 @@\n                     // [databind#631]: Assign current value, to be accessible by custom serializers\n                     p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n-                        p.nextToken();\n+p.nextToken(); // to skip\n                         tokens.copyCurrentStructure(p);\n                         t = p.nextToken();\n                     }\n                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                     //    problems if we maintain invariants\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "p.nextToken(); // to skip name tokens.nextToken();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-101/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 04:49:14.901413605 +0200\n+++ /tmp/tmpois1bchm.java\t2022-07-19 04:49:14.901413605 +0200\n@@ -766,11 +766,11 @@\n                     // [databind#631]: Assign current value, to be accessible by custom serializers\n                     p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n-                        p.nextToken();\n+p.nextToken(); // to skip name tokens.nextToken();\n                         tokens.copyCurrentStructure(p);\n                         t = p.nextToken();\n                     }\n                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                     //    problems if we maintain invariants\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "p.nextToken(); // to skip name",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-101/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 04:50:10.077090813 +0200\n+++ /tmp/tmpjjdpt005.java\t2022-07-19 04:50:10.093090719 +0200\n@@ -766,11 +766,11 @@\n                     // [databind#631]: Assign current value, to be accessible by custom serializers\n                     p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n-                        p.nextToken();\n+p.nextToken(); // to skip name\n                         tokens.copyCurrentStructure(p);\n                         t = p.nextToken();\n                     }\n                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                     //    problems if we maintain invariants\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "p.nextToken(); // to skip it.nextToken();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-101/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 04:51:04.164776061 +0200\n+++ /tmp/tmp7sv_p77p.java\t2022-07-19 04:51:04.184775945 +0200\n@@ -766,11 +766,11 @@\n                     // [databind#631]: Assign current value, to be accessible by custom serializers\n                     p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n-                        p.nextToken();\n+p.nextToken(); // to skip it.nextToken();\n                         tokens.copyCurrentStructure(p);\n                         t = p.nextToken();\n                     }\n                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                     //    problems if we maintain invariants\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "p.nextToken(); // to do a tokens.nextToken();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-101/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 04:51:58.688460283 +0200\n+++ /tmp/tmp1ij7n2g2.java\t2022-07-19 04:51:58.692460260 +0200\n@@ -766,11 +766,11 @@\n                     // [databind#631]: Assign current value, to be accessible by custom serializers\n                     p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n-                        p.nextToken();\n+p.nextToken(); // to do a tokens.nextToken();\n                         tokens.copyCurrentStructure(p);\n                         t = p.nextToken();\n                     }\n                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                     //    problems if we maintain invariants\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "p.nextToken(); // to skip name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-101/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 04:52:53.588143705 +0200\n+++ /tmp/tmp8kohyoub.java\t2022-07-19 04:52:53.588143705 +0200\n@@ -766,11 +766,11 @@\n                     // [databind#631]: Assign current value, to be accessible by custom serializers\n                     p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n-                        p.nextToken();\n+p.nextToken(); // to skip name;\n                         tokens.copyCurrentStructure(p);\n                         t = p.nextToken();\n                     }\n                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                     //    problems if we maintain invariants\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "p.nextToken(); // to do a tokens",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-101/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 04:53:47.495834056 +0200\n+++ /tmp/tmpo0ibouuk.java\t2022-07-19 04:53:47.539833804 +0200\n@@ -766,11 +766,11 @@\n                     // [databind#631]: Assign current value, to be accessible by custom serializers\n                     p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n-                        p.nextToken();\n+p.nextToken(); // to do a tokens\n                         tokens.copyCurrentStructure(p);\n                         t = p.nextToken();\n                     }\n                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                     //    problems if we maintain invariants\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "p.nextToken(); // to do a tokens.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-101/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 04:54:41.319525967 +0200\n+++ /tmp/tmp8hjegu1q.java\t2022-07-19 04:54:41.339525852 +0200\n@@ -766,11 +766,11 @@\n                     // [databind#631]: Assign current value, to be accessible by custom serializers\n                     p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n-                        p.nextToken();\n+p.nextToken(); // to do a tokens.\n                         tokens.copyCurrentStructure(p);\n                         t = p.nextToken();\n                     }\n                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                     //    problems if we maintain invariants\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "p.nextToken(); // to skip name name",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-101/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 04:55:35.139218865 +0200\n+++ /tmp/tmp41sbmeiu.java\t2022-07-19 04:55:35.139218865 +0200\n@@ -766,11 +766,11 @@\n                     // [databind#631]: Assign current value, to be accessible by custom serializers\n                     p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n-                        p.nextToken();\n+p.nextToken(); // to skip name name\n                         tokens.copyCurrentStructure(p);\n                         t = p.nextToken();\n                     }\n                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                     //    problems if we maintain invariants\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "p.nextToken();",
        "fixed_line": "if (t != JsonToken.END_OBJECT) { ctxt.reportWrongTokenException(this, JsonToken.END_OBJECT, \"Attempted to unwrap '%s' value\", handledType().getName()); }"
    },
    "Mockito-8": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-8/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\t2022-07-19 04:56:29.218911154 +0200\n+++ /tmp/tmp1900rgql.java\t2022-07-19 04:56:29.250910974 +0200\n@@ -74,11 +74,11 @@\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             if (actualTypeArgument instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else {\n+} else {\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (typeParameterType) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-8/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\t2022-07-19 04:57:48.258462825 +0200\n+++ /tmp/tmpwc_075le.java\t2022-07-19 04:57:48.310462530 +0200\n@@ -74,11 +74,11 @@\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             if (actualTypeArgument instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else {\n+} else if (typeParameterType) {\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (actualType instanceof WildcardType) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-8/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\t2022-07-19 04:58:00.394394122 +0200\n+++ /tmp/tmpju1fclvf.java\t2022-07-19 04:58:00.414394010 +0200\n@@ -74,11 +74,11 @@\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             if (actualTypeArgument instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else {\n+} else if (actualType instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (actualTypeualActualType) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-8/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\t2022-07-19 04:58:12.246327059 +0200\n+++ /tmp/tmploxosjwq.java\t2022-07-19 04:58:12.246327059 +0200\n@@ -74,11 +74,11 @@\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             if (actualTypeArgument instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else {\n+} else if (actualTypeualActualType) {\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (actualType instanceof floatType) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-8/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\t2022-07-19 04:58:22.978266357 +0200\n+++ /tmp/tmp_x9r54lo.java\t2022-07-19 04:58:22.978266357 +0200\n@@ -74,11 +74,11 @@\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             if (actualTypeArgument instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else {\n+} else if (actualType instanceof floatType) {\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (TypeualActualType) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-8/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\t2022-07-19 04:58:33.446207178 +0200\n+++ /tmp/tmptar7agdq.java\t2022-07-19 04:58:33.446207178 +0200\n@@ -74,11 +74,11 @@\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             if (actualTypeArgument instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else {\n+} else if (TypeualActualType) {\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (leftualActualType) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-8/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\t2022-07-19 04:58:42.494156041 +0200\n+++ /tmp/tmpg24j5n6g.java\t2022-07-19 04:58:42.494156041 +0200\n@@ -74,11 +74,11 @@\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             if (actualTypeArgument instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else {\n+} else if (leftualActualType) {\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (typeParameterType instanceof floatType) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-8/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\t2022-07-19 04:58:51.594104630 +0200\n+++ /tmp/tmpbmurouen.java\t2022-07-19 04:58:51.594104630 +0200\n@@ -74,11 +74,11 @@\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             if (actualTypeArgument instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else {\n+} else if (typeParameterType instanceof floatType) {\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (actualType instanceof byte) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-8/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\t2022-07-19 04:59:00.794052669 +0200\n+++ /tmp/tmp9l3ibo_z.java\t2022-07-19 04:59:00.794052669 +0200\n@@ -74,11 +74,11 @@\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             if (actualTypeArgument instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else {\n+} else if (actualType instanceof byte) {\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (actualType instanceof int[]) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-8/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\t2022-07-19 04:59:09.790001877 +0200\n+++ /tmp/tmpkendp_9g.java\t2022-07-19 04:59:09.790001877 +0200\n@@ -74,11 +74,11 @@\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             if (actualTypeArgument instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else {\n+} else if (actualType instanceof int[]) {\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "} else {",
        "fixed_line": "} else if (typeParameter != actualTypeArgument) {"
    },
    "JacksonDatabind-26": {
        "fixes": [
            {
                "k": 1,
                "patch": "implements BeanProperty",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-26/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\t2022-07-19 04:59:19.013949815 +0200\n+++ /tmp/tmprcf2lan9.java\t2022-07-19 04:59:19.041949657 +0200\n@@ -34,11 +34,11 @@\n  * code and this is to reduce likelihood of data corruption and\n  * synchronization issues.\n  */\n @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\n public class BeanPropertyWriter extends PropertyWriter\n-    implements BeanProperty\n+implements BeanProperty\n {\n     // as of 2.6.2\n \n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "implements BeanProperty(prop);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-26/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\t2022-07-19 04:59:55.497744051 +0200\n+++ /tmp/tmppmqb9p6x.java\t2022-07-19 04:59:55.497744051 +0200\n@@ -34,11 +34,11 @@\n  * code and this is to reduce likelihood of data corruption and\n  * synchronization issues.\n  */\n @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\n public class BeanPropertyWriter extends PropertyWriter\n-    implements BeanProperty\n+implements BeanProperty(prop);\n {\n     // as of 2.6.2\n \n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "implements BeanProperty(name);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-26/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\t2022-07-19 04:59:56.993735619 +0200\n+++ /tmp/tmph02we4z5.java\t2022-07-19 04:59:56.993735619 +0200\n@@ -34,11 +34,11 @@\n  * code and this is to reduce likelihood of data corruption and\n  * synchronization issues.\n  */\n @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\n public class BeanPropertyWriter extends PropertyWriter\n-    implements BeanProperty\n+implements BeanProperty(name);\n {\n     // as of 2.6.2\n \n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "implements BeanProperty(t);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-26/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\t2022-07-19 04:59:58.493727166 +0200\n+++ /tmp/tmplibrh1w9.java\t2022-07-19 04:59:58.497727143 +0200\n@@ -34,11 +34,11 @@\n  * code and this is to reduce likelihood of data corruption and\n  * synchronization issues.\n  */\n @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\n public class BeanPropertyWriter extends PropertyWriter\n-    implements BeanProperty\n+implements BeanProperty(t);\n {\n     // as of 2.6.2\n \n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "implements BeanProperty(propName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-26/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\t2022-07-19 05:00:00.017718576 +0200\n+++ /tmp/tmpqdpagd2u.java\t2022-07-19 05:00:00.021718553 +0200\n@@ -34,11 +34,11 @@\n  * code and this is to reduce likelihood of data corruption and\n  * synchronization issues.\n  */\n @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\n public class BeanPropertyWriter extends PropertyWriter\n-    implements BeanProperty\n+implements BeanProperty(propName);\n {\n     // as of 2.6.2\n \n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "implements BeanProperty(propDef);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-26/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\t2022-07-19 05:00:01.669709266 +0200\n+++ /tmp/tmpgav8maps.java\t2022-07-19 05:00:01.669709266 +0200\n@@ -34,11 +34,11 @@\n  * code and this is to reduce likelihood of data corruption and\n  * synchronization issues.\n  */\n @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\n public class BeanPropertyWriter extends PropertyWriter\n-    implements BeanProperty\n+implements BeanProperty(propDef);\n {\n     // as of 2.6.2\n \n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "implements BeanProperty(sub);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-26/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\t2022-07-19 05:00:03.169700813 +0200\n+++ /tmp/tmp6erpxnk8.java\t2022-07-19 05:00:03.169700813 +0200\n@@ -34,11 +34,11 @@\n  * code and this is to reduce likelihood of data corruption and\n  * synchronization issues.\n  */\n @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\n public class BeanPropertyWriter extends PropertyWriter\n-    implements BeanProperty\n+implements BeanProperty(sub);\n {\n     // as of 2.6.2\n \n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "implements BeanProperty(this.defaultSize);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-26/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\t2022-07-19 05:00:04.717692090 +0200\n+++ /tmp/tmpcpz3_zv6.java\t2022-07-19 05:00:04.717692090 +0200\n@@ -34,11 +34,11 @@\n  * code and this is to reduce likelihood of data corruption and\n  * synchronization issues.\n  */\n @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\n public class BeanPropertyWriter extends PropertyWriter\n-    implements BeanProperty\n+implements BeanProperty(this.defaultSize);\n {\n     // as of 2.6.2\n \n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "implements BeanProperty(this.default BeanProperty);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-26/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\t2022-07-19 05:00:06.249683459 +0200\n+++ /tmp/tmp5acrthso.java\t2022-07-19 05:00:06.249683459 +0200\n@@ -34,11 +34,11 @@\n  * code and this is to reduce likelihood of data corruption and\n  * synchronization issues.\n  */\n @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\n public class BeanPropertyWriter extends PropertyWriter\n-    implements BeanProperty\n+implements BeanProperty(this.default BeanProperty);\n {\n     // as of 2.6.2\n \n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "implements BeanProperty(sub.getIdId);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-26/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\t2022-07-19 05:00:07.809674669 +0200\n+++ /tmp/tmp52yj4blm.java\t2022-07-19 05:00:07.809674669 +0200\n@@ -34,11 +34,11 @@\n  * code and this is to reduce likelihood of data corruption and\n  * synchronization issues.\n  */\n @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\n public class BeanPropertyWriter extends PropertyWriter\n-    implements BeanProperty\n+implements BeanProperty(sub.getIdId);\n {\n     // as of 2.6.2\n \n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "implements BeanProperty",
        "fixed_line": "implements BeanProperty, java.io.Serializable // since 2.6.2 { // as of 2.6.2 private static final long serialVersionUID = 4603296144163950020L;"
    },
    "JacksonCore-15": {
        "fixes": [
            {
                "k": 1,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < v.length; i++) {",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < v.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i!= null) {",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < v.length; ++i) {",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < v.length; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < len; ++i) {",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < len; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// as per [JACKSON-scalar as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < v.length; i++) {",
                "patch_diff": "// as per [JACKSON-scalar as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < v.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// as per [JACKSON-scalar as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i!= null) {",
                "patch_diff": "// as per [JACKSON-scalar as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// as per [JACKSON-scalar as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < _currToken; ++i) {",
                "patch_diff": "// as per [JACKSON-scalar as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < _currToken; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// as per [JACKSON-scalar as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < len; ++i) {",
                "patch_diff": "// as per [JACKSON-scalar as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < len; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// as per [JACKSON-scalar as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < v.length; ++i) {",
                "patch_diff": "// as per [JACKSON-scalar as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < v.length; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// as per [JACKSON-scalar as per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "// as per [JACKSON-scalar as per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if(!_allowMultipleMatches && _currToken != null && _exposedContext == null){ //if not scalar and ended successfully, then return null if((_currToken.isStructEnd() && _headContext.isStartHandled()) ){ return (_currToken = null); } //else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once // then return null else if(_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath && _itemFilter == TokenFilter.INCLUDE_ALL) { return (_currToken = null); } }"
    },
    "JacksonDatabind-91": {
        "fixes": [
            {
                "k": 1,
                "patch": "return (ct.getValueHandler()!= null) || (ct.getTypeHandler()!= null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-91/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\t2022-07-19 05:00:11.241655333 +0200\n+++ /tmp/tmp6ywmhiaj.java\t2022-07-19 05:00:11.261655220 +0200\n@@ -536,11 +536,11 @@\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+return (ct.getValueHandler()!= null) || (ct.getTypeHandler()!= null);\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n             }\n         }\n         return false;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return (ct.getValueHandler() == null) || (ct.getTypeHandler()!= null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-91/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\t2022-07-19 05:00:55.933403722 +0200\n+++ /tmp/tmpx5znh92i.java\t2022-07-19 05:00:55.937403699 +0200\n@@ -536,11 +536,11 @@\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+return (ct.getValueHandler() == null) || (ct.getTypeHandler()!= null);\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n             }\n         }\n         return false;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return (ct.getValueHandler()!= null) && (ct.getTypeHandler()!= null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-91/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\t2022-07-19 05:01:38.161166277 +0200\n+++ /tmp/tmpmrmb9b75.java\t2022-07-19 05:01:38.161166277 +0200\n@@ -536,11 +536,11 @@\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+return (ct.getValueHandler()!= null) && (ct.getTypeHandler()!= null);\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n             }\n         }\n         return false;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return (ct.getValueHandler()!= null && (ct.getTypeHandler()!= null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-91/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\t2022-07-19 05:02:19.536933880 +0200\n+++ /tmp/tmpk6amywce.java\t2022-07-19 05:02:19.540933857 +0200\n@@ -536,11 +536,11 @@\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+return (ct.getValueHandler()!= null && (ct.getTypeHandler()!= null);\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n             }\n         }\n         return false;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return (ct.getValueHandler()!= null || (ct.getTypeHandler()!= null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-91/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\t2022-07-19 05:02:21.132924921 +0200\n+++ /tmp/tmprsne_uuj.java\t2022-07-19 05:02:21.132924921 +0200\n@@ -536,11 +536,11 @@\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+return (ct.getValueHandler()!= null || (ct.getTypeHandler()!= null);\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n             }\n         }\n         return false;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return (ct.getValueHandler()!= null) || (ct.getTypeHandler() == null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-91/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\t2022-07-19 05:02:22.892915040 +0200\n+++ /tmp/tmpar1zm6bz.java\t2022-07-19 05:02:22.896915017 +0200\n@@ -536,11 +536,11 @@\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+return (ct.getValueHandler()!= null) || (ct.getTypeHandler() == null);\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n             }\n         }\n         return false;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return (ct.getValueHandler()!= null) || (ct.getTypeHandler()!= null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-91/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\t2022-07-19 05:03:05.260677330 +0200\n+++ /tmp/tmpoai6t0na.java\t2022-07-19 05:03:05.260677330 +0200\n@@ -536,11 +536,11 @@\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+return (ct.getValueHandler()!= null) || (ct.getTypeHandler()!= null)\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n             }\n         }\n         return false;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return (ct.getValueHandler() == null || (ct.getTypeHandler()!= null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-91/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\t2022-07-19 05:03:06.876668269 +0200\n+++ /tmp/tmpgxqmu5w2.java\t2022-07-19 05:03:06.880668246 +0200\n@@ -536,11 +536,11 @@\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+return (ct.getValueHandler() == null || (ct.getTypeHandler()!= null);\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n             }\n         }\n         return false;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return (ct.getValueHandler()!= null) || (ct.getTypeHandler()!= null));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-91/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\t2022-07-19 05:03:08.516659071 +0200\n+++ /tmp/tmpx6nq55w_.java\t2022-07-19 05:03:08.516659071 +0200\n@@ -536,11 +536,11 @@\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+return (ct.getValueHandler()!= null) || (ct.getTypeHandler()!= null));\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n             }\n         }\n         return false;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return(ct.getValueHandler()!= null) || (ct.getTypeHandler()!= null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-91/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\t2022-07-19 05:03:10.132650012 +0200\n+++ /tmp/tmps4x3a4ie.java\t2022-07-19 05:03:10.132650012 +0200\n@@ -536,11 +536,11 @@\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+return(ct.getValueHandler()!= null) || (ct.getTypeHandler()!= null);\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n             }\n         }\n         return false;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);",
        "fixed_line": "if ((ct.getValueHandler() != null) || (ct.getTypeHandler() != null)) { return true; } } // Second: map(-like) types may have value handler for key (but not type; keys are untyped) if (t.isMapLikeType()) { JavaType kt = t.getKeyType(); if (kt.getValueHandler() != null) { return true; }"
    },
    "Closure-91": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (parent!= null && parent.getType() == Token.ASSIGN) {",
                "patch_diff": "if (parent!= null && parent.getType() == Token.ASSIGN) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (parent!= null && parent.getType() == Token.ASSIGN) { return false; } if (parent!= null && parent.getFirstChild();",
                "patch_diff": "if (parent!= null && parent.getType() == Token.ASSIGN) { return false; } if (parent!= null && parent.getFirstChild();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (parent!= null && parent.getType() == Token.NUMBER)) { return false; } if (parent!= null && parent.getFirstChild();",
                "patch_diff": "if (parent!= null && parent.getType() == Token.NUMBER)) { return false; } if (parent!= null && parent.getFirstChild();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return parent!= null && parent.getType() == Token.NUMBER)) { return false; } if (parent!= null && parent.getFirstChild();",
                "patch_diff": "return parent!= null && parent.getType() == Token.NUMBER)) { return false; } if (parent!= null && parent.getFirstChild();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (parent!= null && parent.getType() == Token.NUMBER) { return false; } if (parent!= null && parent.getFirstChild();",
                "patch_diff": "if (parent!= null && parent.getType() == Token.NUMBER) { return false; } if (parent!= null && parent.getFirstChild();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (lent!= null && parent.getType() == Token.NUMBER)) { return false; } if (parent!= null && parent.getFirstChild();",
                "patch_diff": "if (lent!= null && parent.getType() == Token.NUMBER)) { return false; } if (parent!= null && parent.getFirstChild();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (parent!= null && parent.getType() == Token.NUMBER)) { return false; } if (parent!= null && parent.getFirstChild(); if (lhsType == Token.ASSIGN) { return false; } if (parent!= null && parent.getFirstChild();",
                "patch_diff": "if (parent!= null && parent.getType() == Token.NUMBER)) { return false; } if (parent!= null && parent.getFirstChild(); if (lhsType == Token.ASSIGN) { return false; } if (parent!= null && parent.getFirstChild();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (lent!= null && parent.getType() == Token.NUMBER) { return false; } if (parent!= null && parent.getFirstChild();",
                "patch_diff": "if (lent!= null && parent.getType() == Token.NUMBER) { return false; } if (parent!= null && parent.getFirstChild();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (lent!= null && parent.getType() == Token.ASSIGN) { return false; } if (parent!= null && parent.getFirstChild();",
                "patch_diff": "if (lent!= null && parent.getType() == Token.ASSIGN) { return false; } if (parent!= null && parent.getFirstChild();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (parent!= null && parent.getType() == Token.NUMBER)) { return false; } if (parent!= null && parent.getFirstChild(); } else if (lhsType == Token.ASSIGN) { return false; } if (parent!= null && parent.getFirstChild();",
                "patch_diff": "if (parent!= null && parent.getType() == Token.NUMBER)) { return false; } if (parent!= null && parent.getFirstChild(); } else if (lhsType == Token.ASSIGN) { return false; } if (parent!= null && parent.getFirstChild();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "Node gramps = parent.getParent(); if (NodeUtil.isObjectLitKey(parent, gramps)) { JSDocInfo maybeLends = gramps.getJSDocInfo(); if (maybeLends != null && maybeLends.getLendsName() != null && maybeLends.getLendsName().endsWith(\".prototype\")) { return false; } }"
    },
    "Math-73": {
        "fixes": [
            {
                "k": 1,
                "patch": "return solve(f, initial, max, yInitial);",
                "patch_diff": "return solve(f, initial, max, yInitial);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return solve(f, initial, max, yInitial); }",
                "patch_diff": "return solve(f, initial, max, yInitial); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return solve(f, initial, max, y);",
                "patch_diff": "return solve(f, initial, max, y);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return solve(f, initial, max, yInitial); } // full Brent algorithm starting with max, yInitial);",
                "patch_diff": "return solve(f, initial, max, yInitial); } // full Brent algorithm starting with max, yInitial);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return solve(f, initial, max, yInitial); } // full Brent algorithm starting with max, yInitial); }",
                "patch_diff": "return solve(f, initial, max, yInitial); } // full Brent algorithm starting with max, yInitial); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return solve(f, initial, max, yInitial); } // reduce interval with max, initial, yInitial);",
                "patch_diff": "return solve(f, initial, max, yInitial); } // reduce interval with max, initial, yInitial);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return solve(f, initial, max, yInitial); } // reduce interval with max, initial, yInitial); }",
                "patch_diff": "return solve(f, initial, max, yInitial); } // reduce interval with max, initial, yInitial); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return solve(f, initial, max, yInitial); } // full Brent algorithm starting with max, yInitial",
                "patch_diff": "return solve(f, initial, max, yInitial); } // full Brent algorithm starting with max, yInitial",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return solve(f, initial, max, yInitial); } // full Brent algorithm starting with max, y",
                "patch_diff": "return solve(f, initial, max, yInitial); } // full Brent algorithm starting with max, y",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return solve(f, initial, max, yInitial); } // full Brent algorithm starting with max, max, yInitial);",
                "patch_diff": "return solve(f, initial, max, yInitial); } // full Brent algorithm starting with max, max, yInitial);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (yMin * yMax > 0) { throw MathRuntimeException.createIllegalArgumentException( NON_BRACKETING_MESSAGE, min, max, yMin, yMax); }"
    },
    "Codec-10": {
        "fixes": [
            {
                "k": 1,
                "patch": "txt = txt.replaceAll(\"^mb\", \"m2\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-10/src/java/org/apache/commons/codec/language/Caverphone.java\t2022-07-19 05:03:55.988393008 +0200\n+++ /tmp/tmp5umqlexh.java\t2022-07-19 05:03:56.024392811 +0200\n@@ -71,11 +71,11 @@\n         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+txt = txt.replaceAll(\"^mb\", \"m2\");\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n         txt = txt.replaceAll(\"ci\", \"si\");\n         txt = txt.replaceAll(\"ce\", \"se\");\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "txt = txt.replaceAll(\"^mb\", \"millis",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-10/src/java/org/apache/commons/codec/language/Caverphone.java\t2022-07-19 05:03:58.784377348 +0200\n+++ /tmp/tmp622g_dzf.java\t2022-07-19 05:03:58.784377348 +0200\n@@ -71,11 +71,11 @@\n         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+txt = txt.replaceAll(\"^mb\", \"millis\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n         txt = txt.replaceAll(\"ci\", \"si\");\n         txt = txt.replaceAll(\"ce\", \"se\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "txt = txt.replaceAll(\"^mb\", \"mm2\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-10/src/java/org/apache/commons/codec/language/Caverphone.java\t2022-07-19 05:04:00.400368294 +0200\n+++ /tmp/tmp8q4xh0ua.java\t2022-07-19 05:04:00.400368294 +0200\n@@ -71,11 +71,11 @@\n         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+txt = txt.replaceAll(\"^mb\", \"mm2\");\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n         txt = txt.replaceAll(\"ci\", \"si\");\n         txt = txt.replaceAll(\"ce\", \"se\");\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "txt = txt.replaceAll(\"^mb\", \"mDelimiter",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-10/src/java/org/apache/commons/codec/language/Caverphone.java\t2022-07-19 05:04:03.316351961 +0200\n+++ /tmp/tmphlknjivq.java\t2022-07-19 05:04:03.316351961 +0200\n@@ -71,11 +71,11 @@\n         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+txt = txt.replaceAll(\"^mb\", \"mDelimiter\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n         txt = txt.replaceAll(\"ci\", \"si\");\n         txt = txt.replaceAll(\"ce\", \"se\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "txt = txt.replaceAll(\"^mb\", \"mPres",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-10/src/java/org/apache/commons/codec/language/Caverphone.java\t2022-07-19 05:04:04.868343270 +0200\n+++ /tmp/tmp9cdkryj2.java\t2022-07-19 05:04:04.868343270 +0200\n@@ -71,11 +71,11 @@\n         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+txt = txt.replaceAll(\"^mb\", \"mPres\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n         txt = txt.replaceAll(\"ci\", \"si\");\n         txt = txt.replaceAll(\"ce\", \"se\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "txt = txt.replaceAll(\"^mb\", \"mBD",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-10/src/java/org/apache/commons/codec/language/Caverphone.java\t2022-07-19 05:04:06.432334511 +0200\n+++ /tmp/tmpo56_8zcg.java\t2022-07-19 05:04:06.436334488 +0200\n@@ -71,11 +71,11 @@\n         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+txt = txt.replaceAll(\"^mb\", \"mBD\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n         txt = txt.replaceAll(\"ci\", \"si\");\n         txt = txt.replaceAll(\"ce\", \"se\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "txt = txt.replaceAll(\"^mb\",'m2\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-10/src/java/org/apache/commons/codec/language/Caverphone.java\t2022-07-19 05:04:08.020325615 +0200\n+++ /tmp/tmp3dcp_vr1.java\t2022-07-19 05:04:08.020325615 +0200\n@@ -71,11 +71,11 @@\n         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+txt = txt.replaceAll(\"^mb\",'m2\");\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n         txt = txt.replaceAll(\"ci\", \"si\");\n         txt = txt.replaceAll(\"ce\", \"se\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "txt = txt.replaceAll(\"^mb\", \"mCol",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-10/src/java/org/apache/commons/codec/language/Caverphone.java\t2022-07-19 05:04:09.504317305 +0200\n+++ /tmp/tmpvujxpb54.java\t2022-07-19 05:04:09.504317305 +0200\n@@ -71,11 +71,11 @@\n         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+txt = txt.replaceAll(\"^mb\", \"mCol\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n         txt = txt.replaceAll(\"ci\", \"si\");\n         txt = txt.replaceAll(\"ce\", \"se\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "txt = txt.replaceAll(\"^mb\", \"m\u27ec",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-10/src/java/org/apache/commons/codec/language/Caverphone.java\t2022-07-19 05:04:11.052308634 +0200\n+++ /tmp/tmps28itd0u.java\t2022-07-19 05:04:11.052308634 +0200\n@@ -71,11 +71,11 @@\n         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+txt = txt.replaceAll(\"^mb\", \"m\u27ec\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n         txt = txt.replaceAll(\"ci\", \"si\");\n         txt = txt.replaceAll(\"ce\", \"se\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "txt = txt.replaceAll(\"^mb\", \"mmillis",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-10/src/java/org/apache/commons/codec/language/Caverphone.java\t2022-07-19 05:04:12.600299967 +0200\n+++ /tmp/tmpovjwco6_.java\t2022-07-19 05:04:12.600299967 +0200\n@@ -71,11 +71,11 @@\n         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+txt = txt.replaceAll(\"^mb\", \"mmillis\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n         txt = txt.replaceAll(\"ci\", \"si\");\n         txt = txt.replaceAll(\"ce\", \"se\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "txt = txt.replaceAll(\"^mb\", \"m2\");",
        "fixed_line": "txt = txt.replaceAll(\"mb$\", \"m2\");"
    },
    "Mockito-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "// generic = field.getGenericTypeArguments = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic).getActualTypeArguments;",
                "patch_diff": "// generic = field.getGenericTypeArguments = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic).getActualTypeArguments;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// argument = field.getGenericTypeArguments = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic).getActualTypeArguments;",
                "patch_diff": "// argument = field.getGenericTypeArguments = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic).getActualTypeArguments;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// int generic = field.getGenericTypeArguments = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic).getActualTypeArguments;",
                "patch_diff": "// int generic = field.getGenericTypeArguments = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic).getActualTypeArguments;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int generic = field.getGenericTypeArguments = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic).getActualTypeArguments;",
                "patch_diff": "int generic = field.getGenericTypeArguments = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic).getActualTypeArguments;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// generic = field.getGenericTypeArguments = ((ParameterizedType) generic).getActualTypeArguments()[0]; return ((ParameterizedType) generic).getActualTypeArguments;",
                "patch_diff": "// generic = field.getGenericTypeArguments = ((ParameterizedType) generic).getActualTypeArguments()[0]; return ((ParameterizedType) generic).getActualTypeArguments;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// argument = field.getGenericTypeArguments = ((ParameterizedType) generic).getActualTypeArguments()[0]; return ((ParameterizedType) generic).getActualTypeArguments;",
                "patch_diff": "// argument = field.getGenericTypeArguments = ((ParameterizedType) generic).getActualTypeArguments()[0]; return ((ParameterizedType) generic).getActualTypeArguments;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (generic instanceof ParameterizedType) generic).getActualTypeArguments()[0]; return ((ParameterizedType) generic).getActualTypeArguments;",
                "patch_diff": "if (generic instanceof ParameterizedType) generic).getActualTypeArguments()[0]; return ((ParameterizedType) generic).getActualTypeArguments;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// generic = field.getGenericTypeArguments = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic).getActualTypeArguments();",
                "patch_diff": "// generic = field.getGenericTypeArguments = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic).getActualTypeArguments();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// generic = field.getGenericTypeArguments = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic).getActualTypeArguments()[0];",
                "patch_diff": "// generic = field.getGenericTypeArguments = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic).getActualTypeArguments()[0];",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// int generic = field.getGenericTypeArguments = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic).getActualTypeArguments()[0];",
                "patch_diff": "// int generic = field.getGenericTypeArguments = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic).getActualTypeArguments()[0];",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (actual instanceof Class) { return (Class) actual; } else if (actual instanceof ParameterizedType) { //in case of nested generics we don't go deep return (Class) ((ParameterizedType) actual).getRawType(); }"
    },
    "JacksonDatabind-97": {
        "fixes": [
            {
                "k": 1,
                "patch": "gen.writeObject(_value); // value is lower case",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-97/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\t2022-07-19 05:04:16.036280726 +0200\n+++ /tmp/tmp0zdbctmq.java\t2022-07-19 05:04:16.044280682 +0200\n@@ -109,11 +109,11 @@\n         } else if (_value instanceof JsonSerializable) {\n             ((JsonSerializable) _value).serialize(gen, ctxt);\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            gen.writeObject(_value);\n+gen.writeObject(_value); // value is lower case\n         }\n     }\n \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "gen.writeObject(_value); // value is this to 0",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-97/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\t2022-07-19 05:05:10.195977602 +0200\n+++ /tmp/tmpzr02ua68.java\t2022-07-19 05:05:10.195977602 +0200\n@@ -109,11 +109,11 @@\n         } else if (_value instanceof JsonSerializable) {\n             ((JsonSerializable) _value).serialize(gen, ctxt);\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            gen.writeObject(_value);\n+gen.writeObject(_value); // value is this to 0\n         }\n     }\n \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "gen.writeObject(_value);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-97/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\t2022-07-19 05:06:04.423674383 +0200\n+++ /tmp/tmpmhf8ab7g.java\t2022-07-19 05:06:04.423674383 +0200\n@@ -109,11 +109,11 @@\n         } else if (_value instanceof JsonSerializable) {\n             ((JsonSerializable) _value).serialize(gen, ctxt);\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            gen.writeObject(_value);\n+gen.writeObject(_value);\n         }\n     }\n \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "gen.writeObject(_value); // value is lower case // value is lower case",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-97/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\t2022-07-19 05:06:58.695371181 +0200\n+++ /tmp/tmp4xddunap.java\t2022-07-19 05:06:58.695371181 +0200\n@@ -109,11 +109,11 @@\n         } else if (_value instanceof JsonSerializable) {\n             ((JsonSerializable) _value).serialize(gen, ctxt);\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            gen.writeObject(_value);\n+gen.writeObject(_value); // value is lower case // value is lower case\n         }\n     }\n \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "gen.writeObject(_value); // value is lower case // value is this to 0",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-97/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\t2022-07-19 05:07:52.987068097 +0200\n+++ /tmp/tmpiu43zxxs.java\t2022-07-19 05:07:52.987068097 +0200\n@@ -109,11 +109,11 @@\n         } else if (_value instanceof JsonSerializable) {\n             ((JsonSerializable) _value).serialize(gen, ctxt);\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            gen.writeObject(_value);\n+gen.writeObject(_value); // value is lower case // value is this to 0\n         }\n     }\n \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "gen.writeObject(_value); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-97/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\t2022-07-19 05:08:46.554769259 +0200\n+++ /tmp/tmpbtv202dz.java\t2022-07-19 05:08:46.554769259 +0200\n@@ -109,11 +109,11 @@\n         } else if (_value instanceof JsonSerializable) {\n             ((JsonSerializable) _value).serialize(gen, ctxt);\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            gen.writeObject(_value);\n+gen.writeObject(_value); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n         }\n     }\n \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "gen.writeObject(_value); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-97/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\t2022-07-19 05:09:40.482468597 +0200\n+++ /tmp/tmp78kiv52f.java\t2022-07-19 05:09:40.486468577 +0200\n@@ -109,11 +109,11 @@\n         } else if (_value instanceof JsonSerializable) {\n             ((JsonSerializable) _value).serialize(gen, ctxt);\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            gen.writeObject(_value);\n+gen.writeObject(_value); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n         }\n     }\n \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "gen.writeObject(_value); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-97/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\t2022-07-19 05:10:34.630166878 +0200\n+++ /tmp/tmpaov1inek.java\t2022-07-19 05:10:34.634166858 +0200\n@@ -109,11 +109,11 @@\n         } else if (_value instanceof JsonSerializable) {\n             ((JsonSerializable) _value).serialize(gen, ctxt);\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            gen.writeObject(_value);\n+gen.writeObject(_value); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n         }\n     }\n \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "gen.writeObject(_value); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-97/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\t2022-07-19 05:11:28.413867340 +0200\n+++ /tmp/tmp7vvgn_gs.java\t2022-07-19 05:11:28.413867340 +0200\n@@ -109,11 +109,11 @@\n         } else if (_value instanceof JsonSerializable) {\n             ((JsonSerializable) _value).serialize(gen, ctxt);\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            gen.writeObject(_value);\n+gen.writeObject(_value); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number\n         }\n     }\n \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "gen.writeObject(_value); // we didn't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-97/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\t2022-07-19 05:12:22.541566021 +0200\n+++ /tmp/tmp9jz31lcl.java\t2022-07-19 05:12:22.545566000 +0200\n@@ -109,11 +109,11 @@\n         } else if (_value instanceof JsonSerializable) {\n             ((JsonSerializable) _value).serialize(gen, ctxt);\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            gen.writeObject(_value);\n+gen.writeObject(_value); // we didn't really modify it's totalGJACKSON-notnotnotnot real number\n         }\n     }\n \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "gen.writeObject(_value);",
        "fixed_line": "ctxt.defaultSerializeValue(_value, gen);"
    },
    "Lang-53": {
        "fixes": [
            {
                "k": 1,
                "patch": "} // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done && time < 30)) { time = time - (seconds * 1000L); if (field == Calendar.MINUTE) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java\t2022-07-19 05:13:17.561259861 +0200\n+++ /tmp/tmpt7r32o84.java\t2022-07-19 05:13:17.613259571 +0200\n@@ -640,20 +640,11 @@\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         if (field == Calendar.SECOND) {\n             done = true;\n-            }\n-        }\n-\n-        // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-        if (field == Calendar.MINUTE) {\n-            done = true;\n-            }\n+} // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done && time < 30)) { time = time - (seconds * 1000L); if (field == Calendar.MINUTE) {\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done && time < 30) { time = time - (seconds * 1000L); if (field == Calendar.MINUTE) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java\t2022-07-19 05:13:28.073201380 +0200\n+++ /tmp/tmp6gvyyc2k.java\t2022-07-19 05:13:28.077201359 +0200\n@@ -640,20 +640,11 @@\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         if (field == Calendar.SECOND) {\n             done = true;\n-            }\n-        }\n-\n-        // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-        if (field == Calendar.MINUTE) {\n-            done = true;\n-            }\n+} // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done && time < 30) { time = time - (seconds * 1000L); if (field == Calendar.MINUTE) {\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done && time < 30)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java\t2022-07-19 05:13:37.841147043 +0200\n+++ /tmp/tmpph5nyf5u.java\t2022-07-19 05:13:37.841147043 +0200\n@@ -640,20 +640,11 @@\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         if (field == Calendar.SECOND) {\n             done = true;\n-            }\n-        }\n-\n-        // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-        if (field == Calendar.MINUTE) {\n-            done = true;\n-            }\n+} // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done && time < 30)) {\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done && (!round || seconds < 30)) { time = time - (seconds * 1000L); if (field == Calendar.MINUTE) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java\t2022-07-19 05:13:47.869091262 +0200\n+++ /tmp/tmp5uw7x_6i.java\t2022-07-19 05:13:47.869091262 +0200\n@@ -640,20 +640,11 @@\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         if (field == Calendar.SECOND) {\n             done = true;\n-            }\n-        }\n-\n-        // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-        if (field == Calendar.MINUTE) {\n-            done = true;\n-            }\n+} // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done && (!round || seconds < 30)) { time = time - (seconds * 1000L); if (field == Calendar.MINUTE) {\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done && time < 30)) { time = time - (seconds * 1000L); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java\t2022-07-19 05:13:57.841035795 +0200\n+++ /tmp/tmp2ln486ad.java\t2022-07-19 05:13:57.841035795 +0200\n@@ -640,20 +640,11 @@\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         if (field == Calendar.SECOND) {\n             done = true;\n-            }\n-        }\n-\n-        // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-        if (field == Calendar.MINUTE) {\n-            done = true;\n-            }\n+} // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done && time < 30)) { time = time - (seconds * 1000L); }\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done && (!round || seconds < 30)) { time = time - (seconds * 1000L); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java\t2022-07-19 05:14:07.668981133 +0200\n+++ /tmp/tmp3i8mt94g.java\t2022-07-19 05:14:07.668981133 +0200\n@@ -640,20 +640,11 @@\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         if (field == Calendar.SECOND) {\n             done = true;\n-            }\n-        }\n-\n-        // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-        if (field == Calendar.MINUTE) {\n-            done = true;\n-            }\n+} // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done && (!round || seconds < 30)) { time = time - (seconds * 1000L); }\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done && time < 30) { time = time - (seconds * 1000L); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java\t2022-07-19 05:14:17.564926099 +0200\n+++ /tmp/tmpe0052jue.java\t2022-07-19 05:14:17.564926099 +0200\n@@ -640,20 +640,11 @@\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         if (field == Calendar.SECOND) {\n             done = true;\n-            }\n-        }\n-\n-        // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-        if (field == Calendar.MINUTE) {\n-            done = true;\n-            }\n+} // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done && time < 30) { time = time - (seconds * 1000L); }\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done || time > 30)) { time = time - (seconds * 1000L); if (field == Calendar.MINUTE) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java\t2022-07-19 05:14:27.508870799 +0200\n+++ /tmp/tmpxke19_kp.java\t2022-07-19 05:14:27.508870799 +0200\n@@ -640,20 +640,11 @@\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         if (field == Calendar.SECOND) {\n             done = true;\n-            }\n-        }\n-\n-        // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-        if (field == Calendar.MINUTE) {\n-            done = true;\n-            }\n+} // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done || time > 30)) { time = time - (seconds * 1000L); if (field == Calendar.MINUTE) {\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done || time < 30)) { time = time - (seconds * 1000L); if (field == Calendar.MINUTE) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java\t2022-07-19 05:14:37.444815546 +0200\n+++ /tmp/tmppu83v0zi.java\t2022-07-19 05:14:37.444815546 +0200\n@@ -640,20 +640,11 @@\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         if (field == Calendar.SECOND) {\n             done = true;\n-            }\n-        }\n-\n-        // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-        if (field == Calendar.MINUTE) {\n-            done = true;\n-            }\n+} // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done || time < 30)) { time = time - (seconds * 1000L); if (field == Calendar.MINUTE) {\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done && (!round || seconds < 30)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java\t2022-07-19 05:14:47.196761319 +0200\n+++ /tmp/tmpk2_pnnds.java\t2022-07-19 05:14:47.196761319 +0200\n@@ -640,20 +640,11 @@\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         if (field == Calendar.SECOND) {\n             done = true;\n-            }\n-        }\n-\n-        // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-        if (field == Calendar.MINUTE) {\n-            done = true;\n-            }\n+} // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done && (!round || seconds < 30)) {\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "} } // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done && (!round || seconds < 30)) { time = time - (seconds * 1000L); if (field == Calendar.MINUTE) { done = true; }",
        "fixed_line": "} if (field == Calendar.SECOND) { done = true; } // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done && (!round || seconds < 30)) { time = time - (seconds * 1000L); }"
    },
    "Lang-54": {
        "fixes": [
            {
                "k": 1,
                "patch": "throw new IllegalArgumentException(\"Invalid locale format: \" + str.charAt(3);",
                "patch_diff": "throw new IllegalArgumentException(\"Invalid locale format: \" + str.charAt(3);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (str.charAt(3); } char ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {",
                "patch_diff": "if (str.charAt(3); } char ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "throw new IllegalArgumentException(\"Invalid locale format: \" + str); } char ch3 < 'A' || ch4 > 'Z' || ch4 < 'A' || ch4 > 'Z') {",
                "patch_diff": "throw new IllegalArgumentException(\"Invalid locale format: \" + str); } char ch3 < 'A' || ch4 > 'Z' || ch4 < 'A' || ch4 > 'Z') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new IllegalArgumentException(\"Invalid locale format: \" + str); } char ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {",
                "patch_diff": "throw new IllegalArgumentException(\"Invalid locale format: \" + str); } char ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "throw new IllegalArgumentException(\"Invalid locale format: \" + str.charAt(3); char ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {",
                "patch_diff": "throw new IllegalArgumentException(\"Invalid locale format: \" + str.charAt(3); char ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "throw new IllegalArgumentException(\"Invalid locale format: \" + str + 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {",
                "patch_diff": "throw new IllegalArgumentException(\"Invalid locale format: \" + str + 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "throw new IllegalArgumentException(\"Invalid locale format: \" + str); } char ch3 < 'A' || ch4 > 'Z') {",
                "patch_diff": "throw new IllegalArgumentException(\"Invalid locale format: \" + str); } char ch3 < 'A' || ch4 > 'Z') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "throw new IllegalArgumentException(\"Invalid locale format: \" + str.charAt(3); char ch3 < 'A' || ch4 > 'Z' || ch4 < 'A' || ch4 > 'Z') {",
                "patch_diff": "throw new IllegalArgumentException(\"Invalid locale format: \" + str.charAt(3); char ch3 < 'A' || ch4 > 'Z' || ch4 < 'A' || ch4 > 'Z') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (str.charAt(3); } char ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') { throw new IllegalArgumentException(\"Invalid \" + str); } if (ch3 < 'A' || ch4 > 'Z') {",
                "patch_diff": "if (str.charAt(3); } char ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') { throw new IllegalArgumentException(\"Invalid \" + str); } if (ch3 < 'A' || ch4 > 'Z') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "throw new IllegalArgumentException(\"Invalid locale format: \" + str); } char ch3 < 'A' || ch4 > 'Z' || ch4 < 'A' || ch4 > 'Z') { throw new IllegalArgumentException(\"Invalid \" + str); } if (ch3 < 'A' || ch4 > 'Z') {",
                "patch_diff": "throw new IllegalArgumentException(\"Invalid locale format: \" + str); } char ch3 < 'A' || ch4 > 'Z' || ch4 < 'A' || ch4 > 'Z') { throw new IllegalArgumentException(\"Invalid \" + str); } if (ch3 < 'A' || ch4 > 'Z') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (ch3 == '_') { return new Locale(str.substring(0, 2), \"\", str.substring(4)); }"
    },
    "Closure-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "private boolean hasExceptionHandler(cfgNode, output);",
                "patch_diff": "private boolean hasExceptionHandler(cfgNode, output);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "private boolean hasExceptionHandler(cfgNode, output, conditional);",
                "patch_diff": "private boolean hasExceptionHandler(cfgNode, output, conditional);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "private boolean hasExceptionHandler(cfgNode);",
                "patch_diff": "private boolean hasExceptionHandler(cfgNode);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "private boolean hasExceptionHandler(cfgNode) { return false; } private void computeMayUse(",
                "patch_diff": "private boolean hasExceptionHandler(cfgNode) { return false; } private void computeMayUse(",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private boolean hasExceptionHandler(cfgNode) { return true; } private void computeMayUse(",
                "patch_diff": "private boolean hasExceptionHandler(cfgNode) { return true; } private void computeMayUse(",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "private boolean hasExceptionHandler(cfgNode, output, conditional) {",
                "patch_diff": "private boolean hasExceptionHandler(cfgNode, output, conditional) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private boolean hasExceptionHandler(cfgNode, output;",
                "patch_diff": "private boolean hasExceptionHandler(cfgNode, output;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "private boolean hasExceptionHandler(cfgNode) {",
                "patch_diff": "private boolean hasExceptionHandler(cfgNode) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private boolean hasExceptionHandler(cfgNode) { return true; } private void computeMayUse(cfgNode, output, conditional);",
                "patch_diff": "private boolean hasExceptionHandler(cfgNode) { return true; } private void computeMayUse(cfgNode, output, conditional);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "private boolean hasExceptionHandler(cfgNode) { return false; } private void computeMayUse(cfgNode, output, conditional);",
                "patch_diff": "private boolean hasExceptionHandler(cfgNode) { return false; } private void computeMayUse(cfgNode, output, conditional);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode); for (DiGraphEdge<Node, Branch> edge : branchEdges) { if (edge.getValue() == Branch.ON_EX) { return true; } }"
    },
    "Closure-128": {
        "fixes": [
            {
                "k": 1,
                "patch": "return len > 0 && s.charAt(0) == '0';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-128/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 05:15:00.928684968 +0200\n+++ /tmp/tmp6206_4jh.java\t2022-07-19 05:15:00.952684834 +0200\n@@ -786,11 +786,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+return len > 0 && s.charAt(0) == '0';\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return len > 0 && s.charAt(0)!= '0';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-128/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 05:15:48.908418238 +0200\n+++ /tmp/tmpnvx32oxq.java\t2022-07-19 05:15:48.912418214 +0200\n@@ -786,11 +786,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+return len > 0 && s.charAt(0)!= '0';\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return index > 0 && s.charAt(0) == '0';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-128/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 05:16:33.472170554 +0200\n+++ /tmp/tmpynftq5z4.java\t2022-07-19 05:16:33.472170554 +0200\n@@ -786,11 +786,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+return index > 0 && s.charAt(0) == '0';\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return len > 0 || s.charAt(0) == '0';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-128/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 05:16:37.024150816 +0200\n+++ /tmp/tmpwnjimms2.java\t2022-07-19 05:16:37.024150816 +0200\n@@ -786,11 +786,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+return len > 0 || s.charAt(0) == '0';\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return index > 0 && s.charAt(0)!= '0';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-128/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 05:17:21.539903455 +0200\n+++ /tmp/tmp8knvnu3m.java\t2022-07-19 05:17:21.539903455 +0200\n@@ -786,11 +786,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+return index > 0 && s.charAt(0)!= '0';\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return len > 0 || s.charAt(0)!= '0';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-128/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 05:17:24.999884231 +0200\n+++ /tmp/tmpaeixc9sb.java\t2022-07-19 05:17:24.999884231 +0200\n@@ -786,11 +786,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+return len > 0 || s.charAt(0)!= '0';\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return index >= 0 && s.charAt(0) == '0';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-128/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 05:18:09.439637340 +0200\n+++ /tmp/tmprteom27j.java\t2022-07-19 05:18:09.443637320 +0200\n@@ -786,11 +786,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+return index >= 0 && s.charAt(0) == '0';\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return s > 0 && s.charAt(0) == '0';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-128/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 05:18:13.191616499 +0200\n+++ /tmp/tmp6um0nm2q.java\t2022-07-19 05:18:13.195616475 +0200\n@@ -786,11 +786,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+return s > 0 && s.charAt(0) == '0';\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return index > 0 || s.charAt(0) == '0';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-128/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 05:18:16.763596656 +0200\n+++ /tmp/tmpjrdd3r1n.java\t2022-07-19 05:18:16.763596656 +0200\n@@ -786,11 +786,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+return index > 0 || s.charAt(0) == '0';\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return index >= 0 && s.charAt(0)!= '0';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-128/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 05:18:20.499575902 +0200\n+++ /tmp/tmpl87taec8.java\t2022-07-19 05:18:20.499575902 +0200\n@@ -786,11 +786,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+return index >= 0 && s.charAt(0)!= '0';\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return len > 0 && s.charAt(0) != '0';",
        "fixed_line": "if (len == 0) { return false; } for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c < '0' || c > '9') { return false; } } return len == 1 || s.charAt(0) != '0';"
    },
    "Math-82": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (MathUtils.compareTo( entry, 0, epsilon) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2022-07-19 05:18:24.163555551 +0200\n+++ /tmp/tmpzxyjtogk.java\t2022-07-19 05:18:24.191555394 +0200\n@@ -77,11 +77,11 @@\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+if (MathUtils.compareTo( entry, 0, epsilon) > 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 2,
                "patch": "if (MathUtils.compareTo(entry, 0, epsilon) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2022-07-19 05:18:32.159511134 +0200\n+++ /tmp/tmpkhceiqu5.java\t2022-07-19 05:18:32.163511114 +0200\n@@ -77,11 +77,11 @@\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 3,
                "patch": "if (MathUtils.compareTo( entry, 0, epsilon) == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2022-07-19 05:18:38.779474365 +0200\n+++ /tmp/tmpoy78vlna.java\t2022-07-19 05:18:38.779474365 +0200\n@@ -77,11 +77,11 @@\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+if (MathUtils.compareTo( entry, 0, epsilon) == 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (MathUtils.compareTo( entry, 0, epsilon) >= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2022-07-19 05:18:45.291438195 +0200\n+++ /tmp/tmpsu71scap.java\t2022-07-19 05:18:45.295438172 +0200\n@@ -77,11 +77,11 @@\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+if (MathUtils.compareTo( entry, 0, epsilon) >= 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (MathUtils.compareTo( entry, 0, epsilon) < 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2022-07-19 05:18:51.883401578 +0200\n+++ /tmp/tmpb_02w9x8.java\t2022-07-19 05:18:51.887401558 +0200\n@@ -77,11 +77,11 @@\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+if (MathUtils.compareTo( entry, 0, epsilon) < 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (MathUtils.compareTo(entry, 0, epsilon) == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2022-07-19 05:18:58.439365167 +0200\n+++ /tmp/tmp8xkja190.java\t2022-07-19 05:18:58.443365143 +0200\n@@ -77,11 +77,11 @@\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+if (MathUtils.compareTo(entry, 0, epsilon) == 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (MathUtils.compareTo( entry, 0, epsilon)!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2022-07-19 05:19:05.143327931 +0200\n+++ /tmp/tmp57z1eu78.java\t2022-07-19 05:19:05.143327931 +0200\n@@ -77,11 +77,11 @@\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+if (MathUtils.compareTo( entry, 0, epsilon)!= 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (MathUtils.compareTo( entry, 0, epsilon) > 0.0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2022-07-19 05:19:11.727291367 +0200\n+++ /tmp/tmputfvftrt.java\t2022-07-19 05:19:11.731291344 +0200\n@@ -77,11 +77,11 @@\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+if (MathUtils.compareTo( entry, 0, epsilon) > 0.0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 9,
                "patch": "if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2022-07-19 05:19:18.303254845 +0200\n+++ /tmp/tmp_ylni3bk.java\t2022-07-19 05:19:18.307254821 +0200\n@@ -77,11 +77,11 @@\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (MathUtils.compareTo(entry, 0, epsilon) < 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2022-07-19 05:19:24.883218300 +0200\n+++ /tmp/tmpssgo07kf.java\t2022-07-19 05:19:24.883218300 +0200\n@@ -77,11 +77,11 @@\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+if (MathUtils.compareTo(entry, 0, epsilon) < 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {",
        "fixed_line": "if (MathUtils.compareTo(entry, 0, epsilon) > 0) {"
    },
    "Math-52": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (c > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\t2022-07-19 05:19:31.687180516 +0200\n+++ /tmp/tmpk1aff78j.java\t2022-07-19 05:19:31.707180405 +0200\n@@ -339,26 +339,11 @@\n   Vector3D v1Su1 = v1.subtract(u1);\n   Vector3D v2Su2 = v2.subtract(u2);\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);;\n-      c = k.dotProduct(u2.crossProduct(u3));;\n-\n-      if (c == 0) {\n+if (c > 0) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n         q1 = 0.0;\n         q2 = 0.0;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (c1!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\t2022-07-19 05:19:33.759169007 +0200\n+++ /tmp/tmp6arltt96.java\t2022-07-19 05:19:33.759169007 +0200\n@@ -339,26 +339,11 @@\n   Vector3D v1Su1 = v1.subtract(u1);\n   Vector3D v2Su2 = v2.subtract(u2);\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);;\n-      c = k.dotProduct(u2.crossProduct(u3));;\n-\n-      if (c == 0) {\n+if (c1!= 0) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n         q1 = 0.0;\n         q2 = 0.0;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (c < 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\t2022-07-19 05:19:35.879157236 +0200\n+++ /tmp/tmpt142wj1x.java\t2022-07-19 05:19:35.879157236 +0200\n@@ -339,26 +339,11 @@\n   Vector3D v1Su1 = v1.subtract(u1);\n   Vector3D v2Su2 = v2.subtract(u2);\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);;\n-      c = k.dotProduct(u2.crossProduct(u3));;\n-\n-      if (c == 0) {\n+if (c < 0) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n         q1 = 0.0;\n         q2 = 0.0;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (c!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\t2022-07-19 05:19:37.975145596 +0200\n+++ /tmp/tmpb6sgk7ev.java\t2022-07-19 05:19:37.975145596 +0200\n@@ -339,26 +339,11 @@\n   Vector3D v1Su1 = v1.subtract(u1);\n   Vector3D v2Su2 = v2.subtract(u2);\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);;\n-      c = k.dotProduct(u2.crossProduct(u3));;\n-\n-      if (c == 0) {\n+if (c!= 0) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n         q1 = 0.0;\n         q2 = 0.0;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (c >= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\t2022-07-19 05:19:39.975134490 +0200\n+++ /tmp/tmpclxkgqt6.java\t2022-07-19 05:19:39.979134467 +0200\n@@ -339,26 +339,11 @@\n   Vector3D v1Su1 = v1.subtract(u1);\n   Vector3D v2Su2 = v2.subtract(u2);\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);;\n-      c = k.dotProduct(u2.crossProduct(u3));;\n-\n-      if (c == 0) {\n+if (c >= 0) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n         q1 = 0.0;\n         q2 = 0.0;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (c < 0) { // the (u1 > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\t2022-07-19 05:19:42.015123160 +0200\n+++ /tmp/tmp3s23fg80.java\t2022-07-19 05:19:42.019123136 +0200\n@@ -339,26 +339,11 @@\n   Vector3D v1Su1 = v1.subtract(u1);\n   Vector3D v2Su2 = v2.subtract(u2);\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);;\n-      c = k.dotProduct(u2.crossProduct(u3));;\n-\n-      if (c == 0) {\n+if (c < 0) { // the (u1 > 0) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n         q1 = 0.0;\n         q2 = 0.0;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (c < 0) { // the(u3) vector is close; if (u1 > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\t2022-07-19 05:19:44.055111832 +0200\n+++ /tmp/tmpv8rrvgi4.java\t2022-07-19 05:19:44.055111832 +0200\n@@ -339,26 +339,11 @@\n   Vector3D v1Su1 = v1.subtract(u1);\n   Vector3D v2Su2 = v2.subtract(u2);\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);;\n-      c = k.dotProduct(u2.crossProduct(u3));;\n-\n-      if (c == 0) {\n+if (c < 0) { // the(u3) vector is close; if (u1 > 0) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n         q1 = 0.0;\n         q2 = 0.0;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (c < 0) { // the (u3) vector is close; if (u1 > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\t2022-07-19 05:19:46.171100081 +0200\n+++ /tmp/tmpx6zk9qqq.java\t2022-07-19 05:19:46.171100081 +0200\n@@ -339,26 +339,11 @@\n   Vector3D v1Su1 = v1.subtract(u1);\n   Vector3D v2Su2 = v2.subtract(u2);\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);;\n-      c = k.dotProduct(u2.crossProduct(u3));;\n-\n-      if (c == 0) {\n+if (c < 0) { // the (u3) vector is close; if (u1 > 0) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n         q1 = 0.0;\n         q2 = 0.0;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (c == 0) { // if ((u1 > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\t2022-07-19 05:19:48.211088753 +0200\n+++ /tmp/tmpxrzrdu8k.java\t2022-07-19 05:19:48.211088753 +0200\n@@ -339,26 +339,11 @@\n   Vector3D v1Su1 = v1.subtract(u1);\n   Vector3D v2Su2 = v2.subtract(u2);\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);;\n-      c = k.dotProduct(u2.crossProduct(u3));;\n-\n-      if (c == 0) {\n+if (c == 0) { // if ((u1 > 0) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n         q1 = 0.0;\n         q2 = 0.0;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (c < 0) { // the (u3) vector is close; if (u1 > 31) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\t2022-07-19 05:19:50.275077291 +0200\n+++ /tmp/tmpkdalqdfu.java\t2022-07-19 05:19:50.275077291 +0200\n@@ -339,26 +339,11 @@\n   Vector3D v1Su1 = v1.subtract(u1);\n   Vector3D v2Su2 = v2.subtract(u2);\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);;\n-      c = k.dotProduct(u2.crossProduct(u3));;\n-\n-      if (c == 0) {\n+if (c < 0) { // the (u3) vector is close; if (u1 > 31) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n         q1 = 0.0;\n         q2 = 0.0;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (c == 0) { // the (q1, q2, q3) vector is close to the (u1, u2) plane // we try other vectors Vector3D v3 = Vector3D.crossProduct(v1, v2); Vector3D v3Su3 = v3.subtract(u3); k = v1Su1.crossProduct(v3Su3); Vector3D u2Prime = u1.crossProduct(u3); c = k.dotProduct(u2Prime); if (c == 0) { // the (q1, q2, q3) vector is also close to the (u1, u3) plane, // it is almost aligned with u1: we try (u2, u3) and (v2, v3) k = v2Su2.crossProduct(v3Su3);; c = k.dotProduct(u2.crossProduct(u3));; if (c == 0) {",
        "fixed_line": "final double inPlaneThreshold = 0.001; if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) { // the (q1, q2, q3) vector is close to the (u1, u2) plane // we try other vectors Vector3D v3 = Vector3D.crossProduct(v1, v2); Vector3D v3Su3 = v3.subtract(u3); k = v1Su1.crossProduct(v3Su3); Vector3D u2Prime = u1.crossProduct(u3); c = k.dotProduct(u2Prime); if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) { // the (q1, q2, q3) vector is also close to the (u1, u3) plane, // it is almost aligned with u1: we try (u2, u3) and (v2, v3) k = v2Su2.crossProduct(v3Su3);; c = k.dotProduct(u2.crossProduct(u3));; if (c <= 0) {"
    },
    "Csv-9": {
        "fixes": [
            {
                "k": 1,
                "patch": "final int col = entry.getValue().intValue();",
                "patch_diff": "final int col = entry.getValue().intValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "final int col = entry.next().intValue();",
                "patch_diff": "final int col = entry.next().intValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "final int col = entry.entrySet()) {",
                "patch_diff": "final int col = entry.entrySet()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "final int col = entry.getValue().intValue(); if (col < values.length) {",
                "patch_diff": "final int col = entry.getValue().intValue(); if (col < values.length) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int col = 0; i < values.length; i++) {",
                "patch_diff": "for (int col = 0; i < values.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int col = 0; i < values.length; ++i) {",
                "patch_diff": "for (int col = 0; i < values.length; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "final int col = map.entrySet()) {",
                "patch_diff": "final int col = map.entrySet()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "final int col = i.getValue().intValue();",
                "patch_diff": "final int col = i.getValue().intValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "final int col = entry.length;",
                "patch_diff": "final int col = entry.length;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int col = 0; i < entry.length; i++) {",
                "patch_diff": "for (int col = 0; i < entry.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (mapping == null) { return map; }"
    },
    "JacksonCore-8": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (_hasSegments) return _currentSegment;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-8/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 05:19:54.207055454 +0200\n+++ /tmp/tmpn6zvmzg0.java\t2022-07-19 05:19:54.235055301 +0200\n@@ -302,11 +302,11 @@\n         if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+if (_hasSegments) return _currentSegment;\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n \n     /*\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (_hasSegments) return _currentSegment; // can't really modify it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-8/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 05:19:59.635024042 +0200\n+++ /tmp/tmputzfqtda.java\t2022-07-19 05:19:59.635024042 +0200\n@@ -302,11 +302,11 @@\n         if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+if (_hasSegments) return _currentSegment; // can't really modify it's do implicit re-parse\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n \n     /*\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (_hasSegments) return _currentSegment; // can't really modify it was non-empty's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-8/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 05:20:04.670994360 +0200\n+++ /tmp/tmpjeoz6td_.java\t2022-07-19 05:20:04.670994360 +0200\n@@ -302,11 +302,11 @@\n         if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+if (_hasSegments) return _currentSegment; // can't really modify it was non-empty's do implicit re-parse\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n \n     /*\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (_hasSegments) return _currentSegment; // we didn't really modify it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-8/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 05:20:09.566965523 +0200\n+++ /tmp/tmp4z_7e9_a.java\t2022-07-19 05:20:09.566965523 +0200\n@@ -302,11 +302,11 @@\n         if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+if (_hasSegments) return _currentSegment; // we didn't really modify it's do implicit re-parse\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n \n     /*\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (_hasSegments) return _currentSegment; // to check whether a non-empty's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-8/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 05:20:14.542936225 +0200\n+++ /tmp/tmpr4lcih6l.java\t2022-07-19 05:20:14.542936225 +0200\n@@ -302,11 +302,11 @@\n         if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+if (_hasSegments) return _currentSegment; // to check whether a non-empty's do implicit re-parse\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n \n     /*\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (_hasSegments) return _currentSegment; // can't really modify it was non-empty's do implicit re-closed",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-8/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 05:20:19.562906686 +0200\n+++ /tmp/tmp42st44va.java\t2022-07-19 05:20:19.562906686 +0200\n@@ -302,11 +302,11 @@\n         if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+if (_hasSegments) return _currentSegment; // can't really modify it was non-empty's do implicit re-closed\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n \n     /*\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (_hasSegments) return _currentSegment; // can't really modify it's do implicit re-closed",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-8/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 05:20:24.522877511 +0200\n+++ /tmp/tmpl5gjo6h6.java\t2022-07-19 05:20:24.526877489 +0200\n@@ -302,11 +302,11 @@\n         if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+if (_hasSegments) return _currentSegment; // can't really modify it's do implicit re-closed\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n \n     /*\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (_hasSegments) return _currentSegment; // to do a non-empty's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-8/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 05:20:29.626847504 +0200\n+++ /tmp/tmp_3wllnuq.java\t2022-07-19 05:20:29.626847504 +0200\n@@ -302,11 +302,11 @@\n         if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+if (_hasSegments) return _currentSegment; // to do a non-empty's do implicit re-parse\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n \n     /*\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (_hasSegments) return _currentSegment; // to check whether a non-empty's do implicit re-closed",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-8/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 05:20:34.510818804 +0200\n+++ /tmp/tmpbvpzf7o3.java\t2022-07-19 05:20:34.510818804 +0200\n@@ -302,11 +302,11 @@\n         if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+if (_hasSegments) return _currentSegment; // to check whether a non-empty's do implicit re-closed\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n \n     /*\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (_hasSegments) return _currentSegment; // can't really modify it was non-literal characters that might be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-8/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 05:20:39.362790307 +0200\n+++ /tmp/tmpxqifet8n.java\t2022-07-19 05:20:39.362790307 +0200\n@@ -302,11 +302,11 @@\n         if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+if (_hasSegments) return _currentSegment; // can't really modify it was non-literal characters that might be null!\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n \n     /*\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (!_hasSegments) return _currentSegment;",
        "fixed_line": "if (!_hasSegments && _currentSegment != null) return _currentSegment;"
    },
    "Mockito-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "return 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-11/src/org/mockito/internal/creation/DelegatingMethod.java\t2022-07-19 05:20:44.590759617 +0200\n+++ /tmp/tmp98gb1d4m.java\t2022-07-19 05:20:44.622759427 +0200\n@@ -55,8 +55,8 @@\n             return method.equals(o);\n     }\n \n     @Override\n     public int hashCode() {\n-        return 1;\n+return 0;\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return 0; // let's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-11/src/org/mockito/internal/creation/DelegatingMethod.java\t2022-07-19 05:21:53.166358340 +0200\n+++ /tmp/tmpofv6ryl5.java\t2022-07-19 05:21:53.166358340 +0200\n@@ -55,8 +55,8 @@\n             return method.equals(o);\n     }\n \n     @Override\n     public int hashCode() {\n-        return 1;\n+return 0; // let's do implicit re-parse\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return 0; // let's do implicit re-closed",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-11/src/org/mockito/internal/creation/DelegatingMethod.java\t2022-07-19 05:23:02.745953471 +0200\n+++ /tmp/tmpz_m4msj4.java\t2022-07-19 05:23:02.749953448 +0200\n@@ -55,8 +55,8 @@\n             return method.equals(o);\n     }\n \n     @Override\n     public int hashCode() {\n-        return 1;\n+return 0; // let's do implicit re-closed\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return 0; // let's do implicit rereturnType",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-11/src/org/mockito/internal/creation/DelegatingMethod.java\t2022-07-19 05:24:10.561560799 +0200\n+++ /tmp/tmp7nl_q061.java\t2022-07-19 05:24:10.561560799 +0200\n@@ -55,8 +55,8 @@\n             return method.equals(o);\n     }\n \n     @Override\n     public int hashCode() {\n-        return 1;\n+return 0; // let's do implicit rereturnType\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return 0; // let's do implicit re-literals",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-11/src/org/mockito/internal/creation/DelegatingMethod.java\t2022-07-19 05:25:23.077142752 +0200\n+++ /tmp/tmpomy6uug8.java\t2022-07-19 05:25:23.077142752 +0200\n@@ -55,8 +55,8 @@\n             return method.equals(o);\n     }\n \n     @Override\n     public int hashCode() {\n-        return 1;\n+return 0; // let's do implicit re-literals\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return 2; // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-11/src/org/mockito/internal/creation/DelegatingMethod.java\t2022-07-19 05:26:31.400750392 +0200\n+++ /tmp/tmpyldjknxr.java\t2022-07-19 05:26:31.400750392 +0200\n@@ -55,8 +55,8 @@\n             return method.equals(o);\n     }\n \n     @Override\n     public int hashCode() {\n-        return 1;\n+return 2; // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return 2; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-11/src/org/mockito/internal/creation/DelegatingMethod.java\t2022-07-19 05:27:40.184356691 +0200\n+++ /tmp/tmp0c1m5ai4.java\t2022-07-19 05:27:40.184356691 +0200\n@@ -55,8 +55,8 @@\n             return method.equals(o);\n     }\n \n     @Override\n     public int hashCode() {\n-        return 1;\n+return 2; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return 2; // we didn't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-11/src/org/mockito/internal/creation/DelegatingMethod.java\t2022-07-19 05:28:47.703971332 +0200\n+++ /tmp/tmpv_x6xa4e.java\t2022-07-19 05:28:47.703971332 +0200\n@@ -55,8 +55,8 @@\n             return method.equals(o);\n     }\n \n     @Override\n     public int hashCode() {\n-        return 1;\n+return 2; // we didn't really modify it's totalGJACKSON-notnotnotnot real number\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return 2; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-11/src/org/mockito/internal/creation/DelegatingMethod.java\t2022-07-19 05:29:55.067587822 +0200\n+++ /tmp/tmpxmq9e3oz.java\t2022-07-19 05:29:55.071587799 +0200\n@@ -55,8 +55,8 @@\n             return method.equals(o);\n     }\n \n     @Override\n     public int hashCode() {\n-        return 1;\n+return 2; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return 2; // we didn't really modify it's totalGJACKSON-notnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-11/src/org/mockito/internal/creation/DelegatingMethod.java\t2022-07-19 05:31:02.891202541 +0200\n+++ /tmp/tmpkg3oli8r.java\t2022-07-19 05:31:02.891202541 +0200\n@@ -55,8 +55,8 @@\n             return method.equals(o);\n     }\n \n     @Override\n     public int hashCode() {\n-        return 1;\n+return 2; // we didn't really modify it's totalGJACKSON-notnotnot real number\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return 1;",
        "fixed_line": "if (this == o) { return true; } if (o instanceof DelegatingMethod) { DelegatingMethod that = (DelegatingMethod) o; return method.equals(that.method); } else { return method.equals(o); } } @Override public int hashCode() { return method.hashCode();"
    },
    "Lang-52": {
        "fixes": [
            {
                "k": 1,
                "patch": "out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out",
                "patch_diff": "out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "case '\\\\': out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write",
                "patch_diff": "case '\\\\': out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); break",
                "patch_diff": "out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); break",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); break; case '\\\\'); out",
                "patch_diff": "out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); break; case '\\\\'); out",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); break; case '\\\\'); out.write('\\\\'); out",
                "patch_diff": "out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); break; case '\\\\'); out.write('\\\\'); out",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); break; case '\\\\'); out.write('\\\\'); out.write('\\\\'); out",
                "patch_diff": "out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); break; case '\\\\'); out.write('\\\\'); out.write('\\\\'); out",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); break; case '\\\\': out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out",
                "patch_diff": "out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); break; case '\\\\': out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); break; case '\\\\': out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out",
                "patch_diff": "out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); break; case '\\\\': out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); break; case '\\\\': out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out",
                "patch_diff": "out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); break; case '\\\\': out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); break; case '\\\\': out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out",
                "patch_diff": "out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); break; case '\\\\': out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out.write('\\\\'); out",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "case '/': out.write('\\\\'); out.write('/'); break;"
    },
    "JacksonXml-3": {
        "fixes": [
            {
                "k": 1,
                "patch": "_currText = _currText; break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-3/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\t2022-07-19 05:32:13.326803211 +0200\n+++ /tmp/tmpht6u25b3.java\t2022-07-19 05:32:13.346803095 +0200\n@@ -664,13 +664,11 @@\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _currToken = JsonToken.FIELD_NAME;\n             }\n             break;\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n-            _currText = _xmlTokens.getText();\n-            _currToken = JsonToken.VALUE_STRING;\n-            break;\n+_currText = _currText; break;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n                 // Also: must skip following END_ELEMENT\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "_currText = _parsingContext.getText(); _currToken = JsonToken.VALUE_STRING; break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-3/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\t2022-07-19 05:32:21.626756203 +0200\n+++ /tmp/tmpf9jo3nkc.java\t2022-07-19 05:32:21.626756203 +0200\n@@ -664,13 +664,11 @@\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _currToken = JsonToken.FIELD_NAME;\n             }\n             break;\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n-            _currText = _xmlTokens.getText();\n-            _currToken = JsonToken.VALUE_STRING;\n-            break;\n+_currText = _parsingContext.getText(); _currToken = JsonToken.VALUE_STRING; break;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n                 // Also: must skip following END_ELEMENT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "_currText = jp.getText(); _currToken = JsonToken.VALUE_STRING; break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-3/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\t2022-07-19 05:32:23.302746711 +0200\n+++ /tmp/tmpb10jjm2v.java\t2022-07-19 05:32:23.302746711 +0200\n@@ -664,13 +664,11 @@\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _currToken = JsonToken.FIELD_NAME;\n             }\n             break;\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n-            _currText = _xmlTokens.getText();\n-            _currToken = JsonToken.VALUE_STRING;\n-            break;\n+_currText = jp.getText(); _currToken = JsonToken.VALUE_STRING; break;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n                 // Also: must skip following END_ELEMENT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "_currText = _currText; break; // we didn't really gets this.currToken = JsonToken.VALUE_STRING; break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-3/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\t2022-07-19 05:32:24.998737105 +0200\n+++ /tmp/tmp3nvpr0dr.java\t2022-07-19 05:32:24.998737105 +0200\n@@ -664,13 +664,11 @@\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _currToken = JsonToken.FIELD_NAME;\n             }\n             break;\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n-            _currText = _xmlTokens.getText();\n-            _currToken = JsonToken.VALUE_STRING;\n-            break;\n+_currText = _currText; break; // we didn't really gets this.currToken = JsonToken.VALUE_STRING; break;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n                 // Also: must skip following END_ELEMENT\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "_currText = _currText.getText(); _currToken = JsonToken.VALUE_STRING; break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-3/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\t2022-07-19 05:32:33.326689954 +0200\n+++ /tmp/tmpoms6v460.java\t2022-07-19 05:32:33.326689954 +0200\n@@ -664,13 +664,11 @@\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _currToken = JsonToken.FIELD_NAME;\n             }\n             break;\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n-            _currText = _xmlTokens.getText();\n-            _currToken = JsonToken.VALUE_STRING;\n-            break;\n+_currText = _currText.getText(); _currToken = JsonToken.VALUE_STRING; break;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n                 // Also: must skip following END_ELEMENT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "_currText = _currText; break; // to skip the _currToken = JsonToken.VALUE_STRING; break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-3/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\t2022-07-19 05:32:35.034680284 +0200\n+++ /tmp/tmpwugmo17l.java\t2022-07-19 05:32:35.034680284 +0200\n@@ -664,13 +664,11 @@\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _currToken = JsonToken.FIELD_NAME;\n             }\n             break;\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n-            _currText = _xmlTokens.getText();\n-            _currToken = JsonToken.VALUE_STRING;\n-            break;\n+_currText = _currText; break; // to skip the _currToken = JsonToken.VALUE_STRING; break;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n                 // Also: must skip following END_ELEMENT\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "_currText = _currText; break; // we didn't really gets this.currText = JsonToken.VALUE_STRING; break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-3/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\t2022-07-19 05:32:43.454632621 +0200\n+++ /tmp/tmpbrl983nn.java\t2022-07-19 05:32:43.454632621 +0200\n@@ -664,13 +664,11 @@\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _currToken = JsonToken.FIELD_NAME;\n             }\n             break;\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n-            _currText = _xmlTokens.getText();\n-            _currToken = JsonToken.VALUE_STRING;\n-            break;\n+_currText = _currText; break; // we didn't really gets this.currText = JsonToken.VALUE_STRING; break;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n                 // Also: must skip following END_ELEMENT\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "_currText = _currToken = JsonToken.VALUE_STRING; break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-3/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\t2022-07-19 05:32:51.722585829 +0200\n+++ /tmp/tmp8t50p_uw.java\t2022-07-19 05:32:51.722585829 +0200\n@@ -664,13 +664,11 @@\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _currToken = JsonToken.FIELD_NAME;\n             }\n             break;\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n-            _currText = _xmlTokens.getText();\n-            _currToken = JsonToken.VALUE_STRING;\n-            break;\n+_currText = _currToken = JsonToken.VALUE_STRING; break;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n                 // Also: must skip following END_ELEMENT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "_currText = _currText; break; // to skip the JsonToken.VALUE_STRING = JsonToken.VALUE_STRING; break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-3/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\t2022-07-19 05:32:53.398576344 +0200\n+++ /tmp/tmpks5mu2zo.java\t2022-07-19 05:32:53.398576344 +0200\n@@ -664,13 +664,11 @@\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _currToken = JsonToken.FIELD_NAME;\n             }\n             break;\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n-            _currText = _xmlTokens.getText();\n-            _currToken = JsonToken.VALUE_STRING;\n-            break;\n+_currText = _currText; break; // to skip the JsonToken.VALUE_STRING = JsonToken.VALUE_STRING; break;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n                 // Also: must skip following END_ELEMENT\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "_currText = _currText = _currText; break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-3/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\t2022-07-19 05:33:01.558530173 +0200\n+++ /tmp/tmpiv80sfm3.java\t2022-07-19 05:33:01.558530173 +0200\n@@ -664,13 +664,11 @@\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _currToken = JsonToken.FIELD_NAME;\n             }\n             break;\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n-            _currText = _xmlTokens.getText();\n-            _currToken = JsonToken.VALUE_STRING;\n-            break;\n+_currText = _currText = _currText; break;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n                 // Also: must skip following END_ELEMENT\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "_currText = _xmlTokens.getText(); _currToken = JsonToken.VALUE_STRING; break;",
        "fixed_line": "return (_currText = _xmlTokens.getText());"
    },
    "Closure-146": {
        "fixes": [
            {
                "k": 1,
                "patch": "return new TypePair(null, null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-146/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 05:33:10.006482379 +0200\n+++ /tmp/tmpkg7mpb71.java\t2022-07-19 05:33:10.022482290 +0200\n@@ -701,11 +701,11 @@\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+return new TypePair(null, null);\n \n       case FALSE:\n       case UNKNOWN:\n         return new TypePair(this, that);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return new TypePair(this.testForEquality, null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-146/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 05:33:31.054363348 +0200\n+++ /tmp/tmpcziebtzo.java\t2022-07-19 05:33:31.054363348 +0200\n@@ -701,11 +701,11 @@\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+return new TypePair(this.testForEquality, null);\n \n       case FALSE:\n       case UNKNOWN:\n         return new TypePair(this, that);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return new TypePair(this.null, null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-146/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 05:33:32.818353374 +0200\n+++ /tmp/tmpvnkk3mpf.java\t2022-07-19 05:33:32.818353374 +0200\n@@ -701,11 +701,11 @@\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+return new TypePair(this.null, null);\n \n       case FALSE:\n       case UNKNOWN:\n         return new TypePair(this, that);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return new TypePair(this, null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-146/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 05:33:34.410344373 +0200\n+++ /tmp/tmp1yandrp6.java\t2022-07-19 05:33:34.410344373 +0200\n@@ -701,11 +701,11 @@\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+return new TypePair(this, null);\n \n       case FALSE:\n       case UNKNOWN:\n         return new TypePair(this, that);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return new TypePair(this.testForEquality(null, null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-146/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 05:33:55.350226012 +0200\n+++ /tmp/tmpqs832e1o.java\t2022-07-19 05:33:55.350226012 +0200\n@@ -701,11 +701,11 @@\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+return new TypePair(this.testForEquality(null, null);\n \n       case FALSE:\n       case UNKNOWN:\n         return new TypePair(this, that);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return new TypePair(this.test, null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-146/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 05:33:56.966216880 +0200\n+++ /tmp/tmp6miirtta.java\t2022-07-19 05:33:56.970216857 +0200\n@@ -701,11 +701,11 @@\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+return new TypePair(this.test, null);\n \n       case FALSE:\n       case UNKNOWN:\n         return new TypePair(this, that);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return new TypePair(this.parameters, null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-146/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 05:33:58.602207635 +0200\n+++ /tmp/tmpifu52q5d.java\t2022-07-19 05:33:58.602207635 +0200\n@@ -701,11 +701,11 @@\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+return new TypePair(this.parameters, null);\n \n       case FALSE:\n       case UNKNOWN:\n         return new TypePair(this, that);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return new TypePair(this.testForLabels(null, null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-146/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 05:34:00.342197803 +0200\n+++ /tmp/tmpzxcu9lsw.java\t2022-07-19 05:34:00.342197803 +0200\n@@ -701,11 +701,11 @@\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+return new TypePair(this.testForLabels(null, null);\n \n       case FALSE:\n       case UNKNOWN:\n         return new TypePair(this, that);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return new TypePair(null, this.null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-146/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 05:34:01.958188669 +0200\n+++ /tmp/tmp95dn8dr1.java\t2022-07-19 05:34:01.962188650 +0200\n@@ -701,11 +701,11 @@\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+return new TypePair(null, this.null);\n \n       case FALSE:\n       case UNKNOWN:\n         return new TypePair(this, that);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return new TypePair(null, this.null, null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-146/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-19 05:34:03.554179654 +0200\n+++ /tmp/tmpnjy3zk5o.java\t2022-07-19 05:34:03.554179654 +0200\n@@ -701,11 +701,11 @@\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+return new TypePair(null, this.null, null);\n \n       case FALSE:\n       case UNKNOWN:\n         return new TypePair(this, that);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return new TypePair(null, null);",
        "fixed_line": "JSType noType = getNativeType(JSTypeNative.NO_TYPE); return new TypePair(noType, noType);"
    },
    "Cli-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) {",
                "patch_diff": "if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) {",
                "patch_diff": "} else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (str.startsWith(\"--\")) {",
                "patch_diff": "if (str.startsWith(\"--\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (str.startsWith(\"--\")) {",
                "patch_diff": "} else if (str.startsWith(\"--\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "String stripLeadingHyphens(str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) {",
                "patch_diff": "String stripLeadingHyphens(str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) {",
                "patch_diff": "return str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int stripLeadingHyphens(str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) {",
                "patch_diff": "int stripLeadingHyphens(str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (str.startsWith(\"--\")) { return str.startsWith(\"--\")) {",
                "patch_diff": "if (str.startsWith(\"--\")) { return str.startsWith(\"--\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (str.startsWith(\"--\")) { return str.startsWith(\"--\")) {",
                "patch_diff": "} else if (str.startsWith(\"--\")) { return str.startsWith(\"--\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "String stripLeadingHyphens(str.startsWith(\"--\")) {",
                "patch_diff": "String stripLeadingHyphens(str.startsWith(\"--\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (str == null) { return null; }"
    },
    "Csv-2": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (index == null? record.get(index == null : null; }",
                "patch_diff": "if (index == null? record.get(index == null : null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "throw new IllegalStateException( \"No header mapping was specified = mapping.get(index == null? values[index] : null; }",
                "patch_diff": "throw new IllegalStateException( \"No header mapping was specified = mapping.get(index == null? values[index] : null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "throw new IllegalStateException( \"No header mapping was specified = mapping.get(index); } else if (index!= null? values[index] : null; }",
                "patch_diff": "throw new IllegalStateException( \"No header mapping was specified = mapping.get(index); } else if (index!= null? values[index] : null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (index == null? record values.get(index == null : null; }",
                "patch_diff": "if (index == null? record values.get(index == null : null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "throw new IllegalStateException( \"No header mapping was specified = mapping.get(index); } else if (index == null? values[index] : null; }",
                "patch_diff": "throw new IllegalStateException( \"No header mapping was specified = mapping.get(index); } else if (index == null? values[index] : null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "throw new IllegalStateException( \"No header mapping was specified = mapping.get(index); } else if (index == null? values[index++] : null; }",
                "patch_diff": "throw new IllegalStateException( \"No header mapping was specified = mapping.get(index); } else if (index == null? values[index++] : null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "throw new IllegalStateException( \"No header mapping was specified = mapping.get(index); } else if (index!= null? values[index++] : null; }",
                "patch_diff": "throw new IllegalStateException( \"No header mapping was specified = mapping.get(index); } else if (index!= null? values[index++] : null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "throw new IllegalStateException( \"No header mapping was specified = mapping.get(index); } else if (index == null? record.get(index == null : null; }",
                "patch_diff": "throw new IllegalStateException( \"No header mapping was specified = mapping.get(index); } else if (index == null? record.get(index == null : null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "throw new IllegalStateException( \"No header mapping was specified = mapping.get(index); } else if (index == null? values[index] : null;",
                "patch_diff": "throw new IllegalStateException( \"No header mapping was specified = mapping.get(index); } else if (index == null? values[index] : null;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "throw new IllegalStateException( \"No header mapping was specified = mapping.get(index); } else if (index == null? record.",
                "patch_diff": "throw new IllegalStateException( \"No header mapping was specified = mapping.get(index); } else if (index == null? record.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "try { return index != null ? values[index.intValue()] : null; } catch (ArrayIndexOutOfBoundsException e) { throw new IllegalArgumentException( String.format( \"Index for header '%s' is %d but CSVRecord only has %d values!\", name, index.intValue(), values.length)); }"
    },
    "Closure-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "// // object is not be in the properties should not be in the",
                "patch_diff": "// // object is not be in the properties should not be in the",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// // object is not be in the value is not be in the",
                "patch_diff": "// // object is not be in the value is not be in the",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// object is not be in the properties should not be in the",
                "patch_diff": "// object is not be in the properties should not be in the",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// // object is not be in the properties should not be in the value is not be in the",
                "patch_diff": "// // object is not be in the properties should not be in the value is not be in the",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// // object is not be in the properties should not be in the // object is not be in the value is not be in the",
                "patch_diff": "// // object is not be in the properties should not be in the // object is not be in the value is not be in the",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// // object is not be in the properties should not be in the // object is not be in the",
                "patch_diff": "// // object is not be in the properties should not be in the // object is not be in the",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// object is not be in the value is not be in the",
                "patch_diff": "// object is not be in the value is not be in the",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// // object is not be in the properties should not be in the value is a blind on it.",
                "patch_diff": "// // object is not be in the properties should not be in the value is a blind on it.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// // object is not be in the properties should not be in the // object is not be in the value is a blind on it.",
                "patch_diff": "// // object is not be in the properties should not be in the // object is not be in the value is a blind on it.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// // object, as different semantics the property has different semantics the property has different semantics",
                "patch_diff": "// // object, as different semantics the property has different semantics the property has different semantics",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (gramps.isDelProp()) { return false; }"
    },
    "Closure-24": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (parent.isVar()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-24/src/com/google/javascript/jscomp/ScopedAliases.java\t2022-07-19 05:34:10.474140556 +0200\n+++ /tmp/tmp02_mmsha.java\t2022-07-19 05:34:10.498140421 +0200\n@@ -273,28 +273,11 @@\n       Scope scope = t.getScope();\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-        }\n-        }\n+if (parent.isVar()) {\n       }\n     }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (n.isVar()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-24/src/com/google/javascript/jscomp/ScopedAliases.java\t2022-07-19 05:34:14.090120127 +0200\n+++ /tmp/tmpvr6yg9la.java\t2022-07-19 05:34:14.094120107 +0200\n@@ -273,28 +273,11 @@\n       Scope scope = t.getScope();\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-        }\n-        }\n+if (n.isVar()) {\n       }\n     }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (parent.isVar()) { // can be null if we're not.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-24/src/com/google/javascript/jscomp/ScopedAliases.java\t2022-07-19 05:34:17.606100268 +0200\n+++ /tmp/tmpppfgqwpz.java\t2022-07-19 05:34:17.610100245 +0200\n@@ -273,28 +273,11 @@\n       Scope scope = t.getScope();\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-        }\n-        }\n+if (parent.isVar()) { // can be null if we're not.\n       }\n     }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (parent.isVar()) { // can be null if we're not use a native function.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-24/src/com/google/javascript/jscomp/ScopedAliases.java\t2022-07-19 05:34:20.906081625 +0200\n+++ /tmp/tmpch3q14bh.java\t2022-07-19 05:34:20.910081606 +0200\n@@ -273,28 +273,11 @@\n       Scope scope = t.getScope();\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-        }\n-        }\n+if (parent.isVar()) { // can be null if we're not use a native function.\n       }\n     }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (parent.isVar()) { if (n.getFirstChild().isVar()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-24/src/com/google/javascript/jscomp/ScopedAliases.java\t2022-07-19 05:34:24.382061993 +0200\n+++ /tmp/tmpq2r40deb.java\t2022-07-19 05:34:24.382061993 +0200\n@@ -273,28 +273,11 @@\n       Scope scope = t.getScope();\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-        }\n-        }\n+if (parent.isVar()) { if (n.getFirstChild().isVar()) {\n       }\n     }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (var.isVar()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-24/src/com/google/javascript/jscomp/ScopedAliases.java\t2022-07-19 05:34:27.938041909 +0200\n+++ /tmp/tmp1vppvsju.java\t2022-07-19 05:34:27.938041909 +0200\n@@ -273,28 +273,11 @@\n       Scope scope = t.getScope();\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-        }\n-        }\n+if (var.isVar()) {\n       }\n     }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (parent.isVar()) { if (n.isVar()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-24/src/com/google/javascript/jscomp/ScopedAliases.java\t2022-07-19 05:34:31.234023298 +0200\n+++ /tmp/tmpkneqs18u.java\t2022-07-19 05:34:31.234023298 +0200\n@@ -273,28 +273,11 @@\n       Scope scope = t.getScope();\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-        }\n-        }\n+if (parent.isVar()) { if (n.isVar()) {\n       }\n     }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (aliasVar.isVar()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-24/src/com/google/javascript/jscomp/ScopedAliases.java\t2022-07-19 05:34:34.778003286 +0200\n+++ /tmp/tmpq21qinzj.java\t2022-07-19 05:34:34.778003286 +0200\n@@ -273,28 +273,11 @@\n       Scope scope = t.getScope();\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-        }\n-        }\n+if (aliasVar.isVar()) {\n       }\n     }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (parent.isVar()) { if (parent.getFirstChild().isVar()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-24/src/com/google/javascript/jscomp/ScopedAliases.java\t2022-07-19 05:34:38.205983929 +0200\n+++ /tmp/tmpkdlfmxu9.java\t2022-07-19 05:34:38.205983929 +0200\n@@ -273,28 +273,11 @@\n       Scope scope = t.getScope();\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-        }\n-        }\n+if (parent.isVar()) { if (parent.getFirstChild().isVar()) {\n       }\n     }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (parent.isVar()) { throw new IllegalArgumentException(); } }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-24/src/com/google/javascript/jscomp/ScopedAliases.java\t2022-07-19 05:34:41.509965274 +0200\n+++ /tmp/tmphmidb6s5.java\t2022-07-19 05:34:41.509965274 +0200\n@@ -273,28 +273,11 @@\n       Scope scope = t.getScope();\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-        }\n-        }\n+if (parent.isVar()) { throw new IllegalArgumentException(); } }\n       }\n     }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (parent.isVar()) { if (n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = scope.getVar(name); aliases.put(name, aliasVar); String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); // Bleeding functions already get a BAD_PARAMETERS error, so just // do nothing. // Parameters of the scope function also get a BAD_PARAMETERS // error. } else { // TODO(robbyw): Support using locals for private variables. report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } }",
        "fixed_line": "if (parent.isVar() && n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = scope.getVar(name); aliases.put(name, aliasVar); String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); } else if (v.isBleedingFunction()) { // Bleeding functions already get a BAD_PARAMETERS error, so just // do nothing. } else if (parent.getType() == Token.LP) {"
    },
    "JacksonDatabind-102": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (property!= null) { return null; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-102/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 05:34:45.089945061 +0200\n+++ /tmp/tmp6wbwiwns.java\t2022-07-19 05:34:45.109944948 +0200\n@@ -62,13 +62,11 @@\n     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n             BeanProperty property) throws JsonMappingException\n     {\n         // Note! Should not skip if `property` null since that'd skip check\n         // for config overrides, in case of root value\n-        if (property == null) {\n-            return this;\n-        }\n+if (property!= null) { return null; }\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n         }\n         // Simple case first: serialize as numeric timestamp?\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (property!= null) { return this; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-102/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 05:35:42.789619473 +0200\n+++ /tmp/tmpjq85_7b2.java\t2022-07-19 05:35:42.789619473 +0200\n@@ -62,13 +62,11 @@\n     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n             BeanProperty property) throws JsonMappingException\n     {\n         // Note! Should not skip if `property` null since that'd skip check\n         // for config overrides, in case of root value\n-        if (property == null) {\n-            return this;\n-        }\n+if (property!= null) { return this; }\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n         }\n         // Simple case first: serialize as numeric timestamp?\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (property == null) { return this; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-102/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 05:36:37.029313693 +0200\n+++ /tmp/tmpn8rw8i4t.java\t2022-07-19 05:36:37.033313670 +0200\n@@ -62,13 +62,11 @@\n     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n             BeanProperty property) throws JsonMappingException\n     {\n         // Note! Should not skip if `property` null since that'd skip check\n         // for config overrides, in case of root value\n-        if (property == null) {\n-            return this;\n-        }\n+if (property == null) { return this; }\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n         }\n         // Simple case first: serialize as numeric timestamp?\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (property == null) { return null; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-102/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 05:37:30.821010685 +0200\n+++ /tmp/tmp0nuqdvp4.java\t2022-07-19 05:37:30.821010685 +0200\n@@ -62,13 +62,11 @@\n     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n             BeanProperty property) throws JsonMappingException\n     {\n         // Note! Should not skip if `property` null since that'd skip check\n         // for config overrides, in case of root value\n-        if (property == null) {\n-            return this;\n-        }\n+if (property == null) { return null; }\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n         }\n         // Simple case first: serialize as numeric timestamp?\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (property!= null) { return null; } else if (property!= null) { return null; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-102/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 05:38:24.564708165 +0200\n+++ /tmp/tmp9m4ii33m.java\t2022-07-19 05:38:24.568708142 +0200\n@@ -62,13 +62,11 @@\n     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n             BeanProperty property) throws JsonMappingException\n     {\n         // Note! Should not skip if `property` null since that'd skip check\n         // for config overrides, in case of root value\n-        if (property == null) {\n-            return this;\n-        }\n+if (property!= null) { return null; } else if (property!= null) { return null; }\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n         }\n         // Simple case first: serialize as numeric timestamp?\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (property!= null) { return null; } else if (property!= null) { return this; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-102/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 05:39:19.608398532 +0200\n+++ /tmp/tmp7zpdpkj_.java\t2022-07-19 05:39:19.608398532 +0200\n@@ -62,13 +62,11 @@\n     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n             BeanProperty property) throws JsonMappingException\n     {\n         // Note! Should not skip if `property` null since that'd skip check\n         // for config overrides, in case of root value\n-        if (property == null) {\n-            return this;\n-        }\n+if (property!= null) { return null; } else if (property!= null) { return this; }\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n         }\n         // Simple case first: serialize as numeric timestamp?\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (property!= null) { return this; } else if (property!= null) { return null; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-102/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 05:40:13.308096638 +0200\n+++ /tmp/tmpvd59c38k.java\t2022-07-19 05:40:13.308096638 +0200\n@@ -62,13 +62,11 @@\n     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n             BeanProperty property) throws JsonMappingException\n     {\n         // Note! Should not skip if `property` null since that'd skip check\n         // for config overrides, in case of root value\n-        if (property == null) {\n-            return this;\n-        }\n+if (property!= null) { return this; } else if (property!= null) { return null; }\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n         }\n         // Simple case first: serialize as numeric timestamp?\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (property!= null) { return this; } else if (property!= null) { return this; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-102/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 05:41:08.455786772 +0200\n+++ /tmp/tmpnlknjanc.java\t2022-07-19 05:41:08.455786772 +0200\n@@ -62,13 +62,11 @@\n     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n             BeanProperty property) throws JsonMappingException\n     {\n         // Note! Should not skip if `property` null since that'd skip check\n         // for config overrides, in case of root value\n-        if (property == null) {\n-            return this;\n-        }\n+if (property!= null) { return this; } else if (property!= null) { return this; }\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n         }\n         // Simple case first: serialize as numeric timestamp?\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (property!= null) { return false; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-102/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 05:42:02.751481839 +0200\n+++ /tmp/tmpbtcip53m.java\t2022-07-19 05:42:02.751481839 +0200\n@@ -62,13 +62,11 @@\n     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n             BeanProperty property) throws JsonMappingException\n     {\n         // Note! Should not skip if `property` null since that'd skip check\n         // for config overrides, in case of root value\n-        if (property == null) {\n-            return this;\n-        }\n+if (property!= null) { return false; }\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n         }\n         // Simple case first: serialize as numeric timestamp?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (property!= null) { return null; } if (property!= null) { return null; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-102/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-19 05:42:04.451472292 +0200\n+++ /tmp/tmprr74sc4o.java\t2022-07-19 05:42:04.451472292 +0200\n@@ -62,13 +62,11 @@\n     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n             BeanProperty property) throws JsonMappingException\n     {\n         // Note! Should not skip if `property` null since that'd skip check\n         // for config overrides, in case of root value\n-        if (property == null) {\n-            return this;\n-        }\n+if (property!= null) { return null; } if (property!= null) { return null; }\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n         }\n         // Simple case first: serialize as numeric timestamp?\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (property == null) { return this; }",
        "fixed_line": ""
    },
    "JacksonCore-21": {
        "fixes": [
            {
                "k": 1,
                "patch": "// never gets here } else if (_currToken == Token.INCLUDE_ALL || _currToken == null) {",
                "patch_diff": "// never gets here } else if (_currToken == Token.INCLUDE_ALL || _currToken == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// never gets here } else if (_currToken == Token.NAME || _currToken == JsonToken.INCLUDE_ALL) {",
                "patch_diff": "// never gets here } else if (_currToken == Token.NAME || _currToken == JsonToken.INCLUDE_ALL) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// never gets here } else if (_currToken == Token.NAME || _currToken == null) {",
                "patch_diff": "// never gets here } else if (_currToken == Token.NAME || _currToken == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// never gets here } else if (_currToken == Token.INCLUDE_ALL || _currToken == JsonToken.INCLUDE_ALL) {",
                "patch_diff": "// never gets here } else if (_currToken == Token.INCLUDE_ALL || _currToken == JsonToken.INCLUDE_ALL) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// never gets here } else if (_currToken == Token.INCLUDE_ALL || _currToken == Token.NAME) {",
                "patch_diff": "// never gets here } else if (_currToken == Token.INCLUDE_ALL || _currToken == Token.NAME) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// never gets here } else if (_currToken == Token.INCLUDE_ALL || _currToken == JsonToken.FIELD_NAME) {",
                "patch_diff": "// never gets here } else if (_currToken == Token.INCLUDE_ALL || _currToken == JsonToken.FIELD_NAME) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// never gets here } else if (_currToken == Token.INCLUDE_ALL || _currToken == JsonToken.NAME) {",
                "patch_diff": "// never gets here } else if (_currToken == Token.INCLUDE_ALL || _currToken == JsonToken.NAME) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// never gets here } else if (_currToken == Token.NAME || _currToken == Token.INCLUDE_ALL) {",
                "patch_diff": "// never gets here } else if (_currToken == Token.NAME || _currToken == Token.INCLUDE_ALL) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// never gets here } else if (_currToken == Token.NAME || _currToken == JsonToken.INCLUDE_ALL)) {",
                "patch_diff": "// never gets here } else if (_currToken == Token.NAME || _currToken == JsonToken.INCLUDE_ALL)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// never gets here } else if (_currToken == Token.INCLUDE_ALL || _currToken == JsonToken.INCLUDE_ALL)) {",
                "patch_diff": "// never gets here } else if (_currToken == Token.INCLUDE_ALL || _currToken == JsonToken.INCLUDE_ALL)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (!_includePath) { if (_currToken.isStructEnd()) { if (_headContext.isStartHandled()) { return (_currToken = null); } } else if (_currToken.isScalarValue()) { //else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once // then return null if (!_headContext.isStartHandled() && (_itemFilter == TokenFilter.INCLUDE_ALL)) { return (_currToken = null); } }"
    },
    "JacksonCore-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "_names = Arrays.copyOf(_names, as need to ensure // we re-rehash flag",
                "patch_diff": "_names = Arrays.copyOf(_names, as need to ensure // we re-rehash flag",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "_names = Arrays.copyOf(_names, as need to ensure",
                "patch_diff": "_names = Arrays.copyOf(_names, as need to ensure",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "_names = Arrays.copyOf(_names, as need to ensure // we rehash",
                "patch_diff": "_names = Arrays.copyOf(_names, as need to ensure // we rehash",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "_names = Arrays.copyOf(_names, as need to ensure // we rehash flag",
                "patch_diff": "_names = Arrays.copyOf(_names, as need to ensure // we rehash flag",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "_names = Arrays.copyOf(_names, as need to ensure // we re-parse",
                "patch_diff": "_names = Arrays.copyOf(_names, as need to ensure // we re-parse",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "_names = Arrays.copyOf(_hashShared, as need to ensure // we re-rehash flag",
                "patch_diff": "_names = Arrays.copyOf(_hashShared, as need to ensure // we re-rehash flag",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "_names = Arrays.copyOf(_names, as need to ensure // we rehash is not copied from '_next-rehash flag",
                "patch_diff": "_names = Arrays.copyOf(_names, as need to ensure // we rehash is not copied from '_next-rehash flag",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "_names = Arrays.copyOf(_names, as need to ensure // we re-checkRehash flag",
                "patch_diff": "_names = Arrays.copyOf(_names, as need to ensure // we re-checkRehash flag",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "_names = Arrays.copyOf(_names, as need to ensure // we re-_hash flag",
                "patch_diff": "_names = Arrays.copyOf(_names, as need to ensure // we re-_hash flag",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "_names = Arrays.copyOf(_names, as need to ensure // we re-rehash flag, as need to ensure",
                "patch_diff": "_names = Arrays.copyOf(_names, as need to ensure // we re-rehash flag, as need to ensure",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "_verifyNeedForRehash();"
    },
    "Closure-17": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (rValue.getJSType() == null &&!rValue.getJSType().isUnknownType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-17/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 05:43:01.915149716 +0200\n+++ /tmp/tmp_hl5iu_3.java\t2022-07-19 05:43:01.987149312 +0200\n@@ -1286,11 +1286,11 @@\n         } else {\n           // Check if this is constant, and if it has a known type.\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n+if (rValue.getJSType() == null &&!rValue.getJSType().isUnknownType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n               } else if (rValue.isOr()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (rValue.getJSType() == null ||!rValue.getJSType().isUnknownType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-17/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 05:43:44.466910932 +0200\n+++ /tmp/tmpjnl_2np4.java\t2022-07-19 05:43:44.466910932 +0200\n@@ -1286,11 +1286,11 @@\n         } else {\n           // Check if this is constant, and if it has a known type.\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n+if (rValue.getJSType() == null ||!rValue.getJSType().isUnknownType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n               } else if (rValue.isOr()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (rValue.getJSType()!= null &&!rValue.getJSType().isUnknownType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-17/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 05:44:24.254687719 +0200\n+++ /tmp/tmpmxbh9ylh.java\t2022-07-19 05:44:24.254687719 +0200\n@@ -1286,11 +1286,11 @@\n         } else {\n           // Check if this is constant, and if it has a known type.\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n+if (rValue.getJSType()!= null &&!rValue.getJSType().isUnknownType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n               } else if (rValue.isOr()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (rValue!= null &&!rValue.getJSType().isUnknownType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-17/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 05:45:03.886465435 +0200\n+++ /tmp/tmpibyorap0.java\t2022-07-19 05:45:03.886465435 +0200\n@@ -1286,11 +1286,11 @@\n         } else {\n           // Check if this is constant, and if it has a known type.\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n+if (rValue!= null &&!rValue.getJSType().isUnknownType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n               } else if (rValue.isOr()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (rValue.getJSType()!= null ||!rValue.getJSType().isUnknownType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-17/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 05:45:43.830241450 +0200\n+++ /tmp/tmpgn09bzt8.java\t2022-07-19 05:45:43.830241450 +0200\n@@ -1286,11 +1286,11 @@\n         } else {\n           // Check if this is constant, and if it has a known type.\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n+if (rValue.getJSType()!= null ||!rValue.getJSType().isUnknownType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n               } else if (rValue.isOr()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if(rValue.getJSType() == null &&!rValue.getJSType().isUnknownType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-17/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 05:46:23.942016567 +0200\n+++ /tmp/tmp0cjok0ku.java\t2022-07-19 05:46:23.946016547 +0200\n@@ -1286,11 +1286,11 @@\n         } else {\n           // Check if this is constant, and if it has a known type.\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n+if(rValue.getJSType() == null &&!rValue.getJSType().isUnknownType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n               } else if (rValue.isOr()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (rValue.getJSType() == null &&!rValue!= null &&!rValue.getJSType().isUnknownType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-17/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 05:47:04.365789984 +0200\n+++ /tmp/tmpgntrcunp.java\t2022-07-19 05:47:04.369789961 +0200\n@@ -1286,11 +1286,11 @@\n         } else {\n           // Check if this is constant, and if it has a known type.\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n+if (rValue.getJSType() == null &&!rValue!= null &&!rValue.getJSType().isUnknownType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n               } else if (rValue.isOr()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (rValue == null ||!rValue.getJSType().isUnknownType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-17/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 05:47:08.153768753 +0200\n+++ /tmp/tmpnfhrmqme.java\t2022-07-19 05:47:08.157768730 +0200\n@@ -1286,11 +1286,11 @@\n         } else {\n           // Check if this is constant, and if it has a known type.\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n+if (rValue == null ||!rValue.getJSType().isUnknownType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n               } else if (rValue.isOr()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (rValue == null &&!rValue.getJSType().isUnknownType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-17/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 05:47:48.397543220 +0200\n+++ /tmp/tmp08peyib9.java\t2022-07-19 05:47:48.401543197 +0200\n@@ -1286,11 +1286,11 @@\n         } else {\n           // Check if this is constant, and if it has a known type.\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n+if (rValue == null &&!rValue.getJSType().isUnknownType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n               } else if (rValue.isOr()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (rValue.getJSType() == null &&!rValue.getJSType().isUnknownType()) { // can be null if we're not.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-17/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 05:48:28.577318081 +0200\n+++ /tmp/tmpzdl_k7g7.java\t2022-07-19 05:48:28.577318081 +0200\n@@ -1286,11 +1286,11 @@\n         } else {\n           // Check if this is constant, and if it has a known type.\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n+if (rValue.getJSType() == null &&!rValue.getJSType().isUnknownType()) { // can be null if we're not.\n                 // If rValue has a type-cast, we use the type in the type-cast.\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n               } else if (rValue.isOr()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {",
        "fixed_line": "JSDocInfo rValueInfo = rValue.getJSDocInfo(); if (rValueInfo != null && rValueInfo.hasType()) { // If rValue has a type-cast, we use the type in the type-cast. return rValueInfo.getType().evaluate(scope, typeRegistry); } else if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {"
    },
    "Closure-1": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (closure.get removing() == null) {",
                "patch_diff": "if (closure.get removing() == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (function.get removing() == null) {",
                "patch_diff": "if (function.get removing() == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (closure.get removing()!= null) {",
                "patch_diff": "if (closure.get removing()!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (closure.get removing removing() == null) {",
                "patch_diff": "if (closure.get removing removing() == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (function.get removing() == null)",
                "patch_diff": "if (function.get removing() == null)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (closure.get removing().().().",
                "patch_diff": "if (closure.get removing().().().",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (closure.get removing() == null)",
                "patch_diff": "if (closure.get removing() == null)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (calclosure-compiler.getRootNode().().",
                "patch_diff": "if (calclosure-compiler.getRootNode().().",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (function.get removing() == null) { // as per [Jissues/p/p/p/issues/p/issues-compiler.",
                "patch_diff": "if (function.get removing() == null) { // as per [Jissues/p/p/p/issues/p/issues-compiler.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (closure.get removing() == null) { // as per [Jissues/p/p/p/issues/p/issues-compiler.",
                "patch_diff": "if (closure.get removing() == null) { // as per [Jissues/p/p/p/issues/p/issues-compiler.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (!removeGlobals) { return; }"
    },
    "Closure-168": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (t.getScopeDepth() == 2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-168/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 05:49:10.729081928 +0200\n+++ /tmp/tmpc7rq5dlk.java\t2022-07-19 05:49:10.749081818 +0200\n@@ -1991,11 +1991,11 @@\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+if (t.getScopeDepth() == 2) {\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n         //\n         // 2) Local variables that are assigned more than once.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (t.getScopeDepth()!= 2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-168/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 05:49:52.684846909 +0200\n+++ /tmp/tmpusvmuec9.java\t2022-07-19 05:49:52.684846909 +0200\n@@ -1991,11 +1991,11 @@\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+if (t.getScopeDepth()!= 2) {\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n         //\n         // 2) Local variables that are assigned more than once.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (t.getScopeDepth() < 2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-168/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 05:50:34.384613354 +0200\n+++ /tmp/tmptzx_r393.java\t2022-07-19 05:50:34.388613334 +0200\n@@ -1991,11 +1991,11 @@\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+if (t.getScopeDepth() < 2) {\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n         //\n         // 2) Local variables that are assigned more than once.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 4,
                "patch": "if (t.getScopeDepth() <= 2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-168/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 05:51:15.736381778 +0200\n+++ /tmp/tmpa1uq10hs.java\t2022-07-19 05:51:15.736381778 +0200\n@@ -1991,11 +1991,11 @@\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+if (t.getScopeDepth() <= 2) {\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n         //\n         // 2) Local variables that are assigned more than once.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (t.getScopeDepth() == 2) { // block == null; can't be null if we're not use a native function.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-168/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 05:51:57.464148123 +0200\n+++ /tmp/tmp5qcnb3d6.java\t2022-07-19 05:51:57.464148123 +0200\n@@ -1991,11 +1991,11 @@\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+if (t.getScopeDepth() == 2) { // block == null; can't be null if we're not use a native function.\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n         //\n         // 2) Local variables that are assigned more than once.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (t.getScopeDepth() == 2) { // block == null; can't really modify it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-168/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 05:52:39.407913281 +0200\n+++ /tmp/tmp0mz9c_r0.java\t2022-07-19 05:52:39.407913281 +0200\n@@ -1991,11 +1991,11 @@\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+if (t.getScopeDepth() == 2) { // block == null; can't really modify it's do implicit re-parse\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n         //\n         // 2) Local variables that are assigned more than once.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (t.getScopeDepth() == 2) { // block == null; can't be null if we're not.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-168/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 05:53:20.899680990 +0200\n+++ /tmp/tmp9of8gjc5.java\t2022-07-19 05:53:20.903680970 +0200\n@@ -1991,11 +1991,11 @@\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+if (t.getScopeDepth() == 2) { // block == null; can't be null if we're not.\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n         //\n         // 2) Local variables that are assigned more than once.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (t.getScopeDepth() == 2) { // if it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-168/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 05:54:02.303449215 +0200\n+++ /tmp/tmpoy5virxm.java\t2022-07-19 05:54:02.303449215 +0200\n@@ -1991,11 +1991,11 @@\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+if (t.getScopeDepth() == 2) { // if it's totalGJACKSON-notnotnotnotnotnot real number\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n         //\n         // 2) Local variables that are assigned more than once.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (t.getScopeDepth() == 2) { // if it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-168/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 05:54:44.079205099 +0200\n+++ /tmp/tmp0vl62r7z.java\t2022-07-19 05:54:44.079205099 +0200\n@@ -1991,11 +1991,11 @@\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+if (t.getScopeDepth() == 2) { // if it's totalGJACKSON-notnotnotnotnotnotnot real number\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n         //\n         // 2) Local variables that are assigned more than once.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (t.getScopeDepth() == 2) { // if it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-168/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 05:55:25.922960912 +0200\n+++ /tmp/tmputma0897.java\t2022-07-19 05:55:25.922960912 +0200\n@@ -1991,11 +1991,11 @@\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+if (t.getScopeDepth() == 2) { // if it's totalGJACKSON-notnotnotnotnot real number\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n         //\n         // 2) Local variables that are assigned more than once.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (t.getScopeDepth() <= 2) {",
        "fixed_line": "if (t.getScopeDepth() <= 1) {"
    },
    "JacksonDatabind-58": {
        "fixes": [
            {
                "k": 1,
                "patch": "// note: should be null if (propDef.getWrapper()!= null) {",
                "patch_diff": "// note: should be null if (propDef.getWrapper()!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// throw new BeanProperty.getFullName());",
                "patch_diff": "// throw new BeanProperty.getFullName());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if (propDef.getWrapper()!= null) {",
                "patch_diff": "// if (propDef.getWrapper()!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// throw new BeanProperty.getFullName()); } else if (propDef.getClass().isEnabled(propDef.getWrapper());",
                "patch_diff": "// throw new BeanProperty.getFullName()); } else if (propDef.getClass().isEnabled(propDef.getWrapper());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// throw new BeanProperty.getFullName()); } else if (propDef.getClass().isEnabled(propDef.getWrapperType(), beanDesc.getClassAnnotations(), mutator, propDef.getWrapper());",
                "patch_diff": "// throw new BeanProperty.getFullName()); } else if (propDef.getClass().isEnabled(propDef.getWrapperType(), beanDesc.getClassAnnotations(), mutator, propDef.getWrapper());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// throw new BeanProperty.getFullName()); } else if (propDef.getWrapper()!= null) {",
                "patch_diff": "// throw new BeanProperty.getFullName()); } else if (propDef.getWrapper()!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// note: should be null if (propDef.getWrapperName(), beanDesc.getClassAnnotations(), mutator);",
                "patch_diff": "// note: should be null if (propDef.getWrapperName(), beanDesc.getClassAnnotations(), mutator);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// note: should be null if (propDef.getWrapperName(), beanDesc.getClassAnnotations(), mutator.isEnabled(propDef.getWrapper());",
                "patch_diff": "// note: should be null if (propDef.getWrapperName(), beanDesc.getClassAnnotations(), mutator.isEnabled(propDef.getWrapper());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// note: return new BeanProperty.getFullName());",
                "patch_diff": "// note: return new BeanProperty.getFullName());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// note: should be null if (propDef.getWrapperName(), beanDesc.getClassAnnotations(), mutator, propDef.getWrapper());",
                "patch_diff": "// note: should be null if (propDef.getWrapperName(), beanDesc.getClassAnnotations(), mutator, propDef.getWrapper());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if ((mutator instanceof AnnotatedField) && \"cause\".equals(mutator.getName())) { ; } else { mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS)); }"
    },
    "Closure-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (parent.getJSType() == null && objNode.isAssign()) { return;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-11/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 05:56:09.010710200 +0200\n+++ /tmp/tmpa4leno82.java\t2022-07-19 05:56:09.038710036 +0200\n@@ -1309,12 +1309,11 @@\n     Node objNode = n.getFirstChild();\n     JSType childType = getJSType(objNode);\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      return;\n+} else if (parent.getJSType() == null && objNode.isAssign()) { return;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n     }\n     ensureTyped(t, n);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 2,
                "patch": "} else if (parent.getJSType() == null && parent.isAssign()) { return;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-11/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 05:56:57.798427140 +0200\n+++ /tmp/tmpit7ac2pm.java\t2022-07-19 05:56:57.798427140 +0200\n@@ -1309,12 +1309,11 @@\n     Node objNode = n.getFirstChild();\n     JSType childType = getJSType(objNode);\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      return;\n+} else if (parent.getJSType() == null && parent.isAssign()) { return;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n     }\n     ensureTyped(t, n);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 3,
                "patch": "} else if (parent.getJSType()!= null && objNode.isAssign()) { return;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-11/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 05:57:44.474157083 +0200\n+++ /tmp/tmp_hdmtsoe.java\t2022-07-19 05:57:44.478157060 +0200\n@@ -1309,12 +1309,11 @@\n     Node objNode = n.getFirstChild();\n     JSType childType = getJSType(objNode);\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      return;\n+} else if (parent.getJSType()!= null && objNode.isAssign()) { return;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n     }\n     ensureTyped(t, n);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 4,
                "patch": "} else if (parent.getJSType() == null || objNode.isAssign()) { return;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-11/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 05:58:30.821889583 +0200\n+++ /tmp/tmpnqk5j4l2.java\t2022-07-19 05:58:30.821889583 +0200\n@@ -1309,12 +1309,11 @@\n     Node objNode = n.getFirstChild();\n     JSType childType = getJSType(objNode);\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      return;\n+} else if (parent.getJSType() == null || objNode.isAssign()) { return;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n     }\n     ensureTyped(t, n);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (parent.getJSType() == null || parent.isAssign()) { return;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-11/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 05:59:17.441621119 +0200\n+++ /tmp/tmp_cyknpik.java\t2022-07-19 05:59:17.441621119 +0200\n@@ -1309,12 +1309,11 @@\n     Node objNode = n.getFirstChild();\n     JSType childType = getJSType(objNode);\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      return;\n+} else if (parent.getJSType() == null || parent.isAssign()) { return;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n     }\n     ensureTyped(t, n);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (parent.getJSType()!= null && parent.isAssign()) { return;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-11/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 06:00:04.113352910 +0200\n+++ /tmp/tmpn1kv3erb.java\t2022-07-19 06:00:04.113352910 +0200\n@@ -1309,12 +1309,11 @@\n     Node objNode = n.getFirstChild();\n     JSType childType = getJSType(objNode);\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      return;\n+} else if (parent.getJSType()!= null && parent.isAssign()) { return;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n     }\n     ensureTyped(t, n);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (parent.getJSType() == null && n.isAssign()) { return;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-11/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 06:00:51.025083833 +0200\n+++ /tmp/tmpf3nlk_ni.java\t2022-07-19 06:00:51.025083833 +0200\n@@ -1309,12 +1309,11 @@\n     Node objNode = n.getFirstChild();\n     JSType childType = getJSType(objNode);\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      return;\n+} else if (parent.getJSType() == null && n.isAssign()) { return;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n     }\n     ensureTyped(t, n);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 8,
                "patch": "} else if(parent.getJSType() == null && objNode.isAssign()) { return;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-11/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 06:01:37.264819067 +0200\n+++ /tmp/tmp6h50q6ru.java\t2022-07-19 06:01:37.268819046 +0200\n@@ -1309,12 +1309,11 @@\n     Node objNode = n.getFirstChild();\n     JSType childType = getJSType(objNode);\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      return;\n+} else if(parent.getJSType() == null && objNode.isAssign()) { return;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n     }\n     ensureTyped(t, n);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 9,
                "patch": "} else if (parent.getJSType() == null && objNode.isAssign()) { return; } else if (parent.isAssign()) { return;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-11/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 06:02:23.896552478 +0200\n+++ /tmp/tmpwuucpf5i.java\t2022-07-19 06:02:23.900552455 +0200\n@@ -1309,12 +1309,11 @@\n     Node objNode = n.getFirstChild();\n     JSType childType = getJSType(objNode);\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      return;\n+} else if (parent.getJSType() == null && objNode.isAssign()) { return; } else if (parent.isAssign()) { return;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n     }\n     ensureTyped(t, n);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (parent.getJSType() == null && objNode.isAssign()) { throw;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-11/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 06:03:10.584285953 +0200\n+++ /tmp/tmp2ke9ptz6.java\t2022-07-19 06:03:10.584285953 +0200\n@@ -1309,12 +1309,11 @@\n     Node objNode = n.getFirstChild();\n     JSType childType = getJSType(objNode);\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      return;\n+} else if (parent.getJSType() == null && objNode.isAssign()) { throw;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n     }\n     ensureTyped(t, n);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "} else if (n.getJSType() != null && parent.isAssign()) { return;",
        "fixed_line": ""
    },
    "Time-18": {
        "fixes": [
            {
                "k": 1,
                "patch": "iJulianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);",
                "patch_diff": "iJulianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "iJulianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); }",
                "patch_diff": "iJulianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// secondOfMinute, millisOfSecond, iJulianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);",
                "patch_diff": "// secondOfMinute, millisOfSecond, iJulianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "iJulianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); } // Assume date is GregorianChronology.getDateTimeMillis (year, millisOfSecond);",
                "patch_diff": "iJulianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); } // Assume date is GregorianChronology.getDateTimeMillis (year, millisOfSecond);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// secondOfMinute, millisOfSecond, iJulianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); }",
                "patch_diff": "// secondOfMinute, millisOfSecond, iJulianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// second instant = iJulianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);",
                "patch_diff": "// second instant = iJulianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "iJulianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); } // Assume date is GregorianChronology.getDateTimeMillis (year, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);",
                "patch_diff": "iJulianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); } // Assume date is GregorianChronology.getDateTimeMillis (year, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// instant = iJulianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);",
                "patch_diff": "// instant = iJulianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "iJulianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); } // Assume date is GregorianChronology.getDateTimeMillis (year, secondOfMinute, millisOfSecond);",
                "patch_diff": "iJulianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); } // Assume date is GregorianChronology.getDateTimeMillis (year, secondOfMinute, millisOfSecond);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// secondOfMinute, millisOfSecond, iJulianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); } // Assume date is GregorianChronology.getDateTimeMillis (year, millisOfSecond);",
                "patch_diff": "// secondOfMinute, millisOfSecond, iJulianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); } // Assume date is GregorianChronology.getDateTimeMillis (year, millisOfSecond);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "try { instant = iGregorianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); } catch (IllegalFieldValueException ex) { if (monthOfYear != 2 || dayOfMonth != 29) { throw ex; } instant = iGregorianChronology.getDateTimeMillis (year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); if (instant >= iCutoverMillis) { throw ex; } }"
    },
    "Time-15": {
        "fixes": [
            {
                "k": 1,
                "patch": "long safeMultiply(val1, // -1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L",
                "patch_diff": "long safeMultiply(val1, // -1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "long safeMultiply(val1, // -1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L",
                "patch_diff": "long safeMultiply(val1, // -1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "long safeMultiply(val1, // -1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L",
                "patch_diff": "long safeMultiply(val1, // -1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "long safeMultiply(val1, // -1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L",
                "patch_diff": "long safeMultiply(val1, // -1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "long safeMultiply(val1, // -1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 3L; case 1: return 0L; case",
                "patch_diff": "long safeMultiply(val1, // -1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 3L; case 1: return 0L; case",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "long safeMultiply(val1, // -1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 3L; case",
                "patch_diff": "long safeMultiply(val1, // -1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 3L; case",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "long safeMultiply(val1, // -1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L;",
                "patch_diff": "long safeMultiply(val1, // -1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "long safeMultiply(val1, // -1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L;",
                "patch_diff": "long safeMultiply(val1, // -1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "long safeMultiply(val1, // -1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L;",
                "patch_diff": "long safeMultiply(val1, // -1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "long safeMultiply(val1, // -1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 'D",
                "patch_diff": "long safeMultiply(val1, // -1: return 0L; case 0: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 'D",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (val1 == Long.MIN_VALUE) { throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2); }"
    },
    "Math-58": {
        "fixes": [
            {
                "k": 1,
                "patch": "return guess;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2022-07-19 06:03:18.832238907 +0200\n+++ /tmp/tmpedxg4an6.java\t2022-07-19 06:03:18.856238770 +0200\n@@ -116,11 +116,11 @@\n      * @return the parameters of the Gaussian function that best fits the\n      * observed points (in the same order as above).\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+return guess;\n     }\n \n     /**\n      * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n      * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return guess; // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2022-07-19 06:04:05.047975481 +0200\n+++ /tmp/tmpg26oiq4m.java\t2022-07-19 06:04:05.047975481 +0200\n@@ -116,11 +116,11 @@\n      * @return the parameters of the Gaussian function that best fits the\n      * observed points (in the same order as above).\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+return guess; // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n     }\n \n     /**\n      * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n      * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return guess; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2022-07-19 06:04:47.155735743 +0200\n+++ /tmp/tmphz1qkvb9.java\t2022-07-19 06:04:47.155735743 +0200\n@@ -116,11 +116,11 @@\n      * @return the parameters of the Gaussian function that best fits the\n      * observed points (in the same order as above).\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+return guess; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n     }\n \n     /**\n      * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n      * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return guess; // we didn't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2022-07-19 06:05:29.423495331 +0200\n+++ /tmp/tmpf4z201u2.java\t2022-07-19 06:05:29.423495331 +0200\n@@ -116,11 +116,11 @@\n      * @return the parameters of the Gaussian function that best fits the\n      * observed points (in the same order as above).\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+return guess; // we didn't really modify it's totalGJACKSON-notnotnotnot real number\n     }\n \n     /**\n      * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n      * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return guess; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2022-07-19 06:06:11.467256414 +0200\n+++ /tmp/tmppsh_6dob.java\t2022-07-19 06:06:11.467256414 +0200\n@@ -116,11 +116,11 @@\n      * @return the parameters of the Gaussian function that best fits the\n      * observed points (in the same order as above).\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+return guess; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n     }\n \n     /**\n      * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n      * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return guess; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2022-07-19 06:06:53.611017127 +0200\n+++ /tmp/tmp1vb7nw5u.java\t2022-07-19 06:06:53.611017127 +0200\n@@ -116,11 +116,11 @@\n      * @return the parameters of the Gaussian function that best fits the\n      * observed points (in the same order as above).\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+return guess; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number\n     }\n \n     /**\n      * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n      * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return guess; // we didn't really modify it's totalGJACKSON-notnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2022-07-19 06:07:35.330780433 +0200\n+++ /tmp/tmpp6bz4dci.java\t2022-07-19 06:07:35.330780433 +0200\n@@ -116,11 +116,11 @@\n      * @return the parameters of the Gaussian function that best fits the\n      * observed points (in the same order as above).\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+return guess; // we didn't really modify it's totalGJACKSON-notnotnot real number\n     }\n \n     /**\n      * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n      * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return guess; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2022-07-19 06:08:16.930544584 +0200\n+++ /tmp/tmp19h51xdr.java\t2022-07-19 06:08:16.930544584 +0200\n@@ -116,11 +116,11 @@\n      * @return the parameters of the Gaussian function that best fits the\n      * observed points (in the same order as above).\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+return guess; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number\n     }\n \n     /**\n      * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n      * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return guess; // we didn't really modify it's totalGJACKSON-notnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2022-07-19 06:08:58.942306557 +0200\n+++ /tmp/tmp41lpud35.java\t2022-07-19 06:08:58.942306557 +0200\n@@ -116,11 +116,11 @@\n      * @return the parameters of the Gaussian function that best fits the\n      * observed points (in the same order as above).\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+return guess; // we didn't really modify it's totalGJACKSON-notnot real number\n     }\n \n     /**\n      * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n      * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return guess; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2022-07-19 06:09:40.906068946 +0200\n+++ /tmp/tmpntde5d_o.java\t2022-07-19 06:09:40.906068946 +0200\n@@ -116,11 +116,11 @@\n      * @return the parameters of the Gaussian function that best fits the\n      * observed points (in the same order as above).\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+return guess; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnot real number\n     }\n \n     /**\n      * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n      * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return fit(new Gaussian.Parametric(), guess);",
        "fixed_line": "return fit(guess);"
    },
    "Closure-48": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (inferred) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-48/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 06:10:23.069830338 +0200\n+++ /tmp/tmp93jl4c70.java\t2022-07-19 06:10:23.153829860 +0200\n@@ -1516,15 +1516,11 @@\n             || (info.isConstant() && valueType != null\n                 && !valueType.isUnknownType())\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+if (inferred) {\n       }\n \n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (inferred) { case 'I': for #2 inferred =!(rhsValue!= null && rhsValue.isFunction() && (info!= null ||!scope.isDeclared(qName, false)));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-48/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 06:11:01.761611483 +0200\n+++ /tmp/tmp_j8poig4.java\t2022-07-19 06:11:01.761611483 +0200\n@@ -1516,15 +1516,11 @@\n             || (info.isConstant() && valueType != null\n                 && !valueType.isUnknownType())\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+if (inferred) { case 'I': for #2 inferred =!(rhsValue!= null && rhsValue.isFunction() && (info!= null ||!scope.isDeclared(qName, false)));\n       }\n \n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (inferred) { case 'I': for #2 inferred =!(rhsValue!= null && rhsValue.isFunction() && (info!= null &&!scope.isDeclared(qName, false)));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-48/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 06:11:05.069592776 +0200\n+++ /tmp/tmpb8yvmi_u.java\t2022-07-19 06:11:05.069592776 +0200\n@@ -1516,15 +1516,11 @@\n             || (info.isConstant() && valueType != null\n                 && !valueType.isUnknownType())\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+if (inferred) { case 'I': for #2 inferred =!(rhsValue!= null && rhsValue.isFunction() && (info!= null &&!scope.isDeclared(qName, false)));\n       }\n \n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (inferred) { case 'A': for #2 inferred =!(rhsValue!= null && rhsValue.isFunction() && (info!= null ||!scope.isDeclared(qName, false)));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-48/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 06:11:08.545573119 +0200\n+++ /tmp/tmpgy2asc0r.java\t2022-07-19 06:11:08.545573119 +0200\n@@ -1516,15 +1516,11 @@\n             || (info.isConstant() && valueType != null\n                 && !valueType.isUnknownType())\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+if (inferred) { case 'A': for #2 inferred =!(rhsValue!= null && rhsValue.isFunction() && (info!= null ||!scope.isDeclared(qName, false)));\n       }\n \n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (inferred) { case 'F': for #2 inferred =!(rhsValue!= null && rhsValue.isFunction() && (info!= null ||!scope.isDeclared(qName, false)));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-48/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 06:11:11.993553624 +0200\n+++ /tmp/tmpx83ghfu9.java\t2022-07-19 06:11:11.993553624 +0200\n@@ -1516,15 +1516,11 @@\n             || (info.isConstant() && valueType != null\n                 && !valueType.isUnknownType())\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+if (inferred) { case 'F': for #2 inferred =!(rhsValue!= null && rhsValue.isFunction() && (info!= null ||!scope.isDeclared(qName, false)));\n       }\n \n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (inferred) { case 'I': for #2 inferred =!(rhsValue!= null && rhsValue.isFunction() && (info == null ||!scope.isDeclared(qName, false)));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-48/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 06:11:15.549533518 +0200\n+++ /tmp/tmpdskiox_c.java\t2022-07-19 06:11:15.553533495 +0200\n@@ -1516,15 +1516,11 @@\n             || (info.isConstant() && valueType != null\n                 && !valueType.isUnknownType())\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+if (inferred) { case 'I': for #2 inferred =!(rhsValue!= null && rhsValue.isFunction() && (info == null ||!scope.isDeclared(qName, false)));\n       }\n \n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (inferred) { case 'I': for #2 inferred =!(rhsValue.isFunction() && (info!= null ||!scope.isDeclared(qName, false)));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-48/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 06:11:19.193512914 +0200\n+++ /tmp/tmpwteqis9a.java\t2022-07-19 06:11:19.193512914 +0200\n@@ -1516,15 +1516,11 @@\n             || (info.isConstant() && valueType != null\n                 && !valueType.isUnknownType())\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+if (inferred) { case 'I': for #2 inferred =!(rhsValue.isFunction() && (info!= null ||!scope.isDeclared(qName, false)));\n       }\n \n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (inferred) { case 'I': for #2 inferred =!(rhsValue.isFunction() && (info!= null &&!scope.isDeclared(qName, false)));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-48/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 06:11:22.909491905 +0200\n+++ /tmp/tmpncv7z07e.java\t2022-07-19 06:11:22.913491882 +0200\n@@ -1516,15 +1516,11 @@\n             || (info.isConstant() && valueType != null\n                 && !valueType.isUnknownType())\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+if (inferred) { case 'I': for #2 inferred =!(rhsValue.isFunction() && (info!= null &&!scope.isDeclared(qName, false)));\n       }\n \n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (inferred) { case 'I': for #2 inferred =!(rhsValue!= null && rhsValue.isFunction() &&!scope.isDeclared(qName, false)));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-48/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 06:11:26.653470737 +0200\n+++ /tmp/tmpgvtzbfsp.java\t2022-07-19 06:11:26.653470737 +0200\n@@ -1516,15 +1516,11 @@\n             || (info.isConstant() && valueType != null\n                 && !valueType.isUnknownType())\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+if (inferred) { case 'I': for #2 inferred =!(rhsValue!= null && rhsValue.isFunction() &&!scope.isDeclared(qName, false)));\n       }\n \n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (inferred) { case 'I': for #2 inferred =!(rhsValue!= null && rhsValue.isFunction() && (info!= null ||!scope.isDeclared(qName, false));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-48/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-19 06:11:30.205450656 +0200\n+++ /tmp/tmpwu515d56.java\t2022-07-19 06:11:30.209450633 +0200\n@@ -1516,15 +1516,11 @@\n             || (info.isConstant() && valueType != null\n                 && !valueType.isUnknownType())\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+if (inferred) { case 'I': for #2 inferred =!(rhsValue!= null && rhsValue.isFunction() && (info!= null ||!scope.isDeclared(qName, false));\n       }\n \n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (inferred) { // Determining declaration for #2 inferred = !(rhsValue != null && rhsValue.isFunction() && (info != null || !scope.isDeclared(qName, false)));",
        "fixed_line": "if (inferred && rhsValue != null && rhsValue.isFunction()) { // Determining declaration for #2 if (info != null) { inferred = false; } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) { inferred = false; }"
    },
    "JacksonDatabind-62": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int i = 0; i < property-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'getDelegateType()'\"); }",
                "patch_diff": "for (int i = 0; i < property-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'getDelegateType()'\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = 0; i < property-creator definition for \"+_collectionType +\": value instantiator.getClass().getName() +\": value instantiator.getDelegateType()'\"); }",
                "patch_diff": "for (int i = 0; i < property-creator definition for \"+_collectionType +\": value instantiator.getClass().getName() +\": value instantiator.getDelegateType()'\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0; i < property-creator definition for \"+_collectionType +\": value instantiator.getClass().getName() +\") returned true for 'getDelegateType()'\"); }",
                "patch_diff": "for (int i = 0; i < property-creator definition for \"+_collectionType +\": value instantiator.getClass().getName() +\") returned true for 'getDelegateType()'\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = 0; i < property-creator definition for \"+_collectionType +\": value instantiator.getClass().getName() +\") returned true;",
                "patch_diff": "for (int i = 0; i < property-creator definition for \"+_collectionType +\": value instantiator.getClass().getName() +\") returned true;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = 0; i < property-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true;",
                "patch_diff": "for (int i = 0; i < property-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = 0; i < property-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'getDelegateType()'\"); break;",
                "patch_diff": "for (int i = 0; i < property-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'getDelegateType()'\"); break;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = 0; i < property-creator definition for \"+_collectionType +\": value instantiator.getClass().getName() +\")",
                "patch_diff": "for (int i = 0; i < property-creator definition for \"+_collectionType +\": value instantiator.getClass().getName() +\")",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = 0; i < property-creator definition for \"+_collectionType +\": value instantiator.getClass().getName() +\": value instantiator.class;",
                "patch_diff": "for (int i = 0; i < property-creator definition for \"+_collectionType +\": value instantiator.getClass().getName() +\": value instantiator.class;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int i = 0; i < property-creator definition for \"+_collectionType +\": value instantiator.getClass().getName() +\") returned true for 'getDelegateType()'\"); break;",
                "patch_diff": "for (int i = 0; i < property-creator definition for \"+_collectionType +\": value instantiator.getClass().getName() +\") returned true for 'getDelegateType()'\"); break;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = 0; i < property-creator definition for \"+_collectionType +\": value instantiator.getClass().getName() +\") {",
                "patch_diff": "for (int i = 0; i < property-creator definition for \"+_collectionType +\": value instantiator.getClass().getName() +\") {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "} else if (_valueInstantiator.canCreateUsingArrayDelegate()) { JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig()); if (delegateType == null) { throw new IllegalArgumentException(\"Invalid array-delegate-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'canCreateUsingArrayDelegate()', but null for 'getArrayDelegateType()'\"); } delegateDeser = findDeserializer(ctxt, delegateType, property);"
    },
    "Closure-35": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (constraintObj!= null && objType.isRecordType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-35/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 06:11:35.525420582 +0200\n+++ /tmp/tmpidvq9joi.java\t2022-07-19 06:11:35.629419999 +0200\n@@ -1116,25 +1116,11 @@\n       return;\n     }\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+if (constraintObj!= null && objType.isRecordType()) {\n     }\n   }\n \n   /**\n    * If we access a property of a symbol, then that symbol is not\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (propType!= null && objType.isRecordType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-35/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 06:11:39.841396184 +0200\n+++ /tmp/tmp7f32_8fy.java\t2022-07-19 06:11:39.845396161 +0200\n@@ -1116,25 +1116,11 @@\n       return;\n     }\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+if (propType!= null && objType.isRecordType()) {\n     }\n   }\n \n   /**\n    * If we access a property of a symbol, then that symbol is not\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (constraintObj!= null && propType.isRecordType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-35/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 06:11:43.749374096 +0200\n+++ /tmp/tmpl6l89a1l.java\t2022-07-19 06:11:43.749374096 +0200\n@@ -1116,25 +1116,11 @@\n       return;\n     }\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+if (constraintObj!= null && propType.isRecordType()) {\n     }\n   }\n \n   /**\n    * If we access a property of a symbol, then that symbol is not\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (e.isPropertyType == null && objType.isRecordType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-35/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 06:11:47.621352210 +0200\n+++ /tmp/tmpe4rxis_3.java\t2022-07-19 06:11:47.621352210 +0200\n@@ -1116,25 +1116,11 @@\n       return;\n     }\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+if (e.isPropertyType == null && objType.isRecordType()) {\n     }\n   }\n \n   /**\n    * If we access a property of a symbol, then that symbol is not\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (e.isPropertyType!= null && objType.isRecordType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-35/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 06:11:51.729328991 +0200\n+++ /tmp/tmpa69tytdq.java\t2022-07-19 06:11:51.729328991 +0200\n@@ -1116,25 +1116,11 @@\n       return;\n     }\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+if (e.isPropertyType!= null && objType.isRecordType()) {\n     }\n   }\n \n   /**\n    * If we access a property of a symbol, then that symbol is not\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (constraintObj!= null && propType!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-35/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 06:11:55.737306339 +0200\n+++ /tmp/tmph9xmm8uo.java\t2022-07-19 06:11:55.741306316 +0200\n@@ -1116,25 +1116,11 @@\n       return;\n     }\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+if (constraintObj!= null && propType!= null) {\n     }\n   }\n \n   /**\n    * If we access a property of a symbol, then that symbol is not\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (eObj!= null && objType.isRecordType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-35/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 06:11:59.717283844 +0200\n+++ /tmp/tmpk9k213m4.java\t2022-07-19 06:11:59.717283844 +0200\n@@ -1116,25 +1116,11 @@\n       return;\n     }\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+if (eObj!= null && objType.isRecordType()) {\n     }\n   }\n \n   /**\n    * If we access a property of a symbol, then that symbol is not\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (eObj!= null && propType.isRecordType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-35/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 06:12:03.549262187 +0200\n+++ /tmp/tmpmtxcitto.java\t2022-07-19 06:12:03.549262187 +0200\n@@ -1116,25 +1116,11 @@\n       return;\n     }\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+if (eObj!= null && propType.isRecordType()) {\n     }\n   }\n \n   /**\n    * If we access a property of a symbol, then that symbol is not\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (useType!= null && objType.isRecordType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-35/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 06:12:07.433240240 +0200\n+++ /tmp/tmp643jh3x3.java\t2022-07-19 06:12:07.433240240 +0200\n@@ -1116,25 +1116,11 @@\n       return;\n     }\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+if (useType!= null && objType.isRecordType()) {\n     }\n   }\n \n   /**\n    * If we access a property of a symbol, then that symbol is not\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (e.isPropertyType!= null && propType.isRecordType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-35/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 06:12:11.669216302 +0200\n+++ /tmp/tmplbcw5q_7.java\t2022-07-19 06:12:11.673216279 +0200\n@@ -1116,25 +1116,11 @@\n       return;\n     }\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+if (e.isPropertyType!= null && propType.isRecordType()) {\n     }\n   }\n \n   /**\n    * If we access a property of a symbol, then that symbol is not\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (constraintObj != null && constraintObj.isRecordType()) { ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); if (objType != null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType); } objType.defineInferredProperty(prop, typeToInfer, null); } } }",
        "fixed_line": "if (constraintObj != null) { type.matchConstraint(constraintObj);"
    },
    "Mockito-1": {
        "fixes": [
            {
                "k": 1,
                "patch": "throw new UnsupportedOperationException(\"Vararg\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-1/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 06:12:15.681193631 +0200\n+++ /tmp/tmp3gnxhfgq.java\t2022-07-19 06:12:15.769193134 +0200\n@@ -118,11 +118,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+throw new UnsupportedOperationException(\"Vararg\");\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n                 Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "throw new UnsupportedOperationException(\"Vararg\"); // we didn't really modify it's totalGJACKSON-notnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-1/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 06:13:45.284687527 +0200\n+++ /tmp/tmpri4joz_m.java\t2022-07-19 06:13:45.300687437 +0200\n@@ -118,11 +118,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+throw new UnsupportedOperationException(\"Vararg\"); // we didn't really modify it's totalGJACKSON-notnotnot real number\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n                 Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "throw new UnsupportedOperationException(\"Vararg\"); // we didn't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-1/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 06:15:13.164191525 +0200\n+++ /tmp/tmpq30usdd_.java\t2022-07-19 06:15:13.164191525 +0200\n@@ -118,11 +118,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+throw new UnsupportedOperationException(\"Vararg\"); // we didn't really modify it's totalGJACKSON-notnotnotnot real number\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n                 Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new UnsupportedOperationException(\"Vararg\"); // we didn't really modify it's totalGJACKSON-notnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-1/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 06:16:39.259705889 +0200\n+++ /tmp/tmplq8wadf5.java\t2022-07-19 06:16:39.259705889 +0200\n@@ -118,11 +118,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+throw new UnsupportedOperationException(\"Vararg\"); // we didn't really modify it's totalGJACKSON-notnot real number\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n                 Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "throw new UnsupportedOperationException(\"Vararg\"); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-1/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 06:18:03.955228390 +0200\n+++ /tmp/tmpg19aryrd.java\t2022-07-19 06:18:03.955228390 +0200\n@@ -118,11 +118,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+throw new UnsupportedOperationException(\"Vararg\"); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n                 Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "throw new UnsupportedOperationException(\"Vararg\"); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-1/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 06:19:29.034748930 +0200\n+++ /tmp/tmpfmhu_176.java\t2022-07-19 06:19:29.034748930 +0200\n@@ -118,11 +118,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+throw new UnsupportedOperationException(\"Vararg\"); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n                 Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "throw new UnsupportedOperationException(\"Vararg\"); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-1/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 06:20:54.230268990 +0200\n+++ /tmp/tmpcc73x2ar.java\t2022-07-19 06:20:54.234268966 +0200\n@@ -118,11 +118,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+throw new UnsupportedOperationException(\"Vararg\"); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n                 Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "throw new UnsupportedOperationException(\"Vararg\"); // we didn't really modify it's totalGJACKSON-407] -- allow disabling wrapping for (int i = 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-1/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 06:22:18.769792891 +0200\n+++ /tmp/tmpyu_tkdw4.java\t2022-07-19 06:22:18.769792891 +0200\n@@ -118,11 +118,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+throw new UnsupportedOperationException(\"Vararg\"); // we didn't really modify it's totalGJACKSON-407] -- allow disabling wrapping for (int i = 0;\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n                 Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "throw new UnsupportedOperationException(\"Vararg\"); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-1/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 06:23:43.729314551 +0200\n+++ /tmp/tmpjc_kn2kw.java\t2022-07-19 06:23:43.733314528 +0200\n@@ -118,11 +118,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+throw new UnsupportedOperationException(\"Vararg\"); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n                 Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "throw new UnsupportedOperationException(\"Vararg\"); // we didn't really modify it's totalGJACKSON-not real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-1/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 06:25:08.320838386 +0200\n+++ /tmp/tmp23angchw.java\t2022-07-19 06:25:08.320838386 +0200\n@@ -118,11 +118,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+throw new UnsupportedOperationException(\"Vararg\"); // we didn't really modify it's totalGJACKSON-not real number\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n                 Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "throw new UnsupportedOperationException();",
        "fixed_line": "for (int position = 0; position < indexOfVararg; position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class)); } } for (int position = indexOfVararg; position < matchers.size(); position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]); } }"
    },
    "Closure-2": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (inExterns.getImplicitPrototype()!= null) {",
                "patch_diff": "if (inExterns.getImplicitPrototype()!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (inExterns.getImplicitPrototype()) {",
                "patch_diff": "if (inExterns.getImplicitPrototype()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (inExterns.getImplicitPrototype();",
                "patch_diff": "if (inExterns.getImplicitPrototype();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (ownerType.getPropertyType(name, but shouldn't crash).",
                "patch_diff": "if (ownerType.getPropertyType(name, but shouldn't crash).",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (ownerType.getPropertyType(name, but shouldn't crash).getImplicitPrototype();",
                "patch_diff": "if (ownerType.getPropertyType(name, but shouldn't crash).getImplicitPrototype();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (ownerType.getPropertyType(name, but shouldn't crash).isAssignable()) {",
                "patch_diff": "if (ownerType.getPropertyType(name, but shouldn't crash).isAssignable()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (name.getImplicitPrototype()!= null) {",
                "patch_diff": "if (name.getImplicitPrototype()!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (oType.getPropertyType(name, but shouldn't crash).getImplicitPrototype();",
                "patch_diff": "if (oType.getPropertyType(name, but shouldn't crash).getImplicitPrototype();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (ownerType.getImplicitPrototype();",
                "patch_diff": "if (ownerType.getImplicitPrototype();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (oType.getImplicitPrototype();",
                "patch_diff": "if (oType.getImplicitPrototype();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (implicitProto == null) { // This can be the case if interfaceType is proxy to a non-existent // object (which is a bad type annotation, but shouldn't crash). currentPropertyNames = ImmutableSet.of(); } else { currentPropertyNames = implicitProto.getOwnPropertyNames(); }"
    },
    "Csv-6": {
        "fixes": [
            {
                "k": 1,
                "patch": "final int col = entry.getValue().intValue();",
                "patch_diff": "final int col = entry.getValue().intValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "final int col = entry.getValue().intValue(); map.getValue().intValue();",
                "patch_diff": "final int col = entry.getValue().intValue(); map.getValue().intValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "final int col = entry.getValue().intValue(); map.next; }",
                "patch_diff": "final int col = entry.getValue().intValue(); map.next; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "final int col = entry.entrySet()) { final int col = entry.getValue().intValue(); } return map; }",
                "patch_diff": "final int col = entry.entrySet()) { final int col = entry.getValue().intValue(); } return map; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "final int col = entry.next().intValue();",
                "patch_diff": "final int col = entry.next().intValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "final int col = entry.getValue().intValue(); map.next().intValue();",
                "patch_diff": "final int col = entry.getValue().intValue(); map.next().intValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "final int col = entry.entrySet()) { final int col = entry.getValue().intValue(); }",
                "patch_diff": "final int col = entry.entrySet()) { final int col = entry.getValue().intValue(); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "final int col = entry.entrySet()) { final int col = entry.getValue().intValue();",
                "patch_diff": "final int col = entry.entrySet()) { final int col = entry.getValue().intValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "final int col = entry.getValue().intValue(); map.getValue().intValue(); }",
                "patch_diff": "final int col = entry.getValue().intValue(); map.getValue().intValue(); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "final int col = entry.entrySet()) { final int col = entry.getValue().intValue(); } return map;",
                "patch_diff": "final int col = entry.entrySet()) { final int col = entry.getValue().intValue(); } return map;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (col < values.length) { map.put(entry.getKey(), values[col]); }"
    },
    "Jsoup-41": {
        "fixes": [
            {
                "k": 1,
                "patch": "return this == o;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-41/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 06:26:38.672329892 +0200\n+++ /tmp/tmpaw0pfhv7.java\t2022-07-19 06:26:38.740329512 +0200\n@@ -1170,11 +1170,11 @@\n         if (o == null || getClass() != o.getClass()) return false;\n         if (!super.equals(o)) return false;\n \n         Element element = (Element) o;\n \n-        return this == o;\n+return this == o;\n     }\n \n     @Override\n     public int hashCode() {\n         int result = super.hashCode();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return this!= o;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-41/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 06:26:42.472308510 +0200\n+++ /tmp/tmpz16oy7cz.java\t2022-07-19 06:26:42.472308510 +0200\n@@ -1170,11 +1170,11 @@\n         if (o == null || getClass() != o.getClass()) return false;\n         if (!super.equals(o)) return false;\n \n         Element element = (Element) o;\n \n-        return this == o;\n+return this!= o;\n     }\n \n     @Override\n     public int hashCode() {\n         int result = super.hashCode();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 3,
                "patch": "return this == o; // let's do implicit re-literal characters that might be valid (e if (this == o;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-41/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 06:26:45.924289083 +0200\n+++ /tmp/tmpaxjg7m54.java\t2022-07-19 06:26:45.924289083 +0200\n@@ -1170,11 +1170,11 @@\n         if (o == null || getClass() != o.getClass()) return false;\n         if (!super.equals(o)) return false;\n \n         Element element = (Element) o;\n \n-        return this == o;\n+return this == o; // let's do implicit re-literal characters that might be valid (e if (this == o;\n     }\n \n     @Override\n     public int hashCode() {\n         int result = super.hashCode();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return this == o; // block only override if it's do implicit re-literal characters that might be valid (e if (this == o;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-41/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 06:26:49.396269547 +0200\n+++ /tmp/tmp4f63jpkp.java\t2022-07-19 06:26:49.396269547 +0200\n@@ -1170,11 +1170,11 @@\n         if (o == null || getClass() != o.getClass()) return false;\n         if (!super.equals(o)) return false;\n \n         Element element = (Element) o;\n \n-        return this == o;\n+return this == o; // block only override if it's do implicit re-literal characters that might be valid (e if (this == o;\n     }\n \n     @Override\n     public int hashCode() {\n         int result = super.hashCode();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return this == o; // block only override if it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-41/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 06:26:52.976249402 +0200\n+++ /tmp/tmpbrb8wg61.java\t2022-07-19 06:26:52.976249402 +0200\n@@ -1170,11 +1170,11 @@\n         if (o == null || getClass() != o.getClass()) return false;\n         if (!super.equals(o)) return false;\n \n         Element element = (Element) o;\n \n-        return this == o;\n+return this == o; // block only override if it's do implicit re-parse\n     }\n \n     @Override\n     public int hashCode() {\n         int result = super.hashCode();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return this == o; // let's do implicit re-literal characters that might be valid (e if (o == null) { return this == o;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-41/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 06:26:56.412230064 +0200\n+++ /tmp/tmp52gt78qm.java\t2022-07-19 06:26:56.412230064 +0200\n@@ -1170,11 +1170,11 @@\n         if (o == null || getClass() != o.getClass()) return false;\n         if (!super.equals(o)) return false;\n \n         Element element = (Element) o;\n \n-        return this == o;\n+return this == o; // let's do implicit re-literal characters that might be valid (e if (o == null) { return this == o;\n     }\n \n     @Override\n     public int hashCode() {\n         int result = super.hashCode();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return this == o; // let's do implicit re-literal characters that might be valid (e if (o == this) o;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-41/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 06:26:59.716211473 +0200\n+++ /tmp/tmp1txpcnd_.java\t2022-07-19 06:26:59.716211473 +0200\n@@ -1170,11 +1170,11 @@\n         if (o == null || getClass() != o.getClass()) return false;\n         if (!super.equals(o)) return false;\n \n         Element element = (Element) o;\n \n-        return this == o;\n+return this == o; // let's do implicit re-literal characters that might be valid (e if (o == this) o;\n     }\n \n     @Override\n     public int hashCode() {\n         int result = super.hashCode();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return this == o; // let's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-41/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 06:27:03.016192902 +0200\n+++ /tmp/tmpmhmg5j87.java\t2022-07-19 06:27:03.016192902 +0200\n@@ -1170,11 +1170,11 @@\n         if (o == null || getClass() != o.getClass()) return false;\n         if (!super.equals(o)) return false;\n \n         Element element = (Element) o;\n \n-        return this == o;\n+return this == o; // let's do implicit re-parse\n     }\n \n     @Override\n     public int hashCode() {\n         int result = super.hashCode();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return this == o; // let's do implicit re-literal characters that might be valid (e if (o == null) { return this!= o;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-41/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 06:27:06.180175098 +0200\n+++ /tmp/tmpd75o7fz2.java\t2022-07-19 06:27:06.180175098 +0200\n@@ -1170,11 +1170,11 @@\n         if (o == null || getClass() != o.getClass()) return false;\n         if (!super.equals(o)) return false;\n \n         Element element = (Element) o;\n \n-        return this == o;\n+return this == o; // let's do implicit re-literal characters that might be valid (e if (o == null) { return this!= o;\n     }\n \n     @Override\n     public int hashCode() {\n         int result = super.hashCode();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return this == o; // block only override if it's do implicit re-literal characters that might be valid (e if (o == this) o;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-41/src/main/java/org/jsoup/nodes/Element.java\t2022-07-19 06:27:09.636155651 +0200\n+++ /tmp/tmpwxax6jcx.java\t2022-07-19 06:27:09.636155651 +0200\n@@ -1170,11 +1170,11 @@\n         if (o == null || getClass() != o.getClass()) return false;\n         if (!super.equals(o)) return false;\n \n         Element element = (Element) o;\n \n-        return this == o;\n+return this == o; // block only override if it's do implicit re-literal characters that might be valid (e if (o == this) o;\n     }\n \n     @Override\n     public int hashCode() {\n         int result = super.hashCode();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return this == o;",
        "fixed_line": "return tag.equals(element.tag);"
    },
    "Cli-37": {
        "fixes": [
            {
                "k": 1,
                "patch": "return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-37/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-19 06:27:13.196135620 +0200\n+++ /tmp/tmpqw_29bs3.java\t2022-07-19 06:27:13.324134901 +0200\n@@ -297,11 +297,11 @@\n      * @param token\n      */\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n+return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n \n         // remove leading \"-\" and \"=value\"\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return token.startsWith(\"-\") && token.length() > 2 && options.hasShortOption(token.substring(1, 2));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-37/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-19 06:27:16.136119075 +0200\n+++ /tmp/tmpw6h612vc.java\t2022-07-19 06:27:16.136119075 +0200\n@@ -297,11 +297,11 @@\n      * @param token\n      */\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n+return token.startsWith(\"-\") && token.length() > 2 && options.hasShortOption(token.substring(1, 2));\n \n         // remove leading \"-\" and \"=value\"\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return token.startsWith(\"-\") || token.length() >= 2 && options.hasShortOption(token.substring(1, 2));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-37/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-19 06:27:18.764104289 +0200\n+++ /tmp/tmpudp7q_go.java\t2022-07-19 06:27:18.768104266 +0200\n@@ -297,11 +297,11 @@\n      * @param token\n      */\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n+return token.startsWith(\"-\") || token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n \n         // remove leading \"-\" and \"=value\"\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return token.startsWith(\"-\") || token.length() > 2 && options.hasShortOption(token.substring(1, 2));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-37/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-19 06:27:21.336089817 +0200\n+++ /tmp/tmpi4hgm6om.java\t2022-07-19 06:27:21.336089817 +0200\n@@ -297,11 +297,11 @@\n      * @param token\n      */\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n+return token.startsWith(\"-\") || token.length() > 2 && options.hasShortOption(token.substring(1, 2));\n \n         // remove leading \"-\" and \"=value\"\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return token.startsWith(\"-\") || token.length() == 2 && options.hasShortOption(token.substring(1, 2));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-37/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-19 06:27:23.912075322 +0200\n+++ /tmp/tmpvbsl_6mh.java\t2022-07-19 06:27:23.912075322 +0200\n@@ -297,11 +297,11 @@\n      * @param token\n      */\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n+return token.startsWith(\"-\") || token.length() == 2 && options.hasShortOption(token.substring(1, 2));\n \n         // remove leading \"-\" and \"=value\"\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return token.startsWith(\"-\") && token.length()!= 2 && options.hasShortOption(token.substring(1, 2));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-37/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-19 06:27:26.580060309 +0200\n+++ /tmp/tmp4zu4o_qo.java\t2022-07-19 06:27:26.580060309 +0200\n@@ -297,11 +297,11 @@\n      * @param token\n      */\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n+return token.startsWith(\"-\") && token.length()!= 2 && options.hasShortOption(token.substring(1, 2));\n \n         // remove leading \"-\" and \"=value\"\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return token.startsWith(\"-\") && token.length() == 2 && options.hasShortOption(token.substring(1, 2));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-37/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-19 06:27:29.188045633 +0200\n+++ /tmp/tmpj1y2c9ja.java\t2022-07-19 06:27:29.188045633 +0200\n@@ -297,11 +297,11 @@\n      * @param token\n      */\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n+return token.startsWith(\"-\") && token.length() == 2 && options.hasShortOption(token.substring(1, 2));\n \n         // remove leading \"-\" and \"=value\"\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return token.startsWith(\"-\") || token.length()!= 2 && options.hasShortOption(token.substring(1, 2));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-37/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-19 06:27:31.952030079 +0200\n+++ /tmp/tmpz14kj02u.java\t2022-07-19 06:27:31.952030079 +0200\n@@ -297,11 +297,11 @@\n      * @param token\n      */\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n+return token.startsWith(\"-\") || token.length()!= 2 && options.hasShortOption(token.substring(1, 2));\n \n         // remove leading \"-\" and \"=value\"\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, token.substring(1, 2));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-37/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-19 06:27:34.724014483 +0200\n+++ /tmp/tmpk_ok9by6.java\t2022-07-19 06:27:34.724014483 +0200\n@@ -297,11 +297,11 @@\n      * @param token\n      */\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n+return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, token.substring(1, 2));\n \n         // remove leading \"-\" and \"=value\"\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return token.startsWith(\"-\") || token.length() < 2 && options.hasShortOption(token.substring(1, 2));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-37/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-19 06:27:36.388005121 +0200\n+++ /tmp/tmp7dianpq7.java\t2022-07-19 06:27:36.392005098 +0200\n@@ -297,11 +297,11 @@\n      * @param token\n      */\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n+return token.startsWith(\"-\") || token.length() < 2 && options.hasShortOption(token.substring(1, 2));\n \n         // remove leading \"-\" and \"=value\"\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));",
        "fixed_line": "if (!token.startsWith(\"-\") || token.length() == 1) { return false; } // remove leading \"-\" and \"=value\" int pos = token.indexOf(\"=\"); String optName = pos == -1 ? token.substring(1) : token.substring(1, pos); return options.hasShortOption(optName);"
    },
    "Math-9": {
        "fixes": [
            {
                "k": 1,
                "patch": "final Line reverted = new Line(this, zero.subtract(direction));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-9/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\t2022-07-19 06:27:39.175989432 +0200\n+++ /tmp/tmp6h0s41u3.java\t2022-07-19 06:27:39.219989188 +0200\n@@ -82,11 +82,11 @@\n \n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n+final Line reverted = new Line(this, zero.subtract(direction));\n         return reverted;\n     }\n \n     /** Get the normalized direction vector.\n      * @return normalized direction vector\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "final Line reverted = new Line(zero, zero.subtract(direction));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-9/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\t2022-07-19 06:27:41.503976333 +0200\n+++ /tmp/tmpdopyufgg.java\t2022-07-19 06:27:41.503976333 +0200\n@@ -82,11 +82,11 @@\n \n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n+final Line reverted = new Line(zero, zero.subtract(direction));\n         return reverted;\n     }\n \n     /** Get the normalized direction vector.\n      * @return normalized direction vector\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "final Line reverted = new Line(this, zero);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-9/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\t2022-07-19 06:28:36.427658214 +0200\n+++ /tmp/tmpeaonxm0x.java\t2022-07-19 06:28:36.431658192 +0200\n@@ -82,11 +82,11 @@\n \n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n+final Line reverted = new Line(this, zero);\n         return reverted;\n     }\n \n     /** Get the normalized direction vector.\n      * @return normalized direction vector\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "final Line reverted = new Line(this, zero, zero.subtract(direction));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-9/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\t2022-07-19 06:28:38.683644704 +0200\n+++ /tmp/tmpmee2_zeu.java\t2022-07-19 06:28:38.683644704 +0200\n@@ -82,11 +82,11 @@\n \n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n+final Line reverted = new Line(this, zero, zero.subtract(direction));\n         return reverted;\n     }\n \n     /** Get the normalized direction vector.\n      * @return normalized direction vector\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "final Line reverted = new Line(this.unit, zero.subtract(direction));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-9/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\t2022-07-19 06:28:40.963631050 +0200\n+++ /tmp/tmpsu8esyfx.java\t2022-07-19 06:28:40.963631050 +0200\n@@ -82,11 +82,11 @@\n \n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n+final Line reverted = new Line(this.unit, zero.subtract(direction));\n         return reverted;\n     }\n \n     /** Get the normalized direction vector.\n      * @return normalized direction vector\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "final Line reverted = new Line(i, zero.subtract(direction));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-9/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\t2022-07-19 06:28:43.159617903 +0200\n+++ /tmp/tmp_w23ravk.java\t2022-07-19 06:28:43.159617903 +0200\n@@ -82,11 +82,11 @@\n \n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n+final Line reverted = new Line(i, zero.subtract(direction));\n         return reverted;\n     }\n \n     /** Get the normalized direction vector.\n      * @return normalized direction vector\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "final Line reverted = new Line(types, zero.subtract(direction));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-9/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\t2022-07-19 06:28:45.367604690 +0200\n+++ /tmp/tmp99e1lq_n.java\t2022-07-19 06:28:45.371604666 +0200\n@@ -82,11 +82,11 @@\n \n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n+final Line reverted = new Line(types, zero.subtract(direction));\n         return reverted;\n     }\n \n     /** Get the normalized direction vector.\n      * @return normalized direction vector\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "final Line reverted = new Line(name, zero.subtract(direction));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-9/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\t2022-07-19 06:28:47.491591981 +0200\n+++ /tmp/tmp8xm3k98m.java\t2022-07-19 06:28:47.491591981 +0200\n@@ -82,11 +82,11 @@\n \n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n+final Line reverted = new Line(name, zero.subtract(direction));\n         return reverted;\n     }\n \n     /** Get the normalized direction vector.\n      * @return normalized direction vector\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "final Line reverted = new Line(newInstance, zero.subtract(direction));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-9/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\t2022-07-19 06:28:49.795578196 +0200\n+++ /tmp/tmps7pm_50p.java\t2022-07-19 06:28:49.795578196 +0200\n@@ -82,11 +82,11 @@\n \n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n+final Line reverted = new Line(newInstance, zero.subtract(direction));\n         return reverted;\n     }\n \n     /** Get the normalized direction vector.\n      * @return normalized direction vector\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "final Line reverted = new Line(this, zero, zero);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-9/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\t2022-07-19 06:28:52.027564846 +0200\n+++ /tmp/tmpars_n6gd.java\t2022-07-19 06:28:52.027564846 +0200\n@@ -82,11 +82,11 @@\n \n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n+final Line reverted = new Line(this, zero, zero);\n         return reverted;\n     }\n \n     /** Get the normalized direction vector.\n      * @return normalized direction vector\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "final Line reverted = new Line(zero, zero.subtract(direction));",
        "fixed_line": "final Line reverted = new Line(this); reverted.direction = reverted.direction.negate();"
    },
    "Gson-17": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (in.peek() == JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\t2022-07-19 06:28:54.463550282 +0200\n+++ /tmp/tmp2z05dd4c.java\t2022-07-19 06:28:54.487550136 +0200\n@@ -94,12 +94,11 @@\n     }\n   }\n \n   @Override\n   public Date read(JsonReader in) throws IOException {\n-    if (in.peek() != JsonToken.STRING) {\n-      throw new JsonParseException(\"The date should be a string value\");\n+if (in.peek() == JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\");\n     }\n     Date date = deserializeToDate(in.nextString());\n     if (dateType == Date.class) {\n       return date;\n     } else if (dateType == Timestamp.class) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (in.peek()!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\t2022-07-19 06:28:58.987523240 +0200\n+++ /tmp/tmpuylh6xdu.java\t2022-07-19 06:28:58.987523240 +0200\n@@ -94,12 +94,11 @@\n     }\n   }\n \n   @Override\n   public Date read(JsonReader in) throws IOException {\n-    if (in.peek() != JsonToken.STRING) {\n-      throw new JsonParseException(\"The date should be a string value\");\n+if (in.peek()!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\");\n     }\n     Date date = deserializeToDate(in.nextString());\n     if (dateType == Date.class) {\n       return date;\n     } else if (dateType == Timestamp.class) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if(in.peek() == JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\t2022-07-19 06:29:03.015499174 +0200\n+++ /tmp/tmpjjda8s95.java\t2022-07-19 06:29:03.019499150 +0200\n@@ -94,12 +94,11 @@\n     }\n   }\n \n   @Override\n   public Date read(JsonReader in) throws IOException {\n-    if (in.peek() != JsonToken.STRING) {\n-      throw new JsonParseException(\"The date should be a string value\");\n+if(in.peek() == JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\");\n     }\n     Date date = deserializeToDate(in.nextString());\n     if (dateType == Date.class) {\n       return date;\n     } else if (dateType == Timestamp.class) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (in.peek() == JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\t2022-07-19 06:29:07.119474664 +0200\n+++ /tmp/tmpw7ma9jm8.java\t2022-07-19 06:29:07.119474664 +0200\n@@ -94,12 +94,11 @@\n     }\n   }\n \n   @Override\n   public Date read(JsonReader in) throws IOException {\n-    if (in.peek() != JsonToken.STRING) {\n-      throw new JsonParseException(\"The date should be a string value\");\n+if (in.peek() == JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\"); }\n     }\n     Date date = deserializeToDate(in.nextString());\n     if (dateType == Date.class) {\n       return date;\n     } else if (dateType == Timestamp.class) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (in.peek() == JsonToken.STRING) { throw new JsonToken(\"The date should be a string value\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\t2022-07-19 06:29:08.759464872 +0200\n+++ /tmp/tmp0g8uw8d6.java\t2022-07-19 06:29:08.759464872 +0200\n@@ -94,12 +94,11 @@\n     }\n   }\n \n   @Override\n   public Date read(JsonReader in) throws IOException {\n-    if (in.peek() != JsonToken.STRING) {\n-      throw new JsonParseException(\"The date should be a string value\");\n+if (in.peek() == JsonToken.STRING) { throw new JsonToken(\"The date should be a string value\");\n     }\n     Date date = deserializeToDate(in.nextString());\n     if (dateType == Date.class) {\n       return date;\n     } else if (dateType == Timestamp.class) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (in.peek() == JsonToken.STRING) { throw new IllegalArgumentException(\"The date should be a string value\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\t2022-07-19 06:29:10.519454365 +0200\n+++ /tmp/tmp515wdg3s.java\t2022-07-19 06:29:10.519454365 +0200\n@@ -94,12 +94,11 @@\n     }\n   }\n \n   @Override\n   public Date read(JsonReader in) throws IOException {\n-    if (in.peek() != JsonToken.STRING) {\n-      throw new JsonParseException(\"The date should be a string value\");\n+if (in.peek() == JsonToken.STRING) { throw new IllegalArgumentException(\"The date should be a string value\");\n     }\n     Date date = deserializeToDate(in.nextString());\n     if (dateType == Date.class) {\n       return date;\n     } else if (dateType == Timestamp.class) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (in.peek()!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\t2022-07-19 06:29:14.471430780 +0200\n+++ /tmp/tmpmdp88_3m.java\t2022-07-19 06:29:14.471430780 +0200\n@@ -94,12 +94,11 @@\n     }\n   }\n \n   @Override\n   public Date read(JsonReader in) throws IOException {\n-    if (in.peek() != JsonToken.STRING) {\n-      throw new JsonParseException(\"The date should be a string value\");\n+if (in.peek()!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\"); }\n     }\n     Date date = deserializeToDate(in.nextString());\n     if (dateType == Date.class) {\n       return date;\n     } else if (dateType == Timestamp.class) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (in.peek()!= JsonToken.STRING) { throw new JsonToken(\"The date should be a string value\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\t2022-07-19 06:29:16.063421280 +0200\n+++ /tmp/tmpd8yzrhe9.java\t2022-07-19 06:29:16.067421258 +0200\n@@ -94,12 +94,11 @@\n     }\n   }\n \n   @Override\n   public Date read(JsonReader in) throws IOException {\n-    if (in.peek() != JsonToken.STRING) {\n-      throw new JsonParseException(\"The date should be a string value\");\n+if (in.peek()!= JsonToken.STRING) { throw new JsonToken(\"The date should be a string value\");\n     }\n     Date date = deserializeToDate(in.nextString());\n     if (dateType == Date.class) {\n       return date;\n     } else if (dateType == Timestamp.class) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (in.peek() instanceof JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\t2022-07-19 06:29:17.643411857 +0200\n+++ /tmp/tmpjdu93b66.java\t2022-07-19 06:29:17.647411831 +0200\n@@ -94,12 +94,11 @@\n     }\n   }\n \n   @Override\n   public Date read(JsonReader in) throws IOException {\n-    if (in.peek() != JsonToken.STRING) {\n-      throw new JsonParseException(\"The date should be a string value\");\n+if (in.peek() instanceof JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\");\n     }\n     Date date = deserializeToDate(in.nextString());\n     if (dateType == Date.class) {\n       return date;\n     } else if (dateType == Timestamp.class) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (in.peek() == JsonToken.STRING) { return new JsonParseException(\"The date should be a string value\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\t2022-07-19 06:29:19.395401407 +0200\n+++ /tmp/tmpspvl_5vi.java\t2022-07-19 06:29:19.395401407 +0200\n@@ -94,12 +94,11 @@\n     }\n   }\n \n   @Override\n   public Date read(JsonReader in) throws IOException {\n-    if (in.peek() != JsonToken.STRING) {\n-      throw new JsonParseException(\"The date should be a string value\");\n+if (in.peek() == JsonToken.STRING) { return new JsonParseException(\"The date should be a string value\");\n     }\n     Date date = deserializeToDate(in.nextString());\n     if (dateType == Date.class) {\n       return date;\n     } else if (dateType == Timestamp.class) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (in.peek() != JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\");",
        "fixed_line": "if (in.peek() == JsonToken.NULL) { in.nextNull(); return null;"
    },
    "JacksonDatabind-35": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (p.getCurrentToken()!= JsonToken.START_OBJECT) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-35/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\t2022-07-19 06:29:21.623388119 +0200\n+++ /tmp/tmpjy4w_u9d.java\t2022-07-19 06:29:21.783387168 +0200\n@@ -84,14 +84,11 @@\n             if (typeId != null) {\n                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n             }\n         }\n         // first, sanity checks\n-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n-        }\n+if (p.getCurrentToken()!= JsonToken.START_OBJECT) {\n             // should always get field name, but just in case...\n             if (p.nextToken() != JsonToken.FIELD_NAME) {\n                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (p.getCurrentToken()!= JsonToken.START_OBJECT) { throw ctxt.append(JsonToken.START_OBJECT, \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName()); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-35/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\t2022-07-19 06:29:23.555376601 +0200\n+++ /tmp/tmpo3uzv3nw.java\t2022-07-19 06:29:23.555376601 +0200\n@@ -84,14 +84,11 @@\n             if (typeId != null) {\n                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n             }\n         }\n         // first, sanity checks\n-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n-        }\n+if (p.getCurrentToken()!= JsonToken.START_OBJECT) { throw ctxt.append(JsonToken.START_OBJECT, \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName()); }\n             // should always get field name, but just in case...\n             if (p.nextToken() != JsonToken.FIELD_NAME) {\n                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (p.getCurrentToken()!= JsonToken.START_OBJECT) { throw ctxt.append(JsonToken.START_OBJECT, JsonToken.START_OBJECT, \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName()); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-35/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\t2022-07-19 06:29:25.435365396 +0200\n+++ /tmp/tmpflmgrazw.java\t2022-07-19 06:29:25.435365396 +0200\n@@ -84,14 +84,11 @@\n             if (typeId != null) {\n                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n             }\n         }\n         // first, sanity checks\n-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n-        }\n+if (p.getCurrentToken()!= JsonToken.START_OBJECT) { throw ctxt.append(JsonToken.START_OBJECT, JsonToken.START_OBJECT, \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName()); }\n             // should always get field name, but just in case...\n             if (p.nextToken() != JsonToken.FIELD_NAME) {\n                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (p.getCurrentToken()!= JsonToken.START_OBJECT) { throw ctxt.nextToken()!= JsonToken.START_OBJECT, \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName()); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-35/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\t2022-07-19 06:29:27.391353737 +0200\n+++ /tmp/tmp1m_ecsr3.java\t2022-07-19 06:29:27.391353737 +0200\n@@ -84,14 +84,11 @@\n             if (typeId != null) {\n                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n             }\n         }\n         // first, sanity checks\n-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n-        }\n+if (p.getCurrentToken()!= JsonToken.START_OBJECT) { throw ctxt.nextToken()!= JsonToken.START_OBJECT, \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName()); }\n             // should always get field name, but just in case...\n             if (p.nextToken() != JsonToken.FIELD_NAME) {\n                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (p.getCurrentToken()!= JsonToken.START_OBJECT) { throw ctxt.nextToken()!= JsonToken.START_OBJECT, JsonToken.START_OBJECT, \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName()); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-35/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\t2022-07-19 06:29:29.127343395 +0200\n+++ /tmp/tmpcn0rt36k.java\t2022-07-19 06:29:29.131343369 +0200\n@@ -84,14 +84,11 @@\n             if (typeId != null) {\n                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n             }\n         }\n         // first, sanity checks\n-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n-        }\n+if (p.getCurrentToken()!= JsonToken.START_OBJECT) { throw ctxt.nextToken()!= JsonToken.START_OBJECT, JsonToken.START_OBJECT, \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName()); }\n             // should always get field name, but just in case...\n             if (p.nextToken() != JsonToken.FIELD_NAME) {\n                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (p.getCurrentToken() == JsonToken.START_OBJECT) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-35/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\t2022-07-19 06:29:30.947332552 +0200\n+++ /tmp/tmpk1jpxg7s.java\t2022-07-19 06:29:30.947332552 +0200\n@@ -84,14 +84,11 @@\n             if (typeId != null) {\n                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n             }\n         }\n         // first, sanity checks\n-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n-        }\n+if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n             // should always get field name, but just in case...\n             if (p.nextToken() != JsonToken.FIELD_NAME) {\n                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (p.getCurrentToken()!= JsonToken.START_OBJECT) { throw ctxt.append(JsonToken.START_OBJECT,, JsonToken.START_OBJECT, \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName()); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-35/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\t2022-07-19 06:29:32.575322854 +0200\n+++ /tmp/tmpblckqgfs.java\t2022-07-19 06:29:32.575322854 +0200\n@@ -84,14 +84,11 @@\n             if (typeId != null) {\n                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n             }\n         }\n         // first, sanity checks\n-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n-        }\n+if (p.getCurrentToken()!= JsonToken.START_OBJECT) { throw ctxt.append(JsonToken.START_OBJECT,, JsonToken.START_OBJECT, \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName()); }\n             // should always get field name, but just in case...\n             if (p.nextToken() != JsonToken.FIELD_NAME) {\n                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (p.getCurrentToken()!= JsonToken.START_OBJECT) { throw ctxt.append(JsonToken.START_OBJECT, \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-35/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\t2022-07-19 06:29:34.387312061 +0200\n+++ /tmp/tmpj51j3kla.java\t2022-07-19 06:29:34.387312061 +0200\n@@ -84,14 +84,11 @@\n             if (typeId != null) {\n                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n             }\n         }\n         // first, sanity checks\n-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n-        }\n+if (p.getCurrentToken()!= JsonToken.START_OBJECT) { throw ctxt.append(JsonToken.START_OBJECT, \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n             // should always get field name, but just in case...\n             if (p.nextToken() != JsonToken.FIELD_NAME) {\n                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (p.getCurrentToken()!= JsonToken.START_OBJECT) { throw ctxt.append(JsonToken.START_OBJECT, JsonToken.START_OBJECT, \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-35/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\t2022-07-19 06:29:36.159301509 +0200\n+++ /tmp/tmpmrf505v4.java\t2022-07-19 06:29:36.159301509 +0200\n@@ -84,14 +84,11 @@\n             if (typeId != null) {\n                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n             }\n         }\n         // first, sanity checks\n-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n-        }\n+if (p.getCurrentToken()!= JsonToken.START_OBJECT) { throw ctxt.append(JsonToken.START_OBJECT, JsonToken.START_OBJECT, \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n             // should always get field name, but just in case...\n             if (p.nextToken() != JsonToken.FIELD_NAME) {\n                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (p.getCurrentToken()!= JsonToken.START_OBJECT) { throw ctxt; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-35/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\t2022-07-19 06:29:37.831291557 +0200\n+++ /tmp/tmpwcvlgi5l.java\t2022-07-19 06:29:37.831291557 +0200\n@@ -84,14 +84,11 @@\n             if (typeId != null) {\n                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n             }\n         }\n         // first, sanity checks\n-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n-        }\n+if (p.getCurrentToken()!= JsonToken.START_OBJECT) { throw ctxt; }\n             // should always get field name, but just in case...\n             if (p.nextToken() != JsonToken.FIELD_NAME) {\n                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (p.getCurrentToken() != JsonToken.START_OBJECT) { throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT, \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName()); }",
        "fixed_line": "JsonToken t = p.getCurrentToken(); if (t == JsonToken.START_OBJECT) { // should always get field name, but just in case... if (p.nextToken() != JsonToken.FIELD_NAME) { throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME, \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\"); } } else if (t != JsonToken.FIELD_NAME) { throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT, \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName()); }"
    },
    "Csv-1": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (current == '\\n') { // firstChar; need to check",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\t2022-07-19 06:29:39.847279555 +0200\n+++ /tmp/tmph1m65p4t.java\t2022-07-19 06:29:39.887279317 +0200\n@@ -53,11 +53,11 @@\n     }\n \n     @Override\n     public int read() throws IOException {\n         int current = super.read();\n-        if (current == '\\n') {\n+if (current == '\\n') { // firstChar; need to check\n             lineCounter++;\n         }\n         lastChar = current;\n         return lastChar;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (current == '\\n') { // firstChar; need the lastChar",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\t2022-07-19 06:29:42.519263651 +0200\n+++ /tmp/tmp_7av1ytc.java\t2022-07-19 06:29:42.519263651 +0200\n@@ -53,11 +53,11 @@\n     }\n \n     @Override\n     public int read() throws IOException {\n         int current = super.read();\n-        if (current == '\\n') {\n+if (current == '\\n') { // firstChar; need the lastChar\n             lineCounter++;\n         }\n         lastChar = current;\n         return lastChar;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (current == '\\n') { // firstChar; need to do lineCounter",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\t2022-07-19 06:29:44.999248895 +0200\n+++ /tmp/tmpb_8iutmr.java\t2022-07-19 06:29:44.999248895 +0200\n@@ -53,11 +53,11 @@\n     }\n \n     @Override\n     public int read() throws IOException {\n         int current = super.read();\n-        if (current == '\\n') {\n+if (current == '\\n') { // firstChar; need to do lineCounter\n             lineCounter++;\n         }\n         lastChar = current;\n         return lastChar;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (current == '\\n') { // firstChar == lastChar; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\t2022-07-19 06:29:47.535233812 +0200\n+++ /tmp/tmpzvhvm0vu.java\t2022-07-19 06:29:47.587233500 +0200\n@@ -53,11 +53,11 @@\n     }\n \n     @Override\n     public int read() throws IOException {\n         int current = super.read();\n-        if (current == '\\n') {\n+if (current == '\\n') { // firstChar == lastChar; }\n             lineCounter++;\n         }\n         lastChar = current;\n         return lastChar;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (current == '\\n') { // firstChar = current; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\t2022-07-19 06:29:50.403216757 +0200\n+++ /tmp/tmp581r_cbk.java\t2022-07-19 06:29:50.403216757 +0200\n@@ -53,11 +53,11 @@\n     }\n \n     @Override\n     public int read() throws IOException {\n         int current = super.read();\n-        if (current == '\\n') {\n+if (current == '\\n') { // firstChar = current; }\n             lineCounter++;\n         }\n         lastChar = current;\n         return lastChar;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (current == '\\n') { // firstChar = lastChar; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\t2022-07-19 06:29:52.999201322 +0200\n+++ /tmp/tmptoey4r4q.java\t2022-07-19 06:29:53.003201296 +0200\n@@ -53,11 +53,11 @@\n     }\n \n     @Override\n     public int read() throws IOException {\n         int current = super.read();\n-        if (current == '\\n') {\n+if (current == '\\n') { // firstChar = lastChar; }\n             lineCounter++;\n         }\n         lastChar = current;\n         return lastChar;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (current!= '\\n') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\t2022-07-19 06:29:55.867184272 +0200\n+++ /tmp/tmptlzgwhvx.java\t2022-07-19 06:29:55.867184272 +0200\n@@ -53,11 +53,11 @@\n     }\n \n     @Override\n     public int read() throws IOException {\n         int current = super.read();\n-        if (current == '\\n') {\n+if (current!= '\\n') {\n             lineCounter++;\n         }\n         lastChar = current;\n         return lastChar;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (current == '\\n') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\t2022-07-19 06:29:58.599168037 +0200\n+++ /tmp/tmpgy_35e8_.java\t2022-07-19 06:29:58.599168037 +0200\n@@ -53,11 +53,11 @@\n     }\n \n     @Override\n     public int read() throws IOException {\n         int current = super.read();\n-        if (current == '\\n') {\n+if (current == '\\n') {\n             lineCounter++;\n         }\n         lastChar = current;\n         return lastChar;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (current == '\\n') { // firstChar; need the lastChar; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\t2022-07-19 06:30:01.243152331 +0200\n+++ /tmp/tmp4i4x8nix.java\t2022-07-19 06:30:01.243152331 +0200\n@@ -53,11 +53,11 @@\n     }\n \n     @Override\n     public int read() throws IOException {\n         int current = super.read();\n-        if (current == '\\n') {\n+if (current == '\\n') { // firstChar; need the lastChar; }\n             lineCounter++;\n         }\n         lastChar = current;\n         return lastChar;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (current!= '\\n') { // firstChar; need the lastChar",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\t2022-07-19 06:30:03.959136200 +0200\n+++ /tmp/tmpfuwfd4sn.java\t2022-07-19 06:30:03.959136200 +0200\n@@ -53,11 +53,11 @@\n     }\n \n     @Override\n     public int read() throws IOException {\n         int current = super.read();\n-        if (current == '\\n') {\n+if (current!= '\\n') { // firstChar; need the lastChar\n             lineCounter++;\n         }\n         lastChar = current;\n         return lastChar;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (current == '\\n') {",
        "fixed_line": "if (current == '\\r' || (current == '\\n' && lastChar != '\\r')) {"
    },
    "Codec-2": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (lineSeparator.length < 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-2/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 06:30:06.643120262 +0200\n+++ /tmp/tmpa3urlt3a.java\t2022-07-19 06:30:06.695119953 +0200\n@@ -441,11 +441,11 @@\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buf[pos++] = PAD;\n                     }\n                     break;\n             }\n-            if (lineLength > 0) {\n+if (lineSeparator.length < 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (lineSeparator.length == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-2/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 06:30:09.367104088 +0200\n+++ /tmp/tmp6qpte0vd.java\t2022-07-19 06:30:09.367104088 +0200\n@@ -441,11 +441,11 @@\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buf[pos++] = PAD;\n                     }\n                     break;\n             }\n-            if (lineLength > 0) {\n+if (lineSeparator.length == 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (lineSeparator.length > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-2/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 06:30:11.827089489 +0200\n+++ /tmp/tmpbr1pwobt.java\t2022-07-19 06:30:11.827089489 +0200\n@@ -441,11 +441,11 @@\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buf[pos++] = PAD;\n                     }\n                     break;\n             }\n-            if (lineLength > 0) {\n+if (lineSeparator.length > 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (lineSeparator.length >= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-2/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 06:30:14.471073798 +0200\n+++ /tmp/tmpmhahd1l1.java\t2022-07-19 06:30:14.471073798 +0200\n@@ -441,11 +441,11 @@\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buf[pos++] = PAD;\n                     }\n                     break;\n             }\n-            if (lineLength > 0) {\n+if (lineSeparator.length >= 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (lineSeparator.length!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-2/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 06:30:17.083058301 +0200\n+++ /tmp/tmpw0hh0u3v.java\t2022-07-19 06:30:17.083058301 +0200\n@@ -441,11 +441,11 @@\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buf[pos++] = PAD;\n                     }\n                     break;\n             }\n-            if (lineLength > 0) {\n+if (lineSeparator.length!= 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (pos >= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-2/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 06:30:19.995041032 +0200\n+++ /tmp/tmp7djqrdm7.java\t2022-07-19 06:30:19.995041032 +0200\n@@ -441,11 +441,11 @@\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buf[pos++] = PAD;\n                     }\n                     break;\n             }\n-            if (lineLength > 0) {\n+if (pos >= 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (pos < 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-2/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 06:30:22.683025091 +0200\n+++ /tmp/tmpzfoazc60.java\t2022-07-19 06:30:22.683025091 +0200\n@@ -441,11 +441,11 @@\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buf[pos++] = PAD;\n                     }\n                     break;\n             }\n-            if (lineLength > 0) {\n+if (pos < 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (pos > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-2/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 06:30:25.359009227 +0200\n+++ /tmp/tmpb_6ssdvm.java\t2022-07-19 06:30:25.359009227 +0200\n@@ -441,11 +441,11 @@\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buf[pos++] = PAD;\n                     }\n                     break;\n             }\n-            if (lineLength > 0) {\n+if (pos > 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (lineSeparator.length <= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-2/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 06:30:28.142992728 +0200\n+++ /tmp/tmpnz0uu763.java\t2022-07-19 06:30:28.146992702 +0200\n@@ -441,11 +441,11 @@\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buf[pos++] = PAD;\n                     }\n                     break;\n             }\n-            if (lineLength > 0) {\n+if (lineSeparator.length <= 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (lineSeparator.length + 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-2/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 06:30:30.894976421 +0200\n+++ /tmp/tmperbkx7lr.java\t2022-07-19 06:30:30.894976421 +0200\n@@ -441,11 +441,11 @@\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buf[pos++] = PAD;\n                     }\n                     break;\n             }\n-            if (lineLength > 0) {\n+if (lineSeparator.length + 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (lineLength > 0) {",
        "fixed_line": "if (lineLength > 0 && pos > 0) {"
    },
    "Jsoup-24": {
        "fixes": [
            {
                "k": 1,
                "patch": "r.advance();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-24/src/main/java/org/jsoup/parser/TokeniserState.java\t2022-07-19 06:30:32.894964571 +0200\n+++ /tmp/tmp2op9tcmd.java\t2022-07-19 06:30:32.974964099 +0200\n@@ -553,11 +553,11 @@\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+r.advance();\n                 return;\n             }\n \n             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                 char c = r.consume();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "r.advance(); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-24/src/main/java/org/jsoup/parser/TokeniserState.java\t2022-07-19 06:30:36.666942232 +0200\n+++ /tmp/tmpu9y5dyh5.java\t2022-07-19 06:30:36.666942232 +0200\n@@ -553,11 +553,11 @@\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+r.advance(); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n                 return;\n             }\n \n             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                 char c = r.consume();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "r.advance(); // we didn't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-24/src/main/java/org/jsoup/parser/TokeniserState.java\t2022-07-19 06:30:39.910923022 +0200\n+++ /tmp/tmpx7e6dnty.java\t2022-07-19 06:30:39.914923000 +0200\n@@ -553,11 +553,11 @@\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+r.advance(); // we didn't really modify it's totalGJACKSON-notnotnotnot real number\n                 return;\n             }\n \n             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                 char c = r.consume();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "r.advance(); // we didn't really modify it's totalGJACKSON-407] -- allow use a native function.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-24/src/main/java/org/jsoup/parser/TokeniserState.java\t2022-07-19 06:30:43.118904033 +0200\n+++ /tmp/tmpabkz0131.java\t2022-07-19 06:30:43.122904011 +0200\n@@ -553,11 +553,11 @@\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+r.advance(); // we didn't really modify it's totalGJACKSON-407] -- allow use a native function.\n                 return;\n             }\n \n             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                 char c = r.consume();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "r.advance(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-24/src/main/java/org/jsoup/parser/TokeniserState.java\t2022-07-19 06:30:46.242885545 +0200\n+++ /tmp/tmp8t5ebiuf.java\t2022-07-19 06:30:46.242885545 +0200\n@@ -553,11 +553,11 @@\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+r.advance(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n                 return;\n             }\n \n             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                 char c = r.consume();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "r.advance(); // we didn't really modify it's totalGJACKSON-notnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-24/src/main/java/org/jsoup/parser/TokeniserState.java\t2022-07-19 06:30:49.702865077 +0200\n+++ /tmp/tmpoz47eyy_.java\t2022-07-19 06:30:49.706865051 +0200\n@@ -553,11 +553,11 @@\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+r.advance(); // we didn't really modify it's totalGJACKSON-notnotnot real number\n                 return;\n             }\n \n             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                 char c = r.consume();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "r.advance(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-24/src/main/java/org/jsoup/parser/TokeniserState.java\t2022-07-19 06:30:53.182844494 +0200\n+++ /tmp/tmpwlluis74.java\t2022-07-19 06:30:53.186844468 +0200\n@@ -553,11 +553,11 @@\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+r.advance(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n                 return;\n             }\n \n             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                 char c = r.consume();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "r.advance(); // we didn't really modify it was non-literal characters that might be Token.advance();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-24/src/main/java/org/jsoup/parser/TokeniserState.java\t2022-07-19 06:30:56.498824887 +0200\n+++ /tmp/tmp__am2k5t.java\t2022-07-19 06:30:56.498824887 +0200\n@@ -553,11 +553,11 @@\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+r.advance(); // we didn't really modify it was non-literal characters that might be Token.advance();\n                 return;\n             }\n \n             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                 char c = r.consume();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "r.advance(); // we didn't really modify it's totalGJACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-24/src/main/java/org/jsoup/parser/TokeniserState.java\t2022-07-19 06:30:59.658806207 +0200\n+++ /tmp/tmp7baxrpyj.java\t2022-07-19 06:30:59.658806207 +0200\n@@ -553,11 +553,11 @@\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+r.advance(); // we didn't really modify it's totalGJACKSON-407] -- allow disabling wrapping for\n                 return;\n             }\n \n             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                 char c = r.consume();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "r.advance(); // we didn't really modify it was non-literal characters that might be valid (e if it.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-24/src/main/java/org/jsoup/parser/TokeniserState.java\t2022-07-19 06:31:02.786787721 +0200\n+++ /tmp/tmpehdd0zfb.java\t2022-07-19 06:31:02.786787721 +0200\n@@ -553,11 +553,11 @@\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+r.advance(); // we didn't really modify it was non-literal characters that might be valid (e if it.\n                 return;\n             }\n \n             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                 char c = r.consume();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "r.advance();",
        "fixed_line": ""
    },
    "Math-85": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (fa * fb!= 0.0 ) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2022-07-19 06:31:06.150767846 +0200\n+++ /tmp/tmpseufk2eo.java\t2022-07-19 06:31:06.174767702 +0200\n@@ -193,11 +193,11 @@\n             fb = function.value(b);\n             numIterations++ ;\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+if (fa * fb!= 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n                       numIterations, maximumIterations, initial,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (fa * fb >= 0.0 ) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2022-07-19 06:31:13.558724094 +0200\n+++ /tmp/tmp7a15op59.java\t2022-07-19 06:31:13.558724094 +0200\n@@ -193,11 +193,11 @@\n             fb = function.value(b);\n             numIterations++ ;\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+if (fa * fb >= 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n                       numIterations, maximumIterations, initial,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (fa * fb == 0.0 ) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2022-07-19 06:31:20.310684240 +0200\n+++ /tmp/tmpo4s0slli.java\t2022-07-19 06:31:20.310684240 +0200\n@@ -193,11 +193,11 @@\n             fb = function.value(b);\n             numIterations++ ;\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+if (fa * fb == 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n                       numIterations, maximumIterations, initial,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (fa * fb > 0.0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2022-07-19 06:31:26.934645164 +0200\n+++ /tmp/tmpnc2z5b5m.java\t2022-07-19 06:31:26.934645164 +0200\n@@ -193,11 +193,11 @@\n             fb = function.value(b);\n             numIterations++ ;\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+if (fa * fb > 0.0) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n                       numIterations, maximumIterations, initial,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 5,
                "patch": "if (fa * fb >= 0.0){",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2022-07-19 06:31:33.666605470 +0200\n+++ /tmp/tmp41wrg7f8.java\t2022-07-19 06:31:33.666605470 +0200\n@@ -193,11 +193,11 @@\n             fb = function.value(b);\n             numIterations++ ;\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+if (fa * fb >= 0.0){\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n                       numIterations, maximumIterations, initial,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (fa / 0.0!= 0.0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2022-07-19 06:31:40.318566270 +0200\n+++ /tmp/tmpeh7ggmez.java\t2022-07-19 06:31:40.318566270 +0200\n@@ -193,11 +193,11 @@\n             fb = function.value(b);\n             numIterations++ ;\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+if (fa / 0.0!= 0.0) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n                       numIterations, maximumIterations, initial,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (fa * fb >= 0.0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2022-07-19 06:31:46.882527606 +0200\n+++ /tmp/tmpvupwhqlb.java\t2022-07-19 06:31:46.886527580 +0200\n@@ -193,11 +193,11 @@\n             fb = function.value(b);\n             numIterations++ ;\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+if (fa * fb >= 0.0) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n                       numIterations, maximumIterations, initial,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (fa * fb!= 0.0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2022-07-19 06:31:53.634487851 +0200\n+++ /tmp/tmp6mrklih7.java\t2022-07-19 06:31:53.634487851 +0200\n@@ -193,11 +193,11 @@\n             fb = function.value(b);\n             numIterations++ ;\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+if (fa * fb!= 0.0) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n                       numIterations, maximumIterations, initial,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (fa * fb > 0.0 ) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2022-07-19 06:32:00.354448310 +0200\n+++ /tmp/tmpxp_k4rtv.java\t2022-07-19 06:32:00.354448310 +0200\n@@ -193,11 +193,11 @@\n             fb = function.value(b);\n             numIterations++ ;\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+if (fa * fb > 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n                       numIterations, maximumIterations, initial,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 10,
                "patch": "if (fa * fb < 0.0 ) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2022-07-19 06:32:06.902409795 +0200\n+++ /tmp/tmpry4cy7pd.java\t2022-07-19 06:32:06.906409774 +0200\n@@ -193,11 +193,11 @@\n             fb = function.value(b);\n             numIterations++ ;\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+if (fa * fb < 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n                       numIterations, maximumIterations, initial,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (fa * fb >= 0.0 ) {",
        "fixed_line": "if (fa * fb > 0.0 ) {"
    },
    "Closure-67": {
        "fixes": [
            {
                "k": 1,
                "patch": ") {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-67/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\t2022-07-19 06:32:13.858368901 +0200\n+++ /tmp/tmpahuntuxs.java\t2022-07-19 06:32:13.910368594 +0200\n@@ -313,11 +313,11 @@\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          ) {\n+) {\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n \n         if (isChainedProperty) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": ") { // a assign assign; can't find",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-67/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\t2022-07-19 06:32:51.294149163 +0200\n+++ /tmp/tmpfit9w3si.java\t2022-07-19 06:32:51.294149163 +0200\n@@ -313,11 +313,11 @@\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          ) {\n+) { // a assign assign; can't find\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n \n         if (isChainedProperty) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": ") { // a assign assign; can't be null if we're not handling object literals being // assigned to a assign; can't find",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-67/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\t2022-07-19 06:33:25.321949895 +0200\n+++ /tmp/tmp39lzud6p.java\t2022-07-19 06:33:25.325949870 +0200\n@@ -313,11 +313,11 @@\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          ) {\n+) { // a assign assign; can't be null if we're not handling object literals being // assigned to a assign; can't find\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n \n         if (isChainedProperty) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": ") { // a assign assign; can't be null if we're not handling object literals being // assigned to a assign assign; can't find",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-67/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\t2022-07-19 06:33:59.469750347 +0200\n+++ /tmp/tmp06ojhx8k.java\t2022-07-19 06:33:59.469750347 +0200\n@@ -313,11 +313,11 @@\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          ) {\n+) { // a assign assign; can't be null if we're not handling object literals being // assigned to a assign assign; can't find\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n \n         if (isChainedProperty) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": ") { // a assign assign; can't be null if we're not handling object literals being // a assign assign; can't find",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-67/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\t2022-07-19 06:34:33.793550167 +0200\n+++ /tmp/tmpcgm7__bc.java\t2022-07-19 06:34:33.793550167 +0200\n@@ -313,11 +313,11 @@\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          ) {\n+) { // a assign assign; can't be null if we're not handling object literals being // a assign assign; can't find\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n \n         if (isChainedProperty) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": ") { // a assign assign; can't be null if we're not handling object literals being // assigned to a assign, as per RFC 46 property name; can't find",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-67/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\t2022-07-19 06:35:07.777352338 +0200\n+++ /tmp/tmpw06oktq9.java\t2022-07-19 06:35:07.777352338 +0200\n@@ -313,11 +313,11 @@\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          ) {\n+) { // a assign assign; can't be null if we're not handling object literals being // assigned to a assign, as per RFC 46 property name; can't find\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n \n         if (isChainedProperty) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": ") { // a assign assign; can't really modify it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-67/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\t2022-07-19 06:35:41.729155038 +0200\n+++ /tmp/tmpyt1bapop.java\t2022-07-19 06:35:41.729155038 +0200\n@@ -313,11 +313,11 @@\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          ) {\n+) { // a assign assign; can't really modify it's do implicit re-parse\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n \n         if (isChainedProperty) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": ") { // a assign assign; can't really modify it was non-literal characters that might be Token.GETPROP = assign; can't find",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-67/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\t2022-07-19 06:36:15.960956433 +0200\n+++ /tmp/tmprn6jnoun.java\t2022-07-19 06:36:15.960956433 +0200\n@@ -313,11 +313,11 @@\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          ) {\n+) { // a assign assign; can't really modify it was non-literal characters that might be Token.GETPROP = assign; can't find\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n \n         if (isChainedProperty) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": ") { // a assign assign; can't really here here (n.getType() == Token.GETPROP) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-67/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\t2022-07-19 06:36:49.836760193 +0200\n+++ /tmp/tmpzgc9x39u.java\t2022-07-19 06:36:49.840760170 +0200\n@@ -313,11 +313,11 @@\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          ) {\n+) { // a assign assign; can't really here here (n.getType() == Token.GETPROP) {\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n \n         if (isChainedProperty) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": ") { // a assign assign; can't be null if we're not handling object literals being // assigned to a assign, as per RFC 46 property name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-67/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\t2022-07-19 06:37:23.980562681 +0200\n+++ /tmp/tmpagalncm7.java\t2022-07-19 06:37:23.980562681 +0200\n@@ -313,11 +313,11 @@\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          ) {\n+) { // a assign assign; can't be null if we're not handling object literals being // assigned to a assign, as per RFC 46 property name;\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n \n         if (isChainedProperty) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": ") {",
        "fixed_line": "&& assign.getParent().getType() == Token.EXPR_RESULT) {"
    },
    "Csv-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "final boolean emptyHeader = header.trim().isEmpty();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-11/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 06:37:58.088365642 +0200\n+++ /tmp/tmpy1j73e0m.java\t2022-07-19 06:37:58.112365503 +0200\n@@ -379,11 +379,11 @@\n             // build the name to index mappings\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+final boolean emptyHeader = header.trim().isEmpty();\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n                     }\n                     hdrMap.put(header, Integer.valueOf(i));\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "final boolean emptyHeader = header.trim().isEmpty(); // we didn't really modify it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-11/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 06:38:01.424346383 +0200\n+++ /tmp/tmpa27lq9vj.java\t2022-07-19 06:38:01.424346383 +0200\n@@ -379,11 +379,11 @@\n             // build the name to index mappings\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+final boolean emptyHeader = header.trim().isEmpty(); // we didn't really modify it's do implicit re-parse\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n                     }\n                     hdrMap.put(header, Integer.valueOf(i));\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "final boolean emptyHeader = header.trim().isEmpty(); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-11/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 06:38:04.380329322 +0200\n+++ /tmp/tmpq9sbdxer.java\t2022-07-19 06:38:04.380329322 +0200\n@@ -379,11 +379,11 @@\n             // build the name to index mappings\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+final boolean emptyHeader = header.trim().isEmpty(); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n                     }\n                     hdrMap.put(header, Integer.valueOf(i));\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "final boolean emptyHeader = header.trim().isEmpty(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-11/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 06:38:07.244312791 +0200\n+++ /tmp/tmpx0n7dv6d.java\t2022-07-19 06:38:07.244312791 +0200\n@@ -379,11 +379,11 @@\n             // build the name to index mappings\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+final boolean emptyHeader = header.trim().isEmpty(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n                     }\n                     hdrMap.put(header, Integer.valueOf(i));\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "final boolean emptyHeader = header.trim().isEmpty(); // we didn't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-11/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 06:38:10.076296447 +0200\n+++ /tmp/tmp9xif4659.java\t2022-07-19 06:38:10.080296424 +0200\n@@ -379,11 +379,11 @@\n             // build the name to index mappings\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+final boolean emptyHeader = header.trim().isEmpty(); // we didn't really modify it's totalGJACKSON-notnotnotnot real number\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n                     }\n                     hdrMap.put(header, Integer.valueOf(i));\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "final boolean emptyHeader = header.trim().isEmpty(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-11/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 06:38:13.028279413 +0200\n+++ /tmp/tmp0ij6vrf3.java\t2022-07-19 06:38:13.028279413 +0200\n@@ -379,11 +379,11 @@\n             // build the name to index mappings\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+final boolean emptyHeader = header.trim().isEmpty(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n                     }\n                     hdrMap.put(header, Integer.valueOf(i));\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "final boolean emptyHeader = header.trim().isEmpty(); // we didn't really modify it's totalGJACKSON-notnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-11/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 06:38:15.784263512 +0200\n+++ /tmp/tmpqdc7lx0e.java\t2022-07-19 06:38:15.784263512 +0200\n@@ -379,11 +379,11 @@\n             // build the name to index mappings\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+final boolean emptyHeader = header.trim().isEmpty(); // we didn't really modify it's totalGJACKSON-notnotnot real number\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n                     }\n                     hdrMap.put(header, Integer.valueOf(i));\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "final boolean emptyHeader = header.trim().isEmpty(); // we didn't really modify it.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-11/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 06:38:18.448248142 +0200\n+++ /tmp/tmpd3lvdtdk.java\t2022-07-19 06:38:18.448248142 +0200\n@@ -379,11 +379,11 @@\n             // build the name to index mappings\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+final boolean emptyHeader = header.trim().isEmpty(); // we didn't really modify it.\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n                     }\n                     hdrMap.put(header, Integer.valueOf(i));\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "final boolean emptyHeader = header.trim().isEmpty(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-11/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 06:38:21.296231712 +0200\n+++ /tmp/tmp8nybuooa.java\t2022-07-19 06:38:21.296231712 +0200\n@@ -379,11 +379,11 @@\n             // build the name to index mappings\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+final boolean emptyHeader = header.trim().isEmpty(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n                     }\n                     hdrMap.put(header, Integer.valueOf(i));\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "final boolean emptyHeader = header.trim().isEmpty(); // we didn't really modify it was last",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-11/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-19 06:38:23.928216532 +0200\n+++ /tmp/tmpvz6ztes5.java\t2022-07-19 06:38:23.928216532 +0200\n@@ -379,11 +379,11 @@\n             // build the name to index mappings\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+final boolean emptyHeader = header.trim().isEmpty(); // we didn't really modify it was last\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n                     }\n                     hdrMap.put(header, Integer.valueOf(i));\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "final boolean emptyHeader = header.trim().isEmpty();",
        "fixed_line": "final boolean emptyHeader = header == null || header.trim().isEmpty();"
    },
    "Chart-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "PathIterator iterator2 = p2.getPathIterator(null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-11/source/org/jfree/chart/util/ShapeUtilities.java\t2022-07-19 06:38:27.160197892 +0200\n+++ /tmp/tmpsui7znzf.java\t2022-07-19 06:38:27.220197545 +0200\n@@ -270,11 +270,11 @@\n         }\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+PathIterator iterator2 = p2.getPathIterator(null);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n         while (!done) {\n             if (iterator1.isDone() != iterator2.isDone()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 2,
                "patch": "PathIterator iterator2 = p1.getPathIterator(null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-11/source/org/jfree/chart/util/ShapeUtilities.java\t2022-07-19 06:38:36.840142072 +0200\n+++ /tmp/tmpmasgine1.java\t2022-07-19 06:38:36.840142072 +0200\n@@ -270,11 +270,11 @@\n         }\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+PathIterator iterator2 = p1.getPathIterator(null);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n         while (!done) {\n             if (iterator1.isDone() != iterator2.isDone()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "PathIterator iterator2 = p.getPathIterator(null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-11/source/org/jfree/chart/util/ShapeUtilities.java\t2022-07-19 06:38:45.456092406 +0200\n+++ /tmp/tmp3wk0icrg.java\t2022-07-19 06:38:45.504092130 +0200\n@@ -270,11 +270,11 @@\n         }\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+PathIterator iterator2 = p.getPathIterator(null);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n         while (!done) {\n             if (iterator1.isDone() != iterator2.isDone()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "PathIterator iterator2 = p3.getPathIterator(null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-11/source/org/jfree/chart/util/ShapeUtilities.java\t2022-07-19 06:38:47.404081180 +0200\n+++ /tmp/tmplon1rn_c.java\t2022-07-19 06:38:47.408081158 +0200\n@@ -270,11 +270,11 @@\n         }\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+PathIterator iterator2 = p3.getPathIterator(null);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n         while (!done) {\n             if (iterator1.isDone() != iterator2.isDone()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "PathIterator iterator2 = p1.getPathIterator(null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-11/source/org/jfree/chart/util/ShapeUtilities.java\t2022-07-19 06:38:49.180070944 +0200\n+++ /tmp/tmpsxrkwi_u.java\t2022-07-19 06:38:49.180070944 +0200\n@@ -270,11 +270,11 @@\n         }\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+PathIterator iterator2 = p1.getPathIterator(null);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n         while (!done) {\n             if (iterator1.isDone() != iterator2.isDone()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "PathIterator iterator2 = p0.getPathIterator(null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-11/source/org/jfree/chart/util/ShapeUtilities.java\t2022-07-19 06:38:57.376023718 +0200\n+++ /tmp/tmp61sx0kls.java\t2022-07-19 06:38:57.376023718 +0200\n@@ -270,11 +270,11 @@\n         }\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+PathIterator iterator2 = p0.getPathIterator(null);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n         while (!done) {\n             if (iterator1.isDone() != iterator2.isDone()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "PathIterator iterator2 -= p2.getPathIterator(null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-11/source/org/jfree/chart/util/ShapeUtilities.java\t2022-07-19 06:38:59.232013025 +0200\n+++ /tmp/tmpw86u4dn_.java\t2022-07-19 06:38:59.232013025 +0200\n@@ -270,11 +270,11 @@\n         }\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+PathIterator iterator2 -= p2.getPathIterator(null);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n         while (!done) {\n             if (iterator1.isDone() != iterator2.isDone()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "PathIterator iterator2 -= p1.getPathIterator(null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-11/source/org/jfree/chart/util/ShapeUtilities.java\t2022-07-19 06:39:00.980002955 +0200\n+++ /tmp/tmpkj5x1gus.java\t2022-07-19 06:39:00.980002955 +0200\n@@ -270,11 +270,11 @@\n         }\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+PathIterator iterator2 -= p1.getPathIterator(null);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n         while (!done) {\n             if (iterator1.isDone() != iterator2.isDone()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "PathIterator iterator2 = p2.getPathIterator(null));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-11/source/org/jfree/chart/util/ShapeUtilities.java\t2022-07-19 06:39:02.811992402 +0200\n+++ /tmp/tmpx8yno06f.java\t2022-07-19 06:39:02.811992402 +0200\n@@ -270,11 +270,11 @@\n         }\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+PathIterator iterator2 = p2.getPathIterator(null));\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n         while (!done) {\n             if (iterator1.isDone() != iterator2.isDone()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "PathIterator iterator2 = p2.getPathIterator();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-11/source/org/jfree/chart/util/ShapeUtilities.java\t2022-07-19 06:39:04.475982816 +0200\n+++ /tmp/tmpufprdqce.java\t2022-07-19 06:39:04.479982794 +0200\n@@ -270,11 +270,11 @@\n         }\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+PathIterator iterator2 = p2.getPathIterator();\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n         while (!done) {\n             if (iterator1.isDone() != iterator2.isDone()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "PathIterator iterator2 = p1.getPathIterator(null);",
        "fixed_line": "PathIterator iterator2 = p2.getPathIterator(null);"
    },
    "Closure-87": {
        "fixes": [
            {
                "k": 1,
                "patch": "return NodeUtil.isExpressionNode(maybeExpr);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 06:39:06.543970905 +0200\n+++ /tmp/tmpr0jdo4aa.java\t2022-07-19 06:39:06.583970674 +0200\n@@ -528,11 +528,11 @@\n           // into other expressions.\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n \n-          return NodeUtil.isExpressionNode(maybeExpr);\n+return NodeUtil.isExpressionNode(maybeExpr);\n       }\n     }\n \n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return NodeUtil.isExpressionNode(parent);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 06:39:36.975795713 +0200\n+++ /tmp/tmptyivn1ax.java\t2022-07-19 06:39:36.975795713 +0200\n@@ -528,11 +528,11 @@\n           // into other expressions.\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n \n-          return NodeUtil.isExpressionNode(maybeExpr);\n+return NodeUtil.isExpressionNode(parent);\n       }\n     }\n \n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return NodeUtil.isExpressionNode( return NodeUtil.isExpressionNode(parent);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 06:39:39.871779050 +0200\n+++ /tmp/tmp8fbfuo8x.java\t2022-07-19 06:39:39.871779050 +0200\n@@ -528,11 +528,11 @@\n           // into other expressions.\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n \n-          return NodeUtil.isExpressionNode(maybeExpr);\n+return NodeUtil.isExpressionNode( return NodeUtil.isExpressionNode(parent);\n       }\n     }\n \n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return NodeUtil.isExpressionNode(n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 06:39:42.583763447 +0200\n+++ /tmp/tmpdxwig9vg.java\t2022-07-19 06:39:42.583763447 +0200\n@@ -528,11 +528,11 @@\n           // into other expressions.\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n \n-          return NodeUtil.isExpressionNode(maybeExpr);\n+return NodeUtil.isExpressionNode(n);\n       }\n     }\n \n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return NodeUtil.isExpressionNode( return NodeUtil.isExpressionNode(n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 06:40:10.407603435 +0200\n+++ /tmp/tmpbdfano4p.java\t2022-07-19 06:40:10.407603435 +0200\n@@ -528,11 +528,11 @@\n           // into other expressions.\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n \n-          return NodeUtil.isExpressionNode(maybeExpr);\n+return NodeUtil.isExpressionNode( return NodeUtil.isExpressionNode(n);\n       }\n     }\n \n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return NodeUtil.isExpressionNode( return NodeUtil.isExpressionNode(parent);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 06:40:12.943588857 +0200\n+++ /tmp/tmpitdo_6d0.java\t2022-07-19 06:40:12.943588857 +0200\n@@ -528,11 +528,11 @@\n           // into other expressions.\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n \n-          return NodeUtil.isExpressionNode(maybeExpr);\n+return NodeUtil.isExpressionNode( return NodeUtil.isExpressionNode(parent);\n       }\n     }\n \n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return NodeUtil.isExpressionNode( return NodeUtil.isExpressionNode(maybeExpr);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 06:40:15.579573707 +0200\n+++ /tmp/tmp_i3k9rb6.java\t2022-07-19 06:40:15.579573707 +0200\n@@ -528,11 +528,11 @@\n           // into other expressions.\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n \n-          return NodeUtil.isExpressionNode(maybeExpr);\n+return NodeUtil.isExpressionNode( return NodeUtil.isExpressionNode(maybeExpr);\n       }\n     }\n \n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return NodeUtil.isExpressionNode( return NodeUtil.isExpressionNode(value);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 06:40:18.247558373 +0200\n+++ /tmp/tmp9_22oy93.java\t2022-07-19 06:40:18.251558350 +0200\n@@ -528,11 +528,11 @@\n           // into other expressions.\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n \n-          return NodeUtil.isExpressionNode(maybeExpr);\n+return NodeUtil.isExpressionNode( return NodeUtil.isExpressionNode(value);\n       }\n     }\n \n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return NodeUtil.isExpressionNode( return NodeUtil.isExpressionNode(n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 06:40:20.815543613 +0200\n+++ /tmp/tmp8vdjowf7.java\t2022-07-19 06:40:20.815543613 +0200\n@@ -528,11 +528,11 @@\n           // into other expressions.\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n \n-          return NodeUtil.isExpressionNode(maybeExpr);\n+return NodeUtil.isExpressionNode( return NodeUtil.isExpressionNode(n);\n       }\n     }\n \n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return NodeUtil.isExpressionNode( return NodeUtil.isExpressionNode(parent);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 06:40:23.499528189 +0200\n+++ /tmp/tmpbqayfo4q.java\t2022-07-19 06:40:23.499528189 +0200\n@@ -528,11 +528,11 @@\n           // into other expressions.\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n \n-          return NodeUtil.isExpressionNode(maybeExpr);\n+return NodeUtil.isExpressionNode( return NodeUtil.isExpressionNode(parent);\n       }\n     }\n \n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return NodeUtil.isExpressionNode(maybeExpr);",
        "fixed_line": "if (maybeExpr.getType() == Token.EXPR_RESULT) { // IE has a bug where event handlers behave differently when // their return value is used vs. when their return value is in // an EXPR_RESULT. It's pretty freaking weird. See: // http://code.google.com/p/closure-compiler/issues/detail?id=291 // We try to detect this case, and not fold EXPR_RESULTs // into other expressions. if (maybeExpr.getFirstChild().getType() == Token.CALL) { Node calledFn = maybeExpr.getFirstChild().getFirstChild(); // We only have to worry about methods with an implicit 'this' // param, or this doesn't happen. if (calledFn.getType() == Token.GETELEM) { return false; } else if (calledFn.getType() == Token.GETPROP && calledFn.getLastChild().getString().startsWith(\"on\")) { return false; } } return true; } return false;"
    },
    "Math-40": {
        "fixes": [
            {
                "k": 1,
                "patch": "targetY = -REDUCTION_FACTOR * yB; } else if (is we keep updating the low bracket this targetY = -REDUCTION_FACTOR *DUCTION_FACTOR / 2;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2022-07-19 06:40:26.435511319 +0200\n+++ /tmp/tmp4873ip4_.java\t2022-07-19 06:40:26.611510306 +0200\n@@ -230,14 +230,11 @@\n \n             // target for the next evaluation point\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+targetY = -REDUCTION_FACTOR * yB; } else if (is we keep updating the low bracket this targetY = -REDUCTION_FACTOR *DUCTION_FACTOR / 2;\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "targetY = -REDUCTION_FACTOR / MAX_B; } else if (is we keep updating the lowensate this targetY = -REDUCTION_FACTOR *DUCTION_FACTOR / 2;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2022-07-19 06:40:28.823497598 +0200\n+++ /tmp/tmpcogu6415.java\t2022-07-19 06:40:28.823497598 +0200\n@@ -230,14 +230,11 @@\n \n             // target for the next evaluation point\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+targetY = -REDUCTION_FACTOR / MAX_B; } else if (is we keep updating the lowensate this targetY = -REDUCTION_FACTOR *DUCTION_FACTOR / 2;\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "targetY = -REDUCTION_FACTOR * void; } else if (is we keep updating the low bracket this targetY = -REDUCTION_FACTOR *DUCTION_FACTOR / 2;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2022-07-19 06:40:31.051484797 +0200\n+++ /tmp/tmp1au3ilok.java\t2022-07-19 06:40:31.051484797 +0200\n@@ -230,14 +230,11 @@\n \n             // target for the next evaluation point\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+targetY = -REDUCTION_FACTOR * void; } else if (is we keep updating the low bracket this targetY = -REDUCTION_FACTOR *DUCTION_FACTOR / 2;\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "targetY = -REDUCTION_FACTOR / 2; } else if (is we keep updating the low bracket this targetY = -REDUCTION_FACTOR * yA;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2022-07-19 06:40:33.203472435 +0200\n+++ /tmp/tmptnj7aw6n.java\t2022-07-19 06:40:33.203472435 +0200\n@@ -230,14 +230,11 @@\n \n             // target for the next evaluation point\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+targetY = -REDUCTION_FACTOR / 2; } else if (is we keep updating the low bracket this targetY = -REDUCTION_FACTOR * yA;\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "targetY = -REDUCTION_FACTOR * yB; } else if (is we keep updating the low bracket this targetY = -REDUCTION_FACTOR *DUCTION_FACTOR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2022-07-19 06:40:35.259460623 +0200\n+++ /tmp/tmpat49y71b.java\t2022-07-19 06:40:35.259460623 +0200\n@@ -230,14 +230,11 @@\n \n             // target for the next evaluation point\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+targetY = -REDUCTION_FACTOR * yB; } else if (is we keep updating the low bracket this targetY = -REDUCTION_FACTOR *DUCTION_FACTOR;\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "targetY = -REDUCTION_FACTOR / 2; } else if (targetY >= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2022-07-19 06:40:37.339448669 +0200\n+++ /tmp/tmpz4gjk31k.java\t2022-07-19 06:40:37.343448646 +0200\n@@ -230,14 +230,11 @@\n \n             // target for the next evaluation point\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+targetY = -REDUCTION_FACTOR / 2; } else if (targetY >= 0) {\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "targetY = -REDUCTION_FACTOR / MAX_B; } else if (is we keep updating the lowensate this targetY = -REDUCTION_FACTOR *DUCTION_FACTOR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2022-07-19 06:40:39.715435021 +0200\n+++ /tmp/tmp84mpayfa.java\t2022-07-19 06:40:39.719434998 +0200\n@@ -230,14 +230,11 @@\n \n             // target for the next evaluation point\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+targetY = -REDUCTION_FACTOR / MAX_B; } else if (is we keep updating the lowensate this targetY = -REDUCTION_FACTOR *DUCTION_FACTOR;\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "targetY = -REDUCTION_FACTOR / MAX_B; } else if (is we keep updating the lowensate this targetY = -REDUCTION_FACTOR * yA;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2022-07-19 06:40:41.863422689 +0200\n+++ /tmp/tmpr00i8tk3.java\t2022-07-19 06:40:41.863422689 +0200\n@@ -230,14 +230,11 @@\n \n             // target for the next evaluation point\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+targetY = -REDUCTION_FACTOR / MAX_B; } else if (is we keep updating the lowensate this targetY = -REDUCTION_FACTOR * yA;\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "targetY = -REDUCTION_FACTOR * yB; } else if (is we keep updating the low bracket this targetY = -REDUCTION_FACTOR *DUCTION_FACTOR);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2022-07-19 06:40:43.935410790 +0200\n+++ /tmp/tmp2sayclpc.java\t2022-07-19 06:40:43.939410767 +0200\n@@ -230,14 +230,11 @@\n \n             // target for the next evaluation point\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+targetY = -REDUCTION_FACTOR * yB; } else if (is we keep updating the low bracket this targetY = -REDUCTION_FACTOR *DUCTION_FACTOR);\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "targetY = -REDUCTION_FACTOR / 2; } else if (is we keep updating the low bracket this targetY = -1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2022-07-19 06:40:46.087398431 +0200\n+++ /tmp/tmpco8y2wvi.java\t2022-07-19 06:40:46.087398431 +0200\n@@ -230,14 +230,11 @@\n \n             // target for the next evaluation point\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+targetY = -REDUCTION_FACTOR / 2; } else if (is we keep updating the low bracket this targetY = -1;\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "targetY = -REDUCTION_FACTOR * yB; } else if (agingB >= MAXIMAL_AGING) { // we keep updating the low bracket, try to compensate this targetY = -REDUCTION_FACTOR * yA;",
        "fixed_line": "final int p = agingA - MAXIMAL_AGING; final double weightA = (1 << p) - 1; final double weightB = p + 1; targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB); } else if (agingB >= MAXIMAL_AGING) { // we keep updating the low bracket, try to compensate this final int p = agingB - MAXIMAL_AGING; final double weightA = p + 1; final double weightB = (1 << p) - 1; targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB);"
    },
    "Closure-77": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int i = 0; i < char.length; i++) { sb.append(\"\\\\u\"); break; case 'D': sb",
                "patch_diff": "for (int i = 0; i < char.length; i++) { sb.append(\"\\\\u\"); break; case 'D': sb",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = 0; i < char.length; i++) { sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(backslashEscape); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case '\\\\': sb.",
                "patch_diff": "for (int i = 0; i < char.length; i++) { sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(backslashEscape); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case '\\\\': sb.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0; i < char.length; i++) { sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(backslashEscape); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.",
                "patch_diff": "for (int i = 0; i < char.length; i++) { sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(backslashEscape); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = 0; i < char.length; i++) { sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(backslashEscape); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case '\\\\': sb.",
                "patch_diff": "for (int i = 0; i < char.length; i++) { sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(backslashEscape); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case '\\\\': sb.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = 0; i < char.length; i++) { sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(backslashEscape); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.",
                "patch_diff": "for (int i = 0; i < char.length; i++) { sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(backslashEscape); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = 0; i < char.length; i++) { sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(backslashEscape); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case '\\\\': sb.",
                "patch_diff": "for (int i = 0; i < char.length; i++) { sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(backslashEscape); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case '\\\\': sb.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = 0; i < char.length; i++) { sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(backslashEscape); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.",
                "patch_diff": "for (int i = 0; i < char.length; i++) { sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(backslashEscape); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = 0; i < char.length; i++) { sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(backslashEscape); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u': sb.append(\"\\\\u': sb.",
                "patch_diff": "for (int i = 0; i < char.length; i++) { sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(backslashEscape); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u': sb.append(\"\\\\u': sb.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int i = 0; i < char.length; i++) { sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(backslashEscape); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u': sb.append(\"\\\\u': sb.",
                "patch_diff": "for (int i = 0; i < char.length; i++) { sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(backslashEscape); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u': sb.append(\"\\\\u': sb.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = 0; i < char.length; i++) { sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(backslashEscape); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u': sb.append(\"\\\\u\"); break;",
                "patch_diff": "for (int i = 0; i < char.length; i++) { sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(backslashEscape); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case '\\\\': sb.append(\"\\\\u\"); break; case 'D': sb.append(\"\\\\u': sb.append(\"\\\\u\"); break;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "case '\\0': sb.append(\"\\\\0\"); break;"
    },
    "Lang-14": {
        "fixes": [
            {
                "k": 1,
                "patch": "return false; } if (cs1 == null || cs1.equals(cs2 == null) { return false; } return false;",
                "patch_diff": "return false; } if (cs1 == null || cs1.equals(cs2 == null) { return false; } return false;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return false; } if (cs1 == null || cs1.equals(cs2 == null) { return false; } return false; }",
                "patch_diff": "return false; } if (cs1 == null || cs1.equals(cs2 == null) { return false; } return false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return false; } if (cs1 == null || cs1.equals(cs2 == null) { return false; }",
                "patch_diff": "return false; } if (cs1 == null || cs1.equals(cs2 == null) { return false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return false; } else if (cs1 == null || cs1.equals(cs2 == null) { return false; } return false; }",
                "patch_diff": "return false; } else if (cs1 == null || cs1.equals(cs2 == null) { return false; } return false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return false; } if (cs1 == null || cs1.equals(cs2 == null) { return false; } return false; } return false;",
                "patch_diff": "return false; } if (cs1 == null || cs1.equals(cs2 == null) { return false; } return false; } return false;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return false; } else if (cs1 == null || cs1.equals(cs2 == null) { return false; } return false;",
                "patch_diff": "return false; } else if (cs1 == null || cs1.equals(cs2 == null) { return false; } return false;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return false; } else if (cs1 == null || cs1.equals(cs2 == null) { return false; } return false; } return false;",
                "patch_diff": "return false; } else if (cs1 == null || cs1.equals(cs2 == null) { return false; } return false; } return false;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return false; } if (cs1 == null || cs1.equals(cs2 == null) { return false; } else { return false; } return false; }",
                "patch_diff": "return false; } if (cs1 == null || cs1.equals(cs2 == null) { return false; } else { return false; } return false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// return false; } if (cs1 == null || cs1.equals(cs2 == null) { return false; } return false;",
                "patch_diff": "// return false; } if (cs1 == null || cs1.equals(cs2 == null) { return false; } return false;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// return false; } if (cs1 == null || cs1.equals(cs2 == null) { return false; } return false; }",
                "patch_diff": "// return false; } if (cs1 == null || cs1.equals(cs2 == null) { return false; } return false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));"
    },
    "JacksonDatabind-46": {
        "fixes": [
            {
                "k": 1,
                "patch": "sb.append(';');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-46/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\t2022-07-19 06:40:52.967358924 +0200\n+++ /tmp/tmp3udnrz_d.java\t2022-07-19 06:40:53.079358281 +0200\n@@ -151,11 +151,11 @@\n     public StringBuilder getGenericSignature(StringBuilder sb)\n     {\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(';');\n+sb.append(';');\n         return sb;\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "sb.append(';'); // can't really modify it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-46/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\t2022-07-19 06:41:28.087157362 +0200\n+++ /tmp/tmpxcqaw0n4.java\t2022-07-19 06:41:28.091157339 +0200\n@@ -151,11 +151,11 @@\n     public StringBuilder getGenericSignature(StringBuilder sb)\n     {\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(';');\n+sb.append(';'); // can't really modify it's do implicit re-parse\n         return sb;\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "sb.append(';'); // we didn't really modify it's totalGJACKSON-407] -- allow disabling wrapping for sb.append(';');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-46/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\t2022-07-19 06:42:02.978957281 +0200\n+++ /tmp/tmpnblhuyiq.java\t2022-07-19 06:42:02.978957281 +0200\n@@ -151,11 +151,11 @@\n     public StringBuilder getGenericSignature(StringBuilder sb)\n     {\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(';');\n+sb.append(';'); // we didn't really modify it's totalGJACKSON-407] -- allow disabling wrapping for sb.append(';');\n         return sb;\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "sb.append(';'); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-46/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\t2022-07-19 06:42:37.962756834 +0200\n+++ /tmp/tmpfzyr0qno.java\t2022-07-19 06:42:37.962756834 +0200\n@@ -151,11 +151,11 @@\n     public StringBuilder getGenericSignature(StringBuilder sb)\n     {\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(';');\n+sb.append(';'); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number\n         return sb;\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "sb.append(';'); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-46/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\t2022-07-19 06:43:12.622558392 +0200\n+++ /tmp/tmpxkxqm217.java\t2022-07-19 06:43:12.622558392 +0200\n@@ -151,11 +151,11 @@\n     public StringBuilder getGenericSignature(StringBuilder sb)\n     {\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(';');\n+sb.append(';'); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n         return sb;\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "sb.append(';'); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-46/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\t2022-07-19 06:43:47.210360498 +0200\n+++ /tmp/tmp5366yqbb.java\t2022-07-19 06:43:47.210360498 +0200\n@@ -151,11 +151,11 @@\n     public StringBuilder getGenericSignature(StringBuilder sb)\n     {\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(';');\n+sb.append(';'); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number\n         return sb;\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "sb.append(';'); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-46/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\t2022-07-19 06:44:22.142160766 +0200\n+++ /tmp/tmpdqgb9kws.java\t2022-07-19 06:44:22.142160766 +0200\n@@ -151,11 +151,11 @@\n     public StringBuilder getGenericSignature(StringBuilder sb)\n     {\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(';');\n+sb.append(';'); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n         return sb;\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "sb.append(';'); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-46/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\t2022-07-19 06:44:56.045967029 +0200\n+++ /tmp/tmpzwbztf29.java\t2022-07-19 06:44:56.045967029 +0200\n@@ -151,11 +151,11 @@\n     public StringBuilder getGenericSignature(StringBuilder sb)\n     {\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(';');\n+sb.append(';'); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnot real number\n         return sb;\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "sb.append(';'); // we didn't really modify it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-46/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\t2022-07-19 06:45:30.253771664 +0200\n+++ /tmp/tmp42_mtx94.java\t2022-07-19 06:45:30.253771664 +0200\n@@ -151,11 +151,11 @@\n     public StringBuilder getGenericSignature(StringBuilder sb)\n     {\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(';');\n+sb.append(';'); // we didn't really modify it's do implicit re-parse\n         return sb;\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "sb.append(';'); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-46/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\t2022-07-19 06:46:04.145578206 +0200\n+++ /tmp/tmprcj56jfn.java\t2022-07-19 06:46:04.145578206 +0200\n@@ -151,11 +151,11 @@\n     public StringBuilder getGenericSignature(StringBuilder sb)\n     {\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(';');\n+sb.append(';'); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnotnot real number\n         return sb;\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "sb.append(';');",
        "fixed_line": "sb.append(\">;\");"
    },
    "Time-8": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset * 60; if (hoursInMinutes < 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-8/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 06:46:38.905379889 +0200\n+++ /tmp/tmpfifaxhly.java\t2022-07-19 06:46:38.989379412 +0200\n@@ -274,18 +274,11 @@\n             return DateTimeZone.UTC;\n         }\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < 0 || minutesOffset > 59) {\n-            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n-        }\n-        int offset = 0;\n-        try {\n-            int hoursInMinutes = hoursOffset * 60;\n-            if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset * 60; if (hoursInMinutes < 0) {\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset * 60; } int hoursInMinutes = hoursInMinutes - minutesOffset;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-8/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 06:46:41.661364170 +0200\n+++ /tmp/tmpbi8kou_8.java\t2022-07-19 06:46:41.665364147 +0200\n@@ -274,18 +274,11 @@\n             return DateTimeZone.UTC;\n         }\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < 0 || minutesOffset > 59) {\n-            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n-        }\n-        int offset = 0;\n-        try {\n-            int hoursInMinutes = hoursOffset * 60;\n-            if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset * 60; } int hoursInMinutes = hoursInMinutes - minutesOffset;\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset * 60 * 1000; if (hoursInMinutes < 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-8/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 06:46:44.221349568 +0200\n+++ /tmp/tmpist5ydya.java\t2022-07-19 06:46:44.221349568 +0200\n@@ -274,18 +274,11 @@\n             return DateTimeZone.UTC;\n         }\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < 0 || minutesOffset > 59) {\n-            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n-        }\n-        int offset = 0;\n-        try {\n-            int hoursInMinutes = hoursOffset * 60;\n-            if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset * 60 * 1000; if (hoursInMinutes < 0) {\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset); } int hoursInMinutes = hoursInMinutes - minutesOffset;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-8/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 06:46:46.785334945 +0200\n+++ /tmp/tmpaibustcp.java\t2022-07-19 06:46:46.785334945 +0200\n@@ -274,18 +274,11 @@\n             return DateTimeZone.UTC;\n         }\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < 0 || minutesOffset > 59) {\n-            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n-        }\n-        int offset = 0;\n-        try {\n-            int hoursInMinutes = hoursOffset * 60;\n-            if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset); } int hoursInMinutes = hoursInMinutes - minutesOffset;\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset * 60; if (hoursInMinutes < 0) { int hours = 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-8/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 06:46:49.337320390 +0200\n+++ /tmp/tmpm75ga1tw.java\t2022-07-19 06:46:49.337320390 +0200\n@@ -274,18 +274,11 @@\n             return DateTimeZone.UTC;\n         }\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < 0 || minutesOffset > 59) {\n-            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n-        }\n-        int offset = 0;\n-        try {\n-            int hoursInMinutes = hoursOffset * 60;\n-            if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset * 60; if (hoursInMinutes < 0) { int hours = 0;\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset * 60; if (hoursInMinutes < 0) { int minutesOffset = 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-8/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 06:46:51.929305608 +0200\n+++ /tmp/tmpljy71fh4.java\t2022-07-19 06:46:51.933305584 +0200\n@@ -274,18 +274,11 @@\n             return DateTimeZone.UTC;\n         }\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < 0 || minutesOffset > 59) {\n-            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n-        }\n-        int offset = 0;\n-        try {\n-            int hoursInMinutes = hoursOffset * 60;\n-            if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset * 60; if (hoursInMinutes < 0) { int minutesOffset = 0;\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE; if (hoursInMinutes < 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-8/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 06:46:54.497290962 +0200\n+++ /tmp/tmpo4wj4nu_.java\t2022-07-19 06:46:54.497290962 +0200\n@@ -274,18 +274,11 @@\n             return DateTimeZone.UTC;\n         }\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < 0 || minutesOffset > 59) {\n-            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n-        }\n-        int offset = 0;\n-        try {\n-            int hoursInMinutes = hoursOffset * 60;\n-            if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE; if (hoursInMinutes < 0) {\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE; } int[] { int minutesOffset = 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-8/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 06:46:57.053276387 +0200\n+++ /tmp/tmpiglvb9ig.java\t2022-07-19 06:46:57.053276387 +0200\n@@ -274,18 +274,11 @@\n             return DateTimeZone.UTC;\n         }\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < 0 || minutesOffset > 59) {\n-            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n-        }\n-        int offset = 0;\n-        try {\n-            int hoursInMinutes = hoursOffset * 60;\n-            if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE; } int[] { int minutesOffset = 0;\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset * 60; if (hoursInMinutes < 0) { int minutesOffset = hoursInMinutes; if (hoursOffset > 59) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-8/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 06:46:59.625261720 +0200\n+++ /tmp/tmp2h0csr02.java\t2022-07-19 06:46:59.625261720 +0200\n@@ -274,18 +274,11 @@\n             return DateTimeZone.UTC;\n         }\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < 0 || minutesOffset > 59) {\n-            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n-        }\n-        int offset = 0;\n-        try {\n-            int hoursInMinutes = hoursOffset * 60;\n-            if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset * 60; if (hoursInMinutes < 0) { int minutesOffset = hoursInMinutes; if (hoursOffset > 59) {\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset * 60; if (hoursInMinutes < 0) { throw new IllegalArgumentException(\"Minutes of range: \" + minutesOffset * 60; if (hoursInMinutes < 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-8/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 06:47:02.197247054 +0200\n+++ /tmp/tmprj8mk8b2.java\t2022-07-19 06:47:02.197247054 +0200\n@@ -274,18 +274,11 @@\n             return DateTimeZone.UTC;\n         }\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < 0 || minutesOffset > 59) {\n-            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n-        }\n-        int offset = 0;\n-        try {\n-            int hoursInMinutes = hoursOffset * 60;\n-            if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset * 60; if (hoursInMinutes < 0) { throw new IllegalArgumentException(\"Minutes of range: \" + minutesOffset * 60; if (hoursInMinutes < 0) {\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset); } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset;",
        "fixed_line": "if (minutesOffset < -59 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset); } if (hoursOffset > 0 && minutesOffset < 0) { throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset); } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - Math.abs(minutesOffset);"
    },
    "Closure-112": {
        "fixes": [
            {
                "k": 1,
                "patch": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-112/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 06:47:04.909231590 +0200\n+++ /tmp/tmpmrm139i3.java\t2022-07-19 06:47:04.937231431 +0200\n@@ -1187,12 +1187,11 @@\n     if (keys.isEmpty()) {\n       return false;\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = \n-        inferTemplateTypesFromParameters(fnType, n);\n+Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n);\n \n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n     TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters( fnType, n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-112/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 06:47:58.492926156 +0200\n+++ /tmp/tmp6od8s29y.java\t2022-07-19 06:47:58.496926133 +0200\n@@ -1187,12 +1187,11 @@\n     if (keys.isEmpty()) {\n       return false;\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = \n-        inferTemplateTypesFromParameters(fnType, n);\n+Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters( fnType, n);\n \n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n     TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(allType, n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-112/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 06:48:49.192637335 +0200\n+++ /tmp/tmp_w9o9bft.java\t2022-07-19 06:48:49.196637312 +0200\n@@ -1187,12 +1187,11 @@\n     if (keys.isEmpty()) {\n       return false;\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = \n-        inferTemplateTypesFromParameters(fnType, n);\n+Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(allType, n);\n \n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n     TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(n, n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-112/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 06:48:52.924616081 +0200\n+++ /tmp/tmpzjvqjgyt.java\t2022-07-19 06:48:52.928616058 +0200\n@@ -1187,12 +1187,11 @@\n     if (keys.isEmpty()) {\n       return false;\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = \n-        inferTemplateTypesFromParameters(fnType, n);\n+Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(n, n);\n \n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n     TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(valueType, n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-112/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 06:48:56.564595353 +0200\n+++ /tmp/tmp5bedtyg2.java\t2022-07-19 06:48:56.564595353 +0200\n@@ -1187,12 +1187,11 @@\n     if (keys.isEmpty()) {\n       return false;\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = \n-        inferTemplateTypesFromParameters(fnType, n);\n+Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(valueType, n);\n \n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n     TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "Map<TemplateType,JSType> inferred = inferTemplateTypesFromParameters(fnType, n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-112/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 06:49:00.312574010 +0200\n+++ /tmp/tmp0b3p_330.java\t2022-07-19 06:49:00.316573987 +0200\n@@ -1187,12 +1187,11 @@\n     if (keys.isEmpty()) {\n       return false;\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = \n-        inferTemplateTypesFromParameters(fnType, n);\n+Map<TemplateType,JSType> inferred = inferTemplateTypesFromParameters(fnType, n);\n \n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n     TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(scope, n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-112/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 06:49:51.220284188 +0200\n+++ /tmp/tmpqa8ffd_q.java\t2022-07-19 06:49:51.224284165 +0200\n@@ -1187,12 +1187,11 @@\n     if (keys.isEmpty()) {\n       return false;\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = \n-        inferTemplateTypesFromParameters(fnType, n);\n+Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(scope, n);\n \n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n     TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(enumType, n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-112/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 06:49:55.008262629 +0200\n+++ /tmp/tmprr81mtmu.java\t2022-07-19 06:49:55.008262629 +0200\n@@ -1187,12 +1187,11 @@\n     if (keys.isEmpty()) {\n       return false;\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = \n-        inferTemplateTypesFromParameters(fnType, n);\n+Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(enumType, n);\n \n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n     TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(name, n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-112/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 06:49:58.820240933 +0200\n+++ /tmp/tmp75mfaxzn.java\t2022-07-19 06:49:58.820240933 +0200\n@@ -1187,12 +1187,11 @@\n     if (keys.isEmpty()) {\n       return false;\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = \n-        inferTemplateTypesFromParameters(fnType, n);\n+Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(name, n);\n \n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n     TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-112/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-19 06:50:02.324220991 +0200\n+++ /tmp/tmpgg_1x30b.java\t2022-07-19 06:50:02.328220968 +0200\n@@ -1187,12 +1187,11 @@\n     if (keys.isEmpty()) {\n       return false;\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = \n-        inferTemplateTypesFromParameters(fnType, n);\n+Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n));\n \n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n     TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n);",
        "fixed_line": "Map<TemplateType, JSType> inferred = Maps.filterKeys( inferTemplateTypesFromParameters(fnType, n), new Predicate<TemplateType>() { @Override public boolean apply(TemplateType key) { return keys.contains(key); }} );"
    },
    "Cli-26": {
        "fixes": [
            {
                "k": 1,
                "patch": "Option option = new Option(opt, description);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-26/src/java/org/apache/commons/cli/OptionBuilder.java\t2022-07-19 06:50:05.824201073 +0200\n+++ /tmp/tmplfn3yln0.java\t2022-07-19 06:50:05.852200915 +0200\n@@ -344,11 +344,11 @@\n      * a valid character.  See Option.\n      */\n     public static Option create(String opt) throws IllegalArgumentException\n     {\n             // create the option\n-        Option option = new Option(opt, description);\n+Option option = new Option(opt, description);\n \n             // set the option properties\n             option.setLongOpt(longopt);\n             option.setRequired(required);\n             option.setOptionalArg(optionalArg);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "Option option = new Option(opt, option);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-26/src/java/org/apache/commons/cli/OptionBuilder.java\t2022-07-19 06:50:09.292181337 +0200\n+++ /tmp/tmpljnriuno.java\t2022-07-19 06:50:09.292181337 +0200\n@@ -344,11 +344,11 @@\n      * a valid character.  See Option.\n      */\n     public static Option create(String opt) throws IllegalArgumentException\n     {\n             // create the option\n-        Option option = new Option(opt, description);\n+Option option = new Option(opt, option);\n \n             // set the option properties\n             option.setLongOpt(longopt);\n             option.setRequired(required);\n             option.setOptionalArg(optionalArg);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "Option option = new Option(opt, description + 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-26/src/java/org/apache/commons/cli/OptionBuilder.java\t2022-07-19 06:50:11.052171322 +0200\n+++ /tmp/tmpebi9kuv2.java\t2022-07-19 06:50:11.056171299 +0200\n@@ -344,11 +344,11 @@\n      * a valid character.  See Option.\n      */\n     public static Option create(String opt) throws IllegalArgumentException\n     {\n             // create the option\n-        Option option = new Option(opt, description);\n+Option option = new Option(opt, description + 1);\n \n             // set the option properties\n             option.setLongOpt(longopt);\n             option.setRequired(required);\n             option.setOptionalArg(optionalArg);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "Option option = new Option(opt, description + opt);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-26/src/java/org/apache/commons/cli/OptionBuilder.java\t2022-07-19 06:50:13.580156941 +0200\n+++ /tmp/tmpj84_tjck.java\t2022-07-19 06:50:13.580156941 +0200\n@@ -344,11 +344,11 @@\n      * a valid character.  See Option.\n      */\n     public static Option create(String opt) throws IllegalArgumentException\n     {\n             // create the option\n-        Option option = new Option(opt, description);\n+Option option = new Option(opt, description + opt);\n \n             // set the option properties\n             option.setLongOpt(longopt);\n             option.setRequired(required);\n             option.setOptionalArg(optionalArg);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "Option option = new Option(opt, description); // set the option.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-26/src/java/org/apache/commons/cli/OptionBuilder.java\t2022-07-19 06:50:15.956143415 +0200\n+++ /tmp/tmpv3pvxcux.java\t2022-07-19 06:50:15.960143392 +0200\n@@ -344,11 +344,11 @@\n      * a valid character.  See Option.\n      */\n     public static Option create(String opt) throws IllegalArgumentException\n     {\n             // create the option\n-        Option option = new Option(opt, description);\n+Option option = new Option(opt, description); // set the option.\n \n             // set the option properties\n             option.setLongOpt(longopt);\n             option.setRequired(required);\n             option.setOptionalArg(optionalArg);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "Option option = new Option(opt, description); // set the",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-26/src/java/org/apache/commons/cli/OptionBuilder.java\t2022-07-19 06:50:18.328129918 +0200\n+++ /tmp/tmp7c7o8tb5.java\t2022-07-19 06:50:18.328129918 +0200\n@@ -344,11 +344,11 @@\n      * a valid character.  See Option.\n      */\n     public static Option create(String opt) throws IllegalArgumentException\n     {\n             // create the option\n-        Option option = new Option(opt, description);\n+Option option = new Option(opt, description); // set the\n \n             // set the option properties\n             option.setLongOpt(longopt);\n             option.setRequired(required);\n             option.setOptionalArg(optionalArg);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "Option option = new Option(opt, description); // set on the option.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-26/src/java/org/apache/commons/cli/OptionBuilder.java\t2022-07-19 06:50:20.796115875 +0200\n+++ /tmp/tmph42ncizp.java\t2022-07-19 06:50:20.796115875 +0200\n@@ -344,11 +344,11 @@\n      * a valid character.  See Option.\n      */\n     public static Option create(String opt) throws IllegalArgumentException\n     {\n             // create the option\n-        Option option = new Option(opt, description);\n+Option option = new Option(opt, description); // set on the option.\n \n             // set the option properties\n             option.setLongOpt(longopt);\n             option.setRequired(required);\n             option.setOptionalArg(optionalArg);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "Option option = new Option(opt, description); // set via this class not be null",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-26/src/java/org/apache/commons/cli/OptionBuilder.java\t2022-07-19 06:50:23.196102219 +0200\n+++ /tmp/tmpuhizdy2a.java\t2022-07-19 06:50:23.200102196 +0200\n@@ -344,11 +344,11 @@\n      * a valid character.  See Option.\n      */\n     public static Option create(String opt) throws IllegalArgumentException\n     {\n             // create the option\n-        Option option = new Option(opt, description);\n+Option option = new Option(opt, description); // set via this class not be null\n \n             // set the option properties\n             option.setLongOpt(longopt);\n             option.setRequired(required);\n             option.setOptionalArg(optionalArg);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "Option option = new Option(opt, description); // set the option",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-26/src/java/org/apache/commons/cli/OptionBuilder.java\t2022-07-19 06:50:25.652088244 +0200\n+++ /tmp/tmpeivkhuij.java\t2022-07-19 06:50:25.668088154 +0200\n@@ -344,11 +344,11 @@\n      * a valid character.  See Option.\n      */\n     public static Option create(String opt) throws IllegalArgumentException\n     {\n             // create the option\n-        Option option = new Option(opt, description);\n+Option option = new Option(opt, description); // set the option\n \n             // set the option properties\n             option.setLongOpt(longopt);\n             option.setRequired(required);\n             option.setOptionalArg(optionalArg);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "Option option = new Option(opt, description); // option.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-26/src/java/org/apache/commons/cli/OptionBuilder.java\t2022-07-19 06:50:27.996074907 +0200\n+++ /tmp/tmpnzyqabrw.java\t2022-07-19 06:50:27.996074907 +0200\n@@ -344,11 +344,11 @@\n      * a valid character.  See Option.\n      */\n     public static Option create(String opt) throws IllegalArgumentException\n     {\n             // create the option\n-        Option option = new Option(opt, description);\n+Option option = new Option(opt, description); // option.\n \n             // set the option properties\n             option.setLongOpt(longopt);\n             option.setRequired(required);\n             option.setOptionalArg(optionalArg);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "Option option = new Option(opt, description);",
        "fixed_line": "Option option = null; try { // create the option option = new Option(opt, description); // set the option properties option.setLongOpt(longopt); option.setRequired(required); option.setOptionalArg(optionalArg); option.setArgs(numberOfArgs); option.setType(type); option.setValueSeparator(valuesep); option.setArgName(argName); } finally { // reset the OptionBuilder properties OptionBuilder.reset(); }"
    },
    "JacksonDatabind-8": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (oldOne.getClass() == newOne.getClass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-8/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\t2022-07-19 06:50:30.752059226 +0200\n+++ /tmp/tmp58pyhbpp.java\t2022-07-19 06:50:30.884058476 +0200\n@@ -289,11 +289,11 @@\n                 // both explicit: verify\n                 // otherwise only verify if neither explicitly annotated.\n             }\n \n             // one more thing: ok to override in sub-class\n-            if (oldOne.getClass() == newOne.getClass()) {\n+if (oldOne.getClass() == newOne.getClass()) {\n                 // [databind#667]: avoid one particular class of bogus problems\n \n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                 // otherwise, which one to choose?\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (_oldOne.getClass() == newOne.getClass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-8/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\t2022-07-19 06:51:02.399879184 +0200\n+++ /tmp/tmpz3kyluy8.java\t2022-07-19 06:51:02.399879184 +0200\n@@ -289,11 +289,11 @@\n                 // both explicit: verify\n                 // otherwise only verify if neither explicitly annotated.\n             }\n \n             // one more thing: ok to override in sub-class\n-            if (oldOne.getClass() == newOne.getClass()) {\n+if (_oldOne.getClass() == newOne.getClass()) {\n                 // [databind#667]: avoid one particular class of bogus problems\n \n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                 // otherwise, which one to choose?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (oldOne.getClass() == newOne.getClass()) { // as per [JACKSON-407] --raw)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-8/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\t2022-07-19 06:51:04.151869220 +0200\n+++ /tmp/tmpj8v4406u.java\t2022-07-19 06:51:04.151869220 +0200\n@@ -289,11 +289,11 @@\n                 // both explicit: verify\n                 // otherwise only verify if neither explicitly annotated.\n             }\n \n             // one more thing: ok to override in sub-class\n-            if (oldOne.getClass() == newOne.getClass()) {\n+if (oldOne.getClass() == newOne.getClass()) { // as per [JACKSON-407] --raw)\n                 // [databind#667]: avoid one particular class of bogus problems\n \n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                 // otherwise, which one to choose?\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (oldOne.getClass() == newOne.getClass()) { // as per [JACKSON-407] --raw == newOne.getClass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-8/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\t2022-07-19 06:51:33.339703215 +0200\n+++ /tmp/tmpnq_edifp.java\t2022-07-19 06:51:33.339703215 +0200\n@@ -289,11 +289,11 @@\n                 // both explicit: verify\n                 // otherwise only verify if neither explicitly annotated.\n             }\n \n             // one more thing: ok to override in sub-class\n-            if (oldOne.getClass() == newOne.getClass()) {\n+if (oldOne.getClass() == newOne.getClass()) { // as per [JACKSON-407] --raw == newOne.getClass()) {\n                 // [databind#667]: avoid one particular class of bogus problems\n \n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                 // otherwise, which one to choose?\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (oldOne.getClass() == newOne.getClass()) { // as per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-8/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\t2022-07-19 06:52:01.939540590 +0200\n+++ /tmp/tmpaqyvy7k1.java\t2022-07-19 06:52:01.939540590 +0200\n@@ -289,11 +289,11 @@\n                 // both explicit: verify\n                 // otherwise only verify if neither explicitly annotated.\n             }\n \n             // one more thing: ok to override in sub-class\n-            if (oldOne.getClass() == newOne.getClass()) {\n+if (oldOne.getClass() == newOne.getClass()) { // as per [JACKSON-407] -- allow disabling wrapping for\n                 // [databind#667]: avoid one particular class of bogus problems\n \n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                 // otherwise, which one to choose?\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (oldOne.getClass()!= newOne.getClass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-8/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\t2022-07-19 06:52:31.359373338 +0200\n+++ /tmp/tmpx572511i.java\t2022-07-19 06:52:31.359373338 +0200\n@@ -289,11 +289,11 @@\n                 // both explicit: verify\n                 // otherwise only verify if neither explicitly annotated.\n             }\n \n             // one more thing: ok to override in sub-class\n-            if (oldOne.getClass() == newOne.getClass()) {\n+if (oldOne.getClass()!= newOne.getClass()) {\n                 // [databind#667]: avoid one particular class of bogus problems\n \n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                 // otherwise, which one to choose?\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (oldOne.getClass() == newOne.getClass()) { // could still be null",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-8/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\t2022-07-19 06:53:00.227209256 +0200\n+++ /tmp/tmpr286lr0q.java\t2022-07-19 06:53:00.227209256 +0200\n@@ -289,11 +289,11 @@\n                 // both explicit: verify\n                 // otherwise only verify if neither explicitly annotated.\n             }\n \n             // one more thing: ok to override in sub-class\n-            if (oldOne.getClass() == newOne.getClass()) {\n+if (oldOne.getClass() == newOne.getClass()) { // could still be null\n                 // [databind#667]: avoid one particular class of bogus problems\n \n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                 // otherwise, which one to choose?\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (oldOne.getClass() == newOne.getClass()) { // as per [JACKSON-407] -- allow use a newOne.getClass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-8/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\t2022-07-19 06:53:28.603047998 +0200\n+++ /tmp/tmpby8rb2v1.java\t2022-07-19 06:53:28.603047998 +0200\n@@ -289,11 +289,11 @@\n                 // both explicit: verify\n                 // otherwise only verify if neither explicitly annotated.\n             }\n \n             // one more thing: ok to override in sub-class\n-            if (oldOne.getClass() == newOne.getClass()) {\n+if (oldOne.getClass() == newOne.getClass()) { // as per [JACKSON-407] -- allow use a newOne.getClass()) {\n                 // [databind#667]: avoid one particular class of bogus problems\n \n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                 // otherwise, which one to choose?\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (oldOne.getClass() == newOne.getClass()) { // as per [JACKSON-407] -- allow disabling wrapping for the",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-8/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\t2022-07-19 06:53:57.374884522 +0200\n+++ /tmp/tmpzqsooboy.java\t2022-07-19 06:53:57.378884499 +0200\n@@ -289,11 +289,11 @@\n                 // both explicit: verify\n                 // otherwise only verify if neither explicitly annotated.\n             }\n \n             // one more thing: ok to override in sub-class\n-            if (oldOne.getClass() == newOne.getClass()) {\n+if (oldOne.getClass() == newOne.getClass()) { // as per [JACKSON-407] -- allow disabling wrapping for the\n                 // [databind#667]: avoid one particular class of bogus problems\n \n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                 // otherwise, which one to choose?\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (oldOne.getClass() == newOne.getClass()) { // should never be null",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-8/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\t2022-07-19 06:54:26.442719390 +0200\n+++ /tmp/tmp6ehdaz_s.java\t2022-07-19 06:54:26.442719390 +0200\n@@ -289,11 +289,11 @@\n                 // both explicit: verify\n                 // otherwise only verify if neither explicitly annotated.\n             }\n \n             // one more thing: ok to override in sub-class\n-            if (oldOne.getClass() == newOne.getClass()) {\n+if (oldOne.getClass() == newOne.getClass()) { // should never be null\n                 // [databind#667]: avoid one particular class of bogus problems\n \n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                 // otherwise, which one to choose?\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (oldOne.getClass() == newOne.getClass()) {",
        "fixed_line": "boolean verify; if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is // but skip, if new one not annotated if (!explicit) { return; } // both explicit: verify verify = true; } else { // otherwise only verify if neither explicitly annotated. verify = !explicit; } // one more thing: ok to override in sub-class if (verify && (oldOne.getClass() == newOne.getClass())) { // [databind#667]: avoid one particular class of bogus problems Class<?> oldType = oldOne.getRawParameterType(0); Class<?> newType = newOne.getRawParameterType(0); if (oldType == newType) { throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex] +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne); } // otherwise, which one to choose? if (newType.isAssignableFrom(oldType)) { // new type more generic, use old return; }"
    },
    "Mockito-26": {
        "fixes": [
            {
                "k": 1,
                "patch": "primitiveValues.put(double.class, 0);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-26/src/org/mockito/internal/util/Primitives.java\t2022-07-19 06:54:55.526554194 +0200\n+++ /tmp/tmplykmd7en.java\t2022-07-19 06:54:55.586553852 +0200\n@@ -61,8 +61,8 @@\n         primitiveValues.put(byte.class, (byte) 0);\n         primitiveValues.put(short.class, (short) 0);\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+primitiveValues.put(double.class, 0);\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "primitiveValues.put(double.class, 0); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-26/src/org/mockito/internal/util/Primitives.java\t2022-07-19 06:55:25.890381750 +0200\n+++ /tmp/tmpezo50p85.java\t2022-07-19 06:55:25.890381750 +0200\n@@ -61,8 +61,8 @@\n         primitiveValues.put(byte.class, (byte) 0);\n         primitiveValues.put(short.class, (short) 0);\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+primitiveValues.put(double.class, 0); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "primitiveValues.put(double.class, 0); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-26/src/org/mockito/internal/util/Primitives.java\t2022-07-19 06:55:56.382208608 +0200\n+++ /tmp/tmplx09d5zl.java\t2022-07-19 06:55:56.382208608 +0200\n@@ -61,8 +61,8 @@\n         primitiveValues.put(byte.class, (byte) 0);\n         primitiveValues.put(short.class, (short) 0);\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+primitiveValues.put(double.class, 0); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "primitiveValues.put(double.class, 0); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-26/src/org/mockito/internal/util/Primitives.java\t2022-07-19 06:56:26.930035170 +0200\n+++ /tmp/tmpz7khywqv.java\t2022-07-19 06:56:26.930035170 +0200\n@@ -61,8 +61,8 @@\n         primitiveValues.put(byte.class, (byte) 0);\n         primitiveValues.put(short.class, (short) 0);\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+primitiveValues.put(double.class, 0); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "primitiveValues.put(double.class, 0); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-26/src/org/mockito/internal/util/Primitives.java\t2022-07-19 06:56:57.533861437 +0200\n+++ /tmp/tmpy1xh6fy1.java\t2022-07-19 06:56:57.533861437 +0200\n@@ -61,8 +61,8 @@\n         primitiveValues.put(byte.class, (byte) 0);\n         primitiveValues.put(short.class, (short) 0);\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+primitiveValues.put(double.class, 0); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnot real number\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "primitiveValues.put(double.class, 0); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-26/src/org/mockito/internal/util/Primitives.java\t2022-07-19 06:57:27.885689158 +0200\n+++ /tmp/tmpxvk2hp4r.java\t2022-07-19 06:57:27.885689158 +0200\n@@ -61,8 +61,8 @@\n         primitiveValues.put(byte.class, (byte) 0);\n         primitiveValues.put(short.class, (short) 0);\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+primitiveValues.put(double.class, 0); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "primitiveValues.put(double.class, 0); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-26/src/org/mockito/internal/util/Primitives.java\t2022-07-19 06:57:58.441515740 +0200\n+++ /tmp/tmp6or6n9om.java\t2022-07-19 06:57:58.445515717 +0200\n@@ -61,8 +61,8 @@\n         primitiveValues.put(byte.class, (byte) 0);\n         primitiveValues.put(short.class, (short) 0);\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+primitiveValues.put(double.class, 0); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnotnot real number\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "primitiveValues.put(double.class, 0); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-26/src/org/mockito/internal/util/Primitives.java\t2022-07-19 06:58:28.913342816 +0200\n+++ /tmp/tmpf9c2qy9s.java\t2022-07-19 06:58:28.913342816 +0200\n@@ -61,8 +61,8 @@\n         primitiveValues.put(byte.class, (byte) 0);\n         primitiveValues.put(short.class, (short) 0);\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+primitiveValues.put(double.class, 0); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "primitiveValues.put(double.class, 0); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-26/src/org/mockito/internal/util/Primitives.java\t2022-07-19 06:58:59.185171046 +0200\n+++ /tmp/tmpo5npki_p.java\t2022-07-19 06:58:59.185171046 +0200\n@@ -61,8 +61,8 @@\n         primitiveValues.put(byte.class, (byte) 0);\n         primitiveValues.put(short.class, (short) 0);\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+primitiveValues.put(double.class, 0); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnotnotnot real number\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "primitiveValues.put(double.class, 0); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-26/src/org/mockito/internal/util/Primitives.java\t2022-07-19 06:59:29.804997318 +0200\n+++ /tmp/tmpy4_zbn99.java\t2022-07-19 06:59:29.808997296 +0200\n@@ -61,8 +61,8 @@\n         primitiveValues.put(byte.class, (byte) 0);\n         primitiveValues.put(short.class, (short) 0);\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+primitiveValues.put(double.class, 0); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnotnotnotnot real number\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "primitiveValues.put(double.class, 0);",
        "fixed_line": "primitiveValues.put(double.class, 0D);"
    },
    "Mockito-37": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (answer instanceof DoesNothing) {",
                "patch_diff": "if (answer instanceof DoesNothing) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (answer instanceof DoesNothing) {",
                "patch_diff": "} else if (answer instanceof DoesNothing) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (answer instanceof DoesNothing) { if (answer instanceof DoesNothing) {",
                "patch_diff": "if (answer instanceof DoesNothing) { if (answer instanceof DoesNothing) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "else if (answer instanceof DoesNothing) {",
                "patch_diff": "else if (answer instanceof DoesNothing) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private staticSetToDoNothing(); } else if (answer instanceof DoesNothing) {",
                "patch_diff": "private staticSetToDoNothing(); } else if (answer instanceof DoesNothing) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (answer instanceof DoesNothing) { if (answer instanceof DoesNothing(); } else if (answer instanceof DoesNothing) {",
                "patch_diff": "if (answer instanceof DoesNothing) { if (answer instanceof DoesNothing(); } else if (answer instanceof DoesNothing) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (answer instanceof DoesNothing) { if (answer instanceof DoesNothing(); } else {",
                "patch_diff": "if (answer instanceof DoesNothing) { if (answer instanceof DoesNothing(); } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "private staticSetToDoNothing(); } else if (answer instanceof DoesNothing {",
                "patch_diff": "private staticSetToDoNothing(); } else if (answer instanceof DoesNothing {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (answer instanceof DoesNothing {",
                "patch_diff": "if (answer instanceof DoesNothing {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (answer instanceof DoesNothing) { if (answer instanceof DoesNothing(); } else if (answer instanceof DoesNothing {",
                "patch_diff": "if (answer instanceof DoesNothing) { if (answer instanceof DoesNothing(); } else if (answer instanceof DoesNothing {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (answer instanceof CallsRealMethods) { validateMockingConcreteClass((CallsRealMethods) answer, invocation); } } private void validateMockingConcreteClass(CallsRealMethods answer, Invocation invocation) { if (invocation.getMethod().getDeclaringClass().isInterface()) { reporter.cannotCallRealMethodOnInterface(); } }"
    },
    "Math-33": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (entry.compareTo(entry, 0d, maxUlps) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2022-07-19 07:00:02.044814415 +0200\n+++ /tmp/tmpasgm0y4u.java\t2022-07-19 07:00:02.064814302 +0200\n@@ -333,11 +333,11 @@\n         columnsToDrop.add(0);\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+if (entry.compareTo(entry, 0d, maxUlps) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n \n         // non-basic artificial variables\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (sum.compareTo(entry, 0d, maxUlps) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2022-07-19 07:00:04.260801844 +0200\n+++ /tmp/tmp6plrua2y.java\t2022-07-19 07:00:04.260801844 +0200\n@@ -333,11 +333,11 @@\n         columnsToDrop.add(0);\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+if (sum.compareTo(entry, 0d, maxUlps) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n \n         // non-basic artificial variables\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (trim.compareTo(entry, 0d, maxUlps) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2022-07-19 07:00:06.412789636 +0200\n+++ /tmp/tmpbgxknkyb.java\t2022-07-19 07:00:06.412789636 +0200\n@@ -333,11 +333,11 @@\n         columnsToDrop.add(0);\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+if (trim.compareTo(entry, 0d, maxUlps) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n \n         // non-basic artificial variables\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (groups.compareTo(entry, 0d, maxUlps) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2022-07-19 07:00:08.516777700 +0200\n+++ /tmp/tmp9ogn0kkq.java\t2022-07-19 07:00:08.516777700 +0200\n@@ -333,11 +333,11 @@\n         columnsToDrop.add(0);\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+if (groups.compareTo(entry, 0d, maxUlps) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n \n         // non-basic artificial variables\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (s.compareTo(entry, 0d, maxUlps) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2022-07-19 07:00:10.592765925 +0200\n+++ /tmp/tmp7s13dndn.java\t2022-07-19 07:00:10.592765925 +0200\n@@ -333,11 +333,11 @@\n         columnsToDrop.add(0);\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+if (s.compareTo(entry, 0d, maxUlps) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n \n         // non-basic artificial variables\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (showDifference.compareTo(entry, 0d, maxUlps) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2022-07-19 07:00:12.676754101 +0200\n+++ /tmp/tmpvs98_olb.java\t2022-07-19 07:00:12.676754101 +0200\n@@ -333,11 +333,11 @@\n         columnsToDrop.add(0);\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+if (showDifference.compareTo(entry, 0d, maxUlps) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n \n         // non-basic artificial variables\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (in.compareTo(entry, 0d, maxUlps) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2022-07-19 07:00:14.772742211 +0200\n+++ /tmp/tmpbj2gwaaa.java\t2022-07-19 07:00:14.772742211 +0200\n@@ -333,11 +333,11 @@\n         columnsToDrop.add(0);\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+if (in.compareTo(entry, 0d, maxUlps) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n \n         // non-basic artificial variables\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (font.compareTo(entry, 0d, maxUlps) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2022-07-19 07:00:16.836730505 +0200\n+++ /tmp/tmp3c1hlf6r.java\t2022-07-19 07:00:16.836730505 +0200\n@@ -333,11 +333,11 @@\n         columnsToDrop.add(0);\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+if (font.compareTo(entry, 0d, maxUlps) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n \n         // non-basic artificial variables\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (m.compareTo(entry, 0d, maxUlps) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2022-07-19 07:00:19.012718160 +0200\n+++ /tmp/tmp5e7rzylh.java\t2022-07-19 07:00:19.012718160 +0200\n@@ -333,11 +333,11 @@\n         columnsToDrop.add(0);\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+if (m.compareTo(entry, 0d, maxUlps) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n \n         // non-basic artificial variables\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (show.compareTo(entry, 0d, maxUlps) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2022-07-19 07:00:21.280705294 +0200\n+++ /tmp/tmpb2miipx1.java\t2022-07-19 07:00:21.280705294 +0200\n@@ -333,11 +333,11 @@\n         columnsToDrop.add(0);\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+if (show.compareTo(entry, 0d, maxUlps) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n \n         // non-basic artificial variables\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (Precision.compareTo(entry, 0d, maxUlps) > 0) {",
        "fixed_line": "if (Precision.compareTo(entry, 0d, epsilon) > 0) {"
    },
    "JacksonCore-13": {
        "fixes": [
            {
                "k": 1,
                "patch": "_cfgUnqNames = newFeatureFeature.QUOTE_FIELD_NAMES;",
                "patch_diff": "_cfgUnqNames = newFeatureFeature.QUOTE_FIELD_NAMES;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "_cfgUnqNames = newFeatureFeature.QUOTE_NAMES;",
                "patch_diff": "_cfgUnqNames = newFeatureFeature.QUOTE_NAMES;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "_cfgUnqNames = newFeatureFeature(newFeature.QUOTE_FIELD_NAMES, changedFeatures);",
                "patch_diff": "_cfgUnqNames = newFeatureFeature(newFeature.QUOTE_FIELD_NAMES, changedFeatures);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "_cfgUnqNames = newFeatureFeature(newFeature.QUOTE_FIELD_NAMES);",
                "patch_diff": "_cfgUnqNames = newFeatureFeature(newFeature.QUOTE_FIELD_NAMES);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "_cfgUnqNames = newFeature(newFeature.QUOTE_FIELD_NAMES, changedFeatures);",
                "patch_diff": "_cfgUnqNames = newFeature(newFeature.QUOTE_FIELD_NAMES, changedFeatures);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "_cfgUnqNames = newFeature();",
                "patch_diff": "_cfgUnqNames = newFeature();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "_cfgUnqNames = newFeature(newFeature.QUOTE_FIELD_NAMES);",
                "patch_diff": "_cfgUnqNames = newFeature(newFeature.QUOTE_FIELD_NAMES);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "_cfgUnqNames = newFeatureFeature.QUOTE_ARRAY;",
                "patch_diff": "_cfgUnqNames = newFeatureFeature.QUOTE_ARRAY;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "_cfgUnqNames = newFeatureFeature(newFeature.QUOTE_FIELD_NAMES));",
                "patch_diff": "_cfgUnqNames = newFeatureFeature(newFeature.QUOTE_FIELD_NAMES));",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "_cfgUnqNames = newFeatureFeature.QUOTE_FIELD_NAMES; }",
                "patch_diff": "_cfgUnqNames = newFeatureFeature.QUOTE_FIELD_NAMES; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "@Override public JsonGenerator disable(Feature f) { super.disable(f); if (f == Feature.QUOTE_FIELD_NAMES) { _cfgUnqNames = true; } return this; }"
    },
    "Closure-81": {
        "fixes": [
            {
                "k": 1,
                "patch": "Name name = functionNode.getFunctionName();",
                "patch_diff": "Name name = functionNode.getFunctionName();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "name = functionNode.getFunctionName();",
                "patch_diff": "name = functionNode.getFunctionName();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// name = functionNode.getFunctionName();",
                "patch_diff": "// name = functionNode.getFunctionName();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// name = functionNode.getFunctionName(); Boolean isUnnamedFunction = false;",
                "patch_diff": "// name = functionNode.getFunctionName(); Boolean isUnnamedFunction = false;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// name = functionNode.getFunctionName(); Boolean isUnnamedFunction = true;",
                "patch_diff": "// name = functionNode.getFunctionName(); Boolean isUnnamedFunction = true;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int name = functionNode.getFunctionName();",
                "patch_diff": "int name = functionNode.getFunctionName();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "name = functionNode.getFunctionName(); Boolean isUnnamedFunction = false;",
                "patch_diff": "name = functionNode.getFunctionName(); Boolean isUnnamedFunction = false;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "Name name = functionNode.getFunctionName(); Boolean isUnnamedFunction = false;",
                "patch_diff": "Name name = functionNode.getFunctionName(); Boolean isUnnamedFunction = false;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "Name name = functionNode.getFunctionName(); Boolean isUnnamedFunction = true;",
                "patch_diff": "Name name = functionNode.getFunctionName(); Boolean isUnnamedFunction = true;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "name = functionNode.getFunctionName(); Boolean isUnnamedFunction = true;",
                "patch_diff": "name = functionNode.getFunctionName(); Boolean isUnnamedFunction = true;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "int functionType = functionNode.getFunctionType(); if (functionType != FunctionNode.FUNCTION_EXPRESSION) { errorReporter.error( \"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0); }"
    },
    "JacksonDatabind-27": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (ext.handlePropertyValue(jp, ctxt, propName, buffer)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-27/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 07:00:26.940673187 +0200\n+++ /tmp/tmpitblv2mw.java\t2022-07-19 07:00:26.964673052 +0200\n@@ -789,11 +789,11 @@\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+if (ext.handlePropertyValue(jp, ctxt, propName, buffer)) {\n                     ;\n                 } else {\n                     // Last creator property to set?\n                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                         t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (ext.handlePropertyValue(p, propName, buffer)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-27/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 07:00:28.812662570 +0200\n+++ /tmp/tmpjcwec7yo.java\t2022-07-19 07:00:28.816662547 +0200\n@@ -789,11 +789,11 @@\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+if (ext.handlePropertyValue(p, propName, buffer)) {\n                     ;\n                 } else {\n                     // Last creator property to set?\n                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                         t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (ext.handlePropertyValue(p, propName, ctxt)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-27/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 07:00:30.676651996 +0200\n+++ /tmp/tmpehgewk2j.java\t2022-07-19 07:00:30.676651996 +0200\n@@ -789,11 +789,11 @@\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+if (ext.handlePropertyValue(p, propName, ctxt)) {\n                     ;\n                 } else {\n                     // Last creator property to set?\n                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                         t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (ext.handlePropertyValue(jp, ctxt, buffer, propName, buffer)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-27/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 07:00:32.508641602 +0200\n+++ /tmp/tmp7egff9ar.java\t2022-07-19 07:00:32.508641602 +0200\n@@ -789,11 +789,11 @@\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+if (ext.handlePropertyValue(jp, ctxt, buffer, propName, buffer)) {\n                     ;\n                 } else {\n                     // Last creator property to set?\n                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                         t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (ext.handlePropertyValue(jp, ctxt, buffer)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-27/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 07:00:34.396630894 +0200\n+++ /tmp/tmpdvl50bpb.java\t2022-07-19 07:00:34.396630894 +0200\n@@ -789,11 +789,11 @@\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+if (ext.handlePropertyValue(jp, ctxt, buffer)) {\n                     ;\n                 } else {\n                     // Last creator property to set?\n                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                         t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (ext.handlePropertyValue(jp, ctxt, buffer, propName, bean)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-27/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 07:00:36.220620548 +0200\n+++ /tmp/tmpimjf7ea2.java\t2022-07-19 07:00:36.220620548 +0200\n@@ -789,11 +789,11 @@\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+if (ext.handlePropertyValue(jp, ctxt, buffer, propName, bean)) {\n                     ;\n                 } else {\n                     // Last creator property to set?\n                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                         t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (ext.handlePropertyValue(g2, ctxt, propName, buffer)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-27/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 07:00:37.940610792 +0200\n+++ /tmp/tmp6yukd9g7.java\t2022-07-19 07:00:37.940610792 +0200\n@@ -789,11 +789,11 @@\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+if (ext.handlePropertyValue(g2, ctxt, propName, buffer)) {\n                     ;\n                 } else {\n                     // Last creator property to set?\n                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                         t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (ext.handlePropertyValue(p, propName, ctxt, buffer)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-27/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 07:00:39.748600537 +0200\n+++ /tmp/tmpu3n20r45.java\t2022-07-19 07:00:39.748600537 +0200\n@@ -789,11 +789,11 @@\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+if (ext.handlePropertyValue(p, propName, ctxt, buffer)) {\n                     ;\n                 } else {\n                     // Last creator property to set?\n                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                         t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (ext.handlePropertyValue(ctxt, propName, buffer)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-27/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 07:00:41.456590847 +0200\n+++ /tmp/tmp_1grn2fj.java\t2022-07-19 07:00:41.456590847 +0200\n@@ -789,11 +789,11 @@\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+if (ext.handlePropertyValue(ctxt, propName, buffer)) {\n                     ;\n                 } else {\n                     // Last creator property to set?\n                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                         t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (ext.handlePropertyValue(p, propName, ctxt); } else {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-27/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-19 07:00:43.148581250 +0200\n+++ /tmp/tmp0z4e2g0o.java\t2022-07-19 07:00:43.152581227 +0200\n@@ -789,11 +789,11 @@\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+if (ext.handlePropertyValue(p, propName, ctxt); } else {\n                     ;\n                 } else {\n                     // Last creator property to set?\n                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                         t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {",
        "fixed_line": "if (ext.handlePropertyValue(p, ctxt, propName, null)) {"
    },
    "Lang-24": {
        "fixes": [
            {
                "k": 1,
                "patch": "return foundDigit &&!hasExp; // we need to do a digit after the E",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-24/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 07:00:44.940571086 +0200\n+++ /tmp/tmpp19c2q76.java\t2022-07-19 07:00:44.964570948 +0200\n@@ -1408,11 +1408,11 @@\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+return foundDigit &&!hasExp; // we need to do a digit after the E\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return foundDigit &&!hasExp; // we need to do a digit after the foundDigit",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-24/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 07:00:54.884514681 +0200\n+++ /tmp/tmptjgv8ap3.java\t2022-07-19 07:00:54.900514591 +0200\n@@ -1408,11 +1408,11 @@\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+return foundDigit &&!hasExp; // we need to do a digit after the foundDigit\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return foundDigit &&!hasExp; // we need to do a digit after the",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-24/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 07:01:04.564459777 +0200\n+++ /tmp/tmp2aza420s.java\t2022-07-19 07:01:04.564459777 +0200\n@@ -1408,11 +1408,11 @@\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+return foundDigit &&!hasExp; // we need to do a digit after the\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return foundDigit &&!hasExp; // we need to check whether a digit after the E",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-24/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 07:01:14.012406188 +0200\n+++ /tmp/tmpq_jn9ukt.java\t2022-07-19 07:01:14.012406188 +0200\n@@ -1408,11 +1408,11 @@\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+return foundDigit &&!hasExp; // we need to check whether a digit after the E\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return foundDigit &&!hasExp; // we need to do a digit after this",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-24/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 07:01:23.552352081 +0200\n+++ /tmp/tmpqeujbzyy.java\t2022-07-19 07:01:23.552352081 +0200\n@@ -1408,11 +1408,11 @@\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+return foundDigit &&!hasExp; // we need to do a digit after this\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return foundDigit &&!hasExp; // we need to do a digit after type",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-24/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 07:01:33.204297337 +0200\n+++ /tmp/tmp3eyv41q9.java\t2022-07-19 07:01:33.204297337 +0200\n@@ -1408,11 +1408,11 @@\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+return foundDigit &&!hasExp; // we need to do a digit after type\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return foundDigit &&!hasExp; // we need a digit after the E",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-24/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 07:01:42.584244138 +0200\n+++ /tmp/tmpcabyymwr.java\t2022-07-19 07:01:42.584244138 +0200\n@@ -1408,11 +1408,11 @@\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+return foundDigit &&!hasExp; // we need a digit after the E\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return foundDigit &&!hasExp;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-24/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 07:01:52.152189875 +0200\n+++ /tmp/tmp_pgmwo86.java\t2022-07-19 07:01:52.152189875 +0200\n@@ -1408,11 +1408,11 @@\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+return foundDigit &&!hasExp;\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return foundDigit &&!allowSigns;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-24/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 07:02:01.636136089 +0200\n+++ /tmp/tmpqz2ljw91.java\t2022-07-19 07:02:01.636136089 +0200\n@@ -1408,11 +1408,11 @@\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+return foundDigit &&!allowSigns;\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return foundDigit &&!foundDigit;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-24/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 07:02:11.084082509 +0200\n+++ /tmp/tmpm853mllf.java\t2022-07-19 07:02:11.088082486 +0200\n@@ -1408,11 +1408,11 @@\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+return foundDigit &&!foundDigit;\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return foundDigit && !hasExp;",
        "fixed_line": "return foundDigit && !hasExp && !hasDecPoint;"
    },
    "Mockito-24": {
        "fixes": [
            {
                "k": 1,
                "patch": "return 0; // let's do implicit rereturnType",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-24/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\t2022-07-19 07:02:20.844028623 +0200\n+++ /tmp/tmp50refy_c.java\t2022-07-19 07:02:20.972028129 +0200\n@@ -71,11 +71,11 @@\n             }\n         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+return 0; // let's do implicit rereturnType\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n         return returnValueFor(returnType);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return 0; // let's do implicit re-closed",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-24/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\t2022-07-19 07:02:57.803881972 +0200\n+++ /tmp/tmpk40z8_uk.java\t2022-07-19 07:02:57.803881972 +0200\n@@ -71,11 +71,11 @@\n             }\n         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+return 0; // let's do implicit re-closed\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n         return returnValueFor(returnType);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return 0; // let's do implicit re-returnType",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-24/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\t2022-07-19 07:03:32.631740234 +0200\n+++ /tmp/tmpxfeg5z_t.java\t2022-07-19 07:03:32.631740234 +0200\n@@ -71,11 +71,11 @@\n             }\n         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+return 0; // let's do implicit re-returnType\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n         return returnValueFor(returnType);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return 0; // let's do implicit re-literals",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-24/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\t2022-07-19 07:04:06.827597946 +0200\n+++ /tmp/tmpgmj5tt1h.java\t2022-07-19 07:04:06.827597946 +0200\n@@ -71,11 +71,11 @@\n             }\n         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+return 0; // let's do implicit re-literals\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n         return returnValueFor(returnType);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return 0; // let's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-24/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\t2022-07-19 07:04:41.395451164 +0200\n+++ /tmp/tmpv63ue94u.java\t2022-07-19 07:04:41.395451164 +0200\n@@ -71,11 +71,11 @@\n             }\n         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+return 0; // let's do implicit re-parse\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n         return returnValueFor(returnType);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return 0; // never be null or EMPTY",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-24/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\t2022-07-19 07:05:16.107300993 +0200\n+++ /tmp/tmpdrg1oqw3.java\t2022-07-19 07:05:16.107300993 +0200\n@@ -71,11 +71,11 @@\n             }\n         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+return 0; // never be null or EMPTY\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n         return returnValueFor(returnType);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return 0; // should never be null or EMPTY",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-24/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\t2022-07-19 07:05:50.471149757 +0200\n+++ /tmp/tmp5lxp01dh.java\t2022-07-19 07:05:50.475149739 +0200\n@@ -71,11 +71,11 @@\n             }\n         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+return 0; // should never be null or EMPTY\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n         return returnValueFor(returnType);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return 0; // let's do implicit re-initialized or EMPTY",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-24/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\t2022-07-19 07:06:24.790996334 +0200\n+++ /tmp/tmpp13ry8az.java\t2022-07-19 07:06:24.794996317 +0200\n@@ -71,11 +71,11 @@\n             }\n         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+return 0; // let's do implicit re-initialized or EMPTY\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n         return returnValueFor(returnType);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return 0; // let's do implicit re-signatures",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-24/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\t2022-07-19 07:06:59.318839738 +0200\n+++ /tmp/tmpzgo3cagv.java\t2022-07-19 07:06:59.318839738 +0200\n@@ -71,11 +71,11 @@\n             }\n         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+return 0; // let's do implicit re-signatures\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n         return returnValueFor(returnType);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return 0; // let's do implicit re-407] -- allow disabling wrapping for",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-24/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\t2022-07-19 07:07:33.874680904 +0200\n+++ /tmp/tmp43840r9k.java\t2022-07-19 07:07:33.874680904 +0200\n@@ -71,11 +71,11 @@\n             }\n         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+return 0; // let's do implicit re-407] -- allow disabling wrapping for\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n         return returnValueFor(returnType);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return 1;",
        "fixed_line": "return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;"
    },
    "Closure-88": {
        "fixes": [
            {
                "k": 1,
                "patch": "return VariableLhs.equals(n.getString())) {",
                "patch_diff": "return VariableLhs.equals(n.getString())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return VariableLhs.equals(n, parent)) {",
                "patch_diff": "return VariableLhs.equals(n, parent)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return VariableLhs.equals(n.getParent())) {",
                "patch_diff": "return VariableLhs.equals(n.getParent())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return VariableLhs = n.getString())) {",
                "patch_diff": "return VariableLhs = n.getString())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return VariableLhs.equals(n, parent.getString())) {",
                "patch_diff": "return VariableLhs.equals(n, parent.getString())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return VariableLhs.getParent())) {",
                "patch_diff": "return VariableLhs.getParent())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return VariableLhs(n.getString())) {",
                "patch_diff": "return VariableLhs(n.getString())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return VariableLhs.getString())) {",
                "patch_diff": "return VariableLhs.getString())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return VariableLhs.equals(n, n.getParent())) {",
                "patch_diff": "return VariableLhs.equals(n, n.getParent())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return VariableLhs.equals(n, parent.getParent())) {",
                "patch_diff": "return VariableLhs.equals(n, parent.getParent())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); // The expression to which the assignment is made is evaluated before // the RHS is evaluated (normal left to right evaluation) but the KILL // occurs after the RHS is evaluated. Node rhs = n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) { return state; }"
    },
    "Closure-38": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (x < 0 || x == '-') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-38/src/com/google/javascript/jscomp/CodeConsumer.java\t2022-07-19 07:08:09.894513243 +0200\n+++ /tmp/tmpqjzov8ue.java\t2022-07-19 07:08:09.922513109 +0200\n@@ -240,11 +240,11 @@\n   void addNumber(double x) {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+if (x < 0 || x == '-') {\n       add(\" \");\n     }\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (x < 0 && prev == '-') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-38/src/com/google/javascript/jscomp/CodeConsumer.java\t2022-07-19 07:08:50.522321742 +0200\n+++ /tmp/tmpstefjtjk.java\t2022-07-19 07:08:50.522321742 +0200\n@@ -240,11 +240,11 @@\n   void addNumber(double x) {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+if (x < 0 && prev == '-') {\n       add(\" \");\n     }\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (x >= 0 && prev == '-') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-38/src/com/google/javascript/jscomp/CodeConsumer.java\t2022-07-19 07:09:28.654139872 +0200\n+++ /tmp/tmpgwu91w63.java\t2022-07-19 07:09:28.654139872 +0200\n@@ -240,11 +240,11 @@\n   void addNumber(double x) {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+if (x >= 0 && prev == '-') {\n       add(\" \");\n     }\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (x < 0 || prev == '-') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-38/src/com/google/javascript/jscomp/CodeConsumer.java\t2022-07-19 07:10:06.357958153 +0200\n+++ /tmp/tmpahjhvt1_.java\t2022-07-19 07:10:06.357958153 +0200\n@@ -240,11 +240,11 @@\n   void addNumber(double x) {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+if (x < 0 || prev == '-') {\n       add(\" \");\n     }\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (x < 0 && x == '-') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-38/src/com/google/javascript/jscomp/CodeConsumer.java\t2022-07-19 07:10:44.289773576 +0200\n+++ /tmp/tmpi573j82c.java\t2022-07-19 07:10:44.289773576 +0200\n@@ -240,11 +240,11 @@\n   void addNumber(double x) {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+if (x < 0 && x == '-') {\n       add(\" \");\n     }\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (x >= 0 && x == '-') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-38/src/com/google/javascript/jscomp/CodeConsumer.java\t2022-07-19 07:11:22.321586870 +0200\n+++ /tmp/tmpn0wmjwxh.java\t2022-07-19 07:11:22.321586870 +0200\n@@ -240,11 +240,11 @@\n   void addNumber(double x) {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+if (x >= 0 && x == '-') {\n       add(\" \");\n     }\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (x >= 0 || x == '-') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-38/src/com/google/javascript/jscomp/CodeConsumer.java\t2022-07-19 07:12:00.421398298 +0200\n+++ /tmp/tmpxnau5nw8.java\t2022-07-19 07:12:00.421398298 +0200\n@@ -240,11 +240,11 @@\n   void addNumber(double x) {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+if (x >= 0 || x == '-') {\n       add(\" \");\n     }\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (x == 0 && prev == '-') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-38/src/com/google/javascript/jscomp/CodeConsumer.java\t2022-07-19 07:12:38.477208524 +0200\n+++ /tmp/tmpi7wcngcm.java\t2022-07-19 07:12:38.477208524 +0200\n@@ -240,11 +240,11 @@\n   void addNumber(double x) {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+if (x == 0 && prev == '-') {\n       add(\" \");\n     }\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (x <= 0 && prev == '-') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-38/src/com/google/javascript/jscomp/CodeConsumer.java\t2022-07-19 07:13:16.741016382 +0200\n+++ /tmp/tmprwrq27qo.java\t2022-07-19 07:13:16.741016382 +0200\n@@ -240,11 +240,11 @@\n   void addNumber(double x) {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+if (x <= 0 && prev == '-') {\n       add(\" \");\n     }\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 10,
                "patch": "if (x > 0 && prev == '-') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-38/src/com/google/javascript/jscomp/CodeConsumer.java\t2022-07-19 07:13:55.296821522 +0200\n+++ /tmp/tmpxxwqfgbe.java\t2022-07-19 07:13:55.296821522 +0200\n@@ -240,11 +240,11 @@\n   void addNumber(double x) {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+if (x > 0 && prev == '-') {\n       add(\" \");\n     }\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (x < 0 && prev == '-') {",
        "fixed_line": "if ((x < 0 || negativeZero) && prev == '-') {"
    },
    "Closure-129": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (n.getFirstChild(); // Keep track of a free call.",
                "patch_diff": "if (n.getFirstChild(); // Keep track of a free call.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int first = n.getFirstChild(); // Keep track of a free call.",
                "patch_diff": "int first = n.getFirstChild(); // Keep track of a free call.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (n.getFirstChild(); // Keep track of the \"this\" is a free call. Node first = n.getFirstChild(); // ignore cast nodes.",
                "patch_diff": "if (n.getFirstChild(); // Keep track of the \"this\" is a free call. Node first = n.getFirstChild(); // ignore cast nodes.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (n.getFirstChild(); // Keep track of the \"this\" is a free call. Node first = n.getFirstChild();",
                "patch_diff": "if (n.getFirstChild(); // Keep track of the \"this\" is a free call. Node first = n.getFirstChild();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (n.getFirstChild(); // Keep track of the \"this\" is a free call. Node first = n.getFirstChild()) {",
                "patch_diff": "if (n.getFirstChild(); // Keep track of the \"this\" is a free call. Node first = n.getFirstChild()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (n.getFirstChild(); // Keep track of the \"this\" is a free call.",
                "patch_diff": "if (n.getFirstChild(); // Keep track of the \"this\" is a free call.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (n.getBooleanProp(Node.FREE_CALL, true);",
                "patch_diff": "if (n.getBooleanProp(Node.FREE_CALL, true);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (n.getFirstChild(); // Keep track of the \"this\" is a free call. Node first = n.getFirstChild(); // ignore cast nodes",
                "patch_diff": "if (n.getFirstChild(); // Keep track of the \"this\" is a free call. Node first = n.getFirstChild(); // ignore cast nodes",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (n.getFirstChild(); // Keep track of the \"this\" is a free call. Node first = n.getFirstChild(); // ignore cast out.",
                "patch_diff": "if (n.getFirstChild(); // Keep track of the \"this\" is a free call. Node first = n.getFirstChild(); // ignore cast out.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (n.getFirstChild(); // Keep track of the \"this\" is a free call. Node first = n.getFirstChild(); // ignore cast in.",
                "patch_diff": "if (n.getFirstChild(); // Keep track of the \"this\" is a free call. Node first = n.getFirstChild(); // ignore cast in.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "while (first.isCast()) { first = first.getFirstChild(); }"
    },
    "Mockito-21": {
        "fixes": [
            {
                "k": 1,
                "patch": "return withOuterClass<T> T withOuterClass<T> T withOuterClassInstance.newInstance(outerClassInstance);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-21/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\t2022-07-19 07:14:35.032619485 +0200\n+++ /tmp/tmp08i3fahp.java\t2022-07-19 07:14:35.152618872 +0200\n@@ -12,19 +12,11 @@\n \n     public <T> T newInstance(Class<T> cls) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withOuterClass(cls);\n-    }\n-\n-    private <T> T withOuterClass(Class<T> cls) {\n-        try {\n-            //this is kind of overengineered because we don't need to support more params\n-            //however, I know we will be needing it :)\n-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n-            return c.newInstance(outerClassInstance);\n+return withOuterClass<T> T withOuterClass<T> T withOuterClassInstance.newInstance(outerClassInstance);\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return withOuterClass(getOuterClass<T> T withOuterClass<T> T noArgConstructor.newInstance(outerClassInstance);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-21/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\t2022-07-19 07:14:43.924574113 +0200\n+++ /tmp/tmpvi_kugws.java\t2022-07-19 07:14:43.924574113 +0200\n@@ -12,19 +12,11 @@\n \n     public <T> T newInstance(Class<T> cls) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withOuterClass(cls);\n-    }\n-\n-    private <T> T withOuterClass(Class<T> cls) {\n-        try {\n-            //this is kind of overengineered because we don't need to support more params\n-            //however, I know we will be needing it :)\n-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n-            return c.newInstance(outerClassInstance);\n+return withOuterClass(getOuterClass<T> T withOuterClass<T> T noArgConstructor.newInstance(outerClassInstance);\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return withOuterClass(toClass<T> T withOuterClass<T> T noArgConstructor.newInstance(outerClassInstance);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-21/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\t2022-07-19 07:14:52.768528928 +0200\n+++ /tmp/tmp3sehjjon.java\t2022-07-19 07:14:52.768528928 +0200\n@@ -12,19 +12,11 @@\n \n     public <T> T newInstance(Class<T> cls) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withOuterClass(cls);\n-    }\n-\n-    private <T> T withOuterClass(Class<T> cls) {\n-        try {\n-            //this is kind of overengineered because we don't need to support more params\n-            //however, I know we will be needing it :)\n-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n-            return c.newInstance(outerClassInstance);\n+return withOuterClass(toClass<T> T withOuterClass<T> T noArgConstructor.newInstance(outerClassInstance);\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return withOuterClass(cls.getOuterClass<T> T withOuterClass<T> T noArgConstructor.newInstance(outerClassInstance);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-21/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\t2022-07-19 07:15:01.408484735 +0200\n+++ /tmp/tmpkuf9urhs.java\t2022-07-19 07:15:01.408484735 +0200\n@@ -12,19 +12,11 @@\n \n     public <T> T newInstance(Class<T> cls) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withOuterClass(cls);\n-    }\n-\n-    private <T> T withOuterClass(Class<T> cls) {\n-        try {\n-            //this is kind of overengineered because we don't need to support more params\n-            //however, I know we will be needing it :)\n-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n-            return c.newInstance(outerClassInstance);\n+return withOuterClass(cls.getOuterClass<T> T withOuterClass<T> T noArgConstructor.newInstance(outerClassInstance);\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return withOuterClass(h.getOuterClass<T> T withOuterClass<T> T noArgConstructor.newInstance(outerClassInstance);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-21/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\t2022-07-19 07:15:10.088440286 +0200\n+++ /tmp/tmpyka413_c.java\t2022-07-19 07:15:10.088440286 +0200\n@@ -12,19 +12,11 @@\n \n     public <T> T newInstance(Class<T> cls) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withOuterClass(cls);\n-    }\n-\n-    private <T> T withOuterClass(Class<T> cls) {\n-        try {\n-            //this is kind of overengineered because we don't need to support more params\n-            //however, I know we will be needing it :)\n-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n-            return c.newInstance(outerClassInstance);\n+return withOuterClass(h.getOuterClass<T> T withOuterClass<T> T noArgConstructor.newInstance(outerClassInstance);\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return withOuterClass(getOuterClass<T> T withOuterClass<T> T noArgConstructor.newInstance(outerClass);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-21/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\t2022-07-19 07:15:18.580396749 +0200\n+++ /tmp/tmp8oimv7c8.java\t2022-07-19 07:15:18.580396749 +0200\n@@ -12,19 +12,11 @@\n \n     public <T> T newInstance(Class<T> cls) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withOuterClass(cls);\n-    }\n-\n-    private <T> T withOuterClass(Class<T> cls) {\n-        try {\n-            //this is kind of overengineered because we don't need to support more params\n-            //however, I know we will be needing it :)\n-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n-            return c.newInstance(outerClassInstance);\n+return withOuterClass(getOuterClass<T> T withOuterClass<T> T noArgConstructor.newInstance(outerClass);\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return withOuterClass(getOuterClass<T> T withOuterClass<T> T noArgConstructor);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-21/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\t2022-07-19 07:15:27.124352899 +0200\n+++ /tmp/tmpom55djqa.java\t2022-07-19 07:15:27.128352877 +0200\n@@ -12,19 +12,11 @@\n \n     public <T> T newInstance(Class<T> cls) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withOuterClass(cls);\n-    }\n-\n-    private <T> T withOuterClass(Class<T> cls) {\n-        try {\n-            //this is kind of overengineered because we don't need to support more params\n-            //however, I know we will be needing it :)\n-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n-            return c.newInstance(outerClassInstance);\n+return withOuterClass(getOuterClass<T> T withOuterClass<T> T noArgConstructor);\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return withOuterClass<T> T withOuterClass<T> T withOuterClassInstance.newInstance(outerClass);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-21/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\t2022-07-19 07:15:35.820308216 +0200\n+++ /tmp/tmpgao862as.java\t2022-07-19 07:15:35.824308198 +0200\n@@ -12,19 +12,11 @@\n \n     public <T> T newInstance(Class<T> cls) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withOuterClass(cls);\n-    }\n-\n-    private <T> T withOuterClass(Class<T> cls) {\n-        try {\n-            //this is kind of overengineered because we don't need to support more params\n-            //however, I know we will be needing it :)\n-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n-            return c.newInstance(outerClassInstance);\n+return withOuterClass<T> T withOuterClass<T> T withOuterClassInstance.newInstance(outerClass);\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return withOuterClass(h.getOuterClass<T> T withOuterClass<T> T noArgConstructor);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-21/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\t2022-07-19 07:15:44.280264703 +0200\n+++ /tmp/tmpjl824sby.java\t2022-07-19 07:15:44.284264681 +0200\n@@ -12,19 +12,11 @@\n \n     public <T> T newInstance(Class<T> cls) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withOuterClass(cls);\n-    }\n-\n-    private <T> T withOuterClass(Class<T> cls) {\n-        try {\n-            //this is kind of overengineered because we don't need to support more params\n-            //however, I know we will be needing it :)\n-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n-            return c.newInstance(outerClassInstance);\n+return withOuterClass(h.getOuterClass<T> T withOuterClass<T> T noArgConstructor);\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return withOuterClass(h.getOuterClass<T> T withOuterClass<T> T noArgConstructor.newInstance(outerClass);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-21/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\t2022-07-19 07:15:52.804220812 +0200\n+++ /tmp/tmpt56iipsp.java\t2022-07-19 07:15:52.804220812 +0200\n@@ -12,19 +12,11 @@\n \n     public <T> T newInstance(Class<T> cls) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withOuterClass(cls);\n-    }\n-\n-    private <T> T withOuterClass(Class<T> cls) {\n-        try {\n-            //this is kind of overengineered because we don't need to support more params\n-            //however, I know we will be needing it :)\n-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n-            return c.newInstance(outerClassInstance);\n+return withOuterClass(h.getOuterClass<T> T withOuterClass<T> T noArgConstructor.newInstance(outerClass);\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return withOuterClass(cls); } private <T> T withOuterClass(Class<T> cls) { try { //this is kind of overengineered because we don't need to support more params //however, I know we will be needing it :) Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass()); return c.newInstance(outerClassInstance);",
        "fixed_line": "return withParams(cls, outerClassInstance); } private static <T> T withParams(Class<T> cls, Object... params) { try { //this is kind of overengineered because we don't need to support more params //however, I know we will be needing it :) for (Constructor<?> constructor : cls.getDeclaredConstructors()) { Class<?>[] types = constructor.getParameterTypes(); if (paramsMatch(types, params)) { return (T) constructor.newInstance(params); } } } catch (Exception e) { throw paramsException(cls, e); } throw paramsException(cls, null); } private static <T> InstantationException paramsException(Class<T> cls, Exception e) { return new InstantationException(\"Unable to create mock instance of '\" + cls.getSimpleName() + \"'.\\nPlease ensure that the outer instance has correct type and that the target class has parameter-less constructor.\", e); } private static boolean paramsMatch(Class<?>[] types, Object[] params) { if (params.length != types.length) { return false; } for (int i = 0; i < params.length; i++) { if (!types[i].isInstance(params[i])) { return false; } } return true; }"
    },
    "Closure-102": {
        "fixes": [
            {
                "k": 1,
                "patch": "removeDuplicateDeclarations(root); // remove old items if it's",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-102/src/com/google/javascript/jscomp/Normalize.java\t2022-07-19 07:16:01.540175786 +0200\n+++ /tmp/tmpfoxqkmsy.java\t2022-07-19 07:16:01.572175621 +0200\n@@ -89,11 +89,11 @@\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n+removeDuplicateDeclarations(root); // remove old items if it's\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n \n   @Override\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "removeDuplicateDeclarations(root); // remove old items if necessary, but",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-102/src/com/google/javascript/jscomp/Normalize.java\t2022-07-19 07:16:21.064074983 +0200\n+++ /tmp/tmppt7302k5.java\t2022-07-19 07:16:21.068074965 +0200\n@@ -89,11 +89,11 @@\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n+removeDuplicateDeclarations(root); // remove old items if necessary, but\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n \n   @Override\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "removeDuplicateDeclarations(root); // remove old items if necessary",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-102/src/com/google/javascript/jscomp/Normalize.java\t2022-07-19 07:16:39.539979388 +0200\n+++ /tmp/tmphnof8fx8.java\t2022-07-19 07:16:39.539979388 +0200\n@@ -89,11 +89,11 @@\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n+removeDuplicateDeclarations(root); // remove old items if necessary\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n \n   @Override\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "removeDuplicateDeclarations(root);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-102/src/com/google/javascript/jscomp/Normalize.java\t2022-07-19 07:16:58.151882891 +0200\n+++ /tmp/tmpqd8nk0fg.java\t2022-07-19 07:16:58.151882891 +0200\n@@ -89,11 +89,11 @@\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n+removeDuplicateDeclarations(root);\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n \n   @Override\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "removeDuplicateDeclarations(root); // remove old items if necessary, but // remove old items if it's",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-102/src/com/google/javascript/jscomp/Normalize.java\t2022-07-19 07:17:16.679786640 +0200\n+++ /tmp/tmpf0k9r8uz.java\t2022-07-19 07:17:16.679786640 +0200\n@@ -89,11 +89,11 @@\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n+removeDuplicateDeclarations(root); // remove old items if necessary, but // remove old items if it's\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n \n   @Override\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "removeDuplicateDeclarations(root); // remove old items if necessary, but // remove old items if necessary, but",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-102/src/com/google/javascript/jscomp/Normalize.java\t2022-07-19 07:17:35.047691044 +0200\n+++ /tmp/tmpzlvu9dox.java\t2022-07-19 07:17:35.047691044 +0200\n@@ -89,11 +89,11 @@\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n+removeDuplicateDeclarations(root); // remove old items if necessary, but // remove old items if necessary, but\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n \n   @Override\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "removeDuplicateDeclarations(root); // remove old items if it's // remove old items if it's",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-102/src/com/google/javascript/jscomp/Normalize.java\t2022-07-19 07:17:53.435595170 +0200\n+++ /tmp/tmpaav0jv39.java\t2022-07-19 07:17:53.595594340 +0200\n@@ -89,11 +89,11 @@\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n+removeDuplicateDeclarations(root); // remove old items if it's // remove old items if it's\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n \n   @Override\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "removeDuplicateDeclarations(root); // remove old items if it was -->",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-102/src/com/google/javascript/jscomp/Normalize.java\t2022-07-19 07:18:12.195497186 +0200\n+++ /tmp/tmp8eat2r86.java\t2022-07-19 07:18:12.195497186 +0200\n@@ -89,11 +89,11 @@\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n+removeDuplicateDeclarations(root); // remove old items if it was -->\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n \n   @Override\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "removeDuplicateDeclarations(root); // remove old items if it's.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-102/src/com/google/javascript/jscomp/Normalize.java\t2022-07-19 07:18:30.747400124 +0200\n+++ /tmp/tmp8c9431i9.java\t2022-07-19 07:18:30.747400124 +0200\n@@ -89,11 +89,11 @@\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n+removeDuplicateDeclarations(root); // remove old items if it's.\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n \n   @Override\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "removeDuplicateDeclarations(root); // remove old items if it's, but",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-102/src/com/google/javascript/jscomp/Normalize.java\t2022-07-19 07:18:49.499301853 +0200\n+++ /tmp/tmp6_0q6k8e.java\t2022-07-19 07:18:49.503301835 +0200\n@@ -89,11 +89,11 @@\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n+removeDuplicateDeclarations(root); // remove old items if it's, but\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n \n   @Override\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "removeDuplicateDeclarations(root);",
        "fixed_line": "removeDuplicateDeclarations(root);"
    },
    "Lang-59": {
        "fixes": [
            {
                "k": 1,
                "patch": "str.getChars(0, strLen, buffer, size);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 07:19:08.127204082 +0200\n+++ /tmp/tmpx6n53468.java\t2022-07-19 07:19:08.147203978 +0200\n@@ -879,11 +879,11 @@\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+str.getChars(0, strLen, buffer, size);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + strLen + i] = padChar;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "str.getChars(0, strLen, buffer, size + width);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 07:19:17.555154543 +0200\n+++ /tmp/tmpp9bb9mq4.java\t2022-07-19 07:19:17.559154522 +0200\n@@ -879,11 +879,11 @@\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+str.getChars(0, strLen, buffer, size + width);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + strLen + i] = padChar;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "str.getChars(0, strLen, buffer, size - width);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 07:19:26.783106015 +0200\n+++ /tmp/tmpnsh8pd6y.java\t2022-07-19 07:19:26.787105993 +0200\n@@ -879,11 +879,11 @@\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+str.getChars(0, strLen, buffer, size - width);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + strLen + i] = padChar;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "str.getChars(0, strLen, buffer, size = padLen);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 07:19:36.135056802 +0200\n+++ /tmp/tmpt9zdyidp.java\t2022-07-19 07:19:36.135056802 +0200\n@@ -879,11 +879,11 @@\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+str.getChars(0, strLen, buffer, size = padLen);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + strLen + i] = padChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "str.getChars(0, strLen, buffer, size = width);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 07:19:37.835047853 +0200\n+++ /tmp/tmp8oum4yp8.java\t2022-07-19 07:19:37.839047832 +0200\n@@ -879,11 +879,11 @@\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+str.getChars(0, strLen, buffer, size = width);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + strLen + i] = padChar;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "str.getChars(0, strLen, buffer, size = size + width);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 07:19:47.102999042 +0200\n+++ /tmp/tmpbtrk2amd.java\t2022-07-19 07:19:47.102999042 +0200\n@@ -879,11 +879,11 @@\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+str.getChars(0, strLen, buffer, size = size + width);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + strLen + i] = padChar;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "str.getChars(0, strLen, buffer, size = padChar);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 07:19:56.406950004 +0200\n+++ /tmp/tmp0v49uaii.java\t2022-07-19 07:19:56.406950004 +0200\n@@ -879,11 +879,11 @@\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+str.getChars(0, strLen, buffer, size = padChar);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + strLen + i] = padChar;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "str.getChars(0, strLen, buffer, size < width);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 07:20:05.694901019 +0200\n+++ /tmp/tmp4hqex31j.java\t2022-07-19 07:20:05.698900998 +0200\n@@ -879,11 +879,11 @@\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+str.getChars(0, strLen, buffer, size < width);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + strLen + i] = padChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "str.getChars(0, strLen, buffer, size < size);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 07:20:07.398892028 +0200\n+++ /tmp/tmpaghwuwql.java\t2022-07-19 07:20:07.398892028 +0200\n@@ -879,11 +879,11 @@\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+str.getChars(0, strLen, buffer, size < size);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + strLen + i] = padChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "str.getChars(0, strLen, buffer, size += width);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-19 07:20:09.102883037 +0200\n+++ /tmp/tmpc880h4wf.java\t2022-07-19 07:20:09.102883037 +0200\n@@ -879,11 +879,11 @@\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+str.getChars(0, strLen, buffer, size += width);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + strLen + i] = padChar;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "str.getChars(0, strLen, buffer, size);",
        "fixed_line": "str.getChars(0, width, buffer, size);"
    },
    "Closure-15": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {",
                "patch_diff": "for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) { return false; }",
                "patch_diff": "for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) { return false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) { return false; c = c.getFirstChild();",
                "patch_diff": "for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) { return false; c = c.getFirstChild();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) { return false; } }",
                "patch_diff": "for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) { return false; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return false; c = n.getFirstChild();",
                "patch_diff": "return false; c = n.getFirstChild();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) { return false;",
                "patch_diff": "for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) { return false;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return false; c = c.getFirstChild();",
                "patch_diff": "return false; c = c.getFirstChild();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) { return false; c = c.getFirstChild(); if (c == null) { return false; } }",
                "patch_diff": "for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) { return false; c = c.getFirstChild(); if (c == null) { return false; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) { return false; c = c.getFirstChild(); if (c == null) { return false; }",
                "patch_diff": "for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) { return false; c = c.getFirstChild(); if (c == null) { return false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) { return false; c = c.getFirstChild(); if (c == null) { return false; c = c.getNext()) { return false; } }",
                "patch_diff": "for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) { return false; c = c.getFirstChild(); if (c == null) { return false; c = c.getNext()) { return false; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (n.isDelProp()) { return true; }"
    },
    "JacksonDatabind-24": {
        "fixes": [
            {
                "k": 1,
                "patch": "TimeZone tz = (df == null)? _timeZone : df.getTimeZone(); return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-24/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\t2022-07-19 07:20:20.910820699 +0200\n+++ /tmp/tmp_zux2xnf.java\t2022-07-19 07:20:21.006820193 +0200\n@@ -229,14 +229,11 @@\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n         if (_dateFormat == df) {\n             return this;\n         }\n-        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                tz, _defaultBase64);\n+TimeZone tz = (df == null)? _timeZone : df.getTimeZone(); return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         if (_handlerInstantiator == hi) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "TimeZone tz = (df == null)? _annotationIntrospector : df.getTimeZone(); return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-24/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\t2022-07-19 07:20:57.774625756 +0200\n+++ /tmp/tmpnn5uar4a.java\t2022-07-19 07:20:57.794625650 +0200\n@@ -229,14 +229,11 @@\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n         if (_dateFormat == df) {\n             return this;\n         }\n-        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                tz, _defaultBase64);\n+TimeZone tz = (df == null)? _annotationIntrospector : df.getTimeZone(); return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         if (_handlerInstantiator == hi) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "TimeZone tz = (df == null)? _annotationIntrospector : df.getTimeZone(); return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-24/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\t2022-07-19 07:20:59.494616649 +0200\n+++ /tmp/tmpln89vunn.java\t2022-07-19 07:20:59.494616649 +0200\n@@ -229,14 +229,11 @@\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n         if (_dateFormat == df) {\n             return this;\n         }\n-        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                tz, _defaultBase64);\n+TimeZone tz = (df == null)? _annotationIntrospector : df.getTimeZone(); return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         if (_handlerInstantiator == hi) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "TimeZone tz = (df == null)? _timeZone : df.getTimeZone(); return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-24/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\t2022-07-19 07:21:01.178607731 +0200\n+++ /tmp/tmpny5bv8iw.java\t2022-07-19 07:21:01.178607731 +0200\n@@ -229,14 +229,11 @@\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n         if (_dateFormat == df) {\n             return this;\n         }\n-        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                tz, _defaultBase64);\n+TimeZone tz = (df == null)? _timeZone : df.getTimeZone(); return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         if (_handlerInstantiator == hi) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 5,
                "patch": "TimeZone tz = (df == null)? _annotationIntrospector : _visibilityChecker.getTimeZone(); return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-24/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\t2022-07-19 07:21:34.362431812 +0200\n+++ /tmp/tmpp41dfp93.java\t2022-07-19 07:21:34.362431812 +0200\n@@ -229,14 +229,11 @@\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n         if (_dateFormat == df) {\n             return this;\n         }\n-        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                tz, _defaultBase64);\n+TimeZone tz = (df == null)? _annotationIntrospector : _visibilityChecker.getTimeZone(); return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         if (_handlerInstantiator == hi) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "TimeZone tz = (df == null)? _timeZone : df.getTimeZone(); return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, tz, _defaultBase64);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-24/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\t2022-07-19 07:21:36.118422495 +0200\n+++ /tmp/tmp6q9zd21i.java\t2022-07-19 07:21:36.118422495 +0200\n@@ -229,14 +229,11 @@\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n         if (_dateFormat == df) {\n             return this;\n         }\n-        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                tz, _defaultBase64);\n+TimeZone tz = (df == null)? _timeZone : df.getTimeZone(); return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, tz, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         if (_handlerInstantiator == hi) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "TimeZone tz = (df == null)? _timeZone : df.getTimeZone(); return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone, _defaultBase64);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-24/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\t2022-07-19 07:22:09.154246994 +0200\n+++ /tmp/tmpy0i_rlf7.java\t2022-07-19 07:22:09.154246994 +0200\n@@ -229,14 +229,11 @@\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n         if (_dateFormat == df) {\n             return this;\n         }\n-        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                tz, _defaultBase64);\n+TimeZone tz = (df == null)? _timeZone : df.getTimeZone(); return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         if (_handlerInstantiator == hi) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "TimeZone tz = (_annotationIntrospector == null)? _visibilityChecker : df.getTimeZone(); return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-24/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\t2022-07-19 07:22:42.618068886 +0200\n+++ /tmp/tmpv9efazjl.java\t2022-07-19 07:22:42.618068886 +0200\n@@ -229,14 +229,11 @@\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n         if (_dateFormat == df) {\n             return this;\n         }\n-        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                tz, _defaultBase64);\n+TimeZone tz = (_annotationIntrospector == null)? _visibilityChecker : df.getTimeZone(); return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         if (_handlerInstantiator == hi) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "TimeZone tz = (df == null)? _annotationIntrospector : df.getTimeZone(); return new BaseSettings(_classIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-24/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\t2022-07-19 07:22:44.342059703 +0200\n+++ /tmp/tmpvf9woyc8.java\t2022-07-19 07:22:44.346059681 +0200\n@@ -229,14 +229,11 @@\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n         if (_dateFormat == df) {\n             return this;\n         }\n-        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                tz, _defaultBase64);\n+TimeZone tz = (df == null)? _annotationIntrospector : df.getTimeZone(); return new BaseSettings(_classIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         if (_handlerInstantiator == hi) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "TimeZone tz = (df == null)? _annotationIntrospector : df.getTimeZone(); return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, tz, _defaultBase64);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-24/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\t2022-07-19 07:22:46.082050433 +0200\n+++ /tmp/tmpafqs4b0g.java\t2022-07-19 07:22:46.086050411 +0200\n@@ -229,14 +229,11 @@\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n         if (_dateFormat == df) {\n             return this;\n         }\n-        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                tz, _defaultBase64);\n+TimeZone tz = (df == null)? _annotationIntrospector : df.getTimeZone(); return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, tz, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         if (_handlerInstantiator == hi) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "TimeZone tz = (df == null) ? _timeZone : df.getTimeZone(); return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64);",
        "fixed_line": "_timeZone, _defaultBase64);"
    },
    "Lang-64": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int i = 0; i < other.length; i++) {",
                "patch_diff": "for (int i = 0; i < other.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = 0; i < size; i++) {",
                "patch_diff": "for (int i = 0; i < size; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0; i < size; ++i) {",
                "patch_diff": "for (int i = 0; i < size; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = 0; i < v.length; i++) {",
                "patch_diff": "for (int i = 0; i < v.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = 0; i < other.length; ++i) {",
                "patch_diff": "for (int i = 0; i < other.length; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = 0; i < int.length; i++) {",
                "patch_diff": "for (int i = 0; i < int.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = 0; i < other.length; ++i) { if (other[i] == null) {",
                "patch_diff": "for (int i = 0; i < other.length; ++i) { if (other[i] == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = 0; i < size; ++i) { if (other[i] == null) {",
                "patch_diff": "for (int i = 0; i < size; ++i) { if (other[i] == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return iValue - ((ValuedEnum) other).iValue;",
                "patch_diff": "return iValue - ((ValuedEnum) other).iValue;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = 0; i < other.length; ++i) { if (this == other.i) {",
                "patch_diff": "for (int i = 0; i < other.length; ++i) { if (this == other.i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (other == this) { return 0; } if (other.getClass() != this.getClass()) { if (other.getClass().getName().equals(this.getClass().getName())) { return iValue - getValueInOtherClassLoader(other); } throw new ClassCastException( \"Different enum class '\" + ClassUtils.getShortClassName(other.getClass()) + \"'\"); } return iValue - ((ValuedEnum) other).iValue; } /** * <p>Use reflection to return an objects value.</p> * * @param other the object to determine the value for * @return the value */ private int getValueInOtherClassLoader(Object other) { try { Method mth = other.getClass().getMethod(\"getValue\", null); Integer value = (Integer) mth.invoke(other, null); return value.intValue(); } catch (NoSuchMethodException e) { // ignore - should never happen } catch (IllegalAccessException e) { // ignore - should never happen } catch (InvocationTargetException e) { // ignore - should never happen } throw new IllegalStateException(\"This should not happen\"); }"
    },
    "Chart-1": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (dataset == null) { // block == null; non-empty's after name; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2022-07-19 07:22:49.738030951 +0200\n+++ /tmp/tmpznghzoxp.java\t2022-07-19 07:22:49.806030588 +0200\n@@ -1792,11 +1792,11 @@\n         if (this.plot == null) {\n             return result;\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+if (dataset == null) { // block == null; non-empty's after name; }\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 2,
                "patch": "if (dataset == null) { // block == null; non-empty's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2022-07-19 07:23:00.773972123 +0200\n+++ /tmp/tmpd5i82h2z.java\t2022-07-19 07:23:00.777972102 +0200\n@@ -1792,11 +1792,11 @@\n         if (this.plot == null) {\n             return result;\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+if (dataset == null) { // block == null; non-empty's do implicit re-parse\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 3,
                "patch": "if (dataset == null) { // block == null; non-empty enables",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2022-07-19 07:23:09.797923995 +0200\n+++ /tmp/tmp1yle0380.java\t2022-07-19 07:23:09.797923995 +0200\n@@ -1792,11 +1792,11 @@\n         if (this.plot == null) {\n             return result;\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+if (dataset == null) { // block == null; non-empty enables\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 4,
                "patch": "if (dataset == null) { // add a dataset with 0x result; return result; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2022-07-19 07:23:18.913875356 +0200\n+++ /tmp/tmp003db8tw.java\t2022-07-19 07:23:18.917875333 +0200\n@@ -1792,11 +1792,11 @@\n         if (this.plot == null) {\n             return result;\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+if (dataset == null) { // add a dataset with 0x result; return result; }\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 5,
                "patch": "if (dataset == null) { // block == null; return result; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2022-07-19 07:23:28.249825519 +0200\n+++ /tmp/tmpl3_lmx_q.java\t2022-07-19 07:23:28.249825519 +0200\n@@ -1792,11 +1792,11 @@\n         if (this.plot == null) {\n             return result;\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+if (dataset == null) { // block == null; return result; }\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 6,
                "patch": "if (dataset == null) { // block == null; non-empty's after name; return result; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2022-07-19 07:23:37.381776749 +0200\n+++ /tmp/tmpy6at1hh5.java\t2022-07-19 07:23:37.381776749 +0200\n@@ -1792,11 +1792,11 @@\n         if (this.plot == null) {\n             return result;\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+if (dataset == null) { // block == null; non-empty's after name; return result; }\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 7,
                "patch": "if (dataset == null) { // block == null; non-empty's after name; non-empty's after name; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2022-07-19 07:23:46.545727789 +0200\n+++ /tmp/tmpni3ejy46.java\t2022-07-19 07:23:46.545727789 +0200\n@@ -1792,11 +1792,11 @@\n         if (this.plot == null) {\n             return result;\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+if (dataset == null) { // block == null; non-empty's after name; non-empty's after name; }\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 8,
                "patch": "if (dataset == null) { // block == null; non-empty's after name; non-empty's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2022-07-19 07:23:55.677678977 +0200\n+++ /tmp/tmpkjhlj_i0.java\t2022-07-19 07:23:55.677678977 +0200\n@@ -1792,11 +1792,11 @@\n         if (this.plot == null) {\n             return result;\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+if (dataset == null) { // block == null; non-empty's after name; non-empty's do implicit re-parse\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 9,
                "patch": "if (dataset!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2022-07-19 07:24:04.845629955 +0200\n+++ /tmp/tmpqw31ek5m.java\t2022-07-19 07:24:04.845629955 +0200\n@@ -1792,11 +1792,11 @@\n         if (this.plot == null) {\n             return result;\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+if (dataset!= null) {\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (dataset == null) { // add a dataset (dataset (this.dataset == null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2022-07-19 07:24:13.797582067 +0200\n+++ /tmp/tmpo384m1_x.java\t2022-07-19 07:24:13.797582067 +0200\n@@ -1792,11 +1792,11 @@\n         if (this.plot == null) {\n             return result;\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+if (dataset == null) { // add a dataset (dataset (this.dataset == null)\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            }
        ],
        "buggy_line": "if (dataset != null) {",
        "fixed_line": "if (dataset == null) {"
    },
    "Closure-23": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int i = 0; current!= null && i < intIndex; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-23/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 07:24:23.121532170 +0200\n+++ /tmp/tmpyie4l5x4.java\t2022-07-19 07:24:23.153531999 +0200\n@@ -1446,11 +1446,11 @@\n       return n;\n     }\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null && i < intIndex; i++) {\n+for (int i = 0; current!= null && i < intIndex; i++) {\n         elem = current;\n \n       current = current.getNext();\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = 0; n!= null && i < intIndex; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-23/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 07:25:04.157312332 +0200\n+++ /tmp/tmppi4uga2c.java\t2022-07-19 07:25:04.157312332 +0200\n@@ -1446,11 +1446,11 @@\n       return n;\n     }\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null && i < intIndex; i++) {\n+for (int i = 0; n!= null && i < intIndex; i++) {\n         elem = current;\n \n       current = current.getNext();\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0; elem!= null && i < intIndex; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-23/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 07:25:43.377101891 +0200\n+++ /tmp/tmp4wbkuzyw.java\t2022-07-19 07:25:43.381101870 +0200\n@@ -1446,11 +1446,11 @@\n       return n;\n     }\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null && i < intIndex; i++) {\n+for (int i = 0; elem!= null && i < intIndex; i++) {\n         elem = current;\n \n       current = current.getNext();\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = 0; i!= null && i < intIndex; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-23/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 07:26:22.484891750 +0200\n+++ /tmp/tmpqlk2d2t0.java\t2022-07-19 07:26:22.484891750 +0200\n@@ -1446,11 +1446,11 @@\n       return n;\n     }\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null && i < intIndex; i++) {\n+for (int i = 0; i!= null && i < intIndex; i++) {\n         elem = current;\n \n       current = current.getNext();\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = 0; n == null && i < intIndex; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-23/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 07:26:25.976872972 +0200\n+++ /tmp/tmp64nh9ctm.java\t2022-07-19 07:26:25.980872949 +0200\n@@ -1446,11 +1446,11 @@\n       return n;\n     }\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null && i < intIndex; i++) {\n+for (int i = 0; n == null && i < intIndex; i++) {\n         elem = current;\n \n       current = current.getNext();\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = 0; it!= null && i < intIndex; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-23/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 07:27:05.164662098 +0200\n+++ /tmp/tmpyl4ohwye.java\t2022-07-19 07:27:05.164662098 +0200\n@@ -1446,11 +1446,11 @@\n       return n;\n     }\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null && i < intIndex; i++) {\n+for (int i = 0; it!= null && i < intIndex; i++) {\n         elem = current;\n \n       current = current.getNext();\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = 0; elem == null && i < intIndex; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-23/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 07:27:08.768642691 +0200\n+++ /tmp/tmpab0j5u9f.java\t2022-07-19 07:27:08.768642691 +0200\n@@ -1446,11 +1446,11 @@\n       return n;\n     }\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null && i < intIndex; i++) {\n+for (int i = 0; elem == null && i < intIndex; i++) {\n         elem = current;\n \n       current = current.getNext();\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = 0; n < null && i < intIndex; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-23/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 07:27:47.804432355 +0200\n+++ /tmp/tmpnzbav2q8.java\t2022-07-19 07:27:47.804432355 +0200\n@@ -1446,11 +1446,11 @@\n       return n;\n     }\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null && i < intIndex; i++) {\n+for (int i = 0; n < null && i < intIndex; i++) {\n         elem = current;\n \n       current = current.getNext();\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int i = 0; i < null && i < intIndex; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-23/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 07:27:51.460412645 +0200\n+++ /tmp/tmpm9forffy.java\t2022-07-19 07:27:51.460412645 +0200\n@@ -1446,11 +1446,11 @@\n       return n;\n     }\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null && i < intIndex; i++) {\n+for (int i = 0; i < null && i < intIndex; i++) {\n         elem = current;\n \n       current = current.getNext();\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = 0; i < intIndex; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-23/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 07:27:55.104392995 +0200\n+++ /tmp/tmp1vp4tl_a.java\t2022-07-19 07:27:55.104392995 +0200\n@@ -1446,11 +1446,11 @@\n       return n;\n     }\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null && i < intIndex; i++) {\n+for (int i = 0; i < intIndex; i++) {\n         elem = current;\n \n       current = current.getNext();\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "for (int i = 0; current != null && i < intIndex; i++) {",
        "fixed_line": "for (int i = 0; current != null; i++) { if (i != intIndex) { if (mayHaveSideEffects(current)) { return n; } } else { elem = current; }"
    },
    "Math-80": {
        "fixes": [
            {
                "k": 1,
                "patch": "int j = n / 4 - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2022-07-19 07:28:34.768178994 +0200\n+++ /tmp/tmpld0aglld.java\t2022-07-19 07:28:34.800178820 +0200\n@@ -1130,11 +1130,11 @@\n      * @return true if qd array was flipped\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+int j = n / 4 - 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 2,
                "patch": "int j = n / 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2022-07-19 07:28:41.548142392 +0200\n+++ /tmp/tmp9mlepshg.java\t2022-07-19 07:28:41.552142368 +0200\n@@ -1130,11 +1130,11 @@\n      * @return true if qd array was flipped\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+int j = n / 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int j = n / 4;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2022-07-19 07:28:47.956107789 +0200\n+++ /tmp/tmp_i6cdclj.java\t2022-07-19 07:28:47.956107789 +0200\n@@ -1130,11 +1130,11 @@\n      * @return true if qd array was flipped\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+int j = n / 4;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int j = n / n - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2022-07-19 07:28:54.404072968 +0200\n+++ /tmp/tmptcsjjb17.java\t2022-07-19 07:28:54.404072968 +0200\n@@ -1130,11 +1130,11 @@\n      * @return true if qd array was flipped\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+int j = n / n - 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 5,
                "patch": "int j = n / 2;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2022-07-19 07:29:01.052037059 +0200\n+++ /tmp/tmpjow6swv4.java\t2022-07-19 07:29:01.056037038 +0200\n@@ -1130,11 +1130,11 @@\n      * @return true if qd array was flipped\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+int j = n / 2;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int j = n / 3;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2022-07-19 07:29:07.648001426 +0200\n+++ /tmp/tmpsytw3iog.java\t2022-07-19 07:29:07.648001426 +0200\n@@ -1130,11 +1130,11 @@\n      * @return true if qd array was flipped\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+int j = n / 3;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 7,
                "patch": "int j = 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2022-07-19 07:29:14.195966047 +0200\n+++ /tmp/tmpkwyo5eku.java\t2022-07-19 07:29:14.199966027 +0200\n@@ -1130,11 +1130,11 @@\n      * @return true if qd array was flipped\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+int j = 0;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 8,
                "patch": "int j = n / 4 - 1; // we didn't really gets this may be negative",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2022-07-19 07:29:20.647931181 +0200\n+++ /tmp/tmptlb_kn0v.java\t2022-07-19 07:29:20.651931161 +0200\n@@ -1130,11 +1130,11 @@\n      * @return true if qd array was flipped\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+int j = n / 4 - 1; // we didn't really gets this may be negative\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 9,
                "patch": "int j = n / 1; // we didn't really gets this may be negative",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2022-07-19 07:29:27.323895100 +0200\n+++ /tmp/tmp4pgq4jmo.java\t2022-07-19 07:29:27.323895100 +0200\n@@ -1130,11 +1130,11 @@\n      * @return true if qd array was flipped\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+int j = n / 1; // we didn't really gets this may be negative\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int j = n / 4 - 1; // we didn't really modify it was last",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2022-07-19 07:29:33.815860005 +0200\n+++ /tmp/tmpnttitj5o.java\t2022-07-19 07:29:33.815860005 +0200\n@@ -1130,11 +1130,11 @@\n      * @return true if qd array was flipped\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+int j = n / 4 - 1; // we didn't really modify it was last\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            }
        ],
        "buggy_line": "int j = 4 * n - 1;",
        "fixed_line": "int j = 4 * (n - 1);"
    },
    "JacksonDatabind-106": {
        "fixes": [
            {
                "k": 1,
                "patch": "final NumericNode node = (NumericNode) currentNumericNode.longValue();",
                "patch_diff": "final NumericNode node = (NumericNode) currentNumericNode.longValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "final NumericNode node = (NumericNode) currentNumericNode;",
                "patch_diff": "final NumericNode node = (NumericNode) currentNumericNode;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "final NumericNode node = (NumericNode) currentNumericNode; }",
                "patch_diff": "final NumericNode node = (NumericNode) currentNumericNode; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "final NumericNode node = (NumericNode) currentNumericNode.longValue(); }",
                "patch_diff": "final NumericNode node = (NumericNode) currentNumericNode.longValue(); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "final NumericNode node = (NumericNode) currentNumericNode; } @Override public long getLongValue() {",
                "patch_diff": "final NumericNode node = (NumericNode) currentNumericNode; } @Override public long getLongValue() {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "final NumericNode node = (NumericNode) currentNumericNode.longValue();",
                "patch_diff": "final NumericNode node = (NumericNode) currentNumericNode.longValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "final NumericNode node = (NumericNode)",
                "patch_diff": "final NumericNode node = (NumericNode)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "final NumericNode node = (PeriodNode) currentNumericNode.longValue();",
                "patch_diff": "final NumericNode node = (PeriodNode) currentNumericNode.longValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "final NumericNode node = (NumericNode) currentNumericNode.intValue();",
                "patch_diff": "final NumericNode node = (NumericNode) currentNumericNode.intValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "final NumericNode node = (NumericNode) currentNumericNode.longValue() {",
                "patch_diff": "final NumericNode node = (NumericNode) currentNumericNode.longValue() {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (!node.canConvertToInt()) { reportOverflowInt(); } return node.intValue(); } @Override public long getLongValue() throws IOException { final NumericNode node = (NumericNode) currentNumericNode(); if (!node.canConvertToInt()) { reportOverflowLong(); }"
    },
    "JxPath-10": {
        "fixes": [
            {
                "k": 1,
                "patch": "return compute(args[0].computeValue(context), args[1].computeValue(context))",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-10/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\t2022-07-19 07:29:42.271814287 +0200\n+++ /tmp/tmpxpbmfy_2.java\t2022-07-19 07:29:42.295814158 +0200\n@@ -37,11 +37,11 @@\n     protected CoreOperationRelationalExpression(Expression[] args) {\n         super(args);\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n+return compute(args[0].computeValue(context), args[1].computeValue(context))\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     protected final int getPrecedence() {\n         return 3;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return compute(args[0].computeValue(context), args[0].computeValue(context))",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-10/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\t2022-07-19 07:29:47.675785065 +0200\n+++ /tmp/tmpk38gm14z.java\t2022-07-19 07:29:47.675785065 +0200\n@@ -37,11 +37,11 @@\n     protected CoreOperationRelationalExpression(Expression[] args) {\n         super(args);\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n+return compute(args[0].computeValue(context), args[0].computeValue(context))\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     protected final int getPrecedence() {\n         return 3;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return compute(args[0].computeValue(context), args[1].computeValue(context));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-10/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\t2022-07-19 07:29:52.175760729 +0200\n+++ /tmp/tmpf_2jju8v.java\t2022-07-19 07:29:52.175760729 +0200\n@@ -37,11 +37,11 @@\n     protected CoreOperationRelationalExpression(Expression[] args) {\n         super(args);\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n+return compute(args[0].computeValue(context), args[1].computeValue(context));\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     protected final int getPrecedence() {\n         return 3;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return compute(args[0].computeValue(context), args[0].computeValue(context));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-10/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\t2022-07-19 07:29:53.915751319 +0200\n+++ /tmp/tmp1tj1crg7.java\t2022-07-19 07:29:53.915751319 +0200\n@@ -37,11 +37,11 @@\n     protected CoreOperationRelationalExpression(Expression[] args) {\n         super(args);\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n+return compute(args[0].computeValue(context), args[0].computeValue(context));\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     protected final int getPrecedence() {\n         return 3;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return compute(args[0].computeValue(context), args].computeValue(context))",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-10/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\t2022-07-19 07:29:55.463742946 +0200\n+++ /tmp/tmp7tf1vgdf.java\t2022-07-19 07:29:55.463742946 +0200\n@@ -37,11 +37,11 @@\n     protected CoreOperationRelationalExpression(Expression[] args) {\n         super(args);\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n+return compute(args[0].computeValue(context), args].computeValue(context))\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     protected final int getPrecedence() {\n         return 3;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return compute(args[0].computeValue(context), args[computeValue(context))",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-10/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\t2022-07-19 07:29:57.063734294 +0200\n+++ /tmp/tmpwukcuypu.java\t2022-07-19 07:29:57.063734294 +0200\n@@ -37,11 +37,11 @@\n     protected CoreOperationRelationalExpression(Expression[] args) {\n         super(args);\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n+return compute(args[0].computeValue(context), args[computeValue(context))\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     protected final int getPrecedence() {\n         return 3;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return compute(args[0].computeValue(context), args[0], argsValue(context))",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-10/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\t2022-07-19 07:29:58.547726265 +0200\n+++ /tmp/tmppgmcshi1.java\t2022-07-19 07:29:58.551726244 +0200\n@@ -37,11 +37,11 @@\n     protected CoreOperationRelationalExpression(Expression[] args) {\n         super(args);\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n+return compute(args[0].computeValue(context), args[0], argsValue(context))\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     protected final int getPrecedence() {\n         return 3;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return compute(args[0].computeValue(context)); args[0].computeValue(context))",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-10/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\t2022-07-19 07:30:00.215717243 +0200\n+++ /tmp/tmp3y5hgihp.java\t2022-07-19 07:30:00.239717115 +0200\n@@ -37,11 +37,11 @@\n     protected CoreOperationRelationalExpression(Expression[] args) {\n         super(args);\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n+return compute(args[0].computeValue(context)); args[0].computeValue(context))\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     protected final int getPrecedence() {\n         return 3;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return compute(args[0].computeValue(context), args[1].computeValue(context)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-10/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\t2022-07-19 07:30:01.779708782 +0200\n+++ /tmp/tmpj4qf2mxq.java\t2022-07-19 07:30:01.783708761 +0200\n@@ -37,11 +37,11 @@\n     protected CoreOperationRelationalExpression(Expression[] args) {\n         super(args);\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n+return compute(args[0].computeValue(context), args[1].computeValue(context)) {\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     protected final int getPrecedence() {\n         return 3;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return compute(args[0].computeValue(context)); args[1].computeValue(context))",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-10/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\t2022-07-19 07:30:03.279700671 +0200\n+++ /tmp/tmpc7aii7mi.java\t2022-07-19 07:30:03.279700671 +0200\n@@ -37,11 +37,11 @@\n     protected CoreOperationRelationalExpression(Expression[] args) {\n         super(args);\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n+return compute(args[0].computeValue(context)); args[1].computeValue(context))\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     protected final int getPrecedence() {\n         return 3;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return compute(args[0].computeValue(context), args[1].computeValue(context))",
        "fixed_line": "return compute(args[0].compute(context), args[1].compute(context))"
    },
    "Jsoup-13": {
        "fixes": [
            {
                "k": 1,
                "patch": "// boolean hasAttr(attributeKey) { Validate.notNull(attributeKey); return attributes.",
                "patch_diff": "// boolean hasAttr(attributeKey) { Validate.notNull(attributeKey); return attributes.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// boolean hasAttr(attributeKey) { Validate.notNull(attributeKey); }",
                "patch_diff": "// boolean hasAttr(attributeKey) { Validate.notNull(attributeKey); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// boolean hasAttr(attributeKey) { Validate.notNull(attributeKey); return attributes; }",
                "patch_diff": "// boolean hasAttr(attributeKey) { Validate.notNull(attributeKey); return attributes; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return attributes.notNull(attributeKey); return attributes.hasKey(attributeKey); }",
                "patch_diff": "return attributes.notNull(attributeKey); return attributes.hasKey(attributeKey); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// boolean hasAttr(attributeKey); return attributes.hasKey(attributeKey); }",
                "patch_diff": "// boolean hasAttr(attributeKey); return attributes.hasKey(attributeKey); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// boolean hasAttr(attributeKey) { Validate.notNull(attributeKey); return attributes.hasKey(attributeKey); }",
                "patch_diff": "// boolean hasAttr(attributeKey) { Validate.notNull(attributeKey); return attributes.hasKey(attributeKey); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (attributeKey) { Validate.notNull(attributeKey); return attributes.hasKey(attributeKey); }",
                "patch_diff": "if (attributeKey) { Validate.notNull(attributeKey); return attributes.hasKey(attributeKey); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (attributeKey == null) { Validate.hasAttr(attributeKey); return attributes; }",
                "patch_diff": "if (attributeKey == null) { Validate.hasAttr(attributeKey); return attributes; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "boolean hasAttr(attributeKey) { Validate.notNull(attributeKey); return attributes.hasKey(attributeKey); }",
                "patch_diff": "boolean hasAttr(attributeKey) { Validate.notNull(attributeKey); return attributes.hasKey(attributeKey); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "boolean hasAttr(attributeKey); return attributes.hasKey(attributeKey); }",
                "patch_diff": "boolean hasAttr(attributeKey); return attributes.hasKey(attributeKey); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (attributeKey.toLowerCase().startsWith(\"abs:\")) { String key = attributeKey.substring(\"abs:\".length()); if (attributes.hasKey(key) && !absUrl(key).equals(\"\")) return true; }"
    },
    "Time-27": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (sep.get(0) instanceof Separator sep = elementPairs.get(0); }",
                "patch_diff": "if (sep.get(0) instanceof Separator sep = elementPairs.get(0); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (sep.length == 2 && elementPairs.get(0) instanceof Separator) {",
                "patch_diff": "if (sep.length == 2 && elementPairs.get(0) instanceof Separator) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (elementPairs.get(0) instanceof Separator sep = elementPairs.get(0); }",
                "patch_diff": "if (elementPairs.get(0) instanceof Separator sep = elementPairs.get(0); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int size = elementPairs.get(0) instanceof Separator sep = elementPairs.get(0); }",
                "patch_diff": "int size = elementPairs.get(0) instanceof Separator sep = elementPairs.get(0); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (elementPairs.get(0) instanceof Separator sep = elementPairs.get(0); } else {",
                "patch_diff": "if (elementPairs.get(0) instanceof Separator sep = elementPairs.get(0); } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (elementPairs.get(0) instanceof Separator sep = elementPairs.get(0);",
                "patch_diff": "if (elementPairs.get(0) instanceof Separator sep = elementPairs.get(0);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (sep.get(0) instanceof Separator sep = elementPairs.get(0); } else {",
                "patch_diff": "if (sep.get(0) instanceof Separator sep = elementPairs.get(0); } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (sep.get(0) instanceof Separator sep = elementPairs.get(0); } else if (element instanceof Separator) {",
                "patch_diff": "if (sep.get(0) instanceof Separator sep = elementPairs.get(0); } else if (element instanceof Separator) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (elementPairs.get(0) instanceof Separator sep = elementPairs.get(0); } else if (element instanceof Separator) {",
                "patch_diff": "if (elementPairs.get(0) instanceof Separator sep = elementPairs.get(0); } else if (element instanceof Separator) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (sep.get(0) instanceof Separator sep = elementPairs.get(0);",
                "patch_diff": "if (sep.get(0) instanceof Separator sep = elementPairs.get(0);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (sep.iAfterParser == null && sep.iAfterPrinter == null) { PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); sep = sep.finish(f.getPrinter(), f.getParser()); return new PeriodFormatter(sep, sep); }"
    },
    "Closure-125": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (fnType!= null && fnType!=fnType) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-125/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 07:30:08.639671669 +0200\n+++ /tmp/tmpnqq233cc.java\t2022-07-19 07:30:08.683671436 +0200\n@@ -1656,11 +1656,11 @@\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+if (fnType!= null && fnType!=fnType) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n         ensureTyped(t, n);\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (fnType!= null && fnType!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-125/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 07:30:59.063398722 +0200\n+++ /tmp/tmpkl5h65ro.java\t2022-07-19 07:30:59.067398702 +0200\n@@ -1656,11 +1656,11 @@\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+if (fnType!= null && fnType!= null) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n         ensureTyped(t, n);\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if ( fnType!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-125/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 07:31:47.707135152 +0200\n+++ /tmp/tmpwpegf11i.java\t2022-07-19 07:31:47.711135133 +0200\n@@ -1656,11 +1656,11 @@\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+if ( fnType!= null) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n         ensureTyped(t, n);\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (fnType!= null && fnType!= type) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-125/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 07:32:36.890868427 +0200\n+++ /tmp/tmp_kjyjkir.java\t2022-07-19 07:32:36.890868427 +0200\n@@ -1656,11 +1656,11 @@\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+if (fnType!= null && fnType!= type) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n         ensureTyped(t, n);\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (fnType!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-125/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 07:33:25.230606071 +0200\n+++ /tmp/tmpjm0ypkrk.java\t2022-07-19 07:33:25.230606071 +0200\n@@ -1656,11 +1656,11 @@\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+if (fnType!= null) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n         ensureTyped(t, n);\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if ( fnType!= null && fnType!=fnType) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-125/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 07:34:13.714342747 +0200\n+++ /tmp/tmpszaw29wi.java\t2022-07-19 07:34:13.714342747 +0200\n@@ -1656,11 +1656,11 @@\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+if ( fnType!= null && fnType!=fnType) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n         ensureTyped(t, n);\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (fnType!= null && fnType!= fnType) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-125/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 07:35:02.038080120 +0200\n+++ /tmp/tmp0su298m9.java\t2022-07-19 07:35:02.038080120 +0200\n@@ -1656,11 +1656,11 @@\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+if (fnType!= null && fnType!= fnType) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n         ensureTyped(t, n);\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if ( fnType!= null && fnType!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-125/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 07:35:50.897814426 +0200\n+++ /tmp/tmpvvr5zgf6.java\t2022-07-19 07:35:50.897814426 +0200\n@@ -1656,11 +1656,11 @@\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+if ( fnType!= null && fnType!= null) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n         ensureTyped(t, n);\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (fnType!= null && fnType!=dateType) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-125/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 07:36:39.269562808 +0200\n+++ /tmp/tmpxdli9cf9.java\t2022-07-19 07:36:39.269562808 +0200\n@@ -1656,11 +1656,11 @@\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+if (fnType!= null && fnType!=dateType) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n         ensureTyped(t, n);\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if ( fnType!= null && fnType!= type) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-125/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-19 07:36:43.133546029 +0200\n+++ /tmp/tmpr4s7hlvy.java\t2022-07-19 07:36:43.133546029 +0200\n@@ -1656,11 +1656,11 @@\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+if ( fnType!= null && fnType!= type) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n         ensureTyped(t, n);\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (fnType != null) {",
        "fixed_line": "if (fnType != null && fnType.hasInstanceType()) {"
    },
    "Closure-36": {
        "fixes": [
            {
                "k": 1,
                "patch": "// canMoveAggressively(value) || canMoveModerately",
                "patch_diff": "// canMoveAggressively(value) || canMoveModerately",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return canMoveAggressively(value) || canMoveModerately",
                "patch_diff": "return canMoveAggressively(value) || canMoveModerately",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return canMoveAggressively(value) || canMoveAggressively(value);",
                "patch_diff": "return canMoveAggressively(value) || canMoveAggressively(value);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// canMoveAggressively(value) || canMoveAggressively",
                "patch_diff": "// canMoveAggressively(value) || canMoveAggressively",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return canMoveAggressively(value) || canMoveAggressively",
                "patch_diff": "return canMoveAggressively(value) || canMoveAggressively",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// now 668: Don't inline singleton getter methods",
                "patch_diff": "// now 668: Don't inline singleton getter methods",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return canMoveAggressively(value); // issue 668: Don't inline canMoveAggressively(value) || canMoveAggressively",
                "patch_diff": "return canMoveAggressively(value); // issue 668: Don't inline canMoveAggressively(value) || canMoveAggressively",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return canMoveAggressively(value); // issue 668: Don't inline canMoveAggressively(value)",
                "patch_diff": "return canMoveAggressively(value); // issue 668: Don't inline canMoveAggressively(value)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return canMoveAggressively(value); // issue 668: Don't inline canMoveAggressively(value) || canMoveAggressively(value);",
                "patch_diff": "return canMoveAggressively(value); // issue 668: Don't inline canMoveAggressively(value) || canMoveAggressively(value);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return canMoveAggressively(value); // issue 668: Don't inline canMoveAggressively",
                "patch_diff": "return canMoveAggressively(value); // issue 668: Don't inline canMoveAggressively",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (convention.getSingletonGetterClassName(callNode) != null) { return false; }"
    },
    "Chart-6": {
        "fixes": [
            {
                "k": 1,
                "patch": "return super.equals(obj);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-6/source/org/jfree/chart/util/ShapeList.java\t2022-07-19 07:37:34.465320571 +0200\n+++ /tmp/tmpf2bxke7t.java\t2022-07-19 07:37:34.489320464 +0200\n@@ -106,11 +106,11 @@\n             return true;\n         }\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+return super.equals(obj);\n \n     }\n \n     /**\n      * Returns a hash code value for the object.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return super.equals(obj =obj);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-6/source/org/jfree/chart/util/ShapeList.java\t2022-07-19 07:37:42.977282749 +0200\n+++ /tmp/tmps99u2xw4.java\t2022-07-19 07:37:42.977282749 +0200\n@@ -106,11 +106,11 @@\n             return true;\n         }\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+return super.equals(obj =obj);\n \n     }\n \n     /**\n      * Returns a hash code value for the object.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return super.equals(obj); // TODO: return false;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-6/source/org/jfree/chart/util/ShapeList.java\t2022-07-19 07:37:51.109246504 +0200\n+++ /tmp/tmptxgqfbgn.java\t2022-07-19 07:37:51.109246504 +0200\n@@ -106,11 +106,11 @@\n             return true;\n         }\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+return super.equals(obj); // TODO: return false;\n \n     }\n \n     /**\n      * Returns a hash code value for the object.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return super.equals(obj); // TODO: return super.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-6/source/org/jfree/chart/util/ShapeList.java\t2022-07-19 07:37:59.609208506 +0200\n+++ /tmp/tmp0sq1gmi7.java\t2022-07-19 07:37:59.609208506 +0200\n@@ -106,11 +106,11 @@\n             return true;\n         }\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+return super.equals(obj); // TODO: return super.\n \n     }\n \n     /**\n      * Returns a hash code value for the object.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return super.equals(obj); // value is to do this",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-6/source/org/jfree/chart/util/ShapeList.java\t2022-07-19 07:38:07.677172333 +0200\n+++ /tmp/tmp37fttnxk.java\t2022-07-19 07:38:07.677172333 +0200\n@@ -106,11 +106,11 @@\n             return true;\n         }\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+return super.equals(obj); // value is to do this\n \n     }\n \n     /**\n      * Returns a hash code value for the object.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return super.equals(obj); // to check whether a dataset with 0",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-6/source/org/jfree/chart/util/ShapeList.java\t2022-07-19 07:38:15.677136363 +0200\n+++ /tmp/tmpouj2_8zr.java\t2022-07-19 07:38:15.677136363 +0200\n@@ -106,11 +106,11 @@\n             return true;\n         }\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+return super.equals(obj); // to check whether a dataset with 0\n \n     }\n \n     /**\n      * Returns a hash code value for the object.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return super.equals(obj); // the value is to the",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-6/source/org/jfree/chart/util/ShapeList.java\t2022-07-19 07:38:23.741100008 +0200\n+++ /tmp/tmp2o1w70ku.java\t2022-07-19 07:38:23.741100008 +0200\n@@ -106,11 +106,11 @@\n             return true;\n         }\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+return super.equals(obj); // the value is to the\n \n     }\n \n     /**\n      * Returns a hash code value for the object.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return super.equals(obj); // to check whether a dataset (e.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-6/source/org/jfree/chart/util/ShapeList.java\t2022-07-19 07:38:31.833063426 +0200\n+++ /tmp/tmp3kmwh7n1.java\t2022-07-19 07:38:31.833063426 +0200\n@@ -106,11 +106,11 @@\n             return true;\n         }\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+return super.equals(obj); // to check whether a dataset (e.\n \n     }\n \n     /**\n      * Returns a hash code value for the object.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return super.equals(obj); // value is lower case",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-6/source/org/jfree/chart/util/ShapeList.java\t2022-07-19 07:38:39.885026928 +0200\n+++ /tmp/tmp4uymm2dj.java\t2022-07-19 07:38:39.885026928 +0200\n@@ -106,11 +106,11 @@\n             return true;\n         }\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+return super.equals(obj); // value is lower case\n \n     }\n \n     /**\n      * Returns a hash code value for the object.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return super.equals(obj); // to check whether a size",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-6/source/org/jfree/chart/util/ShapeList.java\t2022-07-19 07:38:48.028989917 +0200\n+++ /tmp/tmp9972hd32.java\t2022-07-19 07:38:48.028989917 +0200\n@@ -106,11 +106,11 @@\n             return true;\n         }\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+return super.equals(obj); // to check whether a size\n \n     }\n \n     /**\n      * Returns a hash code value for the object.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return super.equals(obj);",
        "fixed_line": "ShapeList that = (ShapeList) obj; int listSize = size(); for (int i = 0; i < listSize; i++) { if (!ShapeUtilities.equal((Shape) get(i), (Shape) that.get(i))) { return false; } } return true;"
    },
    "Time-24": {
        "fixes": [
            {
                "k": 1,
                "patch": "e.prependMessage(\"Cannot parse \\\"\" + iMillis[i].set(millis);",
                "patch_diff": "e.prependMessage(\"Cannot parse \\\"\" + iMillis[i].set(millis);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "e.prependMessage(\"Cannot parse \\\"\" + iMillis[i].set(millis); }",
                "patch_diff": "e.prependMessage(\"Cannot parse \\\"\" + iMillis[i].set(millis); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "e.prependMessage(\"Cannot parse \\\"\" + iMillis[i].set(millis, resetFields); }",
                "patch_diff": "e.prependMessage(\"Cannot parse \\\"\" + iMillis[i].set(millis, resetFields); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "e.prependMessage(\"Cannot parse \\\"\" + iMillis[i].set(millis, resetFields);",
                "patch_diff": "e.prependMessage(\"Cannot parse \\\"\" + iMillis[i].set(millis, resetFields);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "e.prependMessage(\"Cannot parse \\\"\" + iMillis[i].set(millis, resetFields); } else {",
                "patch_diff": "e.prependMessage(\"Cannot parse \\\"\" + iMillis[i].set(millis, resetFields); } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "e.prependMessage(\"Cannot parse \\\"\" + iMillis[i].set(millis); } else {",
                "patch_diff": "e.prependMessage(\"Cannot parse \\\"\" + iMillis[i].set(millis); } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "e.prependMessage(\"Cannot parse \\\"\" + text + '\"'); } throw e;",
                "patch_diff": "e.prependMessage(\"Cannot parse \\\"\" + text + '\"'); } throw e;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "e.prependMessage(\"Cannot parse \\\"\" + text + '\"'); } else {",
                "patch_diff": "e.prependMessage(\"Cannot parse \\\"\" + text + '\"'); } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "e.prependMessage(\"Cannot parse \\\"\" + iMillis[i].set(millis); } }",
                "patch_diff": "e.prependMessage(\"Cannot parse \\\"\" + iMillis[i].set(millis); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "e.prependMessage(\"Cannot parse \\\"\" + iMillis[i].set(millis); } throw e;",
                "patch_diff": "e.prependMessage(\"Cannot parse \\\"\" + iMillis[i].set(millis); } throw e;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (resetFields) { for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, i == (count - 1)); } }"
    },
    "JacksonDatabind-74": {
        "fixes": [
            {
                "k": 1,
                "patch": "return super.reportWrongTokenException(p, \"missing property '\"+_typePropertyName+\"' that is to contain type id (for class \"+baseTypeName()+\")\"); return null; }",
                "patch_diff": "return super.reportWrongTokenException(p, \"missing property '\"+_typePropertyName+\"' that is to contain type id (for class \"+baseTypeName()+\")\"); return null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return super.reportWrongTokenException(p, \"missing property '\"+_typePropertyName+\"' that is to contain type id (for class \"+baseTypeName()+\")\"); return null;",
                "patch_diff": "return super.reportWrongTokenException(p, \"missing property '\"+_typePropertyName+\"' that is to contain type id (for class \"+baseTypeName()+\")\"); return null;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return super.reportWrongTokenException(p, JsonToken.FIELD_NAME, \"missing property '\"+_typePropertyName+\"' that is to contain type id (for class \"+baseTypeName()+\")\"); return null; }",
                "patch_diff": "return super.reportWrongTokenException(p, JsonToken.FIELD_NAME, \"missing property '\"+_typePropertyName+\"' that is to contain type id (for class \"+baseTypeName()+\")\"); return null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return super.reportWrongTokenException(p, \"missing property '\"+_typePropertyName+\"' that is to contain type id (for class \"+baseTypeName()+\")",
                "patch_diff": "return super.reportWrongTokenException(p, \"missing property '\"+_typePropertyName+\"' that is to contain type id (for class \"+baseTypeName()+\")",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return super.reportWrongTokenException(p, JsonToken.FIELD_NAME, \"missing property '\"+_typePropertyName+\"' that is to contain type id (for class \"+baseTypeName()+\")\"); return null;",
                "patch_diff": "return super.reportWrongTokenException(p, JsonToken.FIELD_NAME, \"missing property '\"+_typePropertyName+\"' that is to contain type id (for class \"+baseTypeName()+\")\"); return null;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return super.reportWrongTokenException(p, \"missing property '\"+_OBJECT' that is to contain type id (for class \"+baseTypeName()+\")\"); return null; }",
                "patch_diff": "return super.reportWrongTokenException(p, \"missing property '\"+_OBJECT' that is to contain type id (for class \"+baseTypeName()+\")\"); return null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return super.reportWrongTokenException(p, \"missing property '\"+_OBJECT' that is to contain type id (for class \"+baseTypeName()+\")\"); return null;",
                "patch_diff": "return super.reportWrongTokenException(p, \"missing property '\"+_OBJECT' that is to contain type id (for class \"+baseTypeName()+\")\"); return null;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return super.reportWrongTokenException(p, \"missing property '\"+_typePropertyName+\"' that is to contain type id (for which \"wrapper-array\" won't work",
                "patch_diff": "return super.reportWrongTokenException(p, \"missing property '\"+_typePropertyName+\"' that is to contain type id (for which \"wrapper-array\" won't work",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return super.reportWrongTokenException(p, \"missing property '\"+_typePropertyName+\"' that is to contain type id (for class \"+baseTypeName()+\")); return null; }",
                "patch_diff": "return super.reportWrongTokenException(p, \"missing property '\"+_typePropertyName+\"' that is to contain type id (for class \"+baseTypeName()+\")); return null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return super.reportWrongTokenException(p, \"missing property '\"+_typePropertyName+\"' that is to contain type id (for which \"wrapper-array\" won't work, changed into \"wrapper-array\"",
                "patch_diff": "return super.reportWrongTokenException(p, \"missing property '\"+_typePropertyName+\"' that is to contain type id (for which \"wrapper-array\" won't work, changed into \"wrapper-array\"",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "} else if (p.getCurrentToken() == JsonToken.VALUE_STRING) { if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { String str = p.getText().trim(); if (str.isEmpty()) { return null; } }"
    },
    "JacksonDatabind-88": {
        "fixes": [
            {
                "k": 1,
                "patch": "JavaType t = tf.constructFromCanonical(tatu);",
                "patch_diff": "JavaType t = tf.constructFromCanonical(tatu);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "JavaType t = tf.constructFromCanonical(tatu:",
                "patch_diff": "JavaType t = tf.constructFromCanonical(tatu:",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "JavaType t = tf.constructFromCanonical(tatu: As.id);",
                "patch_diff": "JavaType t = tf.constructFromCanonical(tatu: As.id);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "JavaType t = tf.constructFromCanonical(tatu: As per [databind#",
                "patch_diff": "JavaType t = tf.constructFromCanonical(tatu: As per [databind#",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "JavaType t = tf.constructFromCanonical(tatu: As per [databind#17",
                "patch_diff": "JavaType t = tf.constructFromCanonical(tatu: As per [databind#17",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "JavaType t = tf.constructFromCanonical(tatu: As per [databind",
                "patch_diff": "JavaType t = tf.constructFromCanonical(tatu: As per [databind",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "JavaType t = tf.constructFromCanonical(tatu: As.",
                "patch_diff": "JavaType t = tf.constructFromCanonical(tatu: As.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "JavaType t = tf.constructFromCanonical(tatu: As per [JACKSON-407] -- allow use a method",
                "patch_diff": "JavaType t = tf.constructFromCanonical(tatu: As per [JACKSON-407] -- allow use a method",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "JavaType t = tf.constructFromCanonical(tatu: As per [JACKSON-1);",
                "patch_diff": "JavaType t = tf.constructFromCanonical(tatu: As per [JACKSON-1);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "JavaType t = tf.constructFromCanonical(tatu: As.type);",
                "patch_diff": "JavaType t = tf.constructFromCanonical(tatu: As.type);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) { // Probably cleaner to have a method in `TypeFactory` but can't add in patch throw new IllegalArgumentException(String.format( \"Class %s not subtype of %s\", t.getRawClass().getName(), _baseType)); }"
    },
    "Closure-161": {
        "fixes": [
            {
                "k": 1,
                "patch": "// // can't really modify it was non-literal characters that might be valid (e if (left.getType()!= Token.NUMBER) {",
                "patch_diff": "// // can't really modify it was non-literal characters that might be valid (e if (left.getType()!= Token.NUMBER) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// // can't really modify it was non-literal characters that might be valid (e if (left.getType() == Token.NUMBER) {",
                "patch_diff": "// // can't really modify it was non-literal characters that might be valid (e if (left.getType() == Token.NUMBER) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// // can't really modify it was non-literal characters that might be valid (e if (right.getType()!= Token.NUMBER) {",
                "patch_diff": "// // can't really modify it was non-literal characters that might be valid (e if (right.getType()!= Token.NUMBER) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// // can't really modify it was non-literal characters that might be valid (right.getType()!= Token.NUMBER) {",
                "patch_diff": "// // can't really modify it was non-literal characters that might be valid (right.getType()!= Token.NUMBER) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// // can't really modify it was non-literal characters that might be valid (e if (left.getType()!= Token.NAME) {",
                "patch_diff": "// // can't really modify it was non-literal characters that might be valid (e if (left.getType()!= Token.NAME) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// // can't really modify it was non-literal characters that might be valid (e if (right.getType() == Token.NUMBER) {",
                "patch_diff": "// // can't really modify it was non-literal characters that might be valid (e if (right.getType() == Token.NUMBER) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// // can't really modify it was non-literal characters that might be valid (e if it.getType()!= Token.NUMBER) {",
                "patch_diff": "// // can't really modify it was non-literal characters that might be valid (e if it.getType()!= Token.NUMBER) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// // can't really modify it was non-literal characters that might be valid ( (right.getType()!= Token.NUMBER) {",
                "patch_diff": "// // can't really modify it was non-literal characters that might be valid ( (right.getType()!= Token.NUMBER) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// // can't really modify it was non-literal characters that might be valid (e if (right.getType()!= Token.NAME) {",
                "patch_diff": "// // can't really modify it was non-literal characters that might be valid (e if (right.getType()!= Token.NAME) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// // can't really modify it was non-literal characters that might be valid (right.getType() == Token.NUMBER) {",
                "patch_diff": "// // can't really modify it was non-literal characters that might be valid (right.getType() == Token.NUMBER) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (isAssignmentTarget(n)) { return n; }"
    },
    "Cli-23": {
        "fixes": [
            {
                "k": 1,
                "patch": "int lastPos = pos; text = padding + text.length;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-23/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 07:39:03.408919762 +0200\n+++ /tmp/tmpk2lkl3w9.java\t2022-07-19 07:39:03.432919651 +0200\n@@ -819,23 +819,11 @@\n         // characters\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n-            int lastPos = pos;\n-            text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, 0);\n-\n-            if (pos == -1)\n-            {\n-                sb.append(text);\n-\n-                return sb;\n-            } else\n-            if (pos == lastPos)\n-            {\n-                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n+int lastPos = pos; text = padding + text.length;\n             }\n \n             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int lastPos = pos; text = padding + text.length() - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-23/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 07:39:05.068912169 +0200\n+++ /tmp/tmpe56sgcz5.java\t2022-07-19 07:39:05.072912151 +0200\n@@ -819,23 +819,11 @@\n         // characters\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n-            int lastPos = pos;\n-            text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, 0);\n-\n-            if (pos == -1)\n-            {\n-                sb.append(text);\n-\n-                return sb;\n-            } else\n-            if (pos == lastPos)\n-            {\n-                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n+int lastPos = pos; text = padding + text.length() - 1;\n             }\n \n             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int lastPos = pos; text = padding + text.append(pos);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-23/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 07:39:06.604905142 +0200\n+++ /tmp/tmptppwu6h7.java\t2022-07-19 07:39:06.604905142 +0200\n@@ -819,23 +819,11 @@\n         // characters\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n-            int lastPos = pos;\n-            text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, 0);\n-\n-            if (pos == -1)\n-            {\n-                sb.append(text);\n-\n-                return sb;\n-            } else\n-            if (pos == lastPos)\n-            {\n-                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n+int lastPos = pos; text = padding + text.append(pos);\n             }\n \n             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int lastPos = pos; text = padding + text.length - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-23/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 07:39:08.072898421 +0200\n+++ /tmp/tmpjwlff13j.java\t2022-07-19 07:39:08.076898402 +0200\n@@ -819,23 +819,11 @@\n         // characters\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n-            int lastPos = pos;\n-            text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, 0);\n-\n-            if (pos == -1)\n-            {\n-                sb.append(text);\n-\n-                return sb;\n-            } else\n-            if (pos == lastPos)\n-            {\n-                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n+int lastPos = pos; text = padding + text.length - 1;\n             }\n \n             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int lastPos = pos; text = padding + text.getWrapPos(pos);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-23/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 07:39:09.528891752 +0200\n+++ /tmp/tmp54rxk_tc.java\t2022-07-19 07:39:09.532891734 +0200\n@@ -819,23 +819,11 @@\n         // characters\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n-            int lastPos = pos;\n-            text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, 0);\n-\n-            if (pos == -1)\n-            {\n-                sb.append(text);\n-\n-                return sb;\n-            } else\n-            if (pos == lastPos)\n-            {\n-                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n+int lastPos = pos; text = padding + text.getWrapPos(pos);\n             }\n \n             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int lastPos = pos + text.substring(pos).trim(); pos = findWrapPos(pos);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-23/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 07:39:10.992885046 +0200\n+++ /tmp/tmptl7x6qvz.java\t2022-07-19 07:39:10.996885026 +0200\n@@ -819,23 +819,11 @@\n         // characters\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n-            int lastPos = pos;\n-            text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, 0);\n-\n-            if (pos == -1)\n-            {\n-                sb.append(text);\n-\n-                return sb;\n-            } else\n-            if (pos == lastPos)\n-            {\n-                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n+int lastPos = pos + text.substring(pos).trim(); pos = findWrapPos(pos);\n             }\n \n             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int lastPos = pos + text.length; pos = findWrapPos(text);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-23/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 07:39:12.496878150 +0200\n+++ /tmp/tmpli19gjeo.java\t2022-07-19 07:39:12.500878133 +0200\n@@ -819,23 +819,11 @@\n         // characters\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n-            int lastPos = pos;\n-            text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, 0);\n-\n-            if (pos == -1)\n-            {\n-                sb.append(text);\n-\n-                return sb;\n-            } else\n-            if (pos == lastPos)\n-            {\n-                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n+int lastPos = pos + text.length; pos = findWrapPos(text);\n             }\n \n             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int lastPos = pos + text.substring(pos).trim(); pos = findWrapPos(text);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-23/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 07:39:13.952871474 +0200\n+++ /tmp/tmp3qipijz5.java\t2022-07-19 07:39:13.952871474 +0200\n@@ -819,23 +819,11 @@\n         // characters\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n-            int lastPos = pos;\n-            text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, 0);\n-\n-            if (pos == -1)\n-            {\n-                sb.append(text);\n-\n-                return sb;\n-            } else\n-            if (pos == lastPos)\n-            {\n-                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n+int lastPos = pos + text.substring(pos).trim(); pos = findWrapPos(text);\n             }\n \n             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int lastPos = pos; text = padding + text.length; pos = findWrapPos(text);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-23/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 07:39:15.420864737 +0200\n+++ /tmp/tmpi3n4hvmg.java\t2022-07-19 07:39:15.420864737 +0200\n@@ -819,23 +819,11 @@\n         // characters\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n-            int lastPos = pos;\n-            text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, 0);\n-\n-            if (pos == -1)\n-            {\n-                sb.append(text);\n-\n-                return sb;\n-            } else\n-            if (pos == lastPos)\n-            {\n-                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n+int lastPos = pos; text = padding + text.length; pos = findWrapPos(text);\n             }\n \n             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int lastPos = pos + text.length; text = findWrapPos(text);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-23/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 07:39:16.952857707 +0200\n+++ /tmp/tmphh7f5uo7.java\t2022-07-19 07:39:16.952857707 +0200\n@@ -819,23 +819,11 @@\n         // characters\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n-            int lastPos = pos;\n-            text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, 0);\n-\n-            if (pos == -1)\n-            {\n-                sb.append(text);\n-\n-                return sb;\n-            } else\n-            if (pos == lastPos)\n-            {\n-                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n+int lastPos = pos + text.length; text = findWrapPos(text);\n             }\n \n             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "int lastPos = pos; text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } else if (pos == lastPos) { throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);",
        "fixed_line": "} if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) { sb.append(text); return sb;"
    },
    "JacksonDatabind-49": {
        "fixes": [
            {
                "k": 1,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for \"alwaysAsId\", but not being written as POJO;",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for \"alwaysAsId\", but not being written as POJO;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for \"alwaysAsId\", but not being written as POJO of",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for \"alwaysAsId\", but not being written as POJO of",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for \"alwaysAsId\", but not being written as POJO",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for \"alwaysAsId\", but not being written as POJO",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for \"alwaysAsId\", but not being written as POJO (forPojo)",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for \"alwaysAsId\", but not being written as POJO (forPojo)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for \"alwaysAsId\", but not being written as POJO of current:",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for \"alwaysAsId\", but not being written as POJO of current:",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for \"alwaysAsId\", but not being written",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for \"alwaysAsId\", but not being written",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for \"alwaysAsId\", but not being written as POJO of a:",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for \"alwaysAsId\", but not being written as POJO of a:",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return id; // as per [JACKSON-407] -- allow disabling wrapping for \"alwaysAsId\", but not being written as POJO of",
                "patch_diff": "return id; // as per [JACKSON-407] -- allow disabling wrapping for \"alwaysAsId\", but not being written as POJO of",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return id; // as per [JACKSON-407] -- allow disabling wrapping for \"alwaysAsId\", but not being written as POJO;",
                "patch_diff": "return id; // as per [JACKSON-407] -- allow disabling wrapping for \"alwaysAsId\", but not being written as POJO;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return id; // as per [JACKSON-407] -- allow disabling wrapping for \"alwaysAsId\", but not being written as POJO",
                "patch_diff": "return id; // as per [JACKSON-407] -- allow disabling wrapping for \"alwaysAsId\", but not being written as POJO",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (id == null) { id = generator.generateId(forPojo); }"
    },
    "Math-13": {
        "fixes": [
            {
                "k": 1,
                "patch": "final EigenDecomposition dec = new EigenDecomposition(m);",
                "patch_diff": "final EigenDecomposition dec = new EigenDecomposition(m);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "final EigenDecomposition dec = new EigenDecomposition(m); } else {",
                "patch_diff": "final EigenDecomposition dec = new EigenDecomposition(m); } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "final EigenDecomposition dec = new EigenDecomposition(m); }",
                "patch_diff": "final EigenDecomposition dec = new EigenDecomposition(m); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "final EigenDecomposition dec = new EigenDecomposition(m); } }",
                "patch_diff": "final EigenDecomposition dec = new EigenDecomposition(m); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "final EigenDecomposition = new EigenDecomposition(m);",
                "patch_diff": "final EigenDecomposition = new EigenDecomposition(m);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "final EigenDecomposition dec = new EigenDecomposition(m.getSquareRoot()); }",
                "patch_diff": "final EigenDecomposition dec = new EigenDecomposition(m.getSquareRoot()); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private RealMatrix square = new EigenDecomposition(m);",
                "patch_diff": "private RealMatrix square = new EigenDecomposition(m);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "final EigenDecomposition = new EigenDecomposition(m); } else {",
                "patch_diff": "final EigenDecomposition = new EigenDecomposition(m); } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private RealMatrix square = new EigenDecomposition(m); } else {",
                "patch_diff": "private RealMatrix square = new EigenDecomposition(m); } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "final EigenDecomposition dec = new EigenDecomposition(m.getSquareRoot()); } else {",
                "patch_diff": "final EigenDecomposition dec = new EigenDecomposition(m.getSquareRoot()); } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (m instanceof DiagonalMatrix) { final int dim = m.getRowDimension(); final RealMatrix sqrtM = new DiagonalMatrix(dim); for (int i = 0; i < dim; i++) { sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i))); } return sqrtM; } else { final EigenDecomposition dec = new EigenDecomposition(m); return dec.getSquareRoot(); }"
    },
    "Math-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "return FastMath.pow(2 * FastMath.PI, -dim / 2) *",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-11/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\t2022-07-19 07:39:22.012834458 +0200\n+++ /tmp/tmps7vikq84.java\t2022-07-19 07:39:22.044834312 +0200\n@@ -178,11 +178,11 @@\n         final int dim = getDimension();\n         if (vals.length != dim) {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return FastMath.pow(2 * FastMath.PI, -1 *",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-11/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\t2022-07-19 07:40:11.972603114 +0200\n+++ /tmp/tmpa3nps2x7.java\t2022-07-19 07:40:11.972603114 +0200\n@@ -178,11 +178,11 @@\n         final int dim = getDimension();\n         if (vals.length != dim) {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+return FastMath.pow(2 * FastMath.PI, -1 *\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return FastMath.pow(2 * FastMath.PI, -1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-11/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\t2022-07-19 07:40:13.920594030 +0200\n+++ /tmp/tmptu774x9k.java\t2022-07-19 07:40:13.920594030 +0200\n@@ -178,11 +178,11 @@\n         final int dim = getDimension();\n         if (vals.length != dim) {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+return FastMath.pow(2 * FastMath.PI, -1;\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return FastMath.pow(2 * FastMath.PI, -dim *",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-11/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\t2022-07-19 07:40:15.912584737 +0200\n+++ /tmp/tmpmhthsqtj.java\t2022-07-19 07:40:15.912584737 +0200\n@@ -178,11 +178,11 @@\n         final int dim = getDimension();\n         if (vals.length != dim) {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+return FastMath.pow(2 * FastMath.PI, -dim *\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return FastMath.pow(2 * FastMath.PI, -1) *",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-11/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\t2022-07-19 07:40:17.924575344 +0200\n+++ /tmp/tmp2s7vm8gt.java\t2022-07-19 07:40:17.928575324 +0200\n@@ -178,11 +178,11 @@\n         final int dim = getDimension();\n         if (vals.length != dim) {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+return FastMath.pow(2 * FastMath.PI, -1) *\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return FastMath.pow(2 *RECE.PI, -dim / 2) *",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-11/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\t2022-07-19 07:41:04.864354866 +0200\n+++ /tmp/tmpdn0e7ho0.java\t2022-07-19 07:41:04.864354866 +0200\n@@ -178,11 +178,11 @@\n         final int dim = getDimension();\n         if (vals.length != dim) {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+return FastMath.pow(2 *RECE.PI, -dim / 2) *\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return FastMath.pow(2 * publisher.PI, -dim / 2) *",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-11/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\t2022-07-19 07:41:07.004344754 +0200\n+++ /tmp/tmpqqrei2kb.java\t2022-07-19 07:41:07.004344754 +0200\n@@ -178,11 +178,11 @@\n         final int dim = getDimension();\n         if (vals.length != dim) {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+return FastMath.pow(2 * publisher.PI, -dim / 2) *\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return FastMath.pow(2 * FastMath.length, -1 *",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-11/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\t2022-07-19 07:41:09.112334790 +0200\n+++ /tmp/tmpytwpzwon.java\t2022-07-19 07:41:09.116334771 +0200\n@@ -178,11 +178,11 @@\n         final int dim = getDimension();\n         if (vals.length != dim) {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+return FastMath.pow(2 * FastMath.length, -1 *\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return FastMath.pow(2 * FastMath.PI, -1, -1 *",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-11/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\t2022-07-19 07:41:11.192324953 +0200\n+++ /tmp/tmpo2d98p2_.java\t2022-07-19 07:41:11.192324953 +0200\n@@ -178,11 +178,11 @@\n         final int dim = getDimension();\n         if (vals.length != dim) {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+return FastMath.pow(2 * FastMath.PI, -1, -1 *\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return FastMath.pow(2 * FastMath.PI, -dim * 2) / 2;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-11/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\t2022-07-19 07:41:13.084316000 +0200\n+++ /tmp/tmpgrbgzc4n.java\t2022-07-19 07:41:13.084316000 +0200\n@@ -178,11 +178,11 @@\n         final int dim = getDimension();\n         if (vals.length != dim) {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+return FastMath.pow(2 * FastMath.PI, -dim * 2) / 2;\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return FastMath.pow(2 * FastMath.PI, -dim / 2) *",
        "fixed_line": "return FastMath.pow(2 * FastMath.PI, -0.5 * dim) *"
    },
    "Closure-42": {
        "fixes": [
            {
                "k": 1,
                "patch": "return newNodeForInLoop loopNode.getIterator()), transformBlock);",
                "patch_diff": "return newNodeForInLoop loopNode.getIterator()), transformBlock);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return newNodeForInLoop loopNode.getIterator()), transformBlock(loopNode);",
                "patch_diff": "return newNodeForInLoop loopNode.getIterator()), transformBlock(loopNode);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return newNodeForInLoop loopNode.getIterator()), transformBlock;",
                "patch_diff": "return newNodeForInLoop loopNode.getIterator()), transformBlock;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return newNodeForInLoop loopNode.getIterator()), transformBlockNode.getBody()));",
                "patch_diff": "return newNodeForInLoop loopNode.getIterator()), transformBlockNode.getBody()));",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return newNodeForInLoop loopNode.getIterator()), transformBlock(loopNode.getIteratedObject()), transformBlock);",
                "patch_diff": "return newNodeForInLoop loopNode.getIterator()), transformBlock(loopNode.getIteratedObject()), transformBlock);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return newNodeForInLoop loopNode.getIterator()), transformBlockNode);",
                "patch_diff": "return newNodeForInLoop loopNode.getIterator()), transformBlockNode);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return newNodeForInLoop loopNode.getIterator()), transformBlock(loopNode.getIteratedObject()), transformBlock); }",
                "patch_diff": "return newNodeForInLoop loopNode.getIterator()), transformBlock(loopNode.getIteratedObject()), transformBlock); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return newNodeForInLoop loopNode.getIterator()), transformBlock(loopNode.getIteratedObject()), false);",
                "patch_diff": "return newNodeForInLoop loopNode.getIterator()), transformBlock(loopNode.getIteratedObject()), false);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return newNodeForInLoop loopNode.getIterator()), transformBlockInLoop;",
                "patch_diff": "return newNodeForInLoop loopNode.getIterator()), transformBlockInLoop;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return newNode.getIterator()), transformBlock(loopNode.getIteratedObject()), transformBlock);",
                "patch_diff": "return newNode.getIterator()), transformBlock(loopNode.getIteratedObject()), transformBlock);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (loopNode.isForEach()) { errorReporter.error( \"unsupported language extension: for each\", sourceName, loopNode.getLineno(), \"\", 0); // Return the bare minimum to put the AST in a valid state. return newNode(Token.EXPR_RESULT, Node.newNumber(0)); }"
    },
    "Closure-132": {
        "fixes": [
            {
                "k": 1,
                "patch": "!mayEffectMutableState(lhs)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 07:41:17.228296379 +0200\n+++ /tmp/tmpyq_espbx.java\t2022-07-19 07:41:17.320295941 +0200\n@@ -777,11 +777,11 @@\n           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n               // if LHS has side effects, don't proceed [since the optimization\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+!mayEffectMutableState(lhs)) {\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "!mayEffectMutableState(lhs)) { // don't proceed [since the optimization // evaluates LHS before cond] // side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 07:42:09.984045010 +0200\n+++ /tmp/tmpsodi11jb.java\t2022-07-19 07:42:09.984045010 +0200\n@@ -777,11 +777,11 @@\n           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n               // if LHS has side effects, don't proceed [since the optimization\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+!mayEffectMutableState(lhs)) { // don't proceed [since the optimization // evaluates LHS before cond] // side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "!mayEffectMutableState( elseOp.getFirstChild(); elseOp.removeChild(elseOp, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 07:42:59.323807464 +0200\n+++ /tmp/tmp8suzezzo.java\t2022-07-19 07:42:59.327807444 +0200\n@@ -777,11 +777,11 @@\n           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n               // if LHS has side effects, don't proceed [since the optimization\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+!mayEffectMutableState( elseOp.getFirstChild(); elseOp.removeChild(elseOp, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "!mayEffectMutableState(lhs)) { // don't proceed [since the optimization // evaluates LHS before cond] // don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 07:43:02.683791207 +0200\n+++ /tmp/tmpj6dq7wxr.java\t2022-07-19 07:43:02.683791207 +0200\n@@ -777,11 +777,11 @@\n           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n               // if LHS has side effects, don't proceed [since the optimization\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+!mayEffectMutableState(lhs)) { // don't proceed [since the optimization // evaluates LHS before cond] // don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "!mayEffectMutableState(lhs)) { // don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 07:43:52.883547170 +0200\n+++ /tmp/tmp1hus1mp9.java\t2022-07-19 07:43:52.883547170 +0200\n@@ -777,11 +777,11 @@\n           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n               // if LHS has side effects, don't proceed [since the optimization\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+!mayEffectMutableState(lhs)) { // don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "!mayEffectMutableState(lhs)) { // don't proceed [since the optimization // evaluates LHS before cond] // NOTE - // don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 07:44:42.583303592 +0200\n+++ /tmp/tmpr7qf27o_.java\t2022-07-19 07:44:42.583303592 +0200\n@@ -777,11 +777,11 @@\n           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n               // if LHS has side effects, don't proceed [since the optimization\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+!mayEffectMutableState(lhs)) { // don't proceed [since the optimization // evaluates LHS before cond] // NOTE - // don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "!mayEffectMutableState(lhs)) { // don't proceed [since the optimization // evaluates LHS before cond] // side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - // NOTE - there are some circumstances where we can",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 07:45:32.447057413 +0200\n+++ /tmp/tmpo1oueubk.java\t2022-07-19 07:45:32.447057413 +0200\n@@ -777,11 +777,11 @@\n           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n               // if LHS has side effects, don't proceed [since the optimization\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+!mayEffectMutableState(lhs)) { // don't proceed [since the optimization // evaluates LHS before cond] // side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - // NOTE - there are some circumstances where we can\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "!mayEffectMutableState(lhs)) { // don't proceed [since the optimization // evaluates LHS before cond] // side effects, don't proceed [since the optimization // evaluates LHS before cond]",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 07:46:21.870811802 +0200\n+++ /tmp/tmpf52vuc13.java\t2022-07-19 07:46:21.870811802 +0200\n@@ -777,11 +777,11 @@\n           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n               // if LHS has side effects, don't proceed [since the optimization\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+!mayEffectMutableState(lhs)) { // don't proceed [since the optimization // evaluates LHS before cond] // side effects, don't proceed [since the optimization // evaluates LHS before cond]\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "!mayEffectMutableState(lhs)) { // don't proceed [since the optimization // evaluates LHS before cond] // side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can't find",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 07:47:11.450563958 +0200\n+++ /tmp/tmp13iik7do.java\t2022-07-19 07:47:11.450563958 +0200\n@@ -777,11 +777,11 @@\n           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n               // if LHS has side effects, don't proceed [since the optimization\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+!mayEffectMutableState(lhs)) { // don't proceed [since the optimization // evaluates LHS before cond] // side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can't find\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "!mayEffectMutableState( elseOp.getFirstChild(); elseOp.removeChild(elseOp, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - // NOTE - there are some circumstances where we can",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-19 07:48:00.834315770 +0200\n+++ /tmp/tmpnz2fcc5m.java\t2022-07-19 07:48:00.834315770 +0200\n@@ -777,11 +777,11 @@\n           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n               // if LHS has side effects, don't proceed [since the optimization\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+!mayEffectMutableState( elseOp.getFirstChild(); elseOp.removeChild(elseOp, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - // NOTE - there are some circumstances where we can\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "!mayEffectMutableState(lhs)) {",
        "fixed_line": "!mayEffectMutableState(lhs) && (!mayHaveSideEffects(cond) || (thenOp.isAssign() && thenOp.getFirstChild().isName()))) {"
    },
    "Math-43": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (meanImpl instanceof Mean) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-43/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\t2022-07-19 07:48:04.786295856 +0200\n+++ /tmp/tmptw33bg5l.java\t2022-07-19 07:48:04.834295614 +0200\n@@ -153,17 +153,11 @@\n         maxImpl.increment(value);\n         sumLogImpl.increment(value);\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n-            meanImpl.increment(value);\n-        }\n-        if (!(varianceImpl instanceof Variance)) {\n-            varianceImpl.increment(value);\n-        }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+if (meanImpl instanceof Mean) {\n             geoMeanImpl.increment(value);\n         }\n         n++;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (meanImpl instanceof Mean) { throw new IllegalArgumentException(message); } if (isAssignableImpl instanceof GeometricMeanImpl instanceof GeometricMean)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-43/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\t2022-07-19 07:48:24.442196696 +0200\n+++ /tmp/tmp5cd77594.java\t2022-07-19 07:48:24.442196696 +0200\n@@ -153,17 +153,11 @@\n         maxImpl.increment(value);\n         sumLogImpl.increment(value);\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n-            meanImpl.increment(value);\n-        }\n-        if (!(varianceImpl instanceof Variance)) {\n-            varianceImpl.increment(value);\n-        }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+if (meanImpl instanceof Mean) { throw new IllegalArgumentException(message); } if (isAssignableImpl instanceof GeometricMeanImpl instanceof GeometricMean)) {\n             geoMeanImpl.increment(value);\n         }\n         n++;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (meanImpl instanceof Mean) { throw new IllegalArgumentException(message); } if (isAssignableImpl instanceof GeometricMeanImpl instanceof GeometricMean) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-43/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\t2022-07-19 07:48:26.390186861 +0200\n+++ /tmp/tmpppn50bx2.java\t2022-07-19 07:48:26.394186839 +0200\n@@ -153,17 +153,11 @@\n         maxImpl.increment(value);\n         sumLogImpl.increment(value);\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n-            meanImpl.increment(value);\n-        }\n-        if (!(varianceImpl instanceof Variance)) {\n-            varianceImpl.increment(value);\n-        }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+if (meanImpl instanceof Mean) { throw new IllegalArgumentException(message); } if (isAssignableImpl instanceof GeometricMeanImpl instanceof GeometricMean) {\n             geoMeanImpl.increment(value);\n         }\n         n++;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (meanImpl instanceof Mean) { throw new IllegalArgumentException(message); } if (isAssignableImpl instanceof GeometricMeanImpl instanceof GeometricMeanImpl instanceof GeometricMean)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-43/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\t2022-07-19 07:48:28.538176013 +0200\n+++ /tmp/tmpc2o_n99b.java\t2022-07-19 07:48:28.538176013 +0200\n@@ -153,17 +153,11 @@\n         maxImpl.increment(value);\n         sumLogImpl.increment(value);\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n-            meanImpl.increment(value);\n-        }\n-        if (!(varianceImpl instanceof Variance)) {\n-            varianceImpl.increment(value);\n-        }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+if (meanImpl instanceof Mean) { throw new IllegalArgumentException(message); } if (isAssignableImpl instanceof GeometricMeanImpl instanceof GeometricMeanImpl instanceof GeometricMean)) {\n             geoMeanImpl.increment(value);\n         }\n         n++;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (meanImpl instanceof Mean) { throw new IllegalArgumentException(message); } if (isAssignableImpl instanceof GeometricMeanImpl instanceof GeometricMean()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-43/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\t2022-07-19 07:48:30.490166152 +0200\n+++ /tmp/tmpeglt9gay.java\t2022-07-19 07:48:30.490166152 +0200\n@@ -153,17 +153,11 @@\n         maxImpl.increment(value);\n         sumLogImpl.increment(value);\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n-            meanImpl.increment(value);\n-        }\n-        if (!(varianceImpl instanceof Variance)) {\n-            varianceImpl.increment(value);\n-        }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+if (meanImpl instanceof Mean) { throw new IllegalArgumentException(message); } if (isAssignableImpl instanceof GeometricMeanImpl instanceof GeometricMean()) {\n             geoMeanImpl.increment(value);\n         }\n         n++;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (meanImpl instanceof Mean) { throw new IllegalArgumentException(message); } if (isAssignableImpl instanceof GeometricMeanImpl instanceof GeometricMeanImpl instanceof GeometricMean) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-43/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\t2022-07-19 07:48:32.450156248 +0200\n+++ /tmp/tmp_ha_h93_.java\t2022-07-19 07:48:32.450156248 +0200\n@@ -153,17 +153,11 @@\n         maxImpl.increment(value);\n         sumLogImpl.increment(value);\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n-            meanImpl.increment(value);\n-        }\n-        if (!(varianceImpl instanceof Variance)) {\n-            varianceImpl.increment(value);\n-        }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+if (meanImpl instanceof Mean) { throw new IllegalArgumentException(message); } if (isAssignableImpl instanceof GeometricMeanImpl instanceof GeometricMeanImpl instanceof GeometricMean) {\n             geoMeanImpl.increment(value);\n         }\n         n++;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (meanImpl instanceof Mean) { throw new IllegalArgumentException(message); } if (isAssignableImpl instanceof GeometricMeanImpl instanceof GeometricMeanImpl instanceof GeometricMean()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-43/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\t2022-07-19 07:48:34.562145572 +0200\n+++ /tmp/tmpj6zaj92t.java\t2022-07-19 07:48:34.562145572 +0200\n@@ -153,17 +153,11 @@\n         maxImpl.increment(value);\n         sumLogImpl.increment(value);\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n-            meanImpl.increment(value);\n-        }\n-        if (!(varianceImpl instanceof Variance)) {\n-            varianceImpl.increment(value);\n-        }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+if (meanImpl instanceof Mean) { throw new IllegalArgumentException(message); } if (isAssignableImpl instanceof GeometricMeanImpl instanceof GeometricMeanImpl instanceof GeometricMean()) {\n             geoMeanImpl.increment(value);\n         }\n         n++;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (meanImpl instanceof Mean) { throw new IllegalArgumentException(message); } if (isAssignableImpl instanceof GeometricMean) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-43/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\t2022-07-19 07:48:36.574135406 +0200\n+++ /tmp/tmpwiqb2i84.java\t2022-07-19 07:48:36.574135406 +0200\n@@ -153,17 +153,11 @@\n         maxImpl.increment(value);\n         sumLogImpl.increment(value);\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n-            meanImpl.increment(value);\n-        }\n-        if (!(varianceImpl instanceof Variance)) {\n-            varianceImpl.increment(value);\n-        }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+if (meanImpl instanceof Mean) { throw new IllegalArgumentException(message); } if (isAssignableImpl instanceof GeometricMean) {\n             geoMeanImpl.increment(value);\n         }\n         n++;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (meanImpl instanceof Mean) { // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-43/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\t2022-07-19 07:48:38.730124506 +0200\n+++ /tmp/tmpy0blym9y.java\t2022-07-19 07:48:38.730124506 +0200\n@@ -153,17 +153,11 @@\n         maxImpl.increment(value);\n         sumLogImpl.increment(value);\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n-            meanImpl.increment(value);\n-        }\n-        if (!(varianceImpl instanceof Variance)) {\n-            varianceImpl.increment(value);\n-        }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+if (meanImpl instanceof Mean) { // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n             geoMeanImpl.increment(value);\n         }\n         n++;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (meanImpl instanceof Mean) { // [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < count; ++i) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-43/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\t2022-07-19 07:48:56.194036136 +0200\n+++ /tmp/tmp7swk2z31.java\t2022-07-19 07:48:56.194036136 +0200\n@@ -153,17 +153,11 @@\n         maxImpl.increment(value);\n         sumLogImpl.increment(value);\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n-            meanImpl.increment(value);\n-        }\n-        if (!(varianceImpl instanceof Variance)) {\n-            varianceImpl.increment(value);\n-        }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+if (meanImpl instanceof Mean) { // [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < count; ++i) {\n             geoMeanImpl.increment(value);\n         }\n         n++;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (!(meanImpl instanceof Mean)) { meanImpl.increment(value); } if (!(varianceImpl instanceof Variance)) { varianceImpl.increment(value); } if (!(geoMeanImpl instanceof GeometricMean)) {",
        "fixed_line": "if (meanImpl != mean) { meanImpl.increment(value); } if (varianceImpl != variance) { varianceImpl.increment(value); } if (geoMeanImpl != geoMean) {"
    },
    "Lang-37": {
        "fixes": [
            {
                "k": 1,
                "patch": "final int joinedArray = array1.length + array2.length;",
                "patch_diff": "final int joinedArray = array1.length + array2.length;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int joinedArray = array1.length + array2.length;",
                "patch_diff": "int joinedArray = array1.length + array2.length;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "final int joinedArray = array1.length + array2.length);",
                "patch_diff": "final int joinedArray = array1.length + array2.length);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// int joinedArray = array1.length + array2.length;",
                "patch_diff": "// int joinedArray = array1.length + array2.length;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "joined joinedArray = array1.length + array2.length;",
                "patch_diff": "joined joinedArray = array1.length + array2.length;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return joinedArray = array1.length + array2.length;",
                "patch_diff": "return joinedArray = array1.length + array2.length;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "final int joinedArray = array1.length + array2.length; }",
                "patch_diff": "final int joinedArray = array1.length + array2.length; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "final int joinedArray = array1.length - array2.length;",
                "patch_diff": "final int joinedArray = array1.length - array2.length;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// joined joinedArray = array1.length + array2.length;",
                "patch_diff": "// joined joinedArray = array1.length + array2.length;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "joined joinedArray = array1.length + array2.length);",
                "patch_diff": "joined joinedArray = array1.length + array2.length);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "try { System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); } catch (ArrayStoreException ase) { // Check if problem is incompatible types final Class<?> type2 = array2.getClass().getComponentType(); if (!type1.isAssignableFrom(type2)){ throw new IllegalArgumentException(\"Cannot store \"+type2.getName()+\" in an array of \"+type1.getName()); } throw ase; // No, so rethrow original }"
    },
    "Codec-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "// not reached EOF, // as per [JACKSON-407] -- allow not reached EOF, // as per [JACKSON-notnotnotnotnotnot real number",
                "patch_diff": "// not reached EOF, // as per [JACKSON-407] -- allow not reached EOF, // as per [JACKSON-notnotnotnotnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// not reached EOF, // as per [JACKSON-407] -- allow not reached EOF, // as per [JACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "// not reached EOF, // as per [JACKSON-407] -- allow not reached EOF, // as per [JACKSON-notnotnotnotnotnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// not reached EOF, // as per [JACKSON-407] -- allow not reached EOF, // as per [JACKSON-notnotnotnotnot real number",
                "patch_diff": "// not reached EOF, // as per [JACKSON-407] -- allow not reached EOF, // as per [JACKSON-notnotnotnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// not reached EOF, // as per [JACKSON-notnotnotnotnot real number",
                "patch_diff": "// not reached EOF, // as per [JACKSON-notnotnotnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// not reached EOF, // as per [JACKSON-notnotnotnotnotnot real number",
                "patch_diff": "// not reached EOF, // as per [JACKSON-notnotnotnotnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// not reached EOF, // as per [JACKSON-407] -- allow not reached EOF, // as per [JACKSON-notnotnotnotnotnotnotnot real number",
                "patch_diff": "// not reached EOF, // as per [JACKSON-407] -- allow not reached EOF, // as per [JACKSON-notnotnotnotnotnotnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// not reached EOF, // as per [JACKSON-407] -- allow not reached EOF, // as per [JACKSON-notnotnotnot real number",
                "patch_diff": "// not reached EOF, // as per [JACKSON-407] -- allow not reached EOF, // as per [JACKSON-notnotnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// not reached EOF, // as per [JACKSON-notnotnotnot real number",
                "patch_diff": "// not reached EOF, // as per [JACKSON-notnotnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// not reached EOF, // as per [JACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "// not reached EOF, // as per [JACKSON-notnotnotnotnotnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// not reached EOF, // as per [JACKSON-407] -- allow not reached EOF, // as per [JACKSON-notnotnotnotnotnotnotnotnot real number",
                "patch_diff": "// not reached EOF, // as per [JACKSON-407] -- allow not reached EOF, // as per [JACKSON-notnotnotnotnotnotnotnotnot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "@Override public long skip(long n) throws IOException { if (n < 0) { throw new IllegalArgumentException(\"Negative skip length\"); } // skip in chunks of 512 bytes final byte[] b = new byte[512]; final int max = (int) Math.min(n, Integer.MAX_VALUE); int total = 0; while (total < max) { int len = max - total; if (len > b.length) { len = b.length; } len = read(b, 0, len); if (len == EOF) { break; } total += len; } return total; } /** * {@inheritDoc} * * @return <code>0</code> if the {@link InputStream} has reached <code>EOF</code>, * <code>1</code> otherwise */ public int available() throws IOException { // Note: the logic is similar to the InflaterInputStream: // as long as we have not reached EOF, indicate that there is more // data available. As we do not know for sure how much data is left, // just return 1 as a safe guess. // use the EOF flag of the underlying codec instance if (baseNCodec.eof) { return 0; } else { return 1; } }"
    },
    "Gson-18": {
        "fixes": [
            {
                "k": 1,
                "patch": "int int contextRawType = contextRawType.getGenericSupes(context, supertype);",
                "patch_diff": "int int contextRawType = contextRawType.getGenericSupes(context, supertype);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = 0; i < contextRawType, supertype.class; ++i) {",
                "patch_diff": "for (int i = 0; i < contextRawType, supertype.class; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int int contextRawType = contextRawType.getGenericSupes(context, String.class, supertype);",
                "patch_diff": "int int contextRawType = contextRawType.getGenericSupes(context, String.class, supertype);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int int contextRawType = contextRawType.getGenericSupes(context, supertype.class,",
                "patch_diff": "int int contextRawType = contextRawType.getGenericSupes(context, supertype.class,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int int contextRawType = contextRawType.getGenericSupes(context, supertype)) {",
                "patch_diff": "int int contextRawType = contextRawType.getGenericSupes(context, supertype)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int int contextRawType = contextRawType.getGenericSupes(context, supertype.class) {",
                "patch_diff": "int int contextRawType = contextRawType.getGenericSupes(context, supertype.class) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int int contextRawType = contextRawType.getGenericSupes(context, supertype); } else {",
                "patch_diff": "int int contextRawType = contextRawType.getGenericSupes(context, supertype); } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int int contextRawType = contextRawType.getGenericSupes(context, supertype.class);",
                "patch_diff": "int int contextRawType = contextRawType.getGenericSupes(context, supertype.class);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// // can be null if the type inpertype.class || supertype.class) {",
                "patch_diff": "// // can be null if the type inpertype.class || supertype.class) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = 0; i < contextRawType, supertype.class;",
                "patch_diff": "for (int i = 0; i < contextRawType, supertype.class;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (context instanceof WildcardType) { // wildcards are useless for resolving supertypes. As the upper bound has the same raw type, use it instead context = ((WildcardType)context).getUpperBounds()[0]; }"
    },
    "Mockito-34": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (m instanceof CapturesArguments) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-34/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 07:49:18.965920712 +0200\n+++ /tmp/tmp0bfnnhv6.java\t2022-07-19 07:49:19.029920388 +0200\n@@ -101,11 +101,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+if (m instanceof CapturesArguments) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (k < 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-34/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 07:49:36.097833731 +0200\n+++ /tmp/tmp7b2jtybl.java\t2022-07-19 07:49:36.097833731 +0200\n@@ -101,11 +101,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+if (k < 0) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (k >= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-34/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 07:49:53.009747750 +0200\n+++ /tmp/tmppmybeolo.java\t2022-07-19 07:49:53.009747750 +0200\n@@ -101,11 +101,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+if (k >= 0) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (k == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-34/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 07:50:09.805662247 +0200\n+++ /tmp/tmpcjiudj7b.java\t2022-07-19 07:50:09.805662247 +0200\n@@ -101,11 +101,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+if (k == 0) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (m instanceof CapturesArguments) { if (m instanceof CapturesArguments) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-34/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 07:50:26.665576310 +0200\n+++ /tmp/tmpbbzexnn3.java\t2022-07-19 07:50:26.665576310 +0200\n@@ -101,11 +101,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+if (m instanceof CapturesArguments) { if (m instanceof CapturesArguments) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (m instanceof CapturesArguments) { throw new CapturesArguments = (m instanceof CapturesArguments) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-34/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 07:50:28.649566190 +0200\n+++ /tmp/tmp21megroy.java\t2022-07-19 07:50:28.649566190 +0200\n@@ -101,11 +101,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+if (m instanceof CapturesArguments) { throw new CapturesArguments = (m instanceof CapturesArguments) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (m instanceof CapturesArguments) { throw new CapturesArguments(m); } else if (m instanceof CapturesArguments) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-34/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 07:50:30.721555619 +0200\n+++ /tmp/tmp3fbzp6gg.java\t2022-07-19 07:50:30.721555619 +0200\n@@ -101,11 +101,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+if (m instanceof CapturesArguments) { throw new CapturesArguments(m); } else if (m instanceof CapturesArguments) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (m instanceof CapturesArguments) { throw new CapturesArguments = (m instanceof CapturesArguments) m; } else if (m instanceof CapturesArguments) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-34/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 07:50:33.133543314 +0200\n+++ /tmp/tmp2827fn55.java\t2022-07-19 07:50:33.133543314 +0200\n@@ -101,11 +101,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+if (m instanceof CapturesArguments) { throw new CapturesArguments = (m instanceof CapturesArguments) m; } else if (m instanceof CapturesArguments) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if(m instanceof CapturesArguments) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-34/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 07:50:34.905534271 +0200\n+++ /tmp/tmp67yh87fy.java\t2022-07-19 07:50:34.905534271 +0200\n@@ -101,11 +101,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+if(m instanceof CapturesArguments) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (m instanceof CapturesArguments) { throw new CapturesArguments = (m instanceof CapturesArguments) m; } if (m instanceof CapturesArguments) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-34/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-19 07:50:51.945447260 +0200\n+++ /tmp/tmpm1bz0up4.java\t2022-07-19 07:50:51.945447260 +0200\n@@ -101,11 +101,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+if (m instanceof CapturesArguments) { throw new CapturesArguments = (m instanceof CapturesArguments) m; } if (m instanceof CapturesArguments) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (m instanceof CapturesArguments) {",
        "fixed_line": "if (m instanceof CapturesArguments && i.getArguments().length > k) {"
    },
    "Math-79": {
        "fixes": [
            {
                "k": 1,
                "patch": "int sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p1[i];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-79/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 07:50:54.105436223 +0200\n+++ /tmp/tmpjmod5kyz.java\t2022-07-19 07:50:54.137436059 +0200\n@@ -1619,13 +1619,11 @@\n      * @param p1 the first point\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+int sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p1[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p2[i];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-79/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 07:51:02.641392590 +0200\n+++ /tmp/tmprcd7a_jy.java\t2022-07-19 07:51:02.641392590 +0200\n@@ -1619,13 +1619,11 @@\n      * @param p1 the first point\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+int sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p2[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int sum = 1; for (int i = 0; i < p1.length; i++) { final int dp = p1[i];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-79/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 07:51:09.325358408 +0200\n+++ /tmp/tmpcwgubbqa.java\t2022-07-19 07:51:09.325358408 +0200\n@@ -1619,13 +1619,11 @@\n      * @param p1 the first point\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+int sum = 1; for (int i = 0; i < p1.length; i++) { final int dp = p1[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int sum = 0; for (int i = 0; i < p2.length; i++) { final int dp = p1[i];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-79/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 07:51:15.853325008 +0200\n+++ /tmp/tmp6flw82dt.java\t2022-07-19 07:51:15.853325008 +0200\n@@ -1619,13 +1619,11 @@\n      * @param p1 the first point\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+int sum = 0; for (int i = 0; i < p2.length; i++) { final int dp = p1[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int sum = 0; for (int i = 0; i < p1.length; ++i++) { final int dp = p1[i];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-79/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 07:51:22.429291347 +0200\n+++ /tmp/tmp7dxfq2w6.java\t2022-07-19 07:51:22.429291347 +0200\n@@ -1619,13 +1619,11 @@\n      * @param p1 the first point\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+int sum = 0; for (int i = 0; i < p1.length; ++i++) { final int dp = p1[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int sum = 0; for (int i = 1; i < p1.length; i++) { final int dp = p1[i];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-79/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 07:51:24.613280165 +0200\n+++ /tmp/tmp718obw73.java\t2022-07-19 07:51:24.617280146 +0200\n@@ -1619,13 +1619,11 @@\n      * @param p1 the first point\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+int sum = 0; for (int i = 1; i < p1.length; i++) { final int dp = p1[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int sum = 1; for (int i = 0; i < p1.length; i++) { final int dp = p2[i];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-79/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 07:51:31.945242614 +0200\n+++ /tmp/tmpadrldx_4.java\t2022-07-19 07:51:31.949242592 +0200\n@@ -1619,13 +1619,11 @@\n      * @param p1 the first point\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+int sum = 1; for (int i = 0; i < p1.length; i++) { final int dp = p2[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int sum = 0; for(int i = 0; i < p1.length; i++) { final int dp = p1[i];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-79/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 07:51:38.797207505 +0200\n+++ /tmp/tmptj73ymap.java\t2022-07-19 07:51:38.813207423 +0200\n@@ -1619,13 +1619,11 @@\n      * @param p1 the first point\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+int sum = 0; for(int i = 0; i < p1.length; i++) { final int dp = p1[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p[i];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-79/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 07:51:45.793171643 +0200\n+++ /tmp/tmp_l7f5hyk.java\t2022-07-19 07:51:45.797171621 +0200\n@@ -1619,13 +1619,11 @@\n      * @param p1 the first point\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+int sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p1.i];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-79/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 07:51:48.017160238 +0200\n+++ /tmp/tmp8sz8y8d3.java\t2022-07-19 07:51:48.017160238 +0200\n@@ -1619,13 +1619,11 @@\n      * @param p1 the first point\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+int sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p1.i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "int sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p1[i] - p2[i];",
        "fixed_line": "double sum = 0; for (int i = 0; i < p1.length; i++) { final double dp = p1[i] - p2[i];"
    },
    "Chart-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (index < 0 ||!this.allowDuplicateXValues) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-5/source/org/jfree/data/xy/XYSeries.java\t2022-07-19 07:51:50.389148074 +0200\n+++ /tmp/tmpjuws4fh0.java\t2022-07-19 07:51:50.417147932 +0200\n@@ -543,11 +543,11 @@\n         }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n+if (index < 0 ||!this.allowDuplicateXValues) {\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n             }\n             catch (CloneNotSupportedException e) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (index >= 0 ||!this.allowDuplicateXValues) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-5/source/org/jfree/data/xy/XYSeries.java\t2022-07-19 07:51:59.365102026 +0200\n+++ /tmp/tmp019axajl.java\t2022-07-19 07:51:59.365102026 +0200\n@@ -543,11 +543,11 @@\n         }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n+if (index >= 0 ||!this.allowDuplicateXValues) {\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n             }\n             catch (CloneNotSupportedException e) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (index >= 0 &&!this.allowDuplicateXValues) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-5/source/org/jfree/data/xy/XYSeries.java\t2022-07-19 07:52:07.825058604 +0200\n+++ /tmp/tmpgwy7ecrd.java\t2022-07-19 07:52:07.825058604 +0200\n@@ -543,11 +543,11 @@\n         }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n+if (index >= 0 &&!this.allowDuplicateXValues) {\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n             }\n             catch (CloneNotSupportedException e) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (index!= 0 &&!this.allowDuplicateXValues) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-5/source/org/jfree/data/xy/XYSeries.java\t2022-07-19 07:52:16.505014029 +0200\n+++ /tmp/tmpabrglhdr.java\t2022-07-19 07:52:16.505014029 +0200\n@@ -543,11 +543,11 @@\n         }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n+if (index!= 0 &&!this.allowDuplicateXValues) {\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n             }\n             catch (CloneNotSupportedException e) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (index >= 1 &&!this.allowDuplicateXValues) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-5/source/org/jfree/data/xy/XYSeries.java\t2022-07-19 07:52:24.992970418 +0200\n+++ /tmp/tmpgitm1_c3.java\t2022-07-19 07:52:24.992970418 +0200\n@@ -543,11 +543,11 @@\n         }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n+if (index >= 1 &&!this.allowDuplicateXValues) {\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n             }\n             catch (CloneNotSupportedException e) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (index!= 0 ||!this.allowDuplicateXValues) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-5/source/org/jfree/data/xy/XYSeries.java\t2022-07-19 07:52:33.608926129 +0200\n+++ /tmp/tmpovtpzupd.java\t2022-07-19 07:52:33.612926107 +0200\n@@ -543,11 +543,11 @@\n         }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n+if (index!= 0 ||!this.allowDuplicateXValues) {\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n             }\n             catch (CloneNotSupportedException e) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (index < 0 &&!this.allowDuplicateXValues) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-5/source/org/jfree/data/xy/XYSeries.java\t2022-07-19 07:52:42.260881633 +0200\n+++ /tmp/tmpx1jexvb_.java\t2022-07-19 07:52:42.260881633 +0200\n@@ -543,11 +543,11 @@\n         }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n+if (index < 0 &&!this.allowDuplicateXValues) {\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n             }\n             catch (CloneNotSupportedException e) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (index == 0 ||!this.allowDuplicateXValues) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-5/source/org/jfree/data/xy/XYSeries.java\t2022-07-19 07:52:50.772837837 +0200\n+++ /tmp/tmpp3ej9u5n.java\t2022-07-19 07:52:50.772837837 +0200\n@@ -543,11 +543,11 @@\n         }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n+if (index == 0 ||!this.allowDuplicateXValues) {\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n             }\n             catch (CloneNotSupportedException e) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (index == 0 &&!this.allowDuplicateXValues) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-5/source/org/jfree/data/xy/XYSeries.java\t2022-07-19 07:52:59.164794636 +0200\n+++ /tmp/tmpuc0f2s0c.java\t2022-07-19 07:52:59.164794636 +0200\n@@ -543,11 +543,11 @@\n         }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n+if (index == 0 &&!this.allowDuplicateXValues) {\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n             }\n             catch (CloneNotSupportedException e) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (index > 0 &&!this.allowDuplicateXValues) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-5/source/org/jfree/data/xy/XYSeries.java\t2022-07-19 07:53:07.748750430 +0200\n+++ /tmp/tmp7j9iyobk.java\t2022-07-19 07:53:07.752750409 +0200\n@@ -543,11 +543,11 @@\n         }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n+if (index > 0 &&!this.allowDuplicateXValues) {\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n             }\n             catch (CloneNotSupportedException e) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (index >= 0 && !this.allowDuplicateXValues) {",
        "fixed_line": "if (this.allowDuplicateXValues) { add(x, y); return null; } // if we get to here, we know that duplicate X values are not permitted XYDataItem overwritten = null; int index = indexOf(x); if (index >= 0) {"
    },
    "Closure-57": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (target!= null && target.equals(qualifiedName)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-57/src/com/google/javascript/jscomp/ClosureCodingConvention.java\t2022-07-19 07:53:16.432705686 +0200\n+++ /tmp/tmp_68ibw_r.java\t2022-07-19 07:53:16.460705543 +0200\n@@ -192,11 +192,11 @@\n       Node callee = node.getFirstChild();\n       if (callee != null && callee.getType() == Token.GETPROP) {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+if (target!= null && target.equals(qualifiedName)) {\n             className = target.getString();\n           }\n         }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (target!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-57/src/com/google/javascript/jscomp/ClosureCodingConvention.java\t2022-07-19 07:53:54.060511592 +0200\n+++ /tmp/tmpqd_fv8jo.java\t2022-07-19 07:53:54.064511571 +0200\n@@ -192,11 +192,11 @@\n       Node callee = node.getFirstChild();\n       if (callee != null && callee.getType() == Token.GETPROP) {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+if (target!= null) {\n             className = target.getString();\n           }\n         }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (target == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-57/src/com/google/javascript/jscomp/ClosureCodingConvention.java\t2022-07-19 07:54:30.992320748 +0200\n+++ /tmp/tmpfeyokr0d.java\t2022-07-19 07:54:30.992320748 +0200\n@@ -192,11 +192,11 @@\n       Node callee = node.getFirstChild();\n       if (callee != null && callee.getType() == Token.GETPROP) {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+if (target == null) {\n             className = target.getString();\n           }\n         }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (target == null && target.equals(qualifiedName)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-57/src/com/google/javascript/jscomp/ClosureCodingConvention.java\t2022-07-19 07:55:08.136128494 +0200\n+++ /tmp/tmpqikg952f.java\t2022-07-19 07:55:08.136128494 +0200\n@@ -192,11 +192,11 @@\n       Node callee = node.getFirstChild();\n       if (callee != null && callee.getType() == Token.GETPROP) {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+if (target == null && target.equals(qualifiedName)) {\n             className = target.getString();\n           }\n         }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (target == null) { // block == null; non-empty's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-57/src/com/google/javascript/jscomp/ClosureCodingConvention.java\t2022-07-19 07:55:44.187941610 +0200\n+++ /tmp/tmpm36znwcz.java\t2022-07-19 07:55:44.191941592 +0200\n@@ -192,11 +192,11 @@\n       Node callee = node.getFirstChild();\n       if (callee != null && callee.getType() == Token.GETPROP) {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+if (target == null) { // block == null; non-empty's do implicit re-parse\n             className = target.getString();\n           }\n         }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (target == null) { // block == null; can't really modify it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-57/src/com/google/javascript/jscomp/ClosureCodingConvention.java\t2022-07-19 07:56:20.703752062 +0200\n+++ /tmp/tmpuvo1a0f5.java\t2022-07-19 07:56:20.703752062 +0200\n@@ -192,11 +192,11 @@\n       Node callee = node.getFirstChild();\n       if (callee != null && callee.getType() == Token.GETPROP) {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+if (target == null) { // block == null; can't really modify it's do implicit re-parse\n             className = target.getString();\n           }\n         }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (target == null) { // block == null; can't be null if we're not use a native function.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-57/src/com/google/javascript/jscomp/ClosureCodingConvention.java\t2022-07-19 07:56:56.819564347 +0200\n+++ /tmp/tmpu034ybpl.java\t2022-07-19 07:56:56.819564347 +0200\n@@ -192,11 +192,11 @@\n       Node callee = node.getFirstChild();\n       if (callee != null && callee.getType() == Token.GETPROP) {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+if (target == null) { // block == null; can't be null if we're not use a native function.\n             className = target.getString();\n           }\n         }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (target == null) { // block == null; can't really here here (target!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-57/src/com/google/javascript/jscomp/ClosureCodingConvention.java\t2022-07-19 07:57:33.387374054 +0200\n+++ /tmp/tmp00j9x9ph.java\t2022-07-19 07:57:33.387374054 +0200\n@@ -192,11 +192,11 @@\n       Node callee = node.getFirstChild();\n       if (callee != null && callee.getType() == Token.GETPROP) {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+if (target == null) { // block == null; can't really here here (target!= null) {\n             className = target.getString();\n           }\n         }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (target == null) { // block == null; can't be null if we're not.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-57/src/com/google/javascript/jscomp/ClosureCodingConvention.java\t2022-07-19 07:58:09.955183547 +0200\n+++ /tmp/tmpeww73m7g.java\t2022-07-19 07:58:09.955183547 +0200\n@@ -192,11 +192,11 @@\n       Node callee = node.getFirstChild();\n       if (callee != null && callee.getType() == Token.GETPROP) {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+if (target == null) { // block == null; can't be null if we're not.\n             className = target.getString();\n           }\n         }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (target == null) { // block == null; non-empty's after name; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-57/src/com/google/javascript/jscomp/ClosureCodingConvention.java\t2022-07-19 07:58:46.730991756 +0200\n+++ /tmp/tmp0jd1kurc.java\t2022-07-19 07:58:46.730991756 +0200\n@@ -192,11 +192,11 @@\n       Node callee = node.getFirstChild();\n       if (callee != null && callee.getType() == Token.GETPROP) {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+if (target == null) { // block == null; non-empty's after name; }\n             className = target.getString();\n           }\n         }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (target != null) {",
        "fixed_line": "if (target != null && target.getType() == Token.STRING) {"
    },
    "Closure-44": {
        "fixes": [
            {
                "k": 1,
                "patch": "// For example if (isWordChar == '\\\\') || isWordChar == '\\\\') {",
                "patch_diff": "// For example if (isWordChar == '\\\\') || isWordChar == '\\\\') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// For example if (isWordChar == 'D') || isWordChar == '\\\\') {",
                "patch_diff": "// For example if (isWordChar == 'D') || isWordChar == '\\\\') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// For example if (isWordChar == '\\\\') || isWordChar == 'D') {",
                "patch_diff": "// For example if (isWordChar == '\\\\') || isWordChar == 'D') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// For example if (isWordChar == '\\\\') || isWordChar == '\\\\') &&",
                "patch_diff": "// For example if (isWordChar == '\\\\') || isWordChar == '\\\\') &&",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// For example if (isWordChar == 'D') || isWordChar == '\\\\') &&",
                "patch_diff": "// For example if (isWordChar == 'D') || isWordChar == '\\\\') &&",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// For example if (isWordChar == '\\\\') && is not pretty printing.",
                "patch_diff": "// For example if (isWordChar == '\\\\') && is not pretty printing.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// For example if (isWordChar == '\\\\') || isWordChar;",
                "patch_diff": "// For example if (isWordChar == '\\\\') || isWordChar;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// For example if (isWordChar == '\\\\') && isWordChar;",
                "patch_diff": "// For example if (isWordChar == '\\\\') && isWordChar;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// For example if (isWordChar == 'D') || isWordChar == '\\\\')",
                "patch_diff": "// For example if (isWordChar == 'D') || isWordChar == '\\\\')",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// For example if (isWordChar == '\\\\') || isWordChar == '\\\\')",
                "patch_diff": "// For example if (isWordChar == '\\\\') || isWordChar == '\\\\')",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "} else if (c == '/' && getLastChar() == '/') { // Do not allow a forward slash to appear after a DIV. // For example, // REGEXP DIV REGEXP // is valid and should print like // / // / / append(\" \");"
    },
    "Jsoup-38": {
        "fixes": [
            {
                "k": 1,
                "patch": "// case 'I') return true; // we didn't really modify it.",
                "patch_diff": "// case 'I') return true; // we didn't really modify it.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// case 'I') return true; // we didn't really modify it was non-literal characters that might be valid (empty be valid)",
                "patch_diff": "// case 'I') return true; // we didn't really modify it was non-literal characters that might be valid (empty be valid)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// case 'I') { return false; } else if (name.equals(\"img\")) {",
                "patch_diff": "// case 'I') { return false; } else if (name.equals(\"img\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (NAME.equals(\"img\")) { return false; } else if (name.equals(\"img\")) {",
                "patch_diff": "} else if (NAME.equals(\"img\")) { return false; } else if (name.equals(\"img\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// case 'I') return true; // we didn't really modify it was non-literal characters that might be valid (name.",
                "patch_diff": "// case 'I') return true; // we didn't really modify it was non-literal characters that might be valid (name.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// case 'I') { return true; } else if (name.equals(\"img\")) {",
                "patch_diff": "// case 'I') { return true; } else if (name.equals(\"img\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (NAME.equals(\"img\")) {",
                "patch_diff": "} else if (NAME.equals(\"img\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// case 'I') return true; // we didn't really modify it was non-literal characters that might be Token.NAME",
                "patch_diff": "// case 'I') return true; // we didn't really modify it was non-literal characters that might be Token.NAME",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// case 'I') return true; // we didn't really modify it was non-literal characters that might be valid (",
                "patch_diff": "// case 'I') return true; // we didn't really modify it was non-literal characters that might be valid (",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (name.equals(\"img\")) {",
                "patch_diff": "} else if (name.equals(\"img\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (tb.getFromStack(\"svg\") == null) return tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg else tb.insert(startTag);"
    },
    "Codec-16": {
        "fixes": [
            {
                "k": 1,
                "patch": "25, 25, 25, -1, -1, -1, -1, 0, // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-16/src/main/java/org/apache/commons/codec/binary/Base32.java\t2022-07-19 07:59:27.278780075 +0200\n+++ /tmp/tmpmf46aowh.java\t2022-07-19 07:59:27.354779681 +0200\n@@ -94,11 +94,11 @@\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n-            25, 26, 27, 28, 29, 30, 31, 32,\n+25, 25, 25, -1, -1, -1, -1, 0, // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n     };\n \n     /**\n      * This array is a lookup table that translates 5-bit positive integer index values into their\n      * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "25, 25, 25, -1, -1, -1, -1, 0, // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-16/src/main/java/org/apache/commons/codec/binary/Base32.java\t2022-07-19 07:59:32.946750469 +0200\n+++ /tmp/tmpbs7ka00d.java\t2022-07-19 07:59:32.946750469 +0200\n@@ -94,11 +94,11 @@\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n-            25, 26, 27, 28, 29, 30, 31, 32,\n+25, 25, 25, -1, -1, -1, -1, 0, // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n     };\n \n     /**\n      * This array is a lookup table that translates 5-bit positive integer index values into their\n      * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "25, 25, 25, -1, -1, -1, -1, 0, // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-16/src/main/java/org/apache/commons/codec/binary/Base32.java\t2022-07-19 07:59:37.902724578 +0200\n+++ /tmp/tmp8gtobzkt.java\t2022-07-19 07:59:37.902724578 +0200\n@@ -94,11 +94,11 @@\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n-            25, 26, 27, 28, 29, 30, 31, 32,\n+25, 25, 25, -1, -1, -1, -1, 0, // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n     };\n \n     /**\n      * This array is a lookup table that translates 5-bit positive integer index values into their\n      * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "25, 25, 25, -1, -1, -1, -1, 0, // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-16/src/main/java/org/apache/commons/codec/binary/Base32.java\t2022-07-19 07:59:43.038697745 +0200\n+++ /tmp/tmpqu_h3zbi.java\t2022-07-19 07:59:43.038697745 +0200\n@@ -94,11 +94,11 @@\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n-            25, 26, 27, 28, 29, 30, 31, 32,\n+25, 25, 25, -1, -1, -1, -1, 0, // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number\n     };\n \n     /**\n      * This array is a lookup table that translates 5-bit positive integer index values into their\n      * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "25, 25, 25, -1, -1, -1, -1, 0, // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-16/src/main/java/org/apache/commons/codec/binary/Base32.java\t2022-07-19 07:59:48.042671598 +0200\n+++ /tmp/tmpemrm5h1_.java\t2022-07-19 07:59:48.042671598 +0200\n@@ -94,11 +94,11 @@\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n-            25, 26, 27, 28, 29, 30, 31, 32,\n+25, 25, 25, -1, -1, -1, -1, 0, // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number\n     };\n \n     /**\n      * This array is a lookup table that translates 5-bit positive integer index values into their\n      * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "25, 25, 25, -1, -1, -1, -1, 0, // we didn't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-16/src/main/java/org/apache/commons/codec/binary/Base32.java\t2022-07-19 07:59:53.078645277 +0200\n+++ /tmp/tmpfy26so5h.java\t2022-07-19 07:59:53.078645277 +0200\n@@ -94,11 +94,11 @@\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n-            25, 26, 27, 28, 29, 30, 31, 32,\n+25, 25, 25, -1, -1, -1, -1, 0, // we didn't really modify it's totalGJACKSON-notnotnotnot real number\n     };\n \n     /**\n      * This array is a lookup table that translates 5-bit positive integer index values into their\n      * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "25, 25, 25, -1, -1, -1, -1, 0, // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-16/src/main/java/org/apache/commons/codec/binary/Base32.java\t2022-07-19 07:59:58.102619020 +0200\n+++ /tmp/tmpr6p29vi_.java\t2022-07-19 07:59:58.106618997 +0200\n@@ -94,11 +94,11 @@\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n-            25, 26, 27, 28, 29, 30, 31, 32,\n+25, 25, 25, -1, -1, -1, -1, 0, // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnot real number\n     };\n \n     /**\n      * This array is a lookup table that translates 5-bit positive integer index values into their\n      * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "25, 25, 25, -1, -1, -1, -1, 0, // we didn't really modify it's totalGJACKSON-notnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-16/src/main/java/org/apache/commons/codec/binary/Base32.java\t2022-07-19 08:00:03.242592153 +0200\n+++ /tmp/tmpu7d__2dw.java\t2022-07-19 08:00:03.242592153 +0200\n@@ -94,11 +94,11 @@\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n-            25, 26, 27, 28, 29, 30, 31, 32,\n+25, 25, 25, -1, -1, -1, -1, 0, // we didn't really modify it's totalGJACKSON-notnotnot real number\n     };\n \n     /**\n      * This array is a lookup table that translates 5-bit positive integer index values into their\n      * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "25, 25, 25, -1, -1, -1, -1, 0, // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-16/src/main/java/org/apache/commons/codec/binary/Base32.java\t2022-07-19 08:00:08.214566159 +0200\n+++ /tmp/tmp94b9w0f4.java\t2022-07-19 08:00:08.214566159 +0200\n@@ -94,11 +94,11 @@\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n-            25, 26, 27, 28, 29, 30, 31, 32,\n+25, 25, 25, -1, -1, -1, -1, 0, // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnotnot real number\n     };\n \n     /**\n      * This array is a lookup table that translates 5-bit positive integer index values into their\n      * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "25, 25, 25, -1, -1, -1, -1, -1, 0, // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-16/src/main/java/org/apache/commons/codec/binary/Base32.java\t2022-07-19 08:00:13.186540164 +0200\n+++ /tmp/tmpbo7cfpw0.java\t2022-07-19 08:00:13.190540143 +0200\n@@ -94,11 +94,11 @@\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n-            25, 26, 27, 28, 29, 30, 31, 32,\n+25, 25, 25, -1, -1, -1, -1, -1, 0, // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n     };\n \n     /**\n      * This array is a lookup table that translates 5-bit positive integer index values into their\n      * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            }
        ],
        "buggy_line": "25, 26, 27, 28, 29, 30, 31, 32,",
        "fixed_line": "25, 26, 27, 28, 29, 30, 31, // 50-57 P-V"
    },
    "Closure-22": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (parent.getType() == Token.ASSIGN) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2022-07-19 08:00:18.394512933 +0200\n+++ /tmp/tmpfg3qku1k.java\t2022-07-19 08:00:18.442512682 +0200\n@@ -96,48 +96,11 @@\n     }\n \n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n-\n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n+if (parent.getType() == Token.ASSIGN) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (parent.getType() == Token.GETPROP) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2022-07-19 08:00:22.750490150 +0200\n+++ /tmp/tmp7ekpn7zh.java\t2022-07-19 08:00:22.750490150 +0200\n@@ -96,48 +96,11 @@\n     }\n \n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n-\n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n+if (parent.getType() == Token.GETPROP) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (parent.getType() == Token.ASSIGN && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2022-07-19 08:00:26.206472075 +0200\n+++ /tmp/tmp6tfmpqvw.java\t2022-07-19 08:00:26.206472075 +0200\n@@ -96,48 +96,11 @@\n     }\n \n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n-\n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n+if (parent.getType() == Token.ASSIGN && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (parent.getType() == Token.NAME) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2022-07-19 08:00:29.486454920 +0200\n+++ /tmp/tmpepd64omh.java\t2022-07-19 08:00:29.486454920 +0200\n@@ -96,48 +96,11 @@\n     }\n \n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n-\n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n+if (parent.getType() == Token.NAME) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (parent.getType() == Token.VAR) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2022-07-19 08:00:33.142435796 +0200\n+++ /tmp/tmpaipx7jhm.java\t2022-07-19 08:00:33.142435796 +0200\n@@ -96,48 +96,11 @@\n     }\n \n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n-\n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n+if (parent.getType() == Token.VAR) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (n.getType() == Token.ASSIGN) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2022-07-19 08:00:36.698417194 +0200\n+++ /tmp/tmp5ddgay2f.java\t2022-07-19 08:00:36.702417173 +0200\n@@ -96,48 +96,11 @@\n     }\n \n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n-\n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n+if (n.getType() == Token.ASSIGN) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (parent.getType() == Token.COMMA) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2022-07-19 08:00:40.158399093 +0200\n+++ /tmp/tmphxse8xls.java\t2022-07-19 08:00:40.158399093 +0200\n@@ -96,48 +96,11 @@\n     }\n \n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n-\n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n+if (parent.getType() == Token.COMMA) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (parent.getType() == Token.ASSIGN && // Make sure that we're not handling object literals being // assigned to a prototype,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2022-07-19 08:00:43.706380530 +0200\n+++ /tmp/tmpfw7hiwxj.java\t2022-07-19 08:00:43.706380530 +0200\n@@ -96,48 +96,11 @@\n     }\n \n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n-\n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n+if (parent.getType() == Token.ASSIGN && // Make sure that we're not handling object literals being // assigned to a prototype,\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (parent.getType() == Token.GETPROP && parent.getParent()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2022-07-19 08:00:47.066362949 +0200\n+++ /tmp/tmptqfvy5ts.java\t2022-07-19 08:00:47.066362949 +0200\n@@ -96,48 +96,11 @@\n     }\n \n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n-\n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n+if (parent.getType() == Token.GETPROP && parent.getParent()) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (parent.getType() == Token.ASSIGN && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 type",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2022-07-19 08:00:50.642344236 +0200\n+++ /tmp/tmpssl9xdml.java\t2022-07-19 08:00:50.646344215 +0200\n@@ -96,48 +96,11 @@\n     }\n \n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n-\n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n+if (parent.getType() == Token.ASSIGN && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 type\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (parent.getType() == Token.COMMA) { Node gramps = parent.getParent(); if (gramps.isCall() && parent == gramps.getFirstChild()) { if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) { return; } } // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) { } else { return; } } boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { if (n.isQualifiedName() && n.getJSDocInfo() != null) { return; } else if (n.isExprResult()) { return; }",
        "fixed_line": "if (n.isExprResult() || n.isBlock()) { return; } // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n.isQualifiedName() && n.getJSDocInfo() != null) {"
    },
    "Jsoup-15": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (StringUtil.in(name, \"base\", \"bgsound\", \"command\", \"style\", \"title\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-15/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 08:00:54.202325607 +0200\n+++ /tmp/tmp2j510lwr.java\t2022-07-19 08:00:54.226325480 +0200\n@@ -278,11 +278,11 @@\n                         Element html = tb.getStack().getFirst();\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n+} else if (StringUtil.in(name, \"base\", \"bgsound\", \"command\", \"style\", \"title\")) {\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                         LinkedList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (StringUtil.in(name, \"base\", \"bgsound\", \"command\", \"",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-15/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 08:00:57.466308523 +0200\n+++ /tmp/tmpnkfupx3m.java\t2022-07-19 08:00:57.466308523 +0200\n@@ -278,11 +278,11 @@\n                         Element html = tb.getStack().getFirst();\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n+} else if (StringUtil.in(name, \"base\", \"bgsound\", \"command\", \"\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                         LinkedList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"style\", \"title\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-15/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 08:00:58.982300587 +0200\n+++ /tmp/tmpvxc4leiz.java\t2022-07-19 08:00:58.982300587 +0200\n@@ -278,11 +278,11 @@\n                         Element html = tb.getStack().getFirst();\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n+} else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"style\", \"title\")) {\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                         LinkedList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (StringUtil.in(name, \"base\", \"bgsound\", \"command\", \"style\", \"style\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-15/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 08:01:01.774285976 +0200\n+++ /tmp/tmpkdfuays2.java\t2022-07-19 08:01:01.774285976 +0200\n@@ -278,11 +278,11 @@\n                         Element html = tb.getStack().getFirst();\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n+} else if (StringUtil.in(name, \"base\", \"bgsound\", \"command\", \"style\", \"style\")) {\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                         LinkedList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-15/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 08:01:04.618271090 +0200\n+++ /tmp/tmpcwbn3jty.java\t2022-07-19 08:01:04.618271090 +0200\n@@ -278,11 +278,11 @@\n                         Element html = tb.getStack().getFirst();\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n+} else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                         LinkedList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (StringUtil.in(name, \"base\", \"basefont\", \"command\", \"link\", \"meta\", \"style\", \"title\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-15/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 08:01:06.210262756 +0200\n+++ /tmp/tmpg6i7tg0r.java\t2022-07-19 08:01:06.210262756 +0200\n@@ -278,11 +278,11 @@\n                         Element html = tb.getStack().getFirst();\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n+} else if (StringUtil.in(name, \"base\", \"basefont\", \"command\", \"link\", \"meta\", \"style\", \"title\")) {\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                         LinkedList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (StringUtil.in(name, \"base\", \"bgsound\", \"command\", \"link\", \"style\", \"title\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-15/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 08:01:09.138247429 +0200\n+++ /tmp/tmpkw11518v.java\t2022-07-19 08:01:09.142247408 +0200\n@@ -278,11 +278,11 @@\n                         Element html = tb.getStack().getFirst();\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n+} else if (StringUtil.in(name, \"base\", \"bgsound\", \"command\", \"link\", \"style\", \"title\")) {\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                         LinkedList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (StringUtil.in(name, \"base\", \"bgsound\", \"command\", \"title\", \"style\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-15/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 08:01:11.958232663 +0200\n+++ /tmp/tmprwdel2y_.java\t2022-07-19 08:01:11.958232663 +0200\n@@ -278,11 +278,11 @@\n                         Element html = tb.getStack().getFirst();\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n+} else if (StringUtil.in(name, \"base\", \"bgsound\", \"command\", \"title\", \"style\")) {\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                         LinkedList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (StringUtil.in(name, \"base\", \"bgsound\", \"command\", \"map\", \"style\", \"title\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-15/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 08:01:14.714218237 +0200\n+++ /tmp/tmp56het05h.java\t2022-07-19 08:01:14.714218237 +0200\n@@ -278,11 +278,11 @@\n                         Element html = tb.getStack().getFirst();\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n+} else if (StringUtil.in(name, \"base\", \"bgsound\", \"command\", \"map\", \"style\", \"title\")) {\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                         LinkedList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (StringUtil.in(name, \"base\", \"bgsound\", \"command\", \"link\", \"",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-15/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 08:01:17.606203096 +0200\n+++ /tmp/tmp0oyb7aqz.java\t2022-07-19 08:01:17.606203096 +0200\n@@ -278,11 +278,11 @@\n                         Element html = tb.getStack().getFirst();\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n+} else if (StringUtil.in(name, \"base\", \"bgsound\", \"command\", \"link\", \"\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                         LinkedList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "} else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {",
        "fixed_line": "} else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {"
    },
    "Cli-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (options.hasOption(arg.substring(0, 2)))",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-12/src/java/org/apache/commons/cli/GnuParser.java\t2022-07-19 08:01:19.298194240 +0200\n+++ /tmp/tmpet7adxnq.java\t2022-07-19 08:01:19.330194071 +0200\n@@ -76,11 +76,11 @@\n                 {\n                     tokens.add(arg);\n                 }\n                 else\n                 {\n-                    if (options.hasOption(arg.substring(0, 2)))\n+if (options.hasOption(arg.substring(0, 2)))\n                     {\n                         // the format is --foo=value or -foo=value\n                         // the format is a special properties option (-Dproperty=value)\n                         tokens.add(arg.substring(0, 2)); // -D\n                         tokens.add(arg.substring(2)); // property=value\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (arg.hasOption(arg.substring(0, 2)))",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-12/src/java/org/apache/commons/cli/GnuParser.java\t2022-07-19 08:01:22.246178800 +0200\n+++ /tmp/tmp9zgzh73m.java\t2022-07-19 08:01:22.246178800 +0200\n@@ -76,11 +76,11 @@\n                 {\n                     tokens.add(arg);\n                 }\n                 else\n                 {\n-                    if (options.hasOption(arg.substring(0, 2)))\n+if (arg.hasOption(arg.substring(0, 2)))\n                     {\n                         // the format is --foo=value or -foo=value\n                         // the format is a special properties option (-Dproperty=value)\n                         tokens.add(arg.substring(0, 2)); // -D\n                         tokens.add(arg.substring(2)); // property=value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (options.hasOption(arg.substring(0, 2))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-12/src/java/org/apache/commons/cli/GnuParser.java\t2022-07-19 08:01:23.730171027 +0200\n+++ /tmp/tmp42_q4vgl.java\t2022-07-19 08:01:23.730171027 +0200\n@@ -76,11 +76,11 @@\n                 {\n                     tokens.add(arg);\n                 }\n                 else\n                 {\n-                    if (options.hasOption(arg.substring(0, 2)))\n+if (options.hasOption(arg.substring(0, 2))) {\n                     {\n                         // the format is --foo=value or -foo=value\n                         // the format is a special properties option (-Dproperty=value)\n                         tokens.add(arg.substring(0, 2)); // -D\n                         tokens.add(arg.substring(2)); // property=value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (arg.hasOption(arg.substring(0, 2))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-12/src/java/org/apache/commons/cli/GnuParser.java\t2022-07-19 08:01:25.186163406 +0200\n+++ /tmp/tmpd6f1yh7r.java\t2022-07-19 08:01:25.202163321 +0200\n@@ -76,11 +76,11 @@\n                 {\n                     tokens.add(arg);\n                 }\n                 else\n                 {\n-                    if (options.hasOption(arg.substring(0, 2)))\n+if (arg.hasOption(arg.substring(0, 2))) {\n                     {\n                         // the format is --foo=value or -foo=value\n                         // the format is a special properties option (-Dproperty=value)\n                         tokens.add(arg.substring(0, 2)); // -D\n                         tokens.add(arg.substring(2)); // property=value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (options.hasOption(arg.substring(0, 2))) //",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-12/src/java/org/apache/commons/cli/GnuParser.java\t2022-07-19 08:01:26.578156116 +0200\n+++ /tmp/tmpls5yhbfl.java\t2022-07-19 08:01:26.578156116 +0200\n@@ -76,11 +76,11 @@\n                 {\n                     tokens.add(arg);\n                 }\n                 else\n                 {\n-                    if (options.hasOption(arg.substring(0, 2)))\n+if (options.hasOption(arg.substring(0, 2))) //\n                     {\n                         // the format is --foo=value or -foo=value\n                         // the format is a special properties option (-Dproperty=value)\n                         tokens.add(arg.substring(0, 2)); // -D\n                         tokens.add(arg.substring(2)); // property=value\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (options.hasOption(arg);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-12/src/java/org/apache/commons/cli/GnuParser.java\t2022-07-19 08:01:29.158142605 +0200\n+++ /tmp/tmpigytuf47.java\t2022-07-19 08:01:29.158142605 +0200\n@@ -76,11 +76,11 @@\n                 {\n                     tokens.add(arg);\n                 }\n                 else\n                 {\n-                    if (options.hasOption(arg.substring(0, 2)))\n+if (options.hasOption(arg);\n                     {\n                         // the format is --foo=value or -foo=value\n                         // the format is a special properties option (-Dproperty=value)\n                         tokens.add(arg.substring(0, 2)); // -D\n                         tokens.add(arg.substring(2)); // property=value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (options.hasOption(arg.substring(0, 2));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-12/src/java/org/apache/commons/cli/GnuParser.java\t2022-07-19 08:01:30.626134917 +0200\n+++ /tmp/tmppqsrtbjr.java\t2022-07-19 08:01:30.626134917 +0200\n@@ -76,11 +76,11 @@\n                 {\n                     tokens.add(arg);\n                 }\n                 else\n                 {\n-                    if (options.hasOption(arg.substring(0, 2)))\n+if (options.hasOption(arg.substring(0, 2));\n                     {\n                         // the format is --foo=value or -foo=value\n                         // the format is a special properties option (-Dproperty=value)\n                         tokens.add(arg.substring(0, 2)); // -D\n                         tokens.add(arg.substring(2)); // property=value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (arg.hasOption(arg.substring(0, 2))) //",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-12/src/java/org/apache/commons/cli/GnuParser.java\t2022-07-19 08:01:32.050127456 +0200\n+++ /tmp/tmpotc95qxc.java\t2022-07-19 08:01:32.054127438 +0200\n@@ -76,11 +76,11 @@\n                 {\n                     tokens.add(arg);\n                 }\n                 else\n                 {\n-                    if (options.hasOption(arg.substring(0, 2)))\n+if (arg.hasOption(arg.substring(0, 2))) //\n                     {\n                         // the format is --foo=value or -foo=value\n                         // the format is a special properties option (-Dproperty=value)\n                         tokens.add(arg.substring(0, 2)); // -D\n                         tokens.add(arg.substring(2)); // property=value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (options.hasOption(arg.substring(0, 2))",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-12/src/java/org/apache/commons/cli/GnuParser.java\t2022-07-19 08:01:33.670118974 +0200\n+++ /tmp/tmp0xv74p2x.java\t2022-07-19 08:01:33.670118974 +0200\n@@ -76,11 +76,11 @@\n                 {\n                     tokens.add(arg);\n                 }\n                 else\n                 {\n-                    if (options.hasOption(arg.substring(0, 2)))\n+if (options.hasOption(arg.substring(0, 2))\n                     {\n                         // the format is --foo=value or -foo=value\n                         // the format is a special properties option (-Dproperty=value)\n                         tokens.add(arg.substring(0, 2)); // -D\n                         tokens.add(arg.substring(2)); // property=value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (options.hasOption(arg.substring(0, 2))) // -",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-12/src/java/org/apache/commons/cli/GnuParser.java\t2022-07-19 08:01:35.114111411 +0200\n+++ /tmp/tmpagtkn6gv.java\t2022-07-19 08:01:35.118111390 +0200\n@@ -76,11 +76,11 @@\n                 {\n                     tokens.add(arg);\n                 }\n                 else\n                 {\n-                    if (options.hasOption(arg.substring(0, 2)))\n+if (options.hasOption(arg.substring(0, 2))) // -\n                     {\n                         // the format is --foo=value or -foo=value\n                         // the format is a special properties option (-Dproperty=value)\n                         tokens.add(arg.substring(0, 2)); // -D\n                         tokens.add(arg.substring(2)); // property=value\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (options.hasOption(arg.substring(0, 2)))",
        "fixed_line": "if (opt.indexOf('=') != -1 && options.hasOption(opt.substring(0, opt.indexOf('=')))) { // the format is --foo=value or -foo=value tokens.add(arg.substring(0, arg.indexOf('='))); // --foo tokens.add(arg.substring(arg.indexOf('=') + 1)); // value } else if (options.hasOption(arg.substring(0, 2))) {"
    },
    "JacksonXml-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "_rootNameLookup = src._rootNameLookup; // copy from '_next-rootNameLookup = src._rootNameLookup;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-5/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 08:01:37.814097269 +0200\n+++ /tmp/tmproxk1noe.java\t2022-07-19 08:01:37.858097038 +0200\n@@ -54,11 +54,11 @@\n      */\n     protected XmlSerializerProvider(XmlSerializerProvider src) {\n         super(src);\n         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n         //    root name lookup as that may link back to diff version, configuration\n-        _rootNameLookup = src._rootNameLookup;\n+_rootNameLookup = src._rootNameLookup; // copy from '_next-rootNameLookup = src._rootNameLookup;\n     }\n \n     /*\n     /**********************************************************************\n     /* Overridden methods\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "_rootNameLookup = src._rootNameLookup; // copy from '_next-empty to do a nameLookup",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-5/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 08:01:48.218042769 +0200\n+++ /tmp/tmpatv39n1g.java\t2022-07-19 08:01:48.218042769 +0200\n@@ -54,11 +54,11 @@\n      */\n     protected XmlSerializerProvider(XmlSerializerProvider src) {\n         super(src);\n         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n         //    root name lookup as that may link back to diff version, configuration\n-        _rootNameLookup = src._rootNameLookup;\n+_rootNameLookup = src._rootNameLookup; // copy from '_next-empty to do a nameLookup\n     }\n \n     /*\n     /**********************************************************************\n     /* Overridden methods\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "_rootNameLookup = src._rootNameLookup;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-5/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 08:01:58.421989307 +0200\n+++ /tmp/tmpqfx7dfa_.java\t2022-07-19 08:01:58.421989307 +0200\n@@ -54,11 +54,11 @@\n      */\n     protected XmlSerializerProvider(XmlSerializerProvider src) {\n         super(src);\n         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n         //    root name lookup as that may link back to diff version, configuration\n-        _rootNameLookup = src._rootNameLookup;\n+_rootNameLookup = src._rootNameLookup;\n     }\n \n     /*\n     /**********************************************************************\n     /* Overridden methods\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "_rootNameLookup = src._rootNameLookup; // copy from '_next-rootNameLookup;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-5/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 08:02:08.541936274 +0200\n+++ /tmp/tmp7ymjjjwa.java\t2022-07-19 08:02:08.541936274 +0200\n@@ -54,11 +54,11 @@\n      */\n     protected XmlSerializerProvider(XmlSerializerProvider src) {\n         super(src);\n         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n         //    root name lookup as that may link back to diff version, configuration\n-        _rootNameLookup = src._rootNameLookup;\n+_rootNameLookup = src._rootNameLookup; // copy from '_next-rootNameLookup;\n     }\n \n     /*\n     /**********************************************************************\n     /* Overridden methods\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "_rootNameLookup = src._rootNameLookup; // copy from '_next-rootNameLookup",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-5/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 08:02:18.761882709 +0200\n+++ /tmp/tmpbk_fpiah.java\t2022-07-19 08:02:18.761882709 +0200\n@@ -54,11 +54,11 @@\n      */\n     protected XmlSerializerProvider(XmlSerializerProvider src) {\n         super(src);\n         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n         //    root name lookup as that may link back to diff version, configuration\n-        _rootNameLookup = src._rootNameLookup;\n+_rootNameLookup = src._rootNameLookup; // copy from '_next-rootNameLookup\n     }\n \n     /*\n     /**********************************************************************\n     /* Overridden methods\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "_rootNameLookup = src._rootNameLookup; // copy from '_next-is",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-5/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 08:02:28.997829049 +0200\n+++ /tmp/tmpzc0t88rf.java\t2022-07-19 08:02:29.001829028 +0200\n@@ -54,11 +54,11 @@\n      */\n     protected XmlSerializerProvider(XmlSerializerProvider src) {\n         super(src);\n         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n         //    root name lookup as that may link back to diff version, configuration\n-        _rootNameLookup = src._rootNameLookup;\n+_rootNameLookup = src._rootNameLookup; // copy from '_next-is\n     }\n \n     /*\n     /**********************************************************************\n     /* Overridden methods\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "_rootNameLookup = src._rootNameLookup; // copy from '_next-rootNameLookup = src._rootNameLookup; // copy from '_next-rootNameLookup = src._rootNameLookup;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-5/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 08:02:39.173775694 +0200\n+++ /tmp/tmpj_hcbyjt.java\t2022-07-19 08:02:39.177775673 +0200\n@@ -54,11 +54,11 @@\n      */\n     protected XmlSerializerProvider(XmlSerializerProvider src) {\n         super(src);\n         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n         //    root name lookup as that may link back to diff version, configuration\n-        _rootNameLookup = src._rootNameLookup;\n+_rootNameLookup = src._rootNameLookup; // copy from '_next-rootNameLookup = src._rootNameLookup; // copy from '_next-rootNameLookup = src._rootNameLookup;\n     }\n \n     /*\n     /**********************************************************************\n     /* Overridden methods\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "_rootNameLookup = src._rootNameLookup; // copy from '_next-rootNameLookup = src._rootNameLookup; // copy from '_next-empty to do a nameLookup",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-5/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 08:02:49.021724051 +0200\n+++ /tmp/tmp1sxdp357.java\t2022-07-19 08:02:49.021724051 +0200\n@@ -54,11 +54,11 @@\n      */\n     protected XmlSerializerProvider(XmlSerializerProvider src) {\n         super(src);\n         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n         //    root name lookup as that may link back to diff version, configuration\n-        _rootNameLookup = src._rootNameLookup;\n+_rootNameLookup = src._rootNameLookup; // copy from '_next-rootNameLookup = src._rootNameLookup; // copy from '_next-empty to do a nameLookup\n     }\n \n     /*\n     /**********************************************************************\n     /* Overridden methods\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "_rootNameLookup = src._rootNameLookup; // copy from '_next-rootNameLookup = src._rootNameLookup; // copy from '_next-rootNameLookup;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-5/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 08:02:59.285670218 +0200\n+++ /tmp/tmp0kjziwzh.java\t2022-07-19 08:02:59.285670218 +0200\n@@ -54,11 +54,11 @@\n      */\n     protected XmlSerializerProvider(XmlSerializerProvider src) {\n         super(src);\n         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n         //    root name lookup as that may link back to diff version, configuration\n-        _rootNameLookup = src._rootNameLookup;\n+_rootNameLookup = src._rootNameLookup; // copy from '_next-rootNameLookup = src._rootNameLookup; // copy from '_next-rootNameLookup;\n     }\n \n     /*\n     /**********************************************************************\n     /* Overridden methods\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "_rootNameLookup = src._rootNameLookup; // copy from '_next-rootNameLookup = src._rootNameLookup = src._rootNameLookup;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-5/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-19 08:03:09.377617278 +0200\n+++ /tmp/tmpgske0qr1.java\t2022-07-19 08:03:09.377617278 +0200\n@@ -54,11 +54,11 @@\n      */\n     protected XmlSerializerProvider(XmlSerializerProvider src) {\n         super(src);\n         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n         //    root name lookup as that may link back to diff version, configuration\n-        _rootNameLookup = src._rootNameLookup;\n+_rootNameLookup = src._rootNameLookup; // copy from '_next-rootNameLookup = src._rootNameLookup = src._rootNameLookup;\n     }\n \n     /*\n     /**********************************************************************\n     /* Overridden methods\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "_rootNameLookup = src._rootNameLookup;",
        "fixed_line": "_rootNameLookup = new XmlRootNameLookup();"
    },
    "Gson-2": {
        "fixes": [
            {
                "k": 1,
                "patch": "return (TypeAdapter<T2>) typeAdapter;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\t2022-07-19 08:03:19.745562882 +0200\n+++ /tmp/tmpfddxl6pi.java\t2022-07-19 08:03:19.793562629 +0200\n@@ -828,11 +828,11 @@\n       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n         final Class<? super T2> requestedType = typeToken.getRawType();\n         if (!clazz.isAssignableFrom(requestedType)) {\n           return null;\n         }\n-        return (TypeAdapter<T2>) typeAdapter;\n+return (TypeAdapter<T2>) typeAdapter;\n \n       }\n       @Override public String toString() {\n         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return (TypeAdapter<T2>) typeAdapter; // we didn't really modify it's totalGJACKSON-407] -- allow disabling wrapping for the typeAdapter;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\t2022-07-19 08:03:24.477538052 +0200\n+++ /tmp/tmpt4q059_q.java\t2022-07-19 08:03:24.477538052 +0200\n@@ -828,11 +828,11 @@\n       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n         final Class<? super T2> requestedType = typeToken.getRawType();\n         if (!clazz.isAssignableFrom(requestedType)) {\n           return null;\n         }\n-        return (TypeAdapter<T2>) typeAdapter;\n+return (TypeAdapter<T2>) typeAdapter; // we didn't really modify it's totalGJACKSON-407] -- allow disabling wrapping for the typeAdapter;\n \n       }\n       @Override public String toString() {\n         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return (TypeAdapter<T2>) typeAdapter; // we didn't really modify it's totalGJACKSON-407] --raw (Type) typeAdapter;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\t2022-07-19 08:03:28.225518383 +0200\n+++ /tmp/tmpvot881w7.java\t2022-07-19 08:03:28.225518383 +0200\n@@ -828,11 +828,11 @@\n       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n         final Class<? super T2> requestedType = typeToken.getRawType();\n         if (!clazz.isAssignableFrom(requestedType)) {\n           return null;\n         }\n-        return (TypeAdapter<T2>) typeAdapter;\n+return (TypeAdapter<T2>) typeAdapter; // we didn't really modify it's totalGJACKSON-407] --raw (Type) typeAdapter;\n \n       }\n       @Override public String toString() {\n         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return (TypeAdapter<T2>) typeAdapter; // we need to check whether the typeAdapter",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\t2022-07-19 08:03:32.017498483 +0200\n+++ /tmp/tmprankkev7.java\t2022-07-19 08:03:32.017498483 +0200\n@@ -828,11 +828,11 @@\n       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n         final Class<? super T2> requestedType = typeToken.getRawType();\n         if (!clazz.isAssignableFrom(requestedType)) {\n           return null;\n         }\n-        return (TypeAdapter<T2>) typeAdapter;\n+return (TypeAdapter<T2>) typeAdapter; // we need to check whether the typeAdapter\n \n       }\n       @Override public String toString() {\n         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return (TypeAdapter<T2>) typeAdapter; // we didn't really modify it.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\t2022-07-19 08:03:35.741478939 +0200\n+++ /tmp/tmp1rzckr1t.java\t2022-07-19 08:03:35.741478939 +0200\n@@ -828,11 +828,11 @@\n       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n         final Class<? super T2> requestedType = typeToken.getRawType();\n         if (!clazz.isAssignableFrom(requestedType)) {\n           return null;\n         }\n-        return (TypeAdapter<T2>) typeAdapter;\n+return (TypeAdapter<T2>) typeAdapter; // we didn't really modify it.\n \n       }\n       @Override public String toString() {\n         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return (TypeAdapter<T2>) typeAdapter; // we need to check whether the typeAdapter;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\t2022-07-19 08:03:39.601458681 +0200\n+++ /tmp/tmp5quc2vku.java\t2022-07-19 08:03:39.605458660 +0200\n@@ -828,11 +828,11 @@\n       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n         final Class<? super T2> requestedType = typeToken.getRawType();\n         if (!clazz.isAssignableFrom(requestedType)) {\n           return null;\n         }\n-        return (TypeAdapter<T2>) typeAdapter;\n+return (TypeAdapter<T2>) typeAdapter; // we need to check whether the typeAdapter;\n \n       }\n       @Override public String toString() {\n         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return (TypeAdapter<T2>) typeAdapter; // we need to check whether the typeAdapter (Type) typeAdapter;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\t2022-07-19 08:03:43.341439050 +0200\n+++ /tmp/tmp2anpv8bb.java\t2022-07-19 08:03:43.341439050 +0200\n@@ -828,11 +828,11 @@\n       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n         final Class<? super T2> requestedType = typeToken.getRawType();\n         if (!clazz.isAssignableFrom(requestedType)) {\n           return null;\n         }\n-        return (TypeAdapter<T2>) typeAdapter;\n+return (TypeAdapter<T2>) typeAdapter; // we need to check whether the typeAdapter (Type) typeAdapter;\n \n       }\n       @Override public String toString() {\n         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return (TypeAdapter<T2>) typeAdapter; // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\t2022-07-19 08:03:47.221418684 +0200\n+++ /tmp/tmpy6zlc3hn.java\t2022-07-19 08:03:47.221418684 +0200\n@@ -828,11 +828,11 @@\n       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n         final Class<? super T2> requestedType = typeToken.getRawType();\n         if (!clazz.isAssignableFrom(requestedType)) {\n           return null;\n         }\n-        return (TypeAdapter<T2>) typeAdapter;\n+return (TypeAdapter<T2>) typeAdapter; // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n \n       }\n       @Override public String toString() {\n         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return (TypeAdapter<T2>) typeAdapter; // we didn't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\t2022-07-19 08:03:51.121398211 +0200\n+++ /tmp/tmpfxs_av3k.java\t2022-07-19 08:03:51.125398190 +0200\n@@ -828,11 +828,11 @@\n       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n         final Class<? super T2> requestedType = typeToken.getRawType();\n         if (!clazz.isAssignableFrom(requestedType)) {\n           return null;\n         }\n-        return (TypeAdapter<T2>) typeAdapter;\n+return (TypeAdapter<T2>) typeAdapter; // we didn't really modify it's totalGJACKSON-notnotnotnot real number\n \n       }\n       @Override public String toString() {\n         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return (TypeAdapter<T2>) typeAdapter; // we didn't really modify it's totalGJACKSON-407] -- allow use a reference typeAdapter;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\t2022-07-19 08:03:55.029377696 +0200\n+++ /tmp/tmpplxz1868.java\t2022-07-19 08:03:55.029377696 +0200\n@@ -828,11 +828,11 @@\n       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n         final Class<? super T2> requestedType = typeToken.getRawType();\n         if (!clazz.isAssignableFrom(requestedType)) {\n           return null;\n         }\n-        return (TypeAdapter<T2>) typeAdapter;\n+return (TypeAdapter<T2>) typeAdapter; // we didn't really modify it's totalGJACKSON-407] -- allow use a reference typeAdapter;\n \n       }\n       @Override public String toString() {\n         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return (TypeAdapter<T2>) typeAdapter;",
        "fixed_line": "return (TypeAdapter<T2>) new TypeAdapter<T1>() { @Override public void write(JsonWriter out, T1 value) throws IOException { typeAdapter.write(out, value); } @Override public T1 read(JsonReader in) throws IOException { T1 result = typeAdapter.read(in); if (result != null && !requestedType.isInstance(result)) { throw new JsonSyntaxException(\"Expected a \" + requestedType.getName() + \" but was \" + result.getClass().getName()); } return result; } };"
    },
    "Time-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-11/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\t2022-07-19 08:03:59.209355750 +0200\n+++ /tmp/tmp5zdz8brq.java\t2022-07-19 08:03:59.281355373 +0200\n@@ -63,14 +63,11 @@\n public class ZoneInfoCompiler {\n     static DateTimeOfYear cStartOfYear;\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n-    static {\n-        cVerbose.set(Boolean.FALSE);\n-    }\n+static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); }\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n      * @return true to log verbosely\n      */\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); return new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-11/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\t2022-07-19 08:04:10.541296252 +0200\n+++ /tmp/tmphnbct8ak.java\t2022-07-19 08:04:10.553296189 +0200\n@@ -63,14 +63,11 @@\n public class ZoneInfoCompiler {\n     static DateTimeOfYear cStartOfYear;\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n-    static {\n-        cVerbose.set(Boolean.FALSE);\n-    }\n+static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); return new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); }\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n      * @return true to log verbosely\n      */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); } else if (cVerbose.FALSE); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-11/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\t2022-07-19 08:04:13.081282915 +0200\n+++ /tmp/tmpw2pgxqda.java\t2022-07-19 08:04:13.081282915 +0200\n@@ -63,14 +63,11 @@\n public class ZoneInfoCompiler {\n     static DateTimeOfYear cStartOfYear;\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n-    static {\n-        cVerbose.set(Boolean.FALSE);\n-    }\n+static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); } else if (cVerbose.FALSE); }\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n      * @return true to log verbosely\n      */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); break; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-11/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\t2022-07-19 08:04:15.661269367 +0200\n+++ /tmp/tmp4o0znnxr.java\t2022-07-19 08:04:15.661269367 +0200\n@@ -63,14 +63,11 @@\n public class ZoneInfoCompiler {\n     static DateTimeOfYear cStartOfYear;\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n-    static {\n-        cVerbose.set(Boolean.FALSE);\n-    }\n+static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); break; }\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n      * @return true to log verbosely\n      */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); return; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-11/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\t2022-07-19 08:04:18.541254242 +0200\n+++ /tmp/tmpmkk1txqj.java\t2022-07-19 08:04:18.541254242 +0200\n@@ -63,14 +63,11 @@\n public class ZoneInfoCompiler {\n     static DateTimeOfYear cStartOfYear;\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n-    static {\n-        cVerbose.set(Boolean.FALSE);\n-    }\n+static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); return; }\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n      * @return true to log verbosely\n      */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); } else { cVerbose.set(Boolean.FALSE); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-11/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\t2022-07-19 08:04:21.353239474 +0200\n+++ /tmp/tmpmk981ozd.java\t2022-07-19 08:04:21.353239474 +0200\n@@ -63,14 +63,11 @@\n public class ZoneInfoCompiler {\n     static DateTimeOfYear cStartOfYear;\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n-    static {\n-        cVerbose.set(Boolean.FALSE);\n-    }\n+static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); } else { cVerbose.set(Boolean.FALSE); }\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n      * @return true to log verbosely\n      */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); return",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-11/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\t2022-07-19 08:04:24.013225512 +0200\n+++ /tmp/tmp2j_3cbqq.java\t2022-07-19 08:04:24.013225512 +0200\n@@ -63,14 +63,11 @@\n public class ZoneInfoCompiler {\n     static DateTimeOfYear cStartOfYear;\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n-    static {\n-        cVerbose.set(Boolean.FALSE);\n-    }\n+static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); return\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n      * @return true to log verbosely\n      */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); } else { cVerbose.FALSE); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-11/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\t2022-07-19 08:04:26.577212038 +0200\n+++ /tmp/tmpv21xe667.java\t2022-07-19 08:04:26.581212017 +0200\n@@ -63,14 +63,11 @@\n public class ZoneInfoCompiler {\n     static DateTimeOfYear cStartOfYear;\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n-    static {\n-        cVerbose.set(Boolean.FALSE);\n-    }\n+static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); } else { cVerbose.FALSE); }\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n      * @return true to log verbosely\n      */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); return new ThreadLocal<Boolean>(); static { cVerbose.add(Boolean.FALSE); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-11/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\t2022-07-19 08:04:29.193198298 +0200\n+++ /tmp/tmp2ib58572.java\t2022-07-19 08:04:29.193198298 +0200\n@@ -63,14 +63,11 @@\n public class ZoneInfoCompiler {\n     static DateTimeOfYear cStartOfYear;\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n-    static {\n-        cVerbose.set(Boolean.FALSE);\n-    }\n+static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); return new ThreadLocal<Boolean>(); static { cVerbose.add(Boolean.FALSE); }\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n      * @return true to log verbosely\n      */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); return new ThreadLocal<Boolean>(); static { cVerbose.getValue(Boolean.FALSE); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-11/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\t2022-07-19 08:04:31.781184706 +0200\n+++ /tmp/tmpz_a21kne.java\t2022-07-19 08:04:31.781184706 +0200\n@@ -63,14 +63,11 @@\n public class ZoneInfoCompiler {\n     static DateTimeOfYear cStartOfYear;\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n-    static {\n-        cVerbose.set(Boolean.FALSE);\n-    }\n+static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); return new ThreadLocal<Boolean>(); static { cVerbose.getValue(Boolean.FALSE); }\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n      * @return true to log verbosely\n      */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); }",
        "fixed_line": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>() { protected Boolean initialValue() { return Boolean.FALSE; } };"
    },
    "Closure-114": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 08:04:34.549170165 +0200\n+++ /tmp/tmpzwuop53n.java\t2022-07-19 08:04:34.577170019 +0200\n@@ -573,11 +573,11 @@\n           if (parent.getFirstChild().getNext() != n) {\n             recordDepScope(recordNode, ns);\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+} else {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n           // caller expression, but it could be nested deeper in the caller and\n           // we would still get a bug.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (parent.getFirstChild().getNext()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 08:05:25.044904840 +0200\n+++ /tmp/tmpn83nvkpn.java\t2022-07-19 08:05:25.044904840 +0200\n@@ -573,11 +573,11 @@\n           if (parent.getFirstChild().getNext() != n) {\n             recordDepScope(recordNode, ns);\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+} else if (parent.getFirstChild().getNext()) {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n           // caller expression, but it could be nested deeper in the caller and\n           // we would still get a bug.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (parent.getNext()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 08:05:28.832884930 +0200\n+++ /tmp/tmpnggmhu_q.java\t2022-07-19 08:05:28.832884930 +0200\n@@ -573,11 +573,11 @@\n           if (parent.getFirstChild().getNext() != n) {\n             recordDepScope(recordNode, ns);\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+} else if (parent.getNext()) {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n           // caller expression, but it could be nested deeper in the caller and\n           // we would still get a bug.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (parent.getFirstChild().getNext())) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 08:05:32.632864955 +0200\n+++ /tmp/tmpbnxpnx6o.java\t2022-07-19 08:05:32.632864955 +0200\n@@ -573,11 +573,11 @@\n           if (parent.getFirstChild().getNext() != n) {\n             recordDepScope(recordNode, ns);\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+} else if (parent.getFirstChild().getNext())) {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n           // caller expression, but it could be nested deeper in the caller and\n           // we would still get a bug.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (n.getFirstChild().getNext()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 08:05:36.464844813 +0200\n+++ /tmp/tmpf_ox_hwm.java\t2022-07-19 08:05:36.464844813 +0200\n@@ -573,11 +573,11 @@\n           if (parent.getFirstChild().getNext() != n) {\n             recordDepScope(recordNode, ns);\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+} else if (n.getFirstChild().getNext()) {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n           // caller expression, but it could be nested deeper in the caller and\n           // we would still get a bug.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (parent.getFirstChild().",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 08:05:40.356824352 +0200\n+++ /tmp/tmp8m4l6cs_.java\t2022-07-19 08:05:40.356824352 +0200\n@@ -573,11 +573,11 @@\n           if (parent.getFirstChild().getNext() != n) {\n             recordDepScope(recordNode, ns);\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+} else if (parent.getFirstChild().\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n           // caller expression, but it could be nested deeper in the caller and\n           // we would still get a bug.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (parent.getFirstChild()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 08:05:43.852805974 +0200\n+++ /tmp/tmp1dznya_j.java\t2022-07-19 08:05:43.852805974 +0200\n@@ -573,11 +573,11 @@\n           if (parent.getFirstChild().getNext() != n) {\n             recordDepScope(recordNode, ns);\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+} else if (parent.getFirstChild()) {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n           // caller expression, but it could be nested deeper in the caller and\n           // we would still get a bug.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (parent.getType() == Token.ASSIGN) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 08:05:47.576786395 +0200\n+++ /tmp/tmppwrt0k9t.java\t2022-07-19 08:05:47.576786395 +0200\n@@ -573,11 +573,11 @@\n           if (parent.getFirstChild().getNext() != n) {\n             recordDepScope(recordNode, ns);\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+} else if (parent.getType() == Token.ASSIGN) {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n           // caller expression, but it could be nested deeper in the caller and\n           // we would still get a bug.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (parent.getNext())) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 08:06:38.444518884 +0200\n+++ /tmp/tmpouaikwcf.java\t2022-07-19 08:06:38.444518884 +0200\n@@ -573,11 +573,11 @@\n           if (parent.getFirstChild().getNext() != n) {\n             recordDepScope(recordNode, ns);\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+} else if (parent.getNext())) {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n           // caller expression, but it could be nested deeper in the caller and\n           // we would still get a bug.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (parent.getSort() == n) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 08:06:41.864500891 +0200\n+++ /tmp/tmp75bb4cry.java\t2022-07-19 08:06:41.868500870 +0200\n@@ -573,11 +573,11 @@\n           if (parent.getFirstChild().getNext() != n) {\n             recordDepScope(recordNode, ns);\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+} else if (parent.getSort() == n) {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n           // caller expression, but it could be nested deeper in the caller and\n           // we would still get a bug.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "} else {",
        "fixed_line": "} else if (!(parent.isCall() && parent.getFirstChild() == n)) {"
    },
    "Mockito-38": {
        "fixes": [
            {
                "k": 1,
                "patch": "return StringDescription.toString(m).equals(arg);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\t2022-07-19 08:06:45.796480207 +0200\n+++ /tmp/tmpbogidit_.java\t2022-07-19 08:06:45.832480016 +0200\n@@ -43,8 +43,8 @@\n             return false;\n         }\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+return StringDescription.toString(m).equals(arg);\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return StringDescription.toString(m).equals(arg.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\t2022-07-19 08:07:01.052399942 +0200\n+++ /tmp/tmpl8syrew5.java\t2022-07-19 08:07:01.052399942 +0200\n@@ -43,8 +43,8 @@\n             return false;\n         }\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+return StringDescription.toString(m).equals(arg.toString());\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return StringDescription.toString(m).equals(arg == arg.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\t2022-07-19 08:07:15.588323454 +0200\n+++ /tmp/tmp98ro_o4v.java\t2022-07-19 08:07:15.588323454 +0200\n@@ -43,8 +43,8 @@\n             return false;\n         }\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+return StringDescription.toString(m).equals(arg == arg.toString());\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return StringDescription.toString(m).equals(arg!= arg.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\t2022-07-19 08:07:30.472245122 +0200\n+++ /tmp/tmpgrx84bcs.java\t2022-07-19 08:07:30.472245122 +0200\n@@ -43,8 +43,8 @@\n             return false;\n         }\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+return StringDescription.toString(m).equals(arg!= arg.toString());\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return StringDescription.toString(m).equals(arg) == arg.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\t2022-07-19 08:07:45.000168656 +0200\n+++ /tmp/tmpqzcthrcy.java\t2022-07-19 08:07:45.000168656 +0200\n@@ -43,8 +43,8 @@\n             return false;\n         }\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+return StringDescription.toString(m).equals(arg) == arg.toString());\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return StringDescription.toString(m).equals(arg, arg.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\t2022-07-19 08:07:46.716159622 +0200\n+++ /tmp/tmp6756b37q.java\t2022-07-19 08:07:46.716159622 +0200\n@@ -43,8 +43,8 @@\n             return false;\n         }\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+return StringDescription.toString(m).equals(arg, arg.toString());\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return StringDescription.toString(m).equals(arg = arg.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\t2022-07-19 08:07:48.956147832 +0200\n+++ /tmp/tmpaflfuz28.java\t2022-07-19 08:07:48.956147832 +0200\n@@ -43,8 +43,8 @@\n             return false;\n         }\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+return StringDescription.toString(m).equals(arg = arg.toString());\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return StringDescription.toString(m).equals(argName.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\t2022-07-19 08:08:03.448071539 +0200\n+++ /tmp/tmp3fm9rgwi.java\t2022-07-19 08:08:03.448071539 +0200\n@@ -43,8 +43,8 @@\n             return false;\n         }\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+return StringDescription.toString(m).equals(argName.toString());\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return StringDescription.toString(m).equals(arg));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\t2022-07-19 08:08:05.872058777 +0200\n+++ /tmp/tmp7707ogiv.java\t2022-07-19 08:08:05.872058777 +0200\n@@ -43,8 +43,8 @@\n             return false;\n         }\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+return StringDescription.toString(m).equals(arg));\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return StringDescription.toString(m).equals(arg))",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\t2022-07-19 08:08:07.628049531 +0200\n+++ /tmp/tmpycgkneom.java\t2022-07-19 08:08:07.628049531 +0200\n@@ -43,8 +43,8 @@\n             return false;\n         }\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+return StringDescription.toString(m).equals(arg))\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return StringDescription.toString(m).equals(arg.toString());",
        "fixed_line": "return StringDescription.toString(m).equals(arg == null? \"null\" : arg.toString());"
    },
    "JacksonDatabind-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "// can't be null or EMPTY",
                "patch_diff": "// can't be null or EMPTY",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (mixInvisibleinsn!= null) {",
                "patch_diff": "} else if (mixInvisibleinsn!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (mixIn methods!= null) {",
                "patch_diff": "} else if (mixIn methods!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// can't be null, as per [Issue#515",
                "patch_diff": "// can't be null, as per [Issue#515",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (mixIn methods.is(_constructMethod(m)); } else {",
                "patch_diff": "} else if (mixIn methods.is(_constructMethod(m)); } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (mixInvisibleinsn-levellevel) {",
                "patch_diff": "} else if (mixInvisibleinsn-levellevel) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (mixIn methods.level merge within mixinsn-levellevel) {",
                "patch_diff": "} else if (mixIn methods.level merge within mixinsn-levellevel) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (mixIn methods.is(_constructMethod(m)); } }",
                "patch_diff": "} else if (mixIn methods.is(_constructMethod(m)); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (mixIn methods.is(_constructMethod(methodName)) {",
                "patch_diff": "} else if (mixIn methods.is(_constructMethod(methodName)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// can't be null, as per [Issue#515 (mixInvisible)",
                "patch_diff": "// can't be null, as per [Issue#515 (mixInvisible)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "am = mixIns.find(m); if (am != null) { _addMixUnders(m, am); } else { mixIns.add(_constructMethod(m)); }"
    },
    "Gson-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "return getClass().getSimpleName(); pathNames[stackSize - 1] = \"null\"; }",
                "patch_diff": "return getClass().getSimpleName(); pathNames[stackSize - 1] = \"null\"; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return getClass().getSimpleName(); pathNames[stackSize - 1] = \"null\"; } else {",
                "patch_diff": "return getClass().getSimpleName(); pathNames[stackSize - 1] = \"null\"; } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return getClass().getSimpleName(); pathNames[stackSize - 1] = \"null\"; } catch (eIndices[stackSize - 1]++; }",
                "patch_diff": "return getClass().getSimpleName(); pathNames[stackSize - 1] = \"null\"; } catch (eIndices[stackSize - 1]++; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return getClass().getSimpleName(); pathNames[stackSize - 1] = \"null\"; } @Override public",
                "patch_diff": "return getClass().getSimpleName(); pathNames[stackSize - 1] = \"null\"; } @Override public",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return getClass().getSimpleName(); pathNames[stackSize - 1] = \"null\"; } catch (eIndices[stackSize - 1]++; } else {",
                "patch_diff": "return getClass().getSimpleName(); pathNames[stackSize - 1] = \"null\"; } catch (eIndices[stackSize - 1]++; } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return getClass().getSimpleName(); pathNames[stackSize - 1] = \"null\"; } else if (stackSize == JsonToken.NAME) {",
                "patch_diff": "return getClass().getSimpleName(); pathNames[stackSize - 1] = \"null\"; } else if (stackSize == JsonToken.NAME) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return getClass().getSimpleName(); pathNames[stackSize - 1] = \"null\"; } catch (eIndices[stackSize - 1]++;",
                "patch_diff": "return getClass().getSimpleName(); pathNames[stackSize - 1] = \"null\"; } catch (eIndices[stackSize - 1]++;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return getClass().getSimpleName(); pathNames[stackSize - 1] = \"null\"; } else if (stackSize - 1] == JsonToken.NAME) {",
                "patch_diff": "return getClass().getSimpleName(); pathNames[stackSize - 1] = \"null\"; } else if (stackSize - 1] == JsonToken.NAME) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return getClass().getSimpleName(); pathNames[stackSize - 1] = \"null\"; } else { popStack[stackSize - 1] = \"null\"; }",
                "patch_diff": "return getClass().getSimpleName(); pathNames[stackSize - 1] = \"null\"; } else { popStack[stackSize - 1] = \"null\"; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return getClass().getSimpleName(); pathNames[stackSize - 1] = \"null\"; } catch (eIndices[stackSize - 1]++; } @Override = \"null\"; }",
                "patch_diff": "return getClass().getSimpleName(); pathNames[stackSize - 1] = \"null\"; } catch (eIndices[stackSize - 1]++; } @Override = \"null\"; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (stackSize > 0) { pathNames[stackSize - 1] = \"null\"; } } if (stackSize > 0) { pathIndices[stackSize - 1]++; }"
    },
    "Math-97": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (sign == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-97/src/java/org/apache/commons/math/analysis/BrentSolver.java\t2022-07-19 08:08:13.020021143 +0200\n+++ /tmp/tmp4x1r6bfm.java\t2022-07-19 08:08:13.064020912 +0200\n@@ -133,18 +133,11 @@\n         double yMin = f.value(min);\n         double yMax = f.value(max);\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+if (sign == 0) {\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n         }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (sign == 0) { throw new IllegalArgumentException (\"Function values at endpoints do not have different signs.\" + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \"]\"); } else {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-97/src/java/org/apache/commons/math/analysis/BrentSolver.java\t2022-07-19 08:18:16.128962170 +0200\n+++ /tmp/tmp0mh8dc3o.java\t2022-07-19 08:18:16.128962170 +0200\n@@ -133,18 +133,11 @@\n         double yMin = f.value(min);\n         double yMax = f.value(max);\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+if (sign == 0) { throw new IllegalArgumentException (\"Function values at endpoints do not have different signs.\" + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \"]\"); } else {\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n         }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (sign == 0) { // not have different signs.\" + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \"]\"); } else {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-97/src/java/org/apache/commons/math/analysis/BrentSolver.java\t2022-07-19 08:18:22.824928015 +0200\n+++ /tmp/tmpqatbny8t.java\t2022-07-19 08:18:22.828927993 +0200\n@@ -133,18 +133,11 @@\n         double yMin = f.value(min);\n         double yMax = f.value(max);\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+if (sign == 0) { // not have different signs.\" + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \"]\"); } else {\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n         }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (sign >= 0) { throw new IllegalArgumentException (\"Function values at endpoints do not have different signs.\" + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \"]\"); } else {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-97/src/java/org/apache/commons/math/analysis/BrentSolver.java\t2022-07-19 08:28:25.777816376 +0200\n+++ /tmp/tmp8ia775ah.java\t2022-07-19 08:28:25.777816376 +0200\n@@ -133,18 +133,11 @@\n         double yMin = f.value(min);\n         double yMax = f.value(max);\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+if (sign >= 0) { throw new IllegalArgumentException (\"Function values at endpoints do not have different signs.\" + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \"]\"); } else {\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n         }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (sign >= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-97/src/java/org/apache/commons/math/analysis/BrentSolver.java\t2022-07-19 08:28:32.149783238 +0200\n+++ /tmp/tmp51hgm3jo.java\t2022-07-19 08:28:32.149783238 +0200\n@@ -133,18 +133,11 @@\n         double yMin = f.value(min);\n         double yMax = f.value(max);\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+if (sign >= 0) {\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n         }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (sign == 0) { throw new IllegalArgumentException (\"Function values at endpoints do not have different signs.\" + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-97/src/java/org/apache/commons/math/analysis/BrentSolver.java\t2022-07-19 08:38:35.206635923 +0200\n+++ /tmp/tmp0gcnd_ky.java\t2022-07-19 08:38:35.206635923 +0200\n@@ -133,18 +133,11 @@\n         double yMin = f.value(min);\n         double yMax = f.value(max);\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+if (sign == 0) { throw new IllegalArgumentException (\"Function values at endpoints do not have different signs.\" + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else {\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n         }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (sign >= 0) { throw new IllegalArgumentException (\"Function values at endpoints do not have different signs.\" + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-97/src/java/org/apache/commons/math/analysis/BrentSolver.java\t2022-07-19 08:38:41.546602761 +0200\n+++ /tmp/tmpqjy6xj6_.java\t2022-07-19 08:38:41.546602761 +0200\n@@ -133,18 +133,11 @@\n         double yMin = f.value(min);\n         double yMax = f.value(max);\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+if (sign >= 0) { throw new IllegalArgumentException (\"Function values at endpoints do not have different signs.\" + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else {\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n         }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (sign == 0) { // block == null; can't really modify it's do not have different signs.\" + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \"]\"); } else {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-97/src/java/org/apache/commons/math/analysis/BrentSolver.java\t2022-07-19 08:38:47.746570327 +0200\n+++ /tmp/tmphs2jsjef.java\t2022-07-19 08:38:47.750570306 +0200\n@@ -133,18 +133,11 @@\n         double yMin = f.value(min);\n         double yMax = f.value(max);\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+if (sign == 0) { // block == null; can't really modify it's do not have different signs.\" + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \"]\"); } else {\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n         }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (sign == 0) { // block == null; can't really modify it's different signs.\" + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \"]\"); } else {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-97/src/java/org/apache/commons/math/analysis/BrentSolver.java\t2022-07-19 08:48:50.762494015 +0200\n+++ /tmp/tmp0som5yea.java\t2022-07-19 08:48:50.766493981 +0200\n@@ -133,18 +133,11 @@\n         double yMin = f.value(min);\n         double yMax = f.value(max);\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+if (sign == 0) { // block == null; can't really modify it's different signs.\" + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \"]\"); } else {\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n         }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (sign == 0) { // not have different signs.\" + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-97/src/java/org/apache/commons/math/analysis/BrentSolver.java\t2022-07-19 08:58:53.666137008 +0200\n+++ /tmp/tmps2yg9o9v.java\t2022-07-19 08:58:53.666137008 +0200\n@@ -133,18 +133,11 @@\n         double yMin = f.value(min);\n         double yMax = f.value(max);\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+if (sign == 0) { // not have different signs.\" + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else {\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n         }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (sign >= 0) { // check if either value is close to a zero // neither value is close to zero and min and max do not bracket root. throw new IllegalArgumentException (\"Function values at endpoints do not have different signs.\" + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else {",
        "fixed_line": "if (sign > 0) { // check if either value is close to a zero if (Math.abs(yMin) <= functionValueAccuracy) { setResult(min, 0); ret = min; } else if (Math.abs(yMax) <= functionValueAccuracy) { setResult(max, 0); ret = max; } else { // neither value is close to zero and min and max do not bracket root. throw new IllegalArgumentException (\"Function values at endpoints do not have different signs.\" + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } } else if (sign < 0){ // solve using only the first endpoint as initial guess ret = solve(min, yMin, max, yMax, min, yMin); } else { // either min or max is a root if (yMin == 0.0) { ret = min; } else { ret = max; }"
    },
    "Math-96": {
        "fixes": [
            {
                "k": 1,
                "patch": "ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-96/src/java/org/apache/commons/math/complex/Complex.java\t2022-07-19 09:08:57.098392604 +0200\n+++ /tmp/tmprqhnem06.java\t2022-07-19 09:08:57.150392292 +0200\n@@ -253,11 +253,11 @@\n             try {\n                 Complex rhs = (Complex)other;\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) {\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-96/src/java/org/apache/commons/math/complex/Complex.java\t2022-07-19 09:08:59.230379836 +0200\n+++ /tmp/tmp3oj4vsth.java\t2022-07-19 09:08:59.234379810 +0200\n@@ -253,11 +253,11 @@\n             try {\n                 Complex rhs = (Complex)other;\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits);\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits) == Double.doubleToRawLongBits(rhs.getImaginary()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-96/src/java/org/apache/commons/math/complex/Complex.java\t2022-07-19 09:09:01.346367167 +0200\n+++ /tmp/tmp6og26_l9.java\t2022-07-19 09:09:01.346367167 +0200\n@@ -253,11 +253,11 @@\n             try {\n                 Complex rhs = (Complex)other;\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits) == Double.doubleToRawLongBits(rhs.getImaginary()));\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits.getImaginary()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-96/src/java/org/apache/commons/math/complex/Complex.java\t2022-07-19 09:09:03.338355242 +0200\n+++ /tmp/tmp011qql7s.java\t2022-07-19 09:09:03.338355242 +0200\n@@ -253,11 +253,11 @@\n             try {\n                 Complex rhs = (Complex)other;\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits.getImaginary()));\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(rhs.getImaginary()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-96/src/java/org/apache/commons/math/complex/Complex.java\t2022-07-19 09:09:05.294343534 +0200\n+++ /tmp/tmpl7z7kxwv.java\t2022-07-19 09:09:05.294343534 +0200\n@@ -253,11 +253,11 @@\n             try {\n                 Complex rhs = (Complex)other;\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(rhs.getImaginary()));\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-96/src/java/org/apache/commons/math/complex/Complex.java\t2022-07-19 09:09:07.382331035 +0200\n+++ /tmp/tmp79o52uud.java\t2022-07-19 09:09:07.382331035 +0200\n@@ -253,11 +253,11 @@\n             try {\n                 Complex rhs = (Complex)other;\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits,\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits) == Double.doubleToRawLongBits.getImaginary()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-96/src/java/org/apache/commons/math/complex/Complex.java\t2022-07-19 09:09:09.462318591 +0200\n+++ /tmp/tmpmmkqt29b.java\t2022-07-19 09:09:09.462318591 +0200\n@@ -253,11 +253,11 @@\n             try {\n                 Complex rhs = (Complex)other;\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits) == Double.doubleToRawLongBits.getImaginary()));\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits) == Double.doubleToRawLongBits;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-96/src/java/org/apache/commons/math/complex/Complex.java\t2022-07-19 09:09:11.458306647 +0200\n+++ /tmp/tmpm4mjaoh_.java\t2022-07-19 09:09:11.458306647 +0200\n@@ -253,11 +253,11 @@\n             try {\n                 Complex rhs = (Complex)other;\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits) == Double.doubleToRawLongBits;\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits) == Double.doubleToRawLongBits);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-96/src/java/org/apache/commons/math/complex/Complex.java\t2022-07-19 09:09:13.566294038 +0200\n+++ /tmp/tmpq61s7xbr.java\t2022-07-19 09:09:13.566294038 +0200\n@@ -253,11 +253,11 @@\n             try {\n                 Complex rhs = (Complex)other;\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits) == Double.doubleToRawLongBits);\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-96/src/java/org/apache/commons/math/complex/Complex.java\t2022-07-19 09:09:15.554282150 +0200\n+++ /tmp/tmp7y4cv86c.java\t2022-07-19 09:09:15.558282123 +0200\n@@ -253,11 +253,11 @@\n             try {\n                 Complex rhs = (Complex)other;\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));",
        "fixed_line": "ret = (real == rhs.real) && (imaginary == rhs.imaginary);"
    },
    "Closure-166": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (constraint.isRecordType()) {",
                "patch_diff": "} else if (constraint.isRecordType()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (constraint.getOwnProperty any each(prop.getOwnPropertyNames()) {",
                "patch_diff": "} else if (constraint.getOwnProperty any each(prop.getOwnPropertyNames()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (constraint.getOwnProperty any each(prop); } else {",
                "patch_diff": "if (constraint.getOwnProperty any each(prop); } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (constraint.getOwnProperty any each(prop); } else if (constraint.",
                "patch_diff": "if (constraint.getOwnProperty any each(prop); } else if (constraint.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (constraint.getOwnProperty any each(prop); }",
                "patch_diff": "if (constraint.getOwnProperty any each(prop); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (constraint.getOwnProperty any each(prop);",
                "patch_diff": "} else if (constraint.getOwnProperty any each(prop);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "throw new IllegalArgumentException(\"The any must not be trying to match",
                "patch_diff": "throw new IllegalArgumentException(\"The any must not be trying to match",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (constraint.getOwnProperty any each(prop); } else if (constraint.isObjectType()); } else {",
                "patch_diff": "if (constraint.getOwnProperty any each(prop); } else if (constraint.isObjectType()); } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (constraint.getOwnProperty any each(prop); } else if (constraint.getOwnProperty()) {",
                "patch_diff": "if (constraint.getOwnProperty any each(prop); } else if (constraint.getOwnProperty()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (constraint.getOwnProperty any each(prop); } else {",
                "patch_diff": "} else if (constraint.getOwnProperty any each(prop); } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "} else if (constraint.isUnionType()) { for (JSType alt : constraint.toMaybeUnionType().getAlternates()) { if (alt.isRecordType()) { matchRecordTypeConstraint(alt.toObjectType()); } }"
    },
    "Closure-78": {
        "fixes": [
            {
                "k": 1,
                "patch": "error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 09:09:24.506228627 +0200\n+++ /tmp/tmpdmhdjm1t.java\t2022-07-19 09:09:24.562228295 +0200\n@@ -706,18 +706,11 @@\n       case Token.MUL:\n         result = lval * rval;\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n           return null;\n         }\n         result = lval / rval;\n         break;\n       default:\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 09:09:57.234033260 +0200\n+++ /tmp/tmpk0buzlco.java\t2022-07-19 09:09:57.234033260 +0200\n@@ -706,18 +706,11 @@\n       case Token.MUL:\n         result = lval * rval;\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right;\n           return null;\n         }\n         result = lval / rval;\n         break;\n       default:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), rightType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 09:09:59.774018113 +0200\n+++ /tmp/tmpzuiigp8t.java\t2022-07-19 09:09:59.774018113 +0200\n@@ -706,18 +706,11 @@\n       case Token.MUL:\n         result = lval * rval;\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), rightType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n           return null;\n         }\n         result = lval / rval;\n         break;\n       default:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), rightType.error(\"Divide by 0\"), right);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 09:10:02.486001947 +0200\n+++ /tmp/tmpo5zcv_ta.java\t2022-07-19 09:10:02.490001926 +0200\n@@ -706,18 +706,11 @@\n       case Token.MUL:\n         result = lval * rval;\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), rightType.error(\"Divide by 0\"), right);\n           return null;\n         }\n         result = lval / rval;\n         break;\n       default:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right % 0\"), right);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 09:10:05.241985524 +0200\n+++ /tmp/tmpu9__8b08.java\t2022-07-19 09:10:05.249985475 +0200\n@@ -706,18 +706,11 @@\n       case Token.MUL:\n         result = lval * rval;\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right % 0\"), right);\n           return null;\n         }\n         result = lval / rval;\n         break;\n       default:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right; break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 09:10:07.737970650 +0200\n+++ /tmp/tmpil22e3ws.java\t2022-07-19 09:10:07.737970650 +0200\n@@ -706,18 +706,11 @@\n       case Token.MUL:\n         result = lval * rval;\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right; break;\n           return null;\n         }\n         result = lval / rval;\n         break;\n       default:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 09:10:10.241955732 +0200\n+++ /tmp/tmp51p0zssp.java\t2022-07-19 09:10:10.241955732 +0200\n@@ -706,18 +706,11 @@\n       case Token.MUL:\n         result = lval * rval;\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n           return null;\n         }\n         result = lval / rval;\n         break;\n       default:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right % 0\"), rightType.error(\"Divide by 0\"), right);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 09:10:13.001939291 +0200\n+++ /tmp/tmpko7vq2et.java\t2022-07-19 09:10:13.005939268 +0200\n@@ -706,18 +706,11 @@\n       case Token.MUL:\n         result = lval * rval;\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right % 0\"), rightType.error(\"Divide by 0\"), right);\n           return null;\n         }\n         result = lval / rval;\n         break;\n       default:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), rightType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 09:10:15.505924379 +0200\n+++ /tmp/tmpt6tidosv.java\t2022-07-19 09:10:15.505924379 +0200\n@@ -706,18 +706,11 @@\n       case Token.MUL:\n         result = lval * rval;\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), rightType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"),\n           return null;\n         }\n         result = lval / rval;\n         break;\n       default:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right % 0\"), rightType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-19 09:10:18.013909443 +0200\n+++ /tmp/tmp05qbcvk9.java\t2022-07-19 09:10:18.017909420 +0200\n@@ -706,18 +706,11 @@\n       case Token.MUL:\n         result = lval * rval;\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right % 0\"), rightType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n           return null;\n         }\n         result = lval / rval;\n         break;\n       default:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right); return null; } result = lval % rval; break; case Token.DIV: if (rval == 0) { error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);",
        "fixed_line": ""
    },
    "Math-94": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (u / v == 0.0) { // gcd is even...",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-94/src/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 09:10:20.693893486 +0200\n+++ /tmp/tmpx96_r57o.java\t2022-07-19 09:10:20.721893320 +0200\n@@ -407,11 +407,11 @@\n      * @param v a non-zero number\n      * @return the greatest common divisor, never zero\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+if (u / v == 0.0) { // gcd is even...\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (u * v == 0) { // if even...",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-94/src/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 09:10:27.497852990 +0200\n+++ /tmp/tmp7_3rjgvo.java\t2022-07-19 09:10:27.497852990 +0200\n@@ -407,11 +407,11 @@\n      * @param v a non-zero number\n      * @return the greatest common divisor, never zero\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+if (u * v == 0) { // if even...\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (u * v == 0.0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-94/src/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 09:10:34.305812489 +0200\n+++ /tmp/tmp35o1smzg.java\t2022-07-19 09:10:34.309812464 +0200\n@@ -407,11 +407,11 @@\n      * @param v a non-zero number\n      * @return the greatest common divisor, never zero\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+if (u * v == 0.0) {\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (u * v == 0) { // not do zero",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-94/src/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 09:10:41.281771005 +0200\n+++ /tmp/tmpizpr2y2j.java\t2022-07-19 09:10:41.285770983 +0200\n@@ -407,11 +407,11 @@\n      * @param v a non-zero number\n      * @return the greatest common divisor, never zero\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+if (u * v == 0) { // not do zero\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (u / v == 0.0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-94/src/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 09:10:48.145730207 +0200\n+++ /tmp/tmpaarrzvrg.java\t2022-07-19 09:10:48.145730207 +0200\n@@ -407,11 +407,11 @@\n      * @param v a non-zero number\n      * @return the greatest common divisor, never zero\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+if (u / v == 0.0) {\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (u * v == 0) { // even...",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-94/src/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 09:10:55.089688950 +0200\n+++ /tmp/tmp9bh8nldt.java\t2022-07-19 09:10:55.089688950 +0200\n@@ -407,11 +407,11 @@\n      * @param v a non-zero number\n      * @return the greatest common divisor, never zero\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+if (u * v == 0) { // even...\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (u * v == 0) { // gcd is even...",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-94/src/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 09:11:02.029647736 +0200\n+++ /tmp/tmp4v7_c82h.java\t2022-07-19 09:11:02.029647736 +0200\n@@ -407,11 +407,11 @@\n      * @param v a non-zero number\n      * @return the greatest common divisor, never zero\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+if (u * v == 0) { // gcd is even...\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (u * v == 0.0) { // gcd is even...",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-94/src/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 09:11:09.781601719 +0200\n+++ /tmp/tmp5zcgzabe.java\t2022-07-19 09:11:09.781601719 +0200\n@@ -407,11 +407,11 @@\n      * @param v a non-zero number\n      * @return the greatest common divisor, never zero\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+if (u * v == 0.0) { // gcd is even...\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (u * v > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-94/src/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 09:11:17.385556602 +0200\n+++ /tmp/tmphqj99j7a.java\t2022-07-19 09:11:17.389556577 +0200\n@@ -407,11 +407,11 @@\n      * @param v a non-zero number\n      * @return the greatest common divisor, never zero\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+if (u * v > 0) {\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (u * v == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-94/src/java/org/apache/commons/math/util/MathUtils.java\t2022-07-19 09:21:20.613608212 +0200\n+++ /tmp/tmpa8dnw_w4.java\t2022-07-19 09:21:20.613608212 +0200\n@@ -407,11 +407,11 @@\n      * @param v a non-zero number\n      * @return the greatest common divisor, never zero\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+if (u * v == 0) {\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (u * v == 0) {",
        "fixed_line": "if ((u == 0) || (v == 0)) {"
    },
    "Jsoup-46": {
        "fixes": [
            {
                "k": 1,
                "patch": "accum.append(c);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-46/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 09:21:27.621549897 +0200\n+++ /tmp/tmpxr9_e34v.java\t2022-07-19 09:21:27.641549731 +0200\n@@ -113,11 +113,11 @@\n                         break;\n                     case 0xA0:\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+accum.append(c);\n                         break;\n                     case '<':\n                         if (!inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "accum.append(escapeMode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-46/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 09:21:31.585517007 +0200\n+++ /tmp/tmpqz1qtx3s.java\t2022-07-19 09:21:31.585517007 +0200\n@@ -113,11 +113,11 @@\n                         break;\n                     case 0xA0:\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+accum.append(escapeMode);\n                         break;\n                     case '<':\n                         if (!inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "accum.append(c =escapeMode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-46/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 09:21:34.657491561 +0200\n+++ /tmp/tmpm_q8lvv9.java\t2022-07-19 09:21:34.657491561 +0200\n@@ -113,11 +113,11 @@\n                         break;\n                     case 0xA0:\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+accum.append(c =escapeMode);\n                         break;\n                     case '<':\n                         if (!inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "accum.append(c); // '<': if it.append(c);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-46/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 09:21:36.269478226 +0200\n+++ /tmp/tmpxifufkee.java\t2022-07-19 09:21:36.269478226 +0200\n@@ -113,11 +113,11 @@\n                         break;\n                     case 0xA0:\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+accum.append(c); // '<': if it.append(c);\n                         break;\n                     case '<':\n                         if (!inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "accum.append(c); // '<': else if (c == '<') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-46/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 09:21:39.437452049 +0200\n+++ /tmp/tmp_pnpe9hh.java\t2022-07-19 09:21:39.437452049 +0200\n@@ -113,11 +113,11 @@\n                         break;\n                     case 0xA0:\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+accum.append(c); // '<': else if (c == '<') {\n                         break;\n                     case '<':\n                         if (!inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "accum.append(c); // '<': the E",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-46/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 09:21:42.541426442 +0200\n+++ /tmp/tmpm_dfjtfn.java\t2022-07-19 09:21:42.541426442 +0200\n@@ -113,11 +113,11 @@\n                         break;\n                     case 0xA0:\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+accum.append(c); // '<': the E\n                         break;\n                     case '<':\n                         if (!inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "accum.append(c); // '<': if (c == '<') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-46/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 09:21:45.621401074 +0200\n+++ /tmp/tmp688q0usc.java\t2022-07-19 09:21:45.621401074 +0200\n@@ -113,11 +113,11 @@\n                         break;\n                     case 0xA0:\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+accum.append(c); // '<': if (c == '<') {\n                         break;\n                     case '<':\n                         if (!inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "attributes.append(c);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-46/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 09:21:48.821374756 +0200\n+++ /tmp/tmppv22szsc.java\t2022-07-19 09:21:48.825374723 +0200\n@@ -113,11 +113,11 @@\n                         break;\n                     case 0xA0:\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+attributes.append(c);\n                         break;\n                     case '<':\n                         if (!inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "accum.append(c); // '<':",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-46/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 09:21:50.881357837 +0200\n+++ /tmp/tmpt8sfxe8f.java\t2022-07-19 09:21:50.885357805 +0200\n@@ -113,11 +113,11 @@\n                         break;\n                     case 0xA0:\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+accum.append(c); // '<':\n                         break;\n                     case '<':\n                         if (!inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "accum.append(c); // '<': else if (c == 'c)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-46/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-19 09:21:54.053331819 +0200\n+++ /tmp/tmp3y70jfml.java\t2022-07-19 09:21:54.053331819 +0200\n@@ -113,11 +113,11 @@\n                         break;\n                     case 0xA0:\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+accum.append(c); // '<': else if (c == 'c)\n                         break;\n                     case '<':\n                         if (!inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "accum.append(c);",
        "fixed_line": "accum.append(\"&#xa0;\");"
    },
    "Cli-20": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (token.indexOf('=')!= -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-20/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 09:21:57.721301783 +0200\n+++ /tmp/tmp5bq4hr0u.java\t2022-07-19 09:21:57.761301455 +0200\n@@ -109,18 +109,11 @@\n             String token = (String) iter.next();\n \n             // handle long option --foo or --foo=bar\n             if (token.startsWith(\"--\"))\n             {\n-                if (token.indexOf('=') != -1)\n-                {\n-                    tokens.add(token.substring(0, token.indexOf('=')));\n-                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n-                }\n-                else\n-                {\n-                    tokens.add(token);\n+if (token.indexOf('=')!= -1) {\n                 }\n             }\n \n             // single hyphen\n             else if (\"-\".equals(token))\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (token.indexOf('=')!= -1) && token.indexOf('=').indexOf('=') + 1, token.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-20/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 09:22:00.737277127 +0200\n+++ /tmp/tmpa47wa68z.java\t2022-07-19 09:22:00.761276931 +0200\n@@ -109,18 +109,11 @@\n             String token = (String) iter.next();\n \n             // handle long option --foo or --foo=bar\n             if (token.startsWith(\"--\"))\n             {\n-                if (token.indexOf('=') != -1)\n-                {\n-                    tokens.add(token.substring(0, token.indexOf('=')));\n-                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n-                }\n-                else\n-                {\n-                    tokens.add(token);\n+if (token.indexOf('=')!= -1) && token.indexOf('=').indexOf('=') + 1, token.length()));\n                 }\n             }\n \n             // single hyphen\n             else if (\"-\".equals(token))\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (token.indexOf('=')!= -1) { tokens.add(token.indexOf('=') + 1, token.length())); } else if (token.indexOf('=')!= -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-20/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 09:22:02.193265238 +0200\n+++ /tmp/tmp_yvyr2m4.java\t2022-07-19 09:22:02.193265238 +0200\n@@ -109,18 +109,11 @@\n             String token = (String) iter.next();\n \n             // handle long option --foo or --foo=bar\n             if (token.startsWith(\"--\"))\n             {\n-                if (token.indexOf('=') != -1)\n-                {\n-                    tokens.add(token.substring(0, token.indexOf('=')));\n-                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n-                }\n-                else\n-                {\n-                    tokens.add(token);\n+if (token.indexOf('=')!= -1) { tokens.add(token.indexOf('=') + 1, token.length())); } else if (token.indexOf('=')!= -1) {\n                 }\n             }\n \n             // single hyphen\n             else if (\"-\".equals(token))\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (token.indexOf('=')!= -1) { tokens.add(token.indexOf('=') + 1, token.length())); } else if (token.indexOf('=') + 1, token.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-20/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 09:22:03.605253715 +0200\n+++ /tmp/tmp7dc0ojjr.java\t2022-07-19 09:22:03.605253715 +0200\n@@ -109,18 +109,11 @@\n             String token = (String) iter.next();\n \n             // handle long option --foo or --foo=bar\n             if (token.startsWith(\"--\"))\n             {\n-                if (token.indexOf('=') != -1)\n-                {\n-                    tokens.add(token.substring(0, token.indexOf('=')));\n-                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n-                }\n-                else\n-                {\n-                    tokens.add(token);\n+if (token.indexOf('=')!= -1) { tokens.add(token.indexOf('=') + 1, token.length())); } else if (token.indexOf('=') + 1, token.length()));\n                 }\n             }\n \n             // single hyphen\n             else if (\"-\".equals(token))\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (token.indexOf('=')!= -1) { buf.indexOf('=') + 1, token.indexOf('=') + 1, token.length())); } else if (token.indexOf('=')!= -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-20/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 09:22:04.985242458 +0200\n+++ /tmp/tmpm02ih4rn.java\t2022-07-19 09:22:04.985242458 +0200\n@@ -109,18 +109,11 @@\n             String token = (String) iter.next();\n \n             // handle long option --foo or --foo=bar\n             if (token.startsWith(\"--\"))\n             {\n-                if (token.indexOf('=') != -1)\n-                {\n-                    tokens.add(token.substring(0, token.indexOf('=')));\n-                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n-                }\n-                else\n-                {\n-                    tokens.add(token);\n+if (token.indexOf('=')!= -1) { buf.indexOf('=') + 1, token.indexOf('=') + 1, token.length())); } else if (token.indexOf('=')!= -1) {\n                 }\n             }\n \n             // single hyphen\n             else if (\"-\".equals(token))\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (token.indexOf('=')!= -1) { tokens.add(token.indexOf('=') + 1, token.length())); } else if (token.indexOf('=') + 1, token.length())); } else {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-20/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 09:22:06.393230985 +0200\n+++ /tmp/tmphfg0gv2k.java\t2022-07-19 09:22:06.393230985 +0200\n@@ -109,18 +109,11 @@\n             String token = (String) iter.next();\n \n             // handle long option --foo or --foo=bar\n             if (token.startsWith(\"--\"))\n             {\n-                if (token.indexOf('=') != -1)\n-                {\n-                    tokens.add(token.substring(0, token.indexOf('=')));\n-                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n-                }\n-                else\n-                {\n-                    tokens.add(token);\n+if (token.indexOf('=')!= -1) { tokens.add(token.indexOf('=') + 1, token.length())); } else if (token.indexOf('=') + 1, token.length())); } else {\n                 }\n             }\n \n             // single hyphen\n             else if (\"-\".equals(token))\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (token.indexOf('=')!= -1) { buf.indexOf('=') + 1, token.indexOf('=') + 1, token.length())); } else {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-20/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 09:22:07.937218411 +0200\n+++ /tmp/tmp56gg4tpv.java\t2022-07-19 09:22:07.937218411 +0200\n@@ -109,18 +109,11 @@\n             String token = (String) iter.next();\n \n             // handle long option --foo or --foo=bar\n             if (token.startsWith(\"--\"))\n             {\n-                if (token.indexOf('=') != -1)\n-                {\n-                    tokens.add(token.substring(0, token.indexOf('=')));\n-                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n-                }\n-                else\n-                {\n-                    tokens.add(token);\n+if (token.indexOf('=')!= -1) { buf.indexOf('=') + 1, token.indexOf('=') + 1, token.length())); } else {\n                 }\n             }\n \n             // single hyphen\n             else if (\"-\".equals(token))\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (token.indexOf('=')!= -1) { tokens.add(token.indexOf('=') + 1, token.length())); } else {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-20/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 09:22:09.381206661 +0200\n+++ /tmp/tmpywynb21u.java\t2022-07-19 09:22:09.381206661 +0200\n@@ -109,18 +109,11 @@\n             String token = (String) iter.next();\n \n             // handle long option --foo or --foo=bar\n             if (token.startsWith(\"--\"))\n             {\n-                if (token.indexOf('=') != -1)\n-                {\n-                    tokens.add(token.substring(0, token.indexOf('=')));\n-                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n-                }\n-                else\n-                {\n-                    tokens.add(token);\n+if (token.indexOf('=')!= -1) { tokens.add(token.indexOf('=') + 1, token.length())); } else {\n                 }\n             }\n \n             // single hyphen\n             else if (\"-\".equals(token))\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (token.indexOf('=')!= -1) { buf.indexOf('=') + 1, token.indexOf('=') + 1, token.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-20/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 09:22:10.889194397 +0200\n+++ /tmp/tmpc9ktll5p.java\t2022-07-19 09:22:10.889194397 +0200\n@@ -109,18 +109,11 @@\n             String token = (String) iter.next();\n \n             // handle long option --foo or --foo=bar\n             if (token.startsWith(\"--\"))\n             {\n-                if (token.indexOf('=') != -1)\n-                {\n-                    tokens.add(token.substring(0, token.indexOf('=')));\n-                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n-                }\n-                else\n-                {\n-                    tokens.add(token);\n+if (token.indexOf('=')!= -1) { buf.indexOf('=') + 1, token.indexOf('=') + 1, token.length()));\n                 }\n             }\n \n             // single hyphen\n             else if (\"-\".equals(token))\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (token.indexOf('=')!= -1) { buf.indexOf('=') + 1, token.length())); } else if (token.indexOf('=')!= -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-20/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-19 09:22:12.413182012 +0200\n+++ /tmp/tmp7ja6719i.java\t2022-07-19 09:22:12.433181850 +0200\n@@ -109,18 +109,11 @@\n             String token = (String) iter.next();\n \n             // handle long option --foo or --foo=bar\n             if (token.startsWith(\"--\"))\n             {\n-                if (token.indexOf('=') != -1)\n-                {\n-                    tokens.add(token.substring(0, token.indexOf('=')));\n-                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n-                }\n-                else\n-                {\n-                    tokens.add(token);\n+if (token.indexOf('=')!= -1) { buf.indexOf('=') + 1, token.length())); } else if (token.indexOf('=')!= -1) {\n                 }\n             }\n \n             // single hyphen\n             else if (\"-\".equals(token))\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (token.indexOf('=') != -1) { tokens.add(token.substring(0, token.indexOf('='))); tokens.add(token.substring(token.indexOf('=') + 1, token.length())); } else { tokens.add(token);",
        "fixed_line": "int pos = token.indexOf('='); String opt = pos == -1 ? token : token.substring(0, pos); // --foo if (!options.hasOption(opt) && stopAtNonOption) { process(token); } else { tokens.add(opt); if (pos != -1) { tokens.add(token.substring(pos + 1)); }"
    },
    "Closure-71": {
        "fixes": [
            {
                "k": 1,
                "patch": "boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-71/src/com/google/javascript/jscomp/CheckAccessControls.java\t2022-07-19 09:22:14.321166522 +0200\n+++ /tmp/tmp8aewjtiv.java\t2022-07-19 09:22:14.401165869 +0200\n@@ -411,11 +411,11 @@\n     String propertyName = getprop.getLastChild().getString();\n \n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n       // Find the lowest property defined on a class with visibility\n       // information.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-71/src/com/google/javascript/jscomp/CheckAccessControls.java\t2022-07-19 09:22:49.856880528 +0200\n+++ /tmp/tmp3pdcszw6.java\t2022-07-19 09:22:49.860880497 +0200\n@@ -411,11 +411,11 @@\n     String propertyName = getprop.getLastChild().getString();\n \n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype,\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n       // Find the lowest property defined on a class with visibility\n       // information.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "boolean isOverride = t.inGlobalScope() &&",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-71/src/com/google/javascript/jscomp/CheckAccessControls.java\t2022-07-19 09:23:22.936618435 +0200\n+++ /tmp/tmpynhp9tdn.java\t2022-07-19 09:23:22.936618435 +0200\n@@ -411,11 +411,11 @@\n     String propertyName = getprop.getLastChild().getString();\n \n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+boolean isOverride = t.inGlobalScope() &&\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n       // Find the lowest property defined on a class with visibility\n       // information.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-71/src/com/google/javascript/jscomp/CheckAccessControls.java\t2022-07-19 09:23:55.848361372 +0200\n+++ /tmp/tmpcl24hzcu.java\t2022-07-19 09:23:55.848361372 +0200\n@@ -411,11 +411,11 @@\n     String propertyName = getprop.getLastChild().getString();\n \n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n       // Find the lowest property defined on a class with visibility\n       // information.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property-inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-71/src/com/google/javascript/jscomp/CheckAccessControls.java\t2022-07-19 09:24:28.944106357 +0200\n+++ /tmp/tmp8vlj01rk.java\t2022-07-19 09:24:28.944106357 +0200\n@@ -411,11 +411,11 @@\n     String propertyName = getprop.getLastChild().getString();\n \n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property-inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n       // Find the lowest property defined on a class with visibility\n       // information.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // assigned to a prototype, as per RFC 46 property name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-71/src/com/google/javascript/jscomp/CheckAccessControls.java\t2022-07-19 09:25:01.903855652 +0200\n+++ /tmp/tmpjyrlpx4y.java\t2022-07-19 09:25:01.903855652 +0200\n@@ -411,11 +411,11 @@\n     String propertyName = getprop.getLastChild().getString();\n \n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // assigned to a prototype, as per RFC 46 property name;\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n       // Find the lowest property defined on a class with visibility\n       // information.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, // assigned to a prototype, as per RFC 46 property name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-71/src/com/google/javascript/jscomp/CheckAccessControls.java\t2022-07-19 09:25:34.687609311 +0200\n+++ /tmp/tmpocoqrl4w.java\t2022-07-19 09:25:34.687609311 +0200\n@@ -411,11 +411,11 @@\n     String propertyName = getprop.getLastChild().getString();\n \n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, // assigned to a prototype, as per RFC 46 property name;\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n       // Find the lowest property defined on a class with visibility\n       // information.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // object literals being // assigned to a prototype, as per RFC 46 property name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-71/src/com/google/javascript/jscomp/CheckAccessControls.java\t2022-07-19 09:26:07.335366804 +0200\n+++ /tmp/tmp0w7h1qyr.java\t2022-07-19 09:26:07.335366804 +0200\n@@ -411,11 +411,11 @@\n     String propertyName = getprop.getLastChild().getString();\n \n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // object literals being // assigned to a prototype, as per RFC 46 property name;\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n       // Find the lowest property defined on a class with visibility\n       // information.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property-inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-71/src/com/google/javascript/jscomp/CheckAccessControls.java\t2022-07-19 09:26:40.135125816 +0200\n+++ /tmp/tmpgq6_i78k.java\t2022-07-19 09:26:40.139125789 +0200\n@@ -411,11 +411,11 @@\n     String propertyName = getprop.getLastChild().getString();\n \n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property-inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype,\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n       // Find the lowest property defined on a class with visibility\n       // information.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-71/src/com/google/javascript/jscomp/CheckAccessControls.java\t2022-07-19 09:27:12.834888046 +0200\n+++ /tmp/tmp11ph2a9u.java\t2022-07-19 09:27:12.834888046 +0200\n@@ -411,11 +411,11 @@\n     String propertyName = getprop.getLastChild().getString();\n \n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype,\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n       // Find the lowest property defined on a class with visibility\n       // information.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "boolean isOverride = t.inGlobalScope() &&",
        "fixed_line": "boolean isOverride = parent.getJSDocInfo() != null &&"
    },
    "Closure-172": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (qName!= null && qName.endsWith(\".prototype\")) {",
                "patch_diff": "if (qName!= null && qName.endsWith(\".prototype\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (qName == null || qName.endsWith(\".prototype\")) {",
                "patch_diff": "if (qName == null || qName.endsWith(\".prototype\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (qName!= null && qName.endsWith(\".prototype\")) { return false; } boolean inferred = false; if (info.hasType()!= null) {",
                "patch_diff": "if (qName!= null && qName.endsWith(\".prototype\")) { return false; } boolean inferred = false; if (info.hasType()!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (qName!= null && qName.endsWith(\".prototype\")) { return false; } boolean inferred = false; if (info.hasType() == null) {",
                "patch_diff": "if (qName!= null && qName.endsWith(\".prototype\")) { return false; } boolean inferred = false; if (info.hasType() == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (qName!= null && qName.endsWith(\".prototype\")) { return false; } boolean inferred = false;",
                "patch_diff": "if (qName!= null && qName.endsWith(\".prototype\")) { return false; } boolean inferred = false;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (qName!= null && qName.endsWith(\".prototype\")) { return false; } boolean inferred = false; if (info == null) {",
                "patch_diff": "if (qName!= null && qName.endsWith(\".prototype\")) { return false; } boolean inferred = false; if (info == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (qName!= null && qName.endsWith(\".prototype\")) { return false; } boolean inferred = false; }",
                "patch_diff": "if (qName!= null && qName.endsWith(\".prototype\")) { return false; } boolean inferred = false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (qName!= null && qName.endsWith(\".prototype\")) { return false; } if (info.hasType() == null) {",
                "patch_diff": "if (qName!= null && qName.endsWith(\".prototype\")) { return false; } if (info.hasType() == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (qName!= null && qName.endsWith(\".prototype\")) { return false; }",
                "patch_diff": "if (qName!= null && qName.endsWith(\".prototype\")) { return false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (qName!= null && qName.endsWith(\".prototype\")) { return false; } boolean inferred = false; if (info!= null) {",
                "patch_diff": "if (qName!= null && qName.endsWith(\".prototype\")) { return false; } boolean inferred = false; if (info!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "String className = qName.substring(0, qName.lastIndexOf(\".prototype\")); Var slot = scope.getSlot(className); JSType classType = slot == null ? null : slot.getType(); if (classType != null && (classType.isConstructor() || classType.isInterface())) { return false; }"
    },
    "Math-87": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (MathUtils.equals(getEntry(i, col), epsilon)) { if (row == null) { return null; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-87/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 09:27:47.394639276 +0200\n+++ /tmp/tmpusi8fx_i.java\t2022-07-19 09:27:47.450638871 +0200\n@@ -270,16 +270,11 @@\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n-                if (row == null) {\n-                row = i;\n-                } else {\n-                return null;\n-                }\n+if (MathUtils.equals(getEntry(i, col), epsilon)) { if (row == null) { return null; }\n             }\n         }\n         return row;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (!MathUtils.equals(getEntry(i, col), epsilon)) { if (row == null) { return null; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-87/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 09:27:54.574587901 +0200\n+++ /tmp/tmpschfm1jr.java\t2022-07-19 09:27:54.574587901 +0200\n@@ -270,16 +270,11 @@\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n-                if (row == null) {\n-                row = i;\n-                } else {\n-                return null;\n-                }\n+if (!MathUtils.equals(getEntry(i, col), epsilon)) { if (row == null) { return null; }\n             }\n         }\n         return row;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (MathUtils.equals(getEntry(i, col), epsilon)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-87/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 09:28:00.902542709 +0200\n+++ /tmp/tmp1am4ont2.java\t2022-07-19 09:28:00.902542709 +0200\n@@ -270,16 +270,11 @@\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n-                if (row == null) {\n-                row = i;\n-                } else {\n-                return null;\n-                }\n+if (MathUtils.equals(getEntry(i, col), epsilon)) {\n             }\n         }\n         return row;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (MathUtils.equals(getEntry(i, col), 0.0, epsilon)) { if (row == null) { return null; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-87/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 09:28:06.930499736 +0200\n+++ /tmp/tmpwrdb9xr2.java\t2022-07-19 09:28:06.930499736 +0200\n@@ -270,16 +270,11 @@\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n-                if (row == null) {\n-                row = i;\n-                } else {\n-                return null;\n-                }\n+if (MathUtils.equals(getEntry(i, col), 0.0, epsilon)) { if (row == null) { return null; }\n             }\n         }\n         return row;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (MathUtils.equals(getEntry(i, col), epsilon)) { if (row == null) { return null; } else { return null; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-87/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 09:28:13.234454866 +0200\n+++ /tmp/tmpjq3od97t.java\t2022-07-19 09:28:13.238454838 +0200\n@@ -270,16 +270,11 @@\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n-                if (row == null) {\n-                row = i;\n-                } else {\n-                return null;\n-                }\n+if (MathUtils.equals(getEntry(i, col), epsilon)) { if (row == null) { return null; } else { return null; }\n             }\n         }\n         return row;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (MathUtils.equals(getEntry(i, col), epsilon)) { if (row == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-87/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 09:28:19.498410360 +0200\n+++ /tmp/tmp5_cloa4z.java\t2022-07-19 09:28:19.502410334 +0200\n@@ -270,16 +270,11 @@\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n-                if (row == null) {\n-                row = i;\n-                } else {\n-                return null;\n-                }\n+if (MathUtils.equals(getEntry(i, col), epsilon)) { if (row == null) {\n             }\n         }\n         return row;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (!MathUtils.equals(getEntry(i, col), epsilon)) { if (row == null) { return null; } else { return null; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-87/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 09:28:21.474396338 +0200\n+++ /tmp/tmphemg4tnb.java\t2022-07-19 09:28:21.474396338 +0200\n@@ -270,16 +270,11 @@\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n-                if (row == null) {\n-                row = i;\n-                } else {\n-                return null;\n-                }\n+if (!MathUtils.equals(getEntry(i, col), epsilon)) { if (row == null) { return null; } else { return null; }\n             }\n         }\n         return row;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (MathUtils.equals(getEntry(i, col), epsilon)) { return null; } else if (row == null) { return null; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-87/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 09:28:27.490353684 +0200\n+++ /tmp/tmphtmyhmbc.java\t2022-07-19 09:28:27.490353684 +0200\n@@ -270,16 +270,11 @@\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n-                if (row == null) {\n-                row = i;\n-                } else {\n-                return null;\n-                }\n+if (MathUtils.equals(getEntry(i, col), epsilon)) { return null; } else if (row == null) { return null; }\n             }\n         }\n         return row;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (MathUtils.equals(getEntry(i, col), epsilon)) { if (row == null) { if (row == null) { return null; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-87/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 09:28:29.498339462 +0200\n+++ /tmp/tmpwu5kezh1.java\t2022-07-19 09:28:29.498339462 +0200\n@@ -270,16 +270,11 @@\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n-                if (row == null) {\n-                row = i;\n-                } else {\n-                return null;\n-                }\n+if (MathUtils.equals(getEntry(i, col), epsilon)) { if (row == null) { if (row == null) { return null; }\n             }\n         }\n         return row;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (MathUtils.equals(getEntry(i, col), epsilon)) { if (row == null) { return null; } else {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-87/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 09:28:31.438325731 +0200\n+++ /tmp/tmpmaxauvt1.java\t2022-07-19 09:28:31.438325731 +0200\n@@ -270,16 +270,11 @@\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n-                if (row == null) {\n-                row = i;\n-                } else {\n-                return null;\n-                }\n+if (MathUtils.equals(getEntry(i, col), epsilon)) { if (row == null) { return null; } else {\n             }\n         }\n         return row;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) { if (row == null) { row = i; } else { return null; }",
        "fixed_line": "if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) { row = i; } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {"
    },
    "Jsoup-8": {
        "fixes": [
            {
                "k": 1,
                "patch": "new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-8/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 09:28:33.666309968 +0200\n+++ /tmp/tmphxzkv407.java\t2022-07-19 09:28:33.718309599 +0200\n@@ -358,11 +358,11 @@\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n     protected void outerHtml(StringBuilder accum) {\n-        new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n+new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "new NodeTraversor(accum, ownerDocument().outputSettings())).traverse(this);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-8/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 09:28:37.126285508 +0200\n+++ /tmp/tmpozxn70sb.java\t2022-07-19 09:28:37.126285508 +0200\n@@ -358,11 +358,11 @@\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n     protected void outerHtml(StringBuilder accum) {\n-        new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n+new NodeTraversor(accum, ownerDocument().outputSettings())).traverse(this);\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "new NodeTraversor(null OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-8/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 09:28:38.622274939 +0200\n+++ /tmp/tmpk6v1pmc9.java\t2022-07-19 09:28:38.622274939 +0200\n@@ -358,11 +358,11 @@\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n     protected void outerHtml(StringBuilder accum) {\n-        new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n+new NodeTraversor(null OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "new NodeTraversor(old OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-8/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 09:28:40.190263867 +0200\n+++ /tmp/tmpowyowt9x.java\t2022-07-19 09:28:40.190263867 +0200\n@@ -358,11 +358,11 @@\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n     protected void outerHtml(StringBuilder accum) {\n-        new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n+new NodeTraversor(old OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "new NodeTraversor(new OuterHtmlVisitor(compiler, ownerDocument().outputSettings())).traverse(this);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-8/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 09:28:41.754252826 +0200\n+++ /tmp/tmp1fhi96e0.java\t2022-07-19 09:28:41.754252826 +0200\n@@ -358,11 +358,11 @@\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n     protected void outerHtml(StringBuilder accum) {\n-        new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n+new NodeTraversor(new OuterHtmlVisitor(compiler, ownerDocument().outputSettings())).traverse(this);\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "new NodeTraversor(true, ownerDocument().outputSettings())).traverse(this);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-8/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 09:28:43.402241197 +0200\n+++ /tmp/tmpzqf8y4a9.java\t2022-07-19 09:28:43.402241197 +0200\n@@ -358,11 +358,11 @@\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n     protected void outerHtml(StringBuilder accum) {\n-        new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n+new NodeTraversor(true, ownerDocument().outputSettings())).traverse(this);\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "new NodeTraversor(i, ownerDocument().outputSettings())).traverse(this);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-8/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 09:28:44.946230310 +0200\n+++ /tmp/tmpad65k9tm.java\t2022-07-19 09:28:44.946230310 +0200\n@@ -358,11 +358,11 @@\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n     protected void outerHtml(StringBuilder accum) {\n-        new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n+new NodeTraversor(i, ownerDocument().outputSettings())).traverse(this);\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "new NodeTraversor(exp, ownerDocument().outputSettings())).traverse(this);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-8/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 09:28:46.546219028 +0200\n+++ /tmp/tmp4i4nl5hx.java\t2022-07-19 09:28:46.546219028 +0200\n@@ -358,11 +358,11 @@\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n     protected void outerHtml(StringBuilder accum) {\n-        new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n+new NodeTraversor(exp, ownerDocument().outputSettings())).traverse(this);\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "new NodeTraversor(Node, ownerDocument().outputSettings())).traverse(this);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-8/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 09:28:48.094208119 +0200\n+++ /tmp/tmpagpyio64.java\t2022-07-19 09:28:48.094208119 +0200\n@@ -358,11 +358,11 @@\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n     protected void outerHtml(StringBuilder accum) {\n-        new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n+new NodeTraversor(Node, ownerDocument().outputSettings())).traverse(this);\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "new NodeTraversor(compiler, ownerDocument().outputSettings())).traverse(this);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-8/src/main/java/org/jsoup/nodes/Node.java\t2022-07-19 09:28:49.602197495 +0200\n+++ /tmp/tmpurmqka2h.java\t2022-07-19 09:28:49.602197495 +0200\n@@ -358,11 +358,11 @@\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n     protected void outerHtml(StringBuilder accum) {\n-        new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n+new NodeTraversor(compiler, ownerDocument().outputSettings())).traverse(this);\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);",
        "fixed_line": "new NodeTraversor(new OuterHtmlVisitor(accum, getOutputSettings())).traverse(this); } // if this node has no document (or parent), retrieve the default output settings private Document.OutputSettings getOutputSettings() { return ownerDocument() != null ? ownerDocument().outputSettings() : (new Document(\"\")).outputSettings(); }"
    },
    "Jsoup-39": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (docData.length() == 0 && doc.charAt(0) == null) {",
                "patch_diff": "if (docData.length() == 0 && doc.charAt(0) == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (docData.length() == 0 || doc.charAt(0) == null) {",
                "patch_diff": "if (docData.length() == 0 || doc.charAt(0) == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (docData.length()!= 0 && doc.charAt(0) == null) {",
                "patch_diff": "if (docData.length()!= 0 && doc.charAt(0) == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (docData.charAt(0) == null || doc.length() == 0 && docData.charAt(0) == null) {",
                "patch_diff": "if (docData.charAt(0) == null || doc.length() == 0 && docData.charAt(0) == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (docData.charAt(0) == null || doc.length() == 0 && doc.charAt(0) == null) {",
                "patch_diff": "if (docData.charAt(0) == null || doc.length() == 0 && doc.charAt(0) == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (docData.charAt(0) == null) {",
                "patch_diff": "if (docData.charAt(0) == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (docData.length() == 0 || doc.charAt(0) == 0 && doc.charAt(0) == null) {",
                "patch_diff": "if (docData.length() == 0 || doc.charAt(0) == 0 && doc.charAt(0) == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (docData.charAt(0) == null || doc.length() == 0 && doc.outputData.charAt(0) == null) {",
                "patch_diff": "if (docData.charAt(0) == null || doc.length() == 0 && doc.outputData.charAt(0) == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (docData.length() == 0 && doc.charAt(0) == 0 &&",
                "patch_diff": "if (docData.length() == 0 && doc.charAt(0) == 0 &&",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (docData.charAt(0) == null || doc.length() == 0 && doc.charAt(0) == 0) {",
                "patch_diff": "if (docData.charAt(0) == null || doc.length() == 0 && doc.charAt(0) == 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "doc = null;"
    },
    "Mockito-29": {
        "fixes": [
            {
                "k": 1,
                "patch": "description.appendText(description.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-29/src/org/mockito/internal/matchers/Same.java\t2022-07-19 09:28:53.006173529 +0200\n+++ /tmp/tmp_f22rze4.java\t2022-07-19 09:28:53.058173165 +0200\n@@ -24,11 +24,11 @@\n     }\n \n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+description.appendText(description.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n \n     private void appendQuoting(Description description) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "description.appendText(wanted.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-29/src/org/mockito/internal/matchers/Same.java\t2022-07-19 09:29:12.258038374 +0200\n+++ /tmp/tmpw_m11m3p.java\t2022-07-19 09:29:12.258038374 +0200\n@@ -24,11 +24,11 @@\n     }\n \n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+description.appendText(wanted.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n \n     private void appendQuoting(Description description) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "description.appendText(var.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-29/src/org/mockito/internal/matchers/Same.java\t2022-07-19 09:29:31.273905501 +0200\n+++ /tmp/tmpw3yc3vv4.java\t2022-07-19 09:29:31.273905501 +0200\n@@ -24,11 +24,11 @@\n     }\n \n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+description.appendText(var.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n \n     private void appendQuoting(Description description) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "description.appendText(return.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-29/src/org/mockito/internal/matchers/Same.java\t2022-07-19 09:29:33.809887827 +0200\n+++ /tmp/tmp8t4apaxs.java\t2022-07-19 09:29:33.809887827 +0200\n@@ -24,11 +24,11 @@\n     }\n \n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+description.appendText(return.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n \n     private void appendQuoting(Description description) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "description.appendText(bar.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-29/src/org/mockito/internal/matchers/Same.java\t2022-07-19 09:29:35.589875427 +0200\n+++ /tmp/tmpj06y56ia.java\t2022-07-19 09:29:35.589875427 +0200\n@@ -24,11 +24,11 @@\n     }\n \n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+description.appendText(bar.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n \n     private void appendQuoting(Description description) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "description.appendText(index.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-29/src/org/mockito/internal/matchers/Same.java\t2022-07-19 09:29:38.125857771 +0200\n+++ /tmp/tmprb0ifzpm.java\t2022-07-19 09:29:38.125857771 +0200\n@@ -24,11 +24,11 @@\n     }\n \n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+description.appendText(index.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n \n     private void appendQuoting(Description description) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "description.appendText(paint.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-29/src/org/mockito/internal/matchers/Same.java\t2022-07-19 09:29:40.649840210 +0200\n+++ /tmp/tmpnv9bbnsu.java\t2022-07-19 09:29:40.649840210 +0200\n@@ -24,11 +24,11 @@\n     }\n \n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+description.appendText(paint.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n \n     private void appendQuoting(Description description) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "description.appendText( description.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-29/src/org/mockito/internal/matchers/Same.java\t2022-07-19 09:29:43.073823352 +0200\n+++ /tmp/tmpame355nz.java\t2022-07-19 09:29:43.073823352 +0200\n@@ -24,11 +24,11 @@\n     }\n \n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+description.appendText( description.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n \n     private void appendQuoting(Description description) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "description.appendText(base.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-29/src/org/mockito/internal/matchers/Same.java\t2022-07-19 09:30:02.297690000 +0200\n+++ /tmp/tmpc5nx2ef8.java\t2022-07-19 09:30:02.297690000 +0200\n@@ -24,11 +24,11 @@\n     }\n \n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+description.appendText(base.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n \n     private void appendQuoting(Description description) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "description.appendText(description.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-29/src/org/mockito/internal/matchers/Same.java\t2022-07-19 09:30:04.709673309 +0200\n+++ /tmp/tmpf_aq8c7j.java\t2022-07-19 09:30:04.709673309 +0200\n@@ -24,11 +24,11 @@\n     }\n \n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+description.appendText(description.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n \n     private void appendQuoting(Description description) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "description.appendText(wanted.toString());",
        "fixed_line": "description.appendText(wanted == null ? \"null\" : wanted.toString());"
    },
    "JacksonDatabind-76": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (buffer.assignParameter(creatorProp, bean, tokens);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-76/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\t2022-07-19 09:30:24.289538151 +0200\n+++ /tmp/tmpnccy618q.java\t2022-07-19 09:30:24.313537987 +0200\n@@ -578,31 +578,11 @@\n             String propName = p.getCurrentName();\n             p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n-                }\n+if (buffer.assignParameter(creatorProp, bean, tokens);\n                 continue;\n             }\n             // Object Id property?\n             if (buffer.readIdProperty(propName)) {\n                 continue;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (buffer.assignParameter(creatorProp, bean, tokens); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-76/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\t2022-07-19 09:30:25.993526417 +0200\n+++ /tmp/tmp_eurflpy.java\t2022-07-19 09:30:25.993526417 +0200\n@@ -578,31 +578,11 @@\n             String propName = p.getCurrentName();\n             p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n-                }\n+if (buffer.assignParameter(creatorProp, bean, tokens); }\n                 continue;\n             }\n             // Object Id property?\n             if (buffer.readIdProperty(propName)) {\n                 continue;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (_unwrappedPropertyHandler.deserializeUnwrapped(jp, ctxt, bean, tokens);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-76/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\t2022-07-19 09:30:27.505516008 +0200\n+++ /tmp/tmpfq4ibvhk.java\t2022-07-19 09:30:27.505516008 +0200\n@@ -578,31 +578,11 @@\n             String propName = p.getCurrentName();\n             p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n-                }\n+if (_unwrappedPropertyHandler.deserializeUnwrapped(jp, ctxt, bean, tokens);\n                 continue;\n             }\n             // Object Id property?\n             if (buffer.readIdProperty(propName)) {\n                 continue;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (buffer.assignParameter(creatorProp, ctxt.processUnwrapped(jp, ctxt, bean, tokens);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-76/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\t2022-07-19 09:30:29.129504832 +0200\n+++ /tmp/tmp_vs2znet.java\t2022-07-19 09:30:29.129504832 +0200\n@@ -578,31 +578,11 @@\n             String propName = p.getCurrentName();\n             p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n-                }\n+if (buffer.assignParameter(creatorProp, ctxt.processUnwrapped(jp, ctxt, bean, tokens);\n                 continue;\n             }\n             // Object Id property?\n             if (buffer.readIdProperty(propName)) {\n                 continue;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (buffer.assignParameter(t, bean, tokens);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-76/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\t2022-07-19 09:30:30.753493659 +0200\n+++ /tmp/tmp9z9azd_0.java\t2022-07-19 09:30:30.753493659 +0200\n@@ -578,31 +578,11 @@\n             String propName = p.getCurrentName();\n             p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n-                }\n+if (buffer.assignParameter(t, bean, tokens);\n                 continue;\n             }\n             // Object Id property?\n             if (buffer.readIdProperty(propName)) {\n                 continue;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (buffer.assignParameter(creatorProp, ctxt, bean, tokens);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-76/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\t2022-07-19 09:30:32.337482766 +0200\n+++ /tmp/tmphft8hj47.java\t2022-07-19 09:30:32.341482738 +0200\n@@ -578,31 +578,11 @@\n             String propName = p.getCurrentName();\n             p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n-                }\n+if (buffer.assignParameter(creatorProp, ctxt, bean, tokens);\n                 continue;\n             }\n             // Object Id property?\n             if (buffer.readIdProperty(propName)) {\n                 continue;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (buffer.assignParameter(jp, ctxt, bean, tokens);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-76/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\t2022-07-19 09:30:33.873472205 +0200\n+++ /tmp/tmp45flssxc.java\t2022-07-19 09:30:33.877472179 +0200\n@@ -578,31 +578,11 @@\n             String propName = p.getCurrentName();\n             p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n-                }\n+if (buffer.assignParameter(jp, ctxt, bean, tokens);\n                 continue;\n             }\n             // Object Id property?\n             if (buffer.readIdProperty(propName)) {\n                 continue;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (buffer.assignParameter(creatorProp, ctxt.processUnwrapped(jp, ctxt, bean);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-76/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\t2022-07-19 09:30:35.497461044 +0200\n+++ /tmp/tmpjomm0vf5.java\t2022-07-19 09:30:35.497461044 +0200\n@@ -578,31 +578,11 @@\n             String propName = p.getCurrentName();\n             p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n-                }\n+if (buffer.assignParameter(creatorProp, ctxt.processUnwrapped(jp, ctxt, bean);\n                 continue;\n             }\n             // Object Id property?\n             if (buffer.readIdProperty(propName)) {\n                 continue;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (buffer.assignParameter(creatorProp, ctxt.processUnwrapped(jp, ctxt);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-76/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\t2022-07-19 09:30:36.969450932 +0200\n+++ /tmp/tmpm06mfl0o.java\t2022-07-19 09:30:36.969450932 +0200\n@@ -578,31 +578,11 @@\n             String propName = p.getCurrentName();\n             p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n-                }\n+if (buffer.assignParameter(creatorProp, ctxt.processUnwrapped(jp, ctxt);\n                 continue;\n             }\n             // Object Id property?\n             if (buffer.readIdProperty(propName)) {\n                 continue;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (buffer.assignParameter(bean, jp.nextToken() == JsonToken.FIELD_NAME) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-76/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\t2022-07-19 09:30:38.549440080 +0200\n+++ /tmp/tmp7gqxxadb.java\t2022-07-19 09:30:38.549440080 +0200\n@@ -578,31 +578,11 @@\n             String propName = p.getCurrentName();\n             p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n-                }\n+if (buffer.assignParameter(bean, jp.nextToken() == JsonToken.FIELD_NAME) {\n                 continue;\n             }\n             // Object Id property?\n             if (buffer.readIdProperty(propName)) {\n                 continue;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) { t = p.nextToken(); Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); continue; } while (t == JsonToken.FIELD_NAME) { p.nextToken(); tokens.copyCurrentStructure(p); t = p.nextToken(); } tokens.writeEndObject(); if (bean.getClass() != _beanType.getRawClass()) { ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\"); return null; } return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); }",
        "fixed_line": "buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));"
    },
    "Cli-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (option.hasArg() && (option.getArgName()!= null))",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-11/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 09:30:40.277428216 +0200\n+++ /tmp/tmpz6jke4gr.java\t2022-07-19 09:30:40.309427996 +0200\n@@ -627,11 +627,11 @@\n         {\n             buff.append(\"--\").append(option.getLongOpt());\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+if (option.hasArg() && (option.getArgName()!= null))\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n \n         // if the Option is not a required option\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (option.hasArg() && (option.getArgName()!= null)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-11/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 09:30:43.117408726 +0200\n+++ /tmp/tmpgfyyf6fc.java\t2022-07-19 09:30:43.117408726 +0200\n@@ -627,11 +627,11 @@\n         {\n             buff.append(\"--\").append(option.getLongOpt());\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+if (option.hasArg() && (option.getArgName()!= null)) {\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n \n         // if the Option is not a required option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (option.hasArg() || (option.getArgName()!= null))",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-11/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 09:30:44.549398904 +0200\n+++ /tmp/tmp79kw_7z6.java\t2022-07-19 09:30:44.553398876 +0200\n@@ -627,11 +627,11 @@\n         {\n             buff.append(\"--\").append(option.getLongOpt());\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+if (option.hasArg() || (option.getArgName()!= null))\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n \n         // if the Option is not a required option\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (option.hasArg()!= null && (option.getArgName()!= null))",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-11/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 09:30:46.773383655 +0200\n+++ /tmp/tmpxj7a131r.java\t2022-07-19 09:30:46.773383655 +0200\n@@ -627,11 +627,11 @@\n         {\n             buff.append(\"--\").append(option.getLongOpt());\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+if (option.hasArg()!= null && (option.getArgName()!= null))\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n \n         // if the Option is not a required option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (option.hasArg() || (option.getArgName()!= null)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-11/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 09:30:48.405372469 +0200\n+++ /tmp/tmpqg0zfpf1.java\t2022-07-19 09:30:48.405372469 +0200\n@@ -627,11 +627,11 @@\n         {\n             buff.append(\"--\").append(option.getLongOpt());\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+if (option.hasArg() || (option.getArgName()!= null)) {\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n \n         // if the Option is not a required option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (option.hasArg() &&(option.getArgName()!= null))",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-11/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 09:30:49.881362355 +0200\n+++ /tmp/tmp_2shx1rb.java\t2022-07-19 09:30:49.881362355 +0200\n@@ -627,11 +627,11 @@\n         {\n             buff.append(\"--\").append(option.getLongOpt());\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+if (option.hasArg() &&(option.getArgName()!= null))\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n \n         // if the Option is not a required option\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (option.hasArgName() && (option.getArgName()!= null))",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-11/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 09:30:52.481344549 +0200\n+++ /tmp/tmpvzcvds1s.java\t2022-07-19 09:30:52.481344549 +0200\n@@ -627,11 +627,11 @@\n         {\n             buff.append(\"--\").append(option.getLongOpt());\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+if (option.hasArgName() && (option.getArgName()!= null))\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n \n         // if the Option is not a required option\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (option.hasArg() && (option.getArgName()!= null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-11/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 09:30:54.989327380 +0200\n+++ /tmp/tmplximr2uj.java\t2022-07-19 09:30:54.989327380 +0200\n@@ -627,11 +627,11 @@\n         {\n             buff.append(\"--\").append(option.getLongOpt());\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+if (option.hasArg() && (option.getArgName()!= null)\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n \n         // if the Option is not a required option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (option.hasArg() && (option.getArgName() == null))",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-11/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 09:30:56.457317336 +0200\n+++ /tmp/tmpt4sqa1tz.java\t2022-07-19 09:30:56.461317310 +0200\n@@ -627,11 +627,11 @@\n         {\n             buff.append(\"--\").append(option.getLongOpt());\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+if (option.hasArg() && (option.getArgName() == null))\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n \n         // if the Option is not a required option\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 10,
                "patch": "if(option.hasArg() && (option.getArgName()!= null))",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-11/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 09:30:58.925300455 +0200\n+++ /tmp/tmp20855uk_.java\t2022-07-19 09:30:58.925300455 +0200\n@@ -627,11 +627,11 @@\n         {\n             buff.append(\"--\").append(option.getLongOpt());\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+if(option.hasArg() && (option.getArgName()!= null))\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n \n         // if the Option is not a required option\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (option.hasArg() && (option.getArgName() != null))",
        "fixed_line": "if (option.hasArg() && option.hasArgName())"
    },
    "Compress-1": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (this.closed!= null) {",
                "patch_diff": "if (this.closed!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (this.closed) {",
                "patch_diff": "if (this.closed) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (this.closed = false; } else if (this.closed!= null) {",
                "patch_diff": "if (this.closed = false; } else if (this.closed!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (this.closed!= null) { super.close(); this.closed = false; } }",
                "patch_diff": "if (this.closed!= null) { super.close(); this.closed = false; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (this.closed!= null) { super.close(); this.closed = true; } }",
                "patch_diff": "if (this.closed!= null) { super.close(); this.closed = true; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (this.closed = false; } else if (this.closed = true;",
                "patch_diff": "if (this.closed = false; } else if (this.closed = true;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (this.closed = false; } else {",
                "patch_diff": "if (this.closed = false; } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (this.closed.close(); this.closed = true; } else if (this.closed!= null) {",
                "patch_diff": "if (this.closed.close(); this.closed = true; } else if (this.closed!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (this.closed = false; } else if (this.closed) {",
                "patch_diff": "if (this.closed = false; } else if (this.closed) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (this.closed = true; } else if (this.closed!= null) {",
                "patch_diff": "if (this.closed = true; } else if (this.closed!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "this.finish();"
    },
    "Cli-8": {
        "fixes": [
            {
                "k": 1,
                "patch": "pos =findWrapPos(text, width, nextLineTabStop);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-8/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 09:31:03.625268332 +0200\n+++ /tmp/tmpbxdlndre.java\t2022-07-19 09:31:03.657268112 +0200\n@@ -807,11 +807,11 @@\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+pos =findWrapPos(text, width, nextLineTabStop);\n \n             if (pos == -1)\n             {\n                 sb.append(text);\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "pos = findWrapPos(text, width, nextLineTabStop);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-8/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 09:31:07.009245221 +0200\n+++ /tmp/tmplmzq5r5n.java\t2022-07-19 09:31:07.009245221 +0200\n@@ -807,11 +807,11 @@\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+pos = findWrapPos(text, width, nextLineTabStop);\n \n             if (pos == -1)\n             {\n                 sb.append(text);\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "pos =findWrapPos(text, width, nextLineTabStop, nextLineTabStop);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-8/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 09:31:09.545227912 +0200\n+++ /tmp/tmppfau12r3.java\t2022-07-19 09:31:09.545227912 +0200\n@@ -807,11 +807,11 @@\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+pos =findWrapPos(text, width, nextLineTabStop, nextLineTabStop);\n \n             if (pos == -1)\n             {\n                 sb.append(text);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "pos = =findWrapPos(text, width, nextLineTabStop);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-8/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 09:31:11.289216016 +0200\n+++ /tmp/tmp8_v0_xke.java\t2022-07-19 09:31:11.289216016 +0200\n@@ -807,11 +807,11 @@\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+pos = =findWrapPos(text, width, nextLineTabStop);\n \n             if (pos == -1)\n             {\n                 sb.append(text);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "pos =IgnoredWrapPos(text, width, nextLineTabStop);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-8/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 09:31:12.993204395 +0200\n+++ /tmp/tmpldfqkmfb.java\t2022-07-19 09:31:12.993204395 +0200\n@@ -807,11 +807,11 @@\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+pos =IgnoredWrapPos(text, width, nextLineTabStop);\n \n             if (pos == -1)\n             {\n                 sb.append(text);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "pos = ~WrapPos(text, width, nextLineTabStop);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-8/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 09:31:14.761192342 +0200\n+++ /tmp/tmpgxrm648q.java\t2022-07-19 09:31:14.765192313 +0200\n@@ -807,11 +807,11 @@\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+pos = ~WrapPos(text, width, nextLineTabStop);\n \n             if (pos == -1)\n             {\n                 sb.append(text);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "pos =findWrapPos(text, width, nextLineTabStop); // nextLineTabStop =",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-8/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 09:31:16.341181573 +0200\n+++ /tmp/tmpdikzjf0x.java\t2022-07-19 09:31:16.341181573 +0200\n@@ -807,11 +807,11 @@\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+pos =findWrapPos(text, width, nextLineTabStop); // nextLineTabStop =\n \n             if (pos == -1)\n             {\n                 sb.append(text);\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "pos =findWrapPos(text, width, nextLineTabStop + nextLineTabStop);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-8/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 09:31:18.985163563 +0200\n+++ /tmp/tmp882_03cv.java\t2022-07-19 09:31:18.985163563 +0200\n@@ -807,11 +807,11 @@\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+pos =findWrapPos(text, width, nextLineTabStop + nextLineTabStop);\n \n             if (pos == -1)\n             {\n                 sb.append(text);\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "pos = if (text, width, nextLineTabStop);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-8/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 09:31:21.553146077 +0200\n+++ /tmp/tmp9ria9d51.java\t2022-07-19 09:31:21.553146077 +0200\n@@ -807,11 +807,11 @@\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+pos = if (text, width, nextLineTabStop);\n \n             if (pos == -1)\n             {\n                 sb.append(text);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "pos =findWrapPos(text, width, nextLineTabStop = nextLineTabStop);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-8/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-19 09:31:23.093135596 +0200\n+++ /tmp/tmpe3vmi51z.java\t2022-07-19 09:31:23.093135596 +0200\n@@ -807,11 +807,11 @@\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+pos =findWrapPos(text, width, nextLineTabStop = nextLineTabStop);\n \n             if (pos == -1)\n             {\n                 sb.append(text);\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "pos = findWrapPos(text, width, nextLineTabStop);",
        "fixed_line": "pos = findWrapPos(text, width, 0);"
    },
    "Codec-7": {
        "fixes": [
            {
                "k": 1,
                "patch": "return StringUtils.newStringUtf8(getBase64(binaryData, true));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-7/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 09:31:25.629118342 +0200\n+++ /tmp/tmphoqm31a3.java\t2022-07-19 09:31:25.689117935 +0200\n@@ -665,11 +665,11 @@\n      *            binary data to encode\n      * @return String containing Base64 characters.\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+return StringUtils.newStringUtf8(getBase64(binaryData, true));\n     }\n     \n     /**\n      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n      * url-safe variation emits - and _ instead of + and / characters.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return StringUtils.newStringUtf8(encodeBase64(binaryData, true));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-7/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 09:31:27.461105883 +0200\n+++ /tmp/tmp22wm233n.java\t2022-07-19 09:31:27.465105857 +0200\n@@ -665,11 +665,11 @@\n      *            binary data to encode\n      * @return String containing Base64 characters.\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n     }\n     \n     /**\n      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n      * url-safe variation emits - and _ instead of + and / characters.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return StringUtils.newStringUtf8(getBase64(binaryData, false));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-7/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 09:31:30.909082447 +0200\n+++ /tmp/tmpv3a38k88.java\t2022-07-19 09:31:30.909082447 +0200\n@@ -665,11 +665,11 @@\n      *            binary data to encode\n      * @return String containing Base64 characters.\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+return StringUtils.newStringUtf8(getBase64(binaryData, false));\n     }\n     \n     /**\n      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n      * url-safe variation emits - and _ instead of + and / characters.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return StringUtils.newStringUtf8(encodeBase64(binaryData, false));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-7/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 09:31:32.633070737 +0200\n+++ /tmp/tmpb0e7dbi0.java\t2022-07-19 09:31:32.637070708 +0200\n@@ -665,11 +665,11 @@\n      *            binary data to encode\n      * @return String containing Base64 characters.\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+return StringUtils.newStringUtf8(encodeBase64(binaryData, false));\n     }\n     \n     /**\n      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n      * url-safe variation emits - and _ instead of + and / characters.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 5,
                "patch": "return StringUtils.newStringUtf8(base64(binaryData, true));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-7/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 09:31:35.465051506 +0200\n+++ /tmp/tmpit2crieo.java\t2022-07-19 09:31:35.465051506 +0200\n@@ -665,11 +665,11 @@\n      *            binary data to encode\n      * @return String containing Base64 characters.\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+return StringUtils.newStringUtf8(base64(binaryData, true));\n     }\n     \n     /**\n      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n      * url-safe variation emits - and _ instead of + and / characters.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return StringUtils.newStringUtf8(trueBase64(binaryData, true));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-7/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 09:31:37.305039016 +0200\n+++ /tmp/tmpf113edut.java\t2022-07-19 09:31:37.309038990 +0200\n@@ -665,11 +665,11 @@\n      *            binary data to encode\n      * @return String containing Base64 characters.\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+return StringUtils.newStringUtf8(trueBase64(binaryData, true));\n     }\n     \n     /**\n      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n      * url-safe variation emits - and _ instead of + and / characters.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return StringUtils.newStringUtf8(getBase64(0, true));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-7/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 09:31:39.117026720 +0200\n+++ /tmp/tmpq5liql5i.java\t2022-07-19 09:31:39.117026720 +0200\n@@ -665,11 +665,11 @@\n      *            binary data to encode\n      * @return String containing Base64 characters.\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+return StringUtils.newStringUtf8(getBase64(0, true));\n     }\n     \n     /**\n      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n      * url-safe variation emits - and _ instead of + and / characters.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return StringUtils.newStringUtf8(binaryData, true));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-7/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 09:31:40.829015108 +0200\n+++ /tmp/tmpjp58u7uq.java\t2022-07-19 09:31:40.829015108 +0200\n@@ -665,11 +665,11 @@\n      *            binary data to encode\n      * @return String containing Base64 characters.\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+return StringUtils.newStringUtf8(binaryData, true));\n     }\n     \n     /**\n      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n      * url-safe variation emits - and _ instead of + and / characters.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return StringUtils.newStringUtf8(name, false));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-7/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 09:31:42.601003093 +0200\n+++ /tmp/tmpgtt7r093.java\t2022-07-19 09:31:42.601003093 +0200\n@@ -665,11 +665,11 @@\n      *            binary data to encode\n      * @return String containing Base64 characters.\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+return StringUtils.newStringUtf8(name, false));\n     }\n     \n     /**\n      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n      * url-safe variation emits - and _ instead of + and / characters.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return StringUtils.newStringUtf8(name, true));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-7/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 09:31:44.180992384 +0200\n+++ /tmp/tmp6576i20x.java\t2022-07-19 09:31:44.180992384 +0200\n@@ -665,11 +665,11 @@\n      *            binary data to encode\n      * @return String containing Base64 characters.\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+return StringUtils.newStringUtf8(name, true));\n     }\n     \n     /**\n      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n      * url-safe variation emits - and _ instead of + and / characters.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return StringUtils.newStringUtf8(encodeBase64(binaryData, true));",
        "fixed_line": "return StringUtils.newStringUtf8(encodeBase64(binaryData, false));"
    },
    "Chart-17": {
        "fixes": [
            {
                "k": 1,
                "patch": "Object clone = createCopy(0, getItemCount() - 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-17/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 09:31:45.972980242 +0200\n+++ /tmp/tmpd20wy1o1.java\t2022-07-19 09:31:46.092979420 +0200\n@@ -852,11 +852,11 @@\n      * \n      * @throws CloneNotSupportedException not thrown by this class, but \n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        Object clone = createCopy(0, getItemCount() - 1);\n+Object clone = createCopy(0, getItemCount() - 1);\n         return clone;\n     }\n \n     /**\n      * Creates a new timeseries by copying a subset of the data in this time\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "Object clone = createCopy(0, getItemCount()-1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-17/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 09:31:55.044918828 +0200\n+++ /tmp/tmp5v0loeii.java\t2022-07-19 09:31:55.044918828 +0200\n@@ -852,11 +852,11 @@\n      * \n      * @throws CloneNotSupportedException not thrown by this class, but \n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        Object clone = createCopy(0, getItemCount() - 1);\n+Object clone = createCopy(0, getItemCount()-1);\n         return clone;\n     }\n \n     /**\n      * Creates a new timeseries by copying a subset of the data in this time\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "Object clone = createCopy(0, getItemCount() * 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-17/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 09:32:03.148864056 +0200\n+++ /tmp/tmpu1edk968.java\t2022-07-19 09:32:03.148864056 +0200\n@@ -852,11 +852,11 @@\n      * \n      * @throws CloneNotSupportedException not thrown by this class, but \n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        Object clone = createCopy(0, getItemCount() - 1);\n+Object clone = createCopy(0, getItemCount() * 1);\n         return clone;\n     }\n \n     /**\n      * Creates a new timeseries by copying a subset of the data in this time\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "Object clone = createCopy(0, getItemCount() -1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-17/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 09:32:11.080810524 +0200\n+++ /tmp/tmp0_eoah90.java\t2022-07-19 09:32:11.080810524 +0200\n@@ -852,11 +852,11 @@\n      * \n      * @throws CloneNotSupportedException not thrown by this class, but \n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        Object clone = createCopy(0, getItemCount() - 1);\n+Object clone = createCopy(0, getItemCount() -1);\n         return clone;\n     }\n \n     /**\n      * Creates a new timeseries by copying a subset of the data in this time\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "Object clone = createCopy(0, getItemCount() / 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-17/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 09:32:18.836758253 +0200\n+++ /tmp/tmpgnulq8wp.java\t2022-07-19 09:32:18.836758253 +0200\n@@ -852,11 +852,11 @@\n      * \n      * @throws CloneNotSupportedException not thrown by this class, but \n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        Object clone = createCopy(0, getItemCount() - 1);\n+Object clone = createCopy(0, getItemCount() / 1);\n         return clone;\n     }\n \n     /**\n      * Creates a new timeseries by copying a subset of the data in this time\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "Object clone = createCopy(0, getItemCount()[0];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-17/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 09:32:26.660705597 +0200\n+++ /tmp/tmp6omf5frn.java\t2022-07-19 09:32:26.660705597 +0200\n@@ -852,11 +852,11 @@\n      * \n      * @throws CloneNotSupportedException not thrown by this class, but \n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        Object clone = createCopy(0, getItemCount() - 1);\n+Object clone = createCopy(0, getItemCount()[0];\n         return clone;\n     }\n \n     /**\n      * Creates a new timeseries by copying a subset of the data in this time\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "Object clone = createCopy(0, getItemCount() {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-17/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 09:32:28.256694865 +0200\n+++ /tmp/tmpjk55lqab.java\t2022-07-19 09:32:28.256694865 +0200\n@@ -852,11 +852,11 @@\n      * \n      * @throws CloneNotSupportedException not thrown by this class, but \n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        Object clone = createCopy(0, getItemCount() - 1);\n+Object clone = createCopy(0, getItemCount() {\n         return clone;\n     }\n \n     /**\n      * Creates a new timeseries by copying a subset of the data in this time\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "Object clone = createCopy(0, getItemCount() == 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-17/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 09:32:29.908683759 +0200\n+++ /tmp/tmpwp_v2c7r.java\t2022-07-19 09:32:29.908683759 +0200\n@@ -852,11 +852,11 @@\n      * \n      * @throws CloneNotSupportedException not thrown by this class, but \n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        Object clone = createCopy(0, getItemCount() - 1);\n+Object clone = createCopy(0, getItemCount() == 1);\n         return clone;\n     }\n \n     /**\n      * Creates a new timeseries by copying a subset of the data in this time\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "Object clone = createCopy(0, getItemCount());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-17/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 09:32:31.692671769 +0200\n+++ /tmp/tmpas8bgqk3.java\t2022-07-19 09:32:31.696671743 +0200\n@@ -852,11 +852,11 @@\n      * \n      * @throws CloneNotSupportedException not thrown by this class, but \n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        Object clone = createCopy(0, getItemCount() - 1);\n+Object clone = createCopy(0, getItemCount());\n         return clone;\n     }\n \n     /**\n      * Creates a new timeseries by copying a subset of the data in this time\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "Object clone = createCopy(0, getItemCount() * 2);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-17/source/org/jfree/data/time/TimeSeries.java\t2022-07-19 09:32:39.640618401 +0200\n+++ /tmp/tmps3d38ufx.java\t2022-07-19 09:32:39.640618401 +0200\n@@ -852,11 +852,11 @@\n      * \n      * @throws CloneNotSupportedException not thrown by this class, but \n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        Object clone = createCopy(0, getItemCount() - 1);\n+Object clone = createCopy(0, getItemCount() * 2);\n         return clone;\n     }\n \n     /**\n      * Creates a new timeseries by copying a subset of the data in this time\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "Object clone = createCopy(0, getItemCount() - 1);",
        "fixed_line": "TimeSeries clone = (TimeSeries) super.clone(); clone.data = (List) ObjectUtilities.deepClone(this.data);"
    },
    "Math-34": {
        "fixes": [
            {
                "k": 1,
                "patch": "return chromosomes.iterator();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-34/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\t2022-07-19 09:32:47.664564593 +0200\n+++ /tmp/tmpb7g3ysvl.java\t2022-07-19 09:32:47.688564433 +0200\n@@ -204,8 +204,8 @@\n      * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+return chromosomes.iterator();\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return chromosomes.iterator(); // TODO: return chromosomes.iterator();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-34/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\t2022-07-19 09:33:18.088361229 +0200\n+++ /tmp/tmp52u_oco2.java\t2022-07-19 09:33:18.104361121 +0200\n@@ -204,8 +204,8 @@\n      * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+return chromosomes.iterator(); // TODO: return chromosomes.iterator();\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return chromosomes.iterator(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-34/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\t2022-07-19 09:33:44.284186916 +0200\n+++ /tmp/tmpnkk1dqv6.java\t2022-07-19 09:33:44.284186916 +0200\n@@ -204,8 +204,8 @@\n      * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+return chromosomes.iterator(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return chromosomes.iterator(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-34/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\t2022-07-19 09:34:11.020009727 +0200\n+++ /tmp/tmp2s9k4yzb.java\t2022-07-19 09:34:11.020009727 +0200\n@@ -204,8 +204,8 @@\n      * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+return chromosomes.iterator(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return chromosomes.iterator(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-34/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\t2022-07-19 09:34:37.811832854 +0200\n+++ /tmp/tmpkw0eox7x.java\t2022-07-19 09:34:37.827832748 +0200\n@@ -204,8 +204,8 @@\n      * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+return chromosomes.iterator(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return chromosomes.iterator(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-34/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\t2022-07-19 09:35:05.375651566 +0200\n+++ /tmp/tmp4m6lgzhd.java\t2022-07-19 09:35:05.375651566 +0200\n@@ -204,8 +204,8 @@\n      * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+return chromosomes.iterator(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return chromosomes.iterator(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-34/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\t2022-07-19 09:35:36.423448146 +0200\n+++ /tmp/tmpyv4jiqy2.java\t2022-07-19 09:35:36.423448146 +0200\n@@ -204,8 +204,8 @@\n      * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+return chromosomes.iterator(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnot real number\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return chromosomes.iterator(); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-34/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\t2022-07-19 09:36:03.583270844 +0200\n+++ /tmp/tmpyc9bnnaw.java\t2022-07-19 09:36:03.583270844 +0200\n@@ -204,8 +204,8 @@\n      * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+return chromosomes.iterator(); // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return chromosomes.iterator(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-34/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\t2022-07-19 09:36:30.747094082 +0200\n+++ /tmp/tmpzeb6wudc.java\t2022-07-19 09:36:30.759094004 +0200\n@@ -204,8 +204,8 @@\n      * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+return chromosomes.iterator(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnotnot real number\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return chromosomes.iterator(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-34/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\t2022-07-19 09:36:57.494920552 +0200\n+++ /tmp/tmp365tq29c.java\t2022-07-19 09:36:57.494920552 +0200\n@@ -204,8 +204,8 @@\n      * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+return chromosomes.iterator(); // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnotnotnot real number\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return chromosomes.iterator();",
        "fixed_line": "return getChromosomes().iterator();"
    },
    "Closure-40": {
        "fixes": [
            {
                "k": 1,
                "patch": "JsName name = getName(ns.name, false); if (name!= null) { refNodes.add(new ClassDefiningFunctionNode( name, n, parent, parent.getParent())); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-40/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 09:37:24.722744422 +0200\n+++ /tmp/tmpc7n_79q5.java\t2022-07-19 09:37:24.822743777 +0200\n@@ -630,15 +630,11 @@\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n-          }\n+JsName name = getName(ns.name, false); if (name!= null) { refNodes.add(new ClassDefiningFunctionNode( name, n, parent, parent.getParent())); }\n         }\n       }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "JsName name = getName(ns.name, false); if (name!= null) { refNodes.add(new ClassDefiningFunctionNode(name, n, parent, parent.getParent())); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-40/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 09:38:04.706486650 +0200\n+++ /tmp/tmpsk3nantx.java\t2022-07-19 09:38:04.706486650 +0200\n@@ -630,15 +630,11 @@\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n-          }\n+JsName name = getName(ns.name, false); if (name!= null) { refNodes.add(new ClassDefiningFunctionNode(name, n, parent, parent.getParent())); }\n         }\n       }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "JsName name = getName(ns.name, false); if (name!= null) { refNodes.add(new ClassDefiningFunctionNode( name, n, parent, parent); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-40/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 09:38:42.666242822 +0200\n+++ /tmp/tmpw0ppdmrh.java\t2022-07-19 09:38:42.666242822 +0200\n@@ -630,15 +630,11 @@\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n-          }\n+JsName name = getName(ns.name, false); if (name!= null) { refNodes.add(new ClassDefiningFunctionNode( name, n, parent, parent); }\n         }\n       }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "JsName name = getName(ns.name, false); if (name!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-40/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 09:38:46.094220847 +0200\n+++ /tmp/tmpn8fw1tsa.java\t2022-07-19 09:38:46.098220819 +0200\n@@ -630,15 +630,11 @@\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n-          }\n+JsName name = getName(ns.name, false); if (name!= null) {\n         }\n       }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "JsName name = getName(ns.name, false); if (name!= null) { refNodes.add(new ClassDefiningFunctionNode( name, parent, parent.getParent())); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-40/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 09:38:49.578198517 +0200\n+++ /tmp/tmprddmjri4.java\t2022-07-19 09:38:49.578198517 +0200\n@@ -630,15 +630,11 @@\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n-          }\n+JsName name = getName(ns.name, false); if (name!= null) { refNodes.add(new ClassDefiningFunctionNode( name, parent, parent.getParent())); }\n         }\n       }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "JsName name = getName(ns.name, false); if (name!= null) { refNodes.add(new ClassDefiningFunctionNode(parent, n, parent, parent.getParent())); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-40/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 09:38:53.254174961 +0200\n+++ /tmp/tmpqsgeb13d.java\t2022-07-19 09:38:53.258174938 +0200\n@@ -630,15 +630,11 @@\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n-          }\n+JsName name = getName(ns.name, false); if (name!= null) { refNodes.add(new ClassDefiningFunctionNode(parent, n, parent, parent.getParent())); }\n         }\n       }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "JsName name = getName(ns.name, false); if (name!= null) { refNodes.add(new ClassDefiningFunctionNode(name, n, parent, parent); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-40/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 09:38:56.998150983 +0200\n+++ /tmp/tmp6lfz7fkz.java\t2022-07-19 09:38:57.002150956 +0200\n@@ -630,15 +630,11 @@\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n-          }\n+JsName name = getName(ns.name, false); if (name!= null) { refNodes.add(new ClassDefiningFunctionNode(name, n, parent, parent); }\n         }\n       }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "JsName name = getName(ns.name, false); if (name!= null) { refNodes.add(new ClassDefiningFunctionNode( name, n, parent, parent, parent.getParent())); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-40/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 09:39:00.630127725 +0200\n+++ /tmp/tmpeesvs87b.java\t2022-07-19 09:39:00.630127725 +0200\n@@ -630,15 +630,11 @@\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n-          }\n+JsName name = getName(ns.name, false); if (name!= null) { refNodes.add(new ClassDefiningFunctionNode( name, n, parent, parent, parent.getParent())); }\n         }\n       }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "JsName name = getName(ns.name, false); if (name!= null) { refNodes.add(new ClassDefiningFunctionNode( name, n, parent, parent.getParent()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-40/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 09:39:04.370103782 +0200\n+++ /tmp/tmp5aeaha1s.java\t2022-07-19 09:39:04.374103759 +0200\n@@ -630,15 +630,11 @@\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n-          }\n+JsName name = getName(ns.name, false); if (name!= null) { refNodes.add(new ClassDefiningFunctionNode( name, n, parent, parent.getParent()));\n         }\n       }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "JsName name = getName(ns.name, false); if (name!= null) { refNodes.add(new ClassDefiningFunctionNode( name, n, parent.getParent())); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-40/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-19 09:39:08.014080463 +0200\n+++ /tmp/tmp8cz5vvud.java\t2022-07-19 09:39:08.014080463 +0200\n@@ -630,15 +630,11 @@\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n-          }\n+JsName name = getName(ns.name, false); if (name!= null) { refNodes.add(new ClassDefiningFunctionNode( name, n, parent.getParent())); }\n         }\n       }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "JsName name = getName(ns.name, false); if (name != null) { refNodes.add(new ClassDefiningFunctionNode( name, n, parent, parent.getParent())); }",
        "fixed_line": "JsName name = getName(ns.name, true);"
    },
    "Jsoup-20": {
        "fixes": [
            {
                "k": 1,
                "patch": "// as per [JACKSON-order-407] -- allow use a spurious byte-order",
                "patch_diff": "// as per [JACKSON-order-407] -- allow use a spurious byte-order",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// there are times where there is a spurious byte-order",
                "patch_diff": "// there are times where there is a spurious byte-order",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// as per [JACKSON-order-order-407] -- allow use a spurious byte-order",
                "patch_diff": "// as per [JACKSON-order-order-407] -- allow use a spurious byte-order",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// as per [JACKSON-order-407] -- allow use a spurious byte-order;",
                "patch_diff": "// as per [JACKSON-order-407] -- allow use a spurious byte-order;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// } else if (doc == null) {",
                "patch_diff": "// } else if (doc == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// as per [JACKSON-order-order-407] -- allow use a spurious byte-order;",
                "patch_diff": "// as per [JACKSON-order-order-407] -- allow use a spurious byte-order;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// as per [JACKSON-order-order-mark at the start is a spurious byte-order",
                "patch_diff": "// as per [JACKSON-order-order-mark at the start is a spurious byte-order",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// } else if (doc!= null) {",
                "patch_diff": "// } else if (doc!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// as per [JACKSON-order-order-mark at the",
                "patch_diff": "// as per [JACKSON-order-order-mark at the",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// there are times where there is a spurious byte-order;",
                "patch_diff": "// there are times where there is a spurious byte-order;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (docData.charAt(0) == 65279) docData = docData.substring(1);"
    },
    "Closure-111": {
        "fixes": [
            {
                "k": 1,
                "patch": "return topType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-111/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\t2022-07-19 09:39:13.766043669 +0200\n+++ /tmp/tmpwa0rbmo1.java\t2022-07-19 09:39:13.842043182 +0200\n@@ -49,11 +49,11 @@\n    */\n   private final Visitor<JSType> restrictToArrayVisitor =\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType;\n+return topType;\n         }\n \n         @Override\n         public JSType caseObjectType(ObjectType type) {\n           JSType arrayType = getNativeType(ARRAY_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return topType; // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-111/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\t2022-07-19 09:40:06.993703992 +0200\n+++ /tmp/tmp50ps8izr.java\t2022-07-19 09:40:06.993703992 +0200\n@@ -49,11 +49,11 @@\n    */\n   private final Visitor<JSType> restrictToArrayVisitor =\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType;\n+return topType; // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n         }\n \n         @Override\n         public JSType caseObjectType(ObjectType type) {\n           JSType arrayType = getNativeType(ARRAY_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return topType; // we didn't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-111/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\t2022-07-19 09:40:57.689381737 +0200\n+++ /tmp/tmpb5lys8h9.java\t2022-07-19 09:40:57.689381737 +0200\n@@ -49,11 +49,11 @@\n    */\n   private final Visitor<JSType> restrictToArrayVisitor =\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType;\n+return topType; // we didn't really modify it's totalGJACKSON-notnotnotnot real number\n         }\n \n         @Override\n         public JSType caseObjectType(ObjectType type) {\n           JSType arrayType = getNativeType(ARRAY_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return topType; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-111/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\t2022-07-19 09:41:47.889063730 +0200\n+++ /tmp/tmpt1fswakp.java\t2022-07-19 09:41:47.889063730 +0200\n@@ -49,11 +49,11 @@\n    */\n   private final Visitor<JSType> restrictToArrayVisitor =\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType;\n+return topType; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n         }\n \n         @Override\n         public JSType caseObjectType(ObjectType type) {\n           JSType arrayType = getNativeType(ARRAY_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return topType; // we didn't really modify it's totalGJACKSON-notnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-111/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\t2022-07-19 09:42:38.044746992 +0200\n+++ /tmp/tmp8jxkyr2u.java\t2022-07-19 09:42:38.044746992 +0200\n@@ -49,11 +49,11 @@\n    */\n   private final Visitor<JSType> restrictToArrayVisitor =\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType;\n+return topType; // we didn't really modify it's totalGJACKSON-notnotnot real number\n         }\n \n         @Override\n         public JSType caseObjectType(ObjectType type) {\n           JSType arrayType = getNativeType(ARRAY_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return topType; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-111/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\t2022-07-19 09:43:28.452429566 +0200\n+++ /tmp/tmpe7dfo4rn.java\t2022-07-19 09:43:28.452429566 +0200\n@@ -49,11 +49,11 @@\n    */\n   private final Visitor<JSType> restrictToArrayVisitor =\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType;\n+return topType; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n         }\n \n         @Override\n         public JSType caseObjectType(ObjectType type) {\n           JSType arrayType = getNativeType(ARRAY_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return topType; // we didn't really modify it's totalGJACKSON-notnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-111/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\t2022-07-19 09:44:18.828113160 +0200\n+++ /tmp/tmpk2_ygncf.java\t2022-07-19 09:44:18.828113160 +0200\n@@ -49,11 +49,11 @@\n    */\n   private final Visitor<JSType> restrictToArrayVisitor =\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType;\n+return topType; // we didn't really modify it's totalGJACKSON-notnot real number\n         }\n \n         @Override\n         public JSType caseObjectType(ObjectType type) {\n           JSType arrayType = getNativeType(ARRAY_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return topType; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-111/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\t2022-07-19 09:45:08.607801227 +0200\n+++ /tmp/tmpwsdfi4op.java\t2022-07-19 09:45:08.607801227 +0200\n@@ -49,11 +49,11 @@\n    */\n   private final Visitor<JSType> restrictToArrayVisitor =\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType;\n+return topType; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number\n         }\n \n         @Override\n         public JSType caseObjectType(ObjectType type) {\n           JSType arrayType = getNativeType(ARRAY_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return topType; // we didn't really modify it's totalGJACKSON-literal characters that might be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-111/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\t2022-07-19 09:45:58.659488253 +0200\n+++ /tmp/tmptledv56c.java\t2022-07-19 09:45:58.659488253 +0200\n@@ -49,11 +49,11 @@\n    */\n   private final Visitor<JSType> restrictToArrayVisitor =\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType;\n+return topType; // we didn't really modify it's totalGJACKSON-literal characters that might be null!\n         }\n \n         @Override\n         public JSType caseObjectType(ObjectType type) {\n           JSType arrayType = getNativeType(ARRAY_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return topType; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-111/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\t2022-07-19 09:46:48.383177929 +0200\n+++ /tmp/tmp4_l0igkr.java\t2022-07-19 09:46:48.387177902 +0200\n@@ -49,11 +49,11 @@\n    */\n   private final Visitor<JSType> restrictToArrayVisitor =\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType;\n+return topType; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number\n         }\n \n         @Override\n         public JSType caseObjectType(ObjectType type) {\n           JSType arrayType = getNativeType(ARRAY_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return topType;",
        "fixed_line": "return topType.isAllType() ? getNativeType(ARRAY_TYPE) : topType;"
    },
    "Time-20": {
        "fixes": [
            {
                "k": 1,
                "patch": "bucket.setZone(DateTimeZone.forID(id)); return position + id.length();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-20/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\t2022-07-19 09:47:38.462865924 +0200\n+++ /tmp/tmpoye676ld.java\t2022-07-19 09:47:38.494865727 +0200\n@@ -2539,12 +2539,11 @@\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n+bucket.setZone(DateTimeZone.forID(id)); return position + id.length();\n                 }\n             }\n             return ~position;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "bucket.setZone(DateTimeZone.forID(id); return position + id.length();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-20/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\t2022-07-19 09:47:53.302773569 +0200\n+++ /tmp/tmpk85upxso.java\t2022-07-19 09:47:53.302773569 +0200\n@@ -2539,12 +2539,11 @@\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n+bucket.setZone(DateTimeZone.forID(id); return position + id.length();\n                 }\n             }\n             return ~position;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "bucket.setZone(DateTimeZone.forID(id)); return position + i.length();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-20/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\t2022-07-19 09:47:55.522759755 +0200\n+++ /tmp/tmprhk4t8re.java\t2022-07-19 09:47:55.526759731 +0200\n@@ -2539,12 +2539,11 @@\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n+bucket.setZone(DateTimeZone.forID(id)); return position + i.length();\n                 }\n             }\n             return ~position;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "bucket.setZone(DateTimeZone.forID(id)); return position + i();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-20/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\t2022-07-19 09:47:58.234742884 +0200\n+++ /tmp/tmp459hzlf4.java\t2022-07-19 09:47:58.234742884 +0200\n@@ -2539,12 +2539,11 @@\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n+bucket.setZone(DateTimeZone.forID(id)); return position + i();\n                 }\n             }\n             return ~position;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "bucket.setZone(DateTimeZone.forID(id)); return position + length;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-20/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\t2022-07-19 09:48:00.906726261 +0200\n+++ /tmp/tmpttu92stt.java\t2022-07-19 09:48:00.958725939 +0200\n@@ -2539,12 +2539,11 @@\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n+bucket.setZone(DateTimeZone.forID(id)); return position + length;\n                 }\n             }\n             return ~position;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "bucket.setZone(DateTimeZone.forID(id). return position + id.length();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-20/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\t2022-07-19 09:48:04.506703869 +0200\n+++ /tmp/tmp0z78qc0e.java\t2022-07-19 09:48:04.506703869 +0200\n@@ -2539,12 +2539,11 @@\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n+bucket.setZone(DateTimeZone.forID(id). return position + id.length();\n                 }\n             }\n             return ~position;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "bucket.setZone(DateTimeZone.forID(id)); return position + i);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-20/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\t2022-07-19 09:48:07.450685553 +0200\n+++ /tmp/tmph76cpzk6.java\t2022-07-19 09:48:07.450685553 +0200\n@@ -2539,12 +2539,11 @@\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n+bucket.setZone(DateTimeZone.forID(id)); return position + i);\n                 }\n             }\n             return ~position;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "bucket.setZone(DateTimeZone.forID(id)); return position + length();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-20/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\t2022-07-19 09:48:10.730665161 +0200\n+++ /tmp/tmp7olndz16.java\t2022-07-19 09:48:10.730665161 +0200\n@@ -2539,12 +2539,11 @@\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n+bucket.setZone(DateTimeZone.forID(id)); return position + length();\n                 }\n             }\n             return ~position;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "bucket.setZone(DateTimeZone.forID(id), position + id.length();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-20/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\t2022-07-19 09:48:12.770652473 +0200\n+++ /tmp/tmpszyrv0xj.java\t2022-07-19 09:48:12.774652448 +0200\n@@ -2539,12 +2539,11 @@\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n+bucket.setZone(DateTimeZone.forID(id), position + id.length();\n                 }\n             }\n             return ~position;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "bucket.setZone(DateTimeZone.forID(id)); return position + index;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-20/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\t2022-07-19 09:48:15.310636679 +0200\n+++ /tmp/tmpm87zg083.java\t2022-07-19 09:48:15.314636655 +0200\n@@ -2539,12 +2539,11 @@\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n+bucket.setZone(DateTimeZone.forID(id)); return position + index;\n                 }\n             }\n             return ~position;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "bucket.setZone(DateTimeZone.forID(id)); return position + id.length();",
        "fixed_line": "String best = null; for (String id : ALL_IDS) { if (str.startsWith(id)) { if (best == null || id.length() > best.length()) { best = id; } } } if (best != null) { bucket.setZone(DateTimeZone.forID(best)); return position + best.length(); }"
    },
    "JacksonDatabind-51": {
        "fixes": [
            {
                "k": 1,
                "patch": "// now (tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "// now (tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "_deserializers.findContextualValueDeserializer(type, _valueType, deser);",
                "patch_diff": "_deserializers.findContextualValueDeserializer(type, _valueType, deser);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// now (tatu: As per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < _deserializers.getRawClass().constructSpec()) {",
                "patch_diff": "// now (tatu: As per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < _deserializers.getRawClass().constructSpec()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "_deserializers.getRawClass().constructSpecializedType(_baseType, type);",
                "patch_diff": "_deserializers.getRawClass().constructSpecializedType(_baseType, type);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// now (tatu: As per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < _deserializers.getRawClass().constructSpecializedType",
                "patch_diff": "// now (tatu: As per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < _deserializers.getRawClass().constructSpecializedType",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// now (tatu: As per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < v.getRawClass().constructSpec()) {",
                "patch_diff": "// now (tatu: As per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < v.getRawClass().constructSpec()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// now (tatu: As per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < _valueType.getRawClass().constructSpec()) {",
                "patch_diff": "// now (tatu: As per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < _valueType.getRawClass().constructSpec()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// now (tatu: As per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < _deserializers.getRawClass().constructSpecializedType(_baseType, type);",
                "patch_diff": "// now (tatu: As per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < _deserializers.getRawClass().constructSpecializedType(_baseType, type);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// now (tatu: As per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < _deserializers.getRawClass());",
                "patch_diff": "// now (tatu: As per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < _deserializers.getRawClass());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// now (tatu: As per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < _deserializers.getRawClass().constructSpecializedType(type)) {",
                "patch_diff": "// now (tatu: As per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < _deserializers.getRawClass().constructSpecializedType(type)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (!type.hasGenericTypes()) { type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass()); }"
    },
    "Mockito-13": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock()) == invocation.getMock()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-13/src/org/mockito/internal/MockHandler.java\t2022-07-19 09:48:21.346599150 +0200\n+++ /tmp/tmphth7j9fw.java\t2022-07-19 09:48:21.986595170 +0200\n@@ -72,11 +72,11 @@\n \n         //if verificationMode is not null then someone is doing verify()        \n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock()) == invocation.getMock()) {\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n                 // this means there is an invocation on a different mock. Re-adding verification mode \n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-13/src/org/mockito/internal/MockHandler.java\t2022-07-19 09:48:24.930576870 +0200\n+++ /tmp/tmpffi3pxg5.java\t2022-07-19 09:48:24.930576870 +0200\n@@ -72,11 +72,11 @@\n \n         //if verificationMode is not null then someone is doing verify()        \n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock()) {\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n                 // this means there is an invocation on a different mock. Re-adding verification mode \n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-13/src/org/mockito/internal/MockHandler.java\t2022-07-19 09:48:28.242556284 +0200\n+++ /tmp/tmpg25ebnwe.java\t2022-07-19 09:48:28.246556259 +0200\n@@ -72,11 +72,11 @@\n \n         //if verificationMode is not null then someone is doing verify()        \n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n                 // this means there is an invocation on a different mock. Re-adding verification mode \n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock())!= invocation.getMock()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-13/src/org/mockito/internal/MockHandler.java\t2022-07-19 09:48:47.838434517 +0200\n+++ /tmp/tmpgmesbfbf.java\t2022-07-19 09:48:47.858434394 +0200\n@@ -72,11 +72,11 @@\n \n         //if verificationMode is not null then someone is doing verify()        \n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock())!= invocation.getMock()) {\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n                 // this means there is an invocation on a different mock. Re-adding verification mode \n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode).getMock() == invocation.getMock()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-13/src/org/mockito/internal/MockHandler.java\t2022-07-19 09:48:50.430418417 +0200\n+++ /tmp/tmp__0olb8y.java\t2022-07-19 09:48:50.434418392 +0200\n@@ -72,11 +72,11 @@\n \n         //if verificationMode is not null then someone is doing verify()        \n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode).getMock() == invocation.getMock()) {\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n                 // this means there is an invocation on a different mock. Re-adding verification mode \n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (verificationMode instanceof MockAwareVerificationMode || ((MockAwareVerificationMode) verificationMode).getMock()) == invocation.getMock()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-13/src/org/mockito/internal/MockHandler.java\t2022-07-19 09:48:53.266400800 +0200\n+++ /tmp/tmprqu0zz1k.java\t2022-07-19 09:48:53.318400477 +0200\n@@ -72,11 +72,11 @@\n \n         //if verificationMode is not null then someone is doing verify()        \n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+if (verificationMode instanceof MockAwareVerificationMode || ((MockAwareVerificationMode) verificationMode).getMock()) == invocation.getMock()) {\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n                 // this means there is an invocation on a different mock. Re-adding verification mode \n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock()) >= invocation.getMock()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-13/src/org/mockito/internal/MockHandler.java\t2022-07-19 09:48:56.554380382 +0200\n+++ /tmp/tmp28ihi31o.java\t2022-07-19 09:48:56.558380354 +0200\n@@ -72,11 +72,11 @@\n \n         //if verificationMode is not null then someone is doing verify()        \n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock()) >= invocation.getMock()) {\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n                 // this means there is an invocation on a different mock. Re-adding verification mode \n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode instanceof Integer) verificationMode).getMock()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-13/src/org/mockito/internal/MockHandler.java\t2022-07-19 09:48:59.298363337 +0200\n+++ /tmp/tmpsmvg19p5.java\t2022-07-19 09:48:59.346363042 +0200\n@@ -72,11 +72,11 @@\n \n         //if verificationMode is not null then someone is doing verify()        \n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode instanceof Integer) verificationMode).getMock()) {\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n                 // this means there is an invocation on a different mock. Re-adding verification mode \n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock()) > invocation.getMock()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-13/src/org/mockito/internal/MockHandler.java\t2022-07-19 09:49:02.374344236 +0200\n+++ /tmp/tmpfy1vqzrr.java\t2022-07-19 09:49:02.374344236 +0200\n@@ -72,11 +72,11 @@\n \n         //if verificationMode is not null then someone is doing verify()        \n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock()) > invocation.getMock()) {\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n                 // this means there is an invocation on a different mock. Re-adding verification mode \n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (verificationMode instanceof MockAwareVerificationMode || ((MockAwareVerificationMode) verificationMode).getMock()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-13/src/org/mockito/internal/MockHandler.java\t2022-07-19 09:49:05.254326354 +0200\n+++ /tmp/tmp6dl0nt7f.java\t2022-07-19 09:49:05.254326354 +0200\n@@ -72,11 +72,11 @@\n \n         //if verificationMode is not null then someone is doing verify()        \n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+if (verificationMode instanceof MockAwareVerificationMode || ((MockAwareVerificationMode) verificationMode).getMock()) {\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n                 // this means there is an invocation on a different mock. Re-adding verification mode \n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {",
        "fixed_line": "if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) { VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher); verificationMode.verify(data); return null; } else { // this means there is an invocation on a different mock. Re-adding verification mode // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138) mockingProgress.verificationStarted(verificationMode);"
    },
    "Jsoup-17": {
        "fixes": [
            {
                "k": 1,
                "patch": "private static String nullString = String.valueOf(0x0000);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-17/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 09:49:08.746304673 +0200\n+++ /tmp/tmps1mqjxub.java\t2022-07-19 09:49:09.134302262 +0200\n@@ -1446,11 +1446,11 @@\n             return true;\n             // todo: implement. Also; how do we get here?\n         }\n     };\n \n-    private static String nullString = String.valueOf(0x0000);\n+private static String nullString = String.valueOf(0x0000);\n \n     abstract boolean process(Token t, TreeBuilder tb);\n \n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "private static String nullString = String.valueOf(0x0000); //-literal characters that might be valid (empty be valid)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-17/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 09:49:16.902254040 +0200\n+++ /tmp/tmpn_eqr0qo.java\t2022-07-19 09:49:16.902254040 +0200\n@@ -1446,11 +1446,11 @@\n             return true;\n             // todo: implement. Also; how do we get here?\n         }\n     };\n \n-    private static String nullString = String.valueOf(0x0000);\n+private static String nullString = String.valueOf(0x0000); //-literal characters that might be valid (empty be valid)\n \n     abstract boolean process(Token t, TreeBuilder tb);\n \n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "private static String nullString = String.valueOf(0x0000); // object (empty be valid)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-17/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 09:49:21.474225661 +0200\n+++ /tmp/tmpi5gob1bt.java\t2022-07-19 09:49:21.474225661 +0200\n@@ -1446,11 +1446,11 @@\n             return true;\n             // todo: implement. Also; how do we get here?\n         }\n     };\n \n-    private static String nullString = String.valueOf(0x0000);\n+private static String nullString = String.valueOf(0x0000); // object (empty be valid)\n \n     abstract boolean process(Token t, TreeBuilder tb);\n \n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "private static String nullString = String.valueOf(0x0000); ///user default name0000);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-17/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 09:49:27.022191231 +0200\n+++ /tmp/tmp2phdxa5z.java\t2022-07-19 09:49:27.026191207 +0200\n@@ -1446,11 +1446,11 @@\n             return true;\n             // todo: implement. Also; how do we get here?\n         }\n     };\n \n-    private static String nullString = String.valueOf(0x0000);\n+private static String nullString = String.valueOf(0x0000); ///user default name0000);\n \n     abstract boolean process(Token t, TreeBuilder tb);\n \n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private static String nullString = String.valueOf(0x0000); //-literal characters that might be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-17/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 09:49:32.034160130 +0200\n+++ /tmp/tmpgzdr5_35.java\t2022-07-19 09:49:32.034160130 +0200\n@@ -1446,11 +1446,11 @@\n             return true;\n             // todo: implement. Also; how do we get here?\n         }\n     };\n \n-    private static String nullString = String.valueOf(0x0000);\n+private static String nullString = String.valueOf(0x0000); //-literal characters that might be null!\n \n     abstract boolean process(Token t, TreeBuilder tb);\n \n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "private static String nullString = String.valueOf(0x0000); // object (empty be0000);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-17/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 09:49:38.470120200 +0200\n+++ /tmp/tmpr8h7fb3h.java\t2022-07-19 09:49:38.470120200 +0200\n@@ -1446,11 +1446,11 @@\n             return true;\n             // todo: implement. Also; how do we get here?\n         }\n     };\n \n-    private static String nullString = String.valueOf(0x0000);\n+private static String nullString = String.valueOf(0x0000); // object (empty be0000);\n \n     abstract boolean process(Token t, TreeBuilder tb);\n \n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private static String nullString = String.valueOf(0x0000); //-literal characters that might be valid (e if it.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-17/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 09:49:42.930092531 +0200\n+++ /tmp/tmphnzp30rt.java\t2022-07-19 09:49:42.934092506 +0200\n@@ -1446,11 +1446,11 @@\n             return true;\n             // todo: implement. Also; how do we get here?\n         }\n     };\n \n-    private static String nullString = String.valueOf(0x0000);\n+private static String nullString = String.valueOf(0x0000); //-literal characters that might be valid (e if it.\n \n     abstract boolean process(Token t, TreeBuilder tb);\n \n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "private static String nullString = String.valueOf(0x0000); // TODO:",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-17/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 09:49:48.242059584 +0200\n+++ /tmp/tmp_4_vp1k2.java\t2022-07-19 09:49:49.070054447 +0200\n@@ -1446,11 +1446,11 @@\n             return true;\n             // todo: implement. Also; how do we get here?\n         }\n     };\n \n-    private static String nullString = String.valueOf(0x0000);\n+private static String nullString = String.valueOf(0x0000); // TODO:\n \n     abstract boolean process(Token t, TreeBuilder tb);\n \n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private static String nullString = String.valueOf(0x0000); //-literal characters that might be valid (empty be0000);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-17/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 09:49:53.426027433 +0200\n+++ /tmp/tmpoxbzmpsz.java\t2022-07-19 09:49:53.426027433 +0200\n@@ -1446,11 +1446,11 @@\n             return true;\n             // todo: implement. Also; how do we get here?\n         }\n     };\n \n-    private static String nullString = String.valueOf(0x0000);\n+private static String nullString = String.valueOf(0x0000); //-literal characters that might be valid (empty be0000);\n \n     abstract boolean process(Token t, TreeBuilder tb);\n \n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "private static String nullString = String.valueOf(0x0000); //-literal characters that might be null or EMPTY",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-17/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-19 09:49:58.833993898 +0200\n+++ /tmp/tmpxk62arjr.java\t2022-07-19 09:49:58.837993874 +0200\n@@ -1446,11 +1446,11 @@\n             return true;\n             // todo: implement. Also; how do we get here?\n         }\n     };\n \n-    private static String nullString = String.valueOf(0x0000);\n+private static String nullString = String.valueOf(0x0000); //-literal characters that might be null or EMPTY\n \n     abstract boolean process(Token t, TreeBuilder tb);\n \n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "private static String nullString = String.valueOf(0x0000);",
        "fixed_line": "private static String nullString = String.valueOf('\\u0000');"
    },
    "Mockito-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "catch (error.mockito.exceptions.verification.junit.junit.junit.ArgumentsAreDifferent e) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-5/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\t2022-07-19 09:50:04.433959171 +0200\n+++ /tmp/tmpnc1pt27_.java\t2022-07-19 09:50:04.677957664 +0200\n@@ -86,11 +86,11 @@\n                     error = null;\n                 }\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+catch (error.mockito.exceptions.verification.junit.junit.junit.ArgumentsAreDifferent e) {\n                 error = handleVerifyException(e);\n             }\n         }\n \n         if (error != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "catch (error.mockito.exceptions.junit.junit.junit.junit.ArgumentsAreDifferent e) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-5/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\t2022-07-19 09:50:18.773870285 +0200\n+++ /tmp/tmpf96d6vrl.java\t2022-07-19 09:50:18.797870137 +0200\n@@ -86,11 +86,11 @@\n                     error = null;\n                 }\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+catch (error.mockito.exceptions.junit.junit.junit.junit.ArgumentsAreDifferent e) {\n                 error = handleVerifyException(e);\n             }\n         }\n \n         if (error != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "catch (error.mockito.exceptions.verification.junit.junit.ArgumentsAreDifferent e) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-5/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\t2022-07-19 09:50:29.689802641 +0200\n+++ /tmp/tmp7cnz4mar.java\t2022-07-19 09:50:29.689802641 +0200\n@@ -86,11 +86,11 @@\n                     error = null;\n                 }\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+catch (error.mockito.exceptions.verification.junit.junit.ArgumentsAreDifferent e) {\n                 error = handleVerifyException(e);\n             }\n         }\n \n         if (error != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "catch(error.mockito.exceptions.verification.junit.junit.junit.ArgumentsAreDifferent e) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-5/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\t2022-07-19 09:50:39.137744106 +0200\n+++ /tmp/tmp1ybhlxyd.java\t2022-07-19 09:50:39.141744081 +0200\n@@ -86,11 +86,11 @@\n                     error = null;\n                 }\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+catch(error.mockito.exceptions.verification.junit.junit.junit.ArgumentsAreDifferent e) {\n                 error = handleVerifyException(e);\n             }\n         }\n \n         if (error != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "catch (error.mockito.exceptions.verification.junit.junit.junitAreDifferent e) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-5/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\t2022-07-19 09:50:48.185688060 +0200\n+++ /tmp/tmp8de6sqxj.java\t2022-07-19 09:50:48.185688060 +0200\n@@ -86,11 +86,11 @@\n                     error = null;\n                 }\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+catch (error.mockito.exceptions.verification.junit.junit.junitAreDifferent e) {\n                 error = handleVerifyException(e);\n             }\n         }\n \n         if (error != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "catch (error.mockito.exceptions.junit.junit.junit.junit.junit.ArgumentsAreDifferent e) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-5/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\t2022-07-19 09:50:57.405630960 +0200\n+++ /tmp/tmpg6vz7ps9.java\t2022-07-19 09:50:57.405630960 +0200\n@@ -86,11 +86,11 @@\n                     error = null;\n                 }\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+catch (error.mockito.exceptions.junit.junit.junit.junit.junit.ArgumentsAreDifferent e) {\n                 error = handleVerifyException(e);\n             }\n         }\n \n         if (error != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "catch (error.mockito.exceptions.junit.junit.junit.junit.junitAreDifferent e) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-5/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\t2022-07-19 09:51:06.605573996 +0200\n+++ /tmp/tmpqmqdv_zp.java\t2022-07-19 09:51:06.605573996 +0200\n@@ -86,11 +86,11 @@\n                     error = null;\n                 }\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+catch (error.mockito.exceptions.junit.junit.junit.junit.junitAreDifferent e) {\n                 error = handleVerifyException(e);\n             }\n         }\n \n         if (error != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "catch(error.mockito.exceptions.junit.junit.junit.junit.junit.ArgumentsAreDifferent e) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-5/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\t2022-07-19 09:51:15.909516400 +0200\n+++ /tmp/tmpa923kty8.java\t2022-07-19 09:51:15.909516400 +0200\n@@ -86,11 +86,11 @@\n                     error = null;\n                 }\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+catch(error.mockito.exceptions.junit.junit.junit.junit.junit.ArgumentsAreDifferent e) {\n                 error = handleVerifyException(e);\n             }\n         }\n \n         if (error != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "catch(e.getX.verification.junit.junit.junit.junit.ArgumentsAreDifferent e) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-5/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\t2022-07-19 09:51:24.881460868 +0200\n+++ /tmp/tmpanswx105.java\t2022-07-19 09:51:24.881460868 +0200\n@@ -86,11 +86,11 @@\n                     error = null;\n                 }\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+catch(e.getX.verification.junit.junit.junit.junit.ArgumentsAreDifferent e) {\n                 error = handleVerifyException(e);\n             }\n         }\n \n         if (error != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "catch(e.exceptions.verification.junit.junit.junit.ArgumentsAreDifferent e) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-5/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\t2022-07-19 09:51:33.973404607 +0200\n+++ /tmp/tmp1bqe93qo.java\t2022-07-19 09:51:33.977404582 +0200\n@@ -86,11 +86,11 @@\n                     error = null;\n                 }\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+catch(e.exceptions.verification.junit.junit.junit.ArgumentsAreDifferent e) {\n                 error = handleVerifyException(e);\n             }\n         }\n \n         if (error != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {",
        "fixed_line": "catch (AssertionError e) {"
    },
    "Lang-42": {
        "fixes": [
            {
                "k": 1,
                "patch": "char c = str.charAt(i); String entityName = this.entityName(c); if (entity == null) {",
                "patch_diff": "char c = str.charAt(i); String entityName = this.entityName(c); if (entity == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "char c = str.charAt(i); String entityName = this.entityName(c); if (entity!= null) {",
                "patch_diff": "char c = str.charAt(i); String entityName = this.entityName(c); if (entity!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "char c = str.charAt(i); String entityName = this.entityName(c); if (c > 0x7F) {",
                "patch_diff": "char c = str.charAt(i); String entityName = this.entityName(c); if (c > 0x7F) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "char c = str.charAt(i); String entityName = this.entityName(c); if (int == null) {",
                "patch_diff": "char c = str.charAt(i); String entityName = this.entityName(c); if (int == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "char c = str.charAt(i); String entityName = this.entityName(c); if (entity > 0x7F) {",
                "patch_diff": "char c = str.charAt(i); String entityName = this.entityName(c); if (entity > 0x7F) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "char c = str.charAt(i); String entityName = this.entityName(c); if (current < 0x7F) {",
                "patch_diff": "char c = str.charAt(i); String entityName = this.entityName(c); if (current < 0x7F) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "char c = str.charAt(i); String entityName = this.entityName(c); if (current!= null) {",
                "patch_diff": "char c = str.charAt(i); String entityName = this.entityName(c); if (current!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "char c = str.charAt(i); String entityName = this.entityName(c); if (name == null) {",
                "patch_diff": "char c = str.charAt(i); String entityName = this.entityName(c); if (name == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "char c = str.charAt(i); String entityName = this.entityName(c); if (entityName == null) {",
                "patch_diff": "char c = str.charAt(i); String entityName = this.entityName(c); if (entityName == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "char c = str.charAt(i); String entityName = this.entityName(c); if (entity!= null) { if (c > 0x7F) {",
                "patch_diff": "char c = str.charAt(i); String entityName = this.entityName(c); if (entity!= null) { if (c > 0x7F) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "char c = str.charAt(i); String entityName = this.entityName(c); if (entityName == null) { if (c > 0x7F) {",
        "fixed_line": "int c = Character.codePointAt(str, i); String entityName = this.entityName(c); if (entityName == null) { if (c >= 0x010000 && i < len - 1) { writer.write(\"&#\"); writer.write(Integer.toString(c, 10)); writer.write(';'); i++; } else if (c > 0x7F) {"
    },
    "Closure-92": {
        "fixes": [
            {
                "k": 1,
                "patch": "int indexOfDot = this.namespace.indexOf('.');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-92/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 09:51:44.201341326 +0200\n+++ /tmp/tmpnniwpseg.java\t2022-07-19 09:51:44.225341176 +0200\n@@ -784,11 +784,11 @@\n         if (firstModule == minimumModule) {\n           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+int indexOfDot = this.namespace.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n                 .addChildToBack(replacementNode);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int indexOfDot = namespace.indexOf('.');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-92/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 09:52:09.645183959 +0200\n+++ /tmp/tmpt7p90c30.java\t2022-07-19 09:52:09.649183935 +0200\n@@ -784,11 +784,11 @@\n         if (firstModule == minimumModule) {\n           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+int indexOfDot = namespace.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n                 .addChildToBack(replacementNode);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int indexOfDot = Node.indexOf('.');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-92/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 09:52:32.973039746 +0200\n+++ /tmp/tmp_eiy8err.java\t2022-07-19 09:52:32.973039746 +0200\n@@ -784,11 +784,11 @@\n         if (firstModule == minimumModule) {\n           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+int indexOfDot = Node.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n                 .addChildToBack(replacementNode);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int indexOfDot = module.indexOf('.');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-92/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 09:52:34.777028596 +0200\n+++ /tmp/tmpv578mqtk.java\t2022-07-19 09:52:34.777028596 +0200\n@@ -784,11 +784,11 @@\n         if (firstModule == minimumModule) {\n           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+int indexOfDot = module.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n                 .addChildToBack(replacementNode);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int indexOfDot = name.indexOf('.');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-92/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 09:52:36.641017076 +0200\n+++ /tmp/tmpcxlj24t9.java\t2022-07-19 09:52:36.645017051 +0200\n@@ -784,11 +784,11 @@\n         if (firstModule == minimumModule) {\n           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+int indexOfDot = name.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n                 .addChildToBack(replacementNode);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int indexOfDot = this.prefix.indexOf('.');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-92/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 09:52:38.389006273 +0200\n+++ /tmp/tmpsha0gzdy.java\t2022-07-19 09:52:38.389006273 +0200\n@@ -784,11 +784,11 @@\n         if (firstModule == minimumModule) {\n           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+int indexOfDot = this.prefix.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n                 .addChildToBack(replacementNode);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int indexOfDot = s.indexOf('.');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-92/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 09:52:40.196995099 +0200\n+++ /tmp/tmpj2azndl1.java\t2022-07-19 09:52:40.196995099 +0200\n@@ -784,11 +784,11 @@\n         if (firstModule == minimumModule) {\n           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+int indexOfDot = s.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n                 .addChildToBack(replacementNode);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int indexOfDot = map.indexOf('.');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-92/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 09:52:42.004983927 +0200\n+++ /tmp/tmpfdy5hfnx.java\t2022-07-19 09:52:42.008983903 +0200\n@@ -784,11 +784,11 @@\n         if (firstModule == minimumModule) {\n           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+int indexOfDot = map.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n                 .addChildToBack(replacementNode);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int indexOfDot = ns.indexOf('.');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-92/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 09:52:43.756973099 +0200\n+++ /tmp/tmp3cmflec6.java\t2022-07-19 09:52:43.760973075 +0200\n@@ -784,11 +784,11 @@\n         if (firstModule == minimumModule) {\n           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+int indexOfDot = ns.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n                 .addChildToBack(replacementNode);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int indexOfDot = list.indexOf('.');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-92/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-19 09:52:45.524962174 +0200\n+++ /tmp/tmphzwjrcsw.java\t2022-07-19 09:52:45.524962174 +0200\n@@ -784,11 +784,11 @@\n         if (firstModule == minimumModule) {\n           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+int indexOfDot = list.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n                 .addChildToBack(replacementNode);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "int indexOfDot = namespace.indexOf('.');",
        "fixed_line": "int indexOfDot = namespace.lastIndexOf('.');"
    },
    "Closure-46": {
        "fixes": [
            {
                "k": 1,
                "patch": "@Override public JSType getLeastSupertype(Type) { return builder.getLeastSupertype(propertyName); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-46/src/com/google/javascript/rhino/jstype/RecordType.java\t2022-07-19 09:52:47.528949791 +0200\n+++ /tmp/tmpyuge3bdy.java\t2022-07-19 09:52:47.560949593 +0200\n@@ -135,26 +135,11 @@\n \n     return super.defineProperty(propertyName, type, inferred,\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+@Override public JSType getLeastSupertype(Type) { return builder.getLeastSupertype(propertyName); }\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "@Override public JSType getLeastSupertype(JSType) { return builder.getLeastSupertype(propertyName); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-46/src/com/google/javascript/rhino/jstype/RecordType.java\t2022-07-19 09:52:51.344926214 +0200\n+++ /tmp/tmphnm3ocn9.java\t2022-07-19 09:52:51.344926214 +0200\n@@ -135,26 +135,11 @@\n \n     return super.defineProperty(propertyName, type, inferred,\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+@Override public JSType getLeastSupertype(JSType) { return builder.getLeastSupertype(propertyName); }\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "@Override public JSType getLeastSupertype(Type) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-46/src/com/google/javascript/rhino/jstype/RecordType.java\t2022-07-19 09:52:54.668905676 +0200\n+++ /tmp/tmps_jkm91g.java\t2022-07-19 09:52:54.668905676 +0200\n@@ -135,26 +135,11 @@\n \n     return super.defineProperty(propertyName, type, inferred,\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+@Override public JSType getLeastSupertype(Type) {\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "@Override public JSType getLeastSupertype(Type) { return builder.getLeastSupertype; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-46/src/com/google/javascript/rhino/jstype/RecordType.java\t2022-07-19 09:52:58.004885065 +0200\n+++ /tmp/tmpboxpb47a.java\t2022-07-19 09:52:58.008885040 +0200\n@@ -135,26 +135,11 @@\n \n     return super.defineProperty(propertyName, type, inferred,\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+@Override public JSType getLeastSupertype(Type) { return builder.getLeastSupertype; }\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "@Override public JSType getLeastSupertype(JSType) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-46/src/com/google/javascript/rhino/jstype/RecordType.java\t2022-07-19 09:53:01.460863716 +0200\n+++ /tmp/tmpj_vwg64b.java\t2022-07-19 09:53:01.460863716 +0200\n@@ -135,26 +135,11 @@\n \n     return super.defineProperty(propertyName, type, inferred,\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+@Override public JSType getLeastSupertype(JSType) {\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "@Override public JSType getLeastSupertype(propertyName) { return builder.getLeastSupertype(propertyName); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-46/src/com/google/javascript/rhino/jstype/RecordType.java\t2022-07-19 09:53:04.992841897 +0200\n+++ /tmp/tmp9sqg3c8x.java\t2022-07-19 09:53:04.992841897 +0200\n@@ -135,26 +135,11 @@\n \n     return super.defineProperty(propertyName, type, inferred,\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+@Override public JSType getLeastSupertype(propertyName) { return builder.getLeastSupertype(propertyName); }\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "@Override public JSType getLeastSupertype(Type that) { return builder.getLeastSupertype(propertyName); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-46/src/com/google/javascript/rhino/jstype/RecordType.java\t2022-07-19 09:53:08.336821241 +0200\n+++ /tmp/tmp5xzyfz7x.java\t2022-07-19 09:53:08.336821241 +0200\n@@ -135,26 +135,11 @@\n \n     return super.defineProperty(propertyName, type, inferred,\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+@Override public JSType getLeastSupertype(Type that) { return builder.getLeastSupertype(propertyName); }\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "@Override public JSType getLeastSupertype(Type) { return builder.getLeastSupertype(",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-46/src/com/google/javascript/rhino/jstype/RecordType.java\t2022-07-19 09:53:11.844799566 +0200\n+++ /tmp/tmpvnqpfltv.java\t2022-07-19 09:53:11.844799566 +0200\n@@ -135,26 +135,11 @@\n \n     return super.defineProperty(propertyName, type, inferred,\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+@Override public JSType getLeastSupertype(Type) { return builder.getLeastSupertype(\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "@Override public JSType getLeastSupertype(JSType) { return builder.getLeastSupertype; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-46/src/com/google/javascript/rhino/jstype/RecordType.java\t2022-07-19 09:53:15.156779111 +0200\n+++ /tmp/tmpvyx08u49.java\t2022-07-19 09:53:15.160779087 +0200\n@@ -135,26 +135,11 @@\n \n     return super.defineProperty(propertyName, type, inferred,\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+@Override public JSType getLeastSupertype(JSType) { return builder.getLeastSupertype; }\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "@Override public JSType getLeastSupertype(Type) { return builder.getLeastSupertype(); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-46/src/com/google/javascript/rhino/jstype/RecordType.java\t2022-07-19 09:53:18.684757328 +0200\n+++ /tmp/tmpe7l8k4vp.java\t2022-07-19 09:53:18.684757328 +0200\n@@ -135,26 +135,11 @@\n \n     return super.defineProperty(propertyName, type, inferred,\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+@Override public JSType getLeastSupertype(Type) { return builder.getLeastSupertype(); }\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "@Override public JSType getLeastSupertype(JSType that) { if (!that.isRecordType()) { return super.getLeastSupertype(that); } RecordTypeBuilder builder = new RecordTypeBuilder(registry); for (String property : properties.keySet()) { if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property))) { builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } } return builder.build(); }",
        "fixed_line": ""
    },
    "Closure-7": {
        "fixes": [
            {
                "k": 1,
                "patch": "return resultEqualsValue && ctorType.isSubtype(type)? ctorType : null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2022-07-19 09:53:23.144729776 +0200\n+++ /tmp/tmp_ma5ukqf.java\t2022-07-19 09:53:23.284728912 +0200\n@@ -608,11 +608,11 @@\n \n     @Override\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+return resultEqualsValue && ctorType.isSubtype(type)? ctorType : null;\n           // Objects are restricted to \"Function\", subtypes are left\n           // Only filter out subtypes of \"function\"\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return resultEqualsValue && ctorType.isSubtype(type))? ctorType : null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2022-07-19 09:54:17.860426198 +0200\n+++ /tmp/tmpuwx01117.java\t2022-07-19 09:54:17.860426198 +0200\n@@ -608,11 +608,11 @@\n \n     @Override\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+return resultEqualsValue && ctorType.isSubtype(type))? ctorType : null;\n           // Objects are restricted to \"Function\", subtypes are left\n           // Only filter out subtypes of \"function\"\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return resultEqualsValue || ctorType.isSubtype(type)? ctorType : null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2022-07-19 09:54:23.428405310 +0200\n+++ /tmp/tmppqog1ppl.java\t2022-07-19 09:54:23.460405188 +0200\n@@ -608,11 +608,11 @@\n \n     @Override\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+return resultEqualsValue || ctorType.isSubtype(type)? ctorType : null;\n           // Objects are restricted to \"Function\", subtypes are left\n           // Only filter out subtypes of \"function\"\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return resultEqualsValue && ctorType.equals(type)? ctorType : null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2022-07-19 09:55:14.768206889 +0200\n+++ /tmp/tmpz_z92rxe.java\t2022-07-19 09:55:14.768206889 +0200\n@@ -608,11 +608,11 @@\n \n     @Override\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+return resultEqualsValue && ctorType.equals(type)? ctorType : null;\n           // Objects are restricted to \"Function\", subtypes are left\n           // Only filter out subtypes of \"function\"\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return resultEqualsValue && ctorType.isSubtype(type) && ctorType : null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2022-07-19 09:56:00.780020750 +0200\n+++ /tmp/tmpovn0125e.java\t2022-07-19 09:56:00.780020750 +0200\n@@ -608,11 +608,11 @@\n \n     @Override\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+return resultEqualsValue && ctorType.isSubtype(type) && ctorType : null;\n           // Objects are restricted to \"Function\", subtypes are left\n           // Only filter out subtypes of \"function\"\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return resultEqualsValue && ctorType.getSubtype(type)? ctorType : null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2022-07-19 09:56:04.184006688 +0200\n+++ /tmp/tmp_td3c156.java\t2022-07-19 09:56:04.188006673 +0200\n@@ -608,11 +608,11 @@\n \n     @Override\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+return resultEqualsValue && ctorType.getSubtype(type)? ctorType : null;\n           // Objects are restricted to \"Function\", subtypes are left\n           // Only filter out subtypes of \"function\"\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return resultEqualsValue - ctorType.isSubtype(type)? ctorType : null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2022-07-19 09:56:07.723992021 +0200\n+++ /tmp/tmppmr0fytc.java\t2022-07-19 09:56:07.723992021 +0200\n@@ -608,11 +608,11 @@\n \n     @Override\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+return resultEqualsValue - ctorType.isSubtype(type)? ctorType : null;\n           // Objects are restricted to \"Function\", subtypes are left\n           // Only filter out subtypes of \"function\"\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return ctorType && ctorType.isSubtype(type)? ctorType : null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2022-07-19 09:56:11.247977380 +0200\n+++ /tmp/tmp4b6w5iu8.java\t2022-07-19 09:56:11.247977380 +0200\n@@ -608,11 +608,11 @@\n \n     @Override\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+return ctorType && ctorType.isSubtype(type)? ctorType : null;\n           // Objects are restricted to \"Function\", subtypes are left\n           // Only filter out subtypes of \"function\"\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return resultEqualsValue && ctorType.isSubtype(type)? ctorType : null; // empty String means 'default'",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2022-07-19 09:56:14.911962116 +0200\n+++ /tmp/tmpe9xduqdh.java\t2022-07-19 09:56:14.911962116 +0200\n@@ -608,11 +608,11 @@\n \n     @Override\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+return resultEqualsValue && ctorType.isSubtype(type)? ctorType : null; // empty String means 'default'\n           // Objects are restricted to \"Function\", subtypes are left\n           // Only filter out subtypes of \"function\"\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return resultEqualsValue && ctorType.isSubtype(type)? ctorType : null; // should never be null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2022-07-19 09:57:01.091766029 +0200\n+++ /tmp/tmpbwhd4amp.java\t2022-07-19 09:57:01.091766029 +0200\n@@ -608,11 +608,11 @@\n \n     @Override\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+return resultEqualsValue && ctorType.isSubtype(type)? ctorType : null; // should never be null;\n           // Objects are restricted to \"Function\", subtypes are left\n           // Only filter out subtypes of \"function\"\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;",
        "fixed_line": "if (resultEqualsValue) { // Objects are restricted to \"Function\", subtypes are left return ctorType.getGreatestSubtype(type); } else { // Only filter out subtypes of \"function\" return type.isSubtype(ctorType) ? null : type; }"
    },
    "Closure-94": {
        "fixes": [
            {
                "k": 1,
                "patch": "// non-literal characters that might be Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token",
                "patch_diff": "// non-literal characters that might be Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// non-literal characters that might be Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.NAME: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.",
                "patch_diff": "// non-literal characters that might be Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.NAME: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// non-literal characters that might be Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.NAME: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.",
                "patch_diff": "// non-literal characters that might be Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.NAME: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// non-literal characters that might be Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.NAME: case Token.BITNOT: case Token.BITNOT: case Token.",
                "patch_diff": "// non-literal characters that might be Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.NAME: case Token.BITNOT: case Token.BITNOT: case Token.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// non-literal characters that might be Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.NAME: case Token.BITNOT: case Token.",
                "patch_diff": "// non-literal characters that might be Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.NAME: case Token.BITNOT: case Token.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// non-literal characters that might be Token.TRUE: case Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.NAME: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.",
                "patch_diff": "// non-literal characters that might be Token.TRUE: case Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.NAME: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// non-literal characters that might be Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.NAME: case Token.",
                "patch_diff": "// non-literal characters that might be Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.NAME: case Token.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// non-literal characters that might be Token.TRUE: case Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.NAME: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.",
                "patch_diff": "// non-literal characters that might be Token.TRUE: case Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.NAME: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// non-literal characters that might be Token.TRUE: case Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.NAME: case Token.BITNOT: case Token.BITNOT: case Token.NAME: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BIT",
                "patch_diff": "// non-literal characters that might be Token.TRUE: case Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.NAME: case Token.BITNOT: case Token.BITNOT: case Token.NAME: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BIT",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// non-literal characters that might be Token.TRUE: case Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.NAME: case Token.BITNOT: case Token.BITNOT: case Token.NAME: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BIT",
                "patch_diff": "// non-literal characters that might be Token.TRUE: case Token.FALSE: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.NAME: case Token.BITNOT: case Token.BITNOT: case Token.NAME: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BIT",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "case Token.ADD: case Token.BITAND: case Token.BITNOT: case Token.BITOR: case Token.BITXOR: case Token.DIV: case Token.EQ: case Token.GE: case Token.GT: case Token.LE: case Token.LSH: case Token.LT: case Token.MOD: case Token.MUL: case Token.NE: case Token.RSH: case Token.SHEQ: case Token.SHNE: case Token.SUB: case Token.URSH: return isValidDefineValue(val.getFirstChild(), defines) && isValidDefineValue(val.getLastChild(), defines); // Uniary operators are valid if the child is valid. case Token.NOT: case Token.NEG: case Token.POS:"
    },
    "JacksonDatabind-84": {
        "fixes": [
            {
                "k": 1,
                "patch": "_referencedType = new IllegalStateException(\"Trying to re-set self reference \"+_referencedType+\", new = \"+_referencedType; }",
                "patch_diff": "_referencedType = new IllegalStateException(\"Trying to re-set self reference \"+_referencedType+\", new = \"+_referencedType; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "throw new IllegalStateException(\"Trying to re-set self reference \"+_referencedType+\", new = \"+_referencedType; }",
                "patch_diff": "throw new IllegalStateException(\"Trying to re-set self reference \"+_referencedType+\", new = \"+_referencedType; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "_referencedType = new IllegalStateException(\"Trying to re-set self reference; }",
                "patch_diff": "_referencedType = new IllegalStateException(\"Trying to re-set self reference; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "_referencedType = null; old value = \"+_referencedType+\", new = \"+_referencedType; }",
                "patch_diff": "_referencedType = null; old value = \"+_referencedType+\", new = \"+_referencedType; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "_referencedType = new IllegalStateException(\"Trying to re-set self reference \"+_referencedType+\", new = \"+ref); }",
                "patch_diff": "_referencedType = new IllegalStateException(\"Trying to re-set self reference \"+_referencedType+\", new = \"+ref); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "_referencedType = new IllegalStateException(\"Trying to re-set self reference \"+_referencedType+\", new = \"+_referencedType); }",
                "patch_diff": "_referencedType = new IllegalStateException(\"Trying to re-set self reference \"+_referencedType+\", new = \"+_referencedType); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "_referencedType = new IllegalStateException(\"Trying to re-set self reference \"+_referencedType+\", new = \"+_referencedType+\", new = \"+_referencedType; }",
                "patch_diff": "_referencedType = new IllegalStateException(\"Trying to re-set self reference \"+_referencedType+\", new = \"+_referencedType+\", new = \"+_referencedType; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "_referencedType = new IllegalStateException(\"Trying to re-set self reference \"+_referencedType+\", new = \"+_referencedType)) { return _referencedType; }",
                "patch_diff": "_referencedType = new IllegalStateException(\"Trying to re-set self reference \"+_referencedType+\", new = \"+_referencedType)) { return _referencedType; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "_referencedType = new IllegalStateException(\"Trying to re-set self reference \"+_referencedType+\", new = \"+ref; }",
                "patch_diff": "_referencedType = new IllegalStateException(\"Trying to re-set self reference \"+_referencedType+\", new = \"+ref; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "JavaType(\"Trying to re-set self reference \"+_referencedType+\", new = \"+_referencedType; }",
                "patch_diff": "JavaType(\"Trying to re-set self reference \"+_referencedType+\", new = \"+_referencedType; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "@Override public JavaType getSuperClass() { if (_referencedType != null) { return _referencedType.getSuperClass(); } return super.getSuperClass(); }"
    },
    "JacksonDatabind-96": {
        "fixes": [
            {
                "k": 1,
                "patch": "paramName = candidate.findImplicitParamName(1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-96/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 09:57:51.619544159 +0200\n+++ /tmp/tmpy5u670dg.java\t2022-07-19 09:57:51.639544071 +0200\n@@ -730,11 +730,11 @@\n             // or field, we'll consider it property-based as well\n \n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+paramName = candidate.findImplicitParamName(1);\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "paramName = candidate.findImplicitParamName(0);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-96/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 09:58:46.483295407 +0200\n+++ /tmp/tmpv5f279wk.java\t2022-07-19 09:58:46.483295407 +0200\n@@ -730,11 +730,11 @@\n             // or field, we'll consider it property-based as well\n \n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+paramName = candidate.findImplicitParamName(0);\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "paramName = candidate.findImplicitParamName(prop);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-96/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 09:59:40.491043346 +0200\n+++ /tmp/tmp1e761wqp.java\t2022-07-19 09:59:40.491043346 +0200\n@@ -730,11 +730,11 @@\n             // or field, we'll consider it property-based as well\n \n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+paramName = candidate.findImplicitParamName(prop);\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "paramName = candidate.findImplicitParamName();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-96/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 09:59:42.443034111 +0200\n+++ /tmp/tmpv1ugz2xy.java\t2022-07-19 09:59:42.443034111 +0200\n@@ -730,11 +730,11 @@\n             // or field, we'll consider it property-based as well\n \n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+paramName = candidate.findImplicitParamName();\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "paramName = candidate.findImplicitParamName(propName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-96/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 09:59:44.291025359 +0200\n+++ /tmp/tmpgxw5abmt.java\t2022-07-19 09:59:44.291025359 +0200\n@@ -730,11 +730,11 @@\n             // or field, we'll consider it property-based as well\n \n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+paramName = candidate.findImplicitParamName(propName);\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "paramName = candidate.findImplicitParamName(paramName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-96/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 09:59:46.127016661 +0200\n+++ /tmp/tmpt48xsgob.java\t2022-07-19 09:59:46.127016661 +0200\n@@ -730,11 +730,11 @@\n             // or field, we'll consider it property-based as well\n \n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+paramName = candidate.findImplicitParamName(paramName);\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "paramName = candidate.findImplicitParamName(_name);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-96/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 09:59:48.007007744 +0200\n+++ /tmp/tmpld7x6yk5.java\t2022-07-19 09:59:48.011007723 +0200\n@@ -730,11 +730,11 @@\n             // or field, we'll consider it property-based as well\n \n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+paramName = candidate.findImplicitParamName(_name);\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "paramName = candidate.findImplicitParamName(prop.name);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-96/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 09:59:49.826999105 +0200\n+++ /tmp/tmpf1sg3tye.java\t2022-07-19 09:59:49.826999105 +0200\n@@ -730,11 +730,11 @@\n             // or field, we'll consider it property-based as well\n \n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+paramName = candidate.findImplicitParamName(prop.name);\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "paramName = candidate.findImplicitParamName(name);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-96/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 09:59:51.722990096 +0200\n+++ /tmp/tmp35rutfoq.java\t2022-07-19 09:59:51.722990096 +0200\n@@ -730,11 +730,11 @@\n             // or field, we'll consider it property-based as well\n \n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+paramName = candidate.findImplicitParamName(name);\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "paramName = candidate.findImplicitParamName(_propName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-96/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-19 09:59:53.550981404 +0200\n+++ /tmp/tmpa6hbj8on.java\t2022-07-19 09:59:53.586981233 +0200\n@@ -730,11 +730,11 @@\n             // or field, we'll consider it property-based as well\n \n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+paramName = candidate.findImplicitParamName(_propName);\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "paramName = candidate.findImplicitParamName(0);",
        "fixed_line": "paramName = candidate.paramName(0);"
    },
    "Lang-3": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (d == 0.0) || (d == 0.0) {",
                "patch_diff": "if (d == 0.0) || (d == 0.0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (d == 0.0) || (d.isAllZeros == 0.0) {",
                "patch_diff": "if (d == 0.0) || (d.isAllZeros == 0.0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (d == 0.0) || (d.isAllZeros))) {",
                "patch_diff": "if (d == 0.0) || (d.isAllZeros))) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (d == 0.0 ||!allZeros))) {",
                "patch_diff": "if (d == 0.0 ||!allZeros))) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (d == 0.0) || (d == 0.0F &&!allZeros))) {",
                "patch_diff": "if (d == 0.0) || (d == 0.0F &&!allZeros))) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (d.isAllZeros ||!allZeros))) {",
                "patch_diff": "if (d.isAllZeros ||!allZeros))) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (d == 0.0) ||!allZeros))) {",
                "patch_diff": "if (d == 0.0) ||!allZeros))) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (d.isInfinite() == 0.0) {",
                "patch_diff": "if (d.isInfinite() == 0.0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (d == 0.0) || (d.isAllZeros) == 0.0) {",
                "patch_diff": "if (d == 0.0) || (d.isAllZeros) == 0.0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (d == 0.0) {",
                "patch_diff": "if (d == 0.0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float final Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } } catch (final NumberFormatException nfe) { // NOPMD // ignore the bad number } try { if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double final Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } }"
    },
    "Codec-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < 6; i++) {",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < 6; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < 6; ++i) {",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < 6; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < 6; ++k) {",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < 6; ++k) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; x < 6; i++) {",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; x < 6; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; x < 6; ++i) {",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; x < 6; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < 6; ++i) {",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < 6; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < 6; ++x) {",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < 6; ++x) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < 6; i++) {",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for object (int i = 0; i < 6; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for (int x = 0; i < 6; i++) {",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for (int x = 0; i < 6; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < 6;",
                "patch_diff": "// as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < 6;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (buffer == null || buffer.length - pos < decodeSize) { resizeBuffer(); }"
    },
    "Jsoup-10": {
        "fixes": [
            {
                "k": 1,
                "patch": "return abs.toExternalForm(); }",
                "patch_diff": "return abs.toExternalForm(); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return abs.toExternalForm();",
                "patch_diff": "return abs.toExternalForm();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return abs.toExternalForm(); } catch (IllegalArgumentException e) {",
                "patch_diff": "return abs.toExternalForm(); } catch (IllegalArgumentException e) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return abs.toExternalForm(); } else {",
                "patch_diff": "return abs.toExternalForm(); } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return abs.toExternalForm(); } else { abs = new URL(base, relUrl); return abs.toExternalForm(); }",
                "patch_diff": "return abs.toExternalForm(); } else { abs = new URL(base, relUrl); return abs.toExternalForm(); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return abs.toExternalForm(); } else { abs = new URL(base, relUrl); }",
                "patch_diff": "return abs.toExternalForm(); } else { abs = new URL(base, relUrl); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return abs.toExternalForm(); } catch (IllegalArgumentException e) { abs = new URL(base, relUrl); return abs.toExternalForm(); }",
                "patch_diff": "return abs.toExternalForm(); } catch (IllegalArgumentException e) { abs = new URL(base, relUrl); return abs.toExternalForm(); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return abs.toExternalForm(); } else { abs = new URL(base, relUrl); return abs; }",
                "patch_diff": "return abs.toExternalForm(); } else { abs = new URL(base, relUrl); return abs; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return abs.toExternalForm(); } catch (IllegalArgumentException e) { abs = new URL(base, relUrl); }",
                "patch_diff": "return abs.toExternalForm(); } catch (IllegalArgumentException e) { abs = new URL(base, relUrl); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return abs.toExternalForm(); } catch (IllegalArgumentException e) { abs = new URL(base, relUrl); return abs; }",
                "patch_diff": "return abs.toExternalForm(); } catch (IllegalArgumentException e) { abs = new URL(base, relUrl); return abs; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (relUrl.startsWith(\"?\")) relUrl = base.getPath() + relUrl;"
    },
    "Lang-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (count < 0 || start > end) {",
                "patch_diff": "} else if (count < 0 || start > end) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (count < 0 &&!numbers) {",
                "patch_diff": "} else if (count < 0 &&!numbers) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (count < 0 && end > 0) {",
                "patch_diff": "} else if (count < 0 && end > 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (count < 0) {",
                "patch_diff": "} else if (count < 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (count < 0 && start > end) {",
                "patch_diff": "} else if (count < 0 && start > end) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (count < 0 &&!numbers) { end = 'z'",
                "patch_diff": "} else if (count < 0 &&!numbers) { end = 'z'",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (count < 0 || start > end) { end = 'z'",
                "patch_diff": "} else if (count < 0 || start > end) { end = 'z'",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (count < 0 && start > 0) {",
                "patch_diff": "} else if (count < 0 && start > 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (count == 0 &&!numbers) {",
                "patch_diff": "} else if (count == 0 &&!numbers) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (count < 0 || start > end) { end = 'L'",
                "patch_diff": "} else if (count < 0 || start > end) { end = 'L'",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (chars != null && chars.length == 0) { throw new IllegalArgumentException(\"The chars array must not be empty\"); } if (start == 0 && end == 0) { if (chars != null) { end = chars.length; } else { if (!letters && !numbers) { end = Integer.MAX_VALUE; } else { end = 'z' + 1; start = ' '; } }"
    },
    "JacksonDatabind-71": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] --raw == Object.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-71/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\t2022-07-19 10:00:02.734937626 +0200\n+++ /tmp/tmpdp0syxe1.java\t2022-07-19 10:00:02.782937398 +0200\n@@ -70,11 +70,11 @@\n     public static StdKeyDeserializer forType(Class<?> raw)\n     {\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class) {\n+if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] --raw == Object.class) {\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n         } else if (raw == Integer.class) {\n             kind = TYPE_INT;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (raw == String.class || raw == Object.class || raw == Object.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-71/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\t2022-07-19 10:00:42.294747063 +0200\n+++ /tmp/tmpghoyum0w.java\t2022-07-19 10:00:42.310746986 +0200\n@@ -70,11 +70,11 @@\n     public static StdKeyDeserializer forType(Class<?> raw)\n     {\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class) {\n+if (raw == String.class || raw == Object.class || raw == Object.class) {\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n         } else if (raw == Integer.class) {\n             kind = TYPE_INT;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] --raw (raw == Object.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-71/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\t2022-07-19 10:01:19.650564314 +0200\n+++ /tmp/tmp3d6i6u6u.java\t2022-07-19 10:01:19.654564295 +0200\n@@ -70,11 +70,11 @@\n     public static StdKeyDeserializer forType(Class<?> raw)\n     {\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class) {\n+if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] --raw (raw == Object.class) {\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n         } else if (raw == Integer.class) {\n             kind = TYPE_INT;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (raw == String.class || raw == Object.class || raw == Object.class) { // as per [JACKSON-407] --raw == Object.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-71/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\t2022-07-19 10:01:57.206378039 +0200\n+++ /tmp/tmp8kmaogl1.java\t2022-07-19 10:01:57.210378020 +0200\n@@ -70,11 +70,11 @@\n     public static StdKeyDeserializer forType(Class<?> raw)\n     {\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class) {\n+if (raw == String.class || raw == Object.class || raw == Object.class) { // as per [JACKSON-407] --raw == Object.class) {\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n         } else if (raw == Integer.class) {\n             kind = TYPE_INT;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class; {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-71/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\t2022-07-19 10:02:34.586190283 +0200\n+++ /tmp/tmp3ph21rw8.java\t2022-07-19 10:02:34.586190283 +0200\n@@ -70,11 +70,11 @@\n     public static StdKeyDeserializer forType(Class<?> raw)\n     {\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class) {\n+if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class; {\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n         } else if (raw == Integer.class) {\n             kind = TYPE_INT;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] --raw)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-71/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\t2022-07-19 10:03:11.794001215 +0200\n+++ /tmp/tmp2h_fhny_.java\t2022-07-19 10:03:11.794001215 +0200\n@@ -70,11 +70,11 @@\n     public static StdKeyDeserializer forType(Class<?> raw)\n     {\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class) {\n+if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] --raw)\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n         } else if (raw == Integer.class) {\n             kind = TYPE_INT;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-71/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\t2022-07-19 10:03:48.865810839 +0200\n+++ /tmp/tmpr1_jug1f.java\t2022-07-19 10:03:48.865810839 +0200\n@@ -70,11 +70,11 @@\n     public static StdKeyDeserializer forType(Class<?> raw)\n     {\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class) {\n+if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n         } else if (raw == Integer.class) {\n             kind = TYPE_INT;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] --raw == Object.class || raw == Object.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-71/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\t2022-07-19 10:04:26.521615559 +0200\n+++ /tmp/tmpeha7qiro.java\t2022-07-19 10:04:26.521615559 +0200\n@@ -70,11 +70,11 @@\n     public static StdKeyDeserializer forType(Class<?> raw)\n     {\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class) {\n+if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] --raw == Object.class || raw == Object.class) {\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n         } else if (raw == Integer.class) {\n             kind = TYPE_INT;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (raw == String.class || raw == Object.class || raw == Object.class) { // as per [JACKSON-407] --raw (raw == Object.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-71/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\t2022-07-19 10:05:03.569421692 +0200\n+++ /tmp/tmpkt7_72sp.java\t2022-07-19 10:05:03.569421692 +0200\n@@ -70,11 +70,11 @@\n     public static StdKeyDeserializer forType(Class<?> raw)\n     {\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class) {\n+if (raw == String.class || raw == Object.class || raw == Object.class) { // as per [JACKSON-407] --raw (raw == Object.class) {\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n         } else if (raw == Integer.class) {\n             kind = TYPE_INT;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] -- allow use a Object.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-71/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\t2022-07-19 10:05:40.189228487 +0200\n+++ /tmp/tmp06g14fsc.java\t2022-07-19 10:05:40.193228466 +0200\n@@ -70,11 +70,11 @@\n     public static StdKeyDeserializer forType(Class<?> raw)\n     {\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class) {\n+if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] -- allow use a Object.class) {\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n         } else if (raw == Integer.class) {\n             kind = TYPE_INT;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (raw == String.class || raw == Object.class) {",
        "fixed_line": "if (raw == String.class || raw == Object.class || raw == CharSequence.class) {"
    },
    "JacksonDatabind-82": {
        "fixes": [
            {
                "k": 1,
                "patch": "ignored = ignorals.getIgnored();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-82/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\t2022-07-19 10:06:17.873028146 +0200\n+++ /tmp/tmpsfedv8nz.java\t2022-07-19 10:06:17.925027870 +0200\n@@ -490,11 +490,11 @@\n \n         if (ignorals != null) {\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.getIgnored();\n+ignored = ignorals.getIgnored();\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n         } else {\n             ignored = Collections.emptySet();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "ignored = ignorals.getIgnored(); // to check whether a prototype, as per [JACKSON-407] -- allow disabling wrapping for \" + ignorals.getIgnored();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-82/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\t2022-07-19 10:07:04.244779657 +0200\n+++ /tmp/tmpyrid7ncy.java\t2022-07-19 10:07:04.244779657 +0200\n@@ -490,11 +490,11 @@\n \n         if (ignorals != null) {\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.getIgnored();\n+ignored = ignorals.getIgnored(); // to check whether a prototype, as per [JACKSON-407] -- allow disabling wrapping for \" + ignorals.getIgnored();\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n         } else {\n             ignored = Collections.emptySet();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "ignored = ignorals.getIgnored(); // to check whether a prototype, as per [JACKSON-407] -- allow disabling wrapping for \" + ignorals = ignorals.getIgnored();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-82/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\t2022-07-19 10:07:45.320557884 +0200\n+++ /tmp/tmpnipiilnf.java\t2022-07-19 10:07:45.324557864 +0200\n@@ -490,11 +490,11 @@\n \n         if (ignorals != null) {\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.getIgnored();\n+ignored = ignorals.getIgnored(); // to check whether a prototype, as per [JACKSON-407] -- allow disabling wrapping for \" + ignorals = ignorals.getIgnored();\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n         } else {\n             ignored = Collections.emptySet();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "ignored = ignorals.getIgnored(); // to check whether a prototype, as per [JACKSON-407] -- allow use a digit after the",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-82/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\t2022-07-19 10:08:26.024336700 +0200\n+++ /tmp/tmp4og4qokr.java\t2022-07-19 10:08:26.028336680 +0200\n@@ -490,11 +490,11 @@\n \n         if (ignorals != null) {\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.getIgnored();\n+ignored = ignorals.getIgnored(); // to check whether a prototype, as per [JACKSON-407] -- allow use a digit after the\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n         } else {\n             ignored = Collections.emptySet();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "ignored = ignorals.getIgnored(); // to check whether a prototype, as per [JACKSON-407] -- allow use a native function.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-82/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\t2022-07-19 10:09:06.536115265 +0200\n+++ /tmp/tmphkljw61c.java\t2022-07-19 10:09:06.536115265 +0200\n@@ -490,11 +490,11 @@\n \n         if (ignorals != null) {\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.getIgnored();\n+ignored = ignorals.getIgnored(); // to check whether a prototype, as per [JACKSON-407] -- allow use a native function.\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n         } else {\n             ignored = Collections.emptySet();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "ignored = ignorals.getIgnored(); // to check whether a prototype, as per [JACKSON-407] --raw)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-82/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\t2022-07-19 10:09:47.627889440 +0200\n+++ /tmp/tmp63iimtv4.java\t2022-07-19 10:09:47.627889440 +0200\n@@ -490,11 +490,11 @@\n \n         if (ignorals != null) {\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.getIgnored();\n+ignored = ignorals.getIgnored(); // to check whether a prototype, as per [JACKSON-407] --raw)\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n         } else {\n             ignored = Collections.emptySet();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "ignored = ignorals.getIgnored(); // to check whether a prototype, as per [JACKSON-407] -- allow disabling wrapping for the",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-82/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\t2022-07-19 10:10:27.879667136 +0200\n+++ /tmp/tmp5hv2lc9i.java\t2022-07-19 10:10:27.879667136 +0200\n@@ -490,11 +490,11 @@\n \n         if (ignorals != null) {\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.getIgnored();\n+ignored = ignorals.getIgnored(); // to check whether a prototype, as per [JACKSON-407] -- allow disabling wrapping for the\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n         } else {\n             ignored = Collections.emptySet();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "ignored = ignorals.getIgnored(); // no need to check whether a prototype, as per [JACKSON-407] -- allow use a digit after the",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-82/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\t2022-07-19 10:11:08.691440711 +0200\n+++ /tmp/tmpl43u6u8b.java\t2022-07-19 10:11:08.691440711 +0200\n@@ -490,11 +490,11 @@\n \n         if (ignorals != null) {\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.getIgnored();\n+ignored = ignorals.getIgnored(); // no need to check whether a prototype, as per [JACKSON-407] -- allow use a digit after the\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n         } else {\n             ignored = Collections.emptySet();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "ignored = ignorals.getIgnored(); // to check whether a prototype, as per [JACKSON-407] -- allow use a digit after the E",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-82/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\t2022-07-19 10:11:49.591212840 +0200\n+++ /tmp/tmp_13gq5bf.java\t2022-07-19 10:11:49.595212816 +0200\n@@ -490,11 +490,11 @@\n \n         if (ignorals != null) {\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.getIgnored();\n+ignored = ignorals.getIgnored(); // to check whether a prototype, as per [JACKSON-407] -- allow use a digit after the E\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n         } else {\n             ignored = Collections.emptySet();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "ignored = ignorals.getIgnored(); // no need to check whether a prototype, as per [JACKSON-407] -- allow use a native function.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-82/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\t2022-07-19 10:12:30.058986506 +0200\n+++ /tmp/tmpm8b7pp5r.java\t2022-07-19 10:12:30.058986506 +0200\n@@ -490,11 +490,11 @@\n \n         if (ignorals != null) {\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.getIgnored();\n+ignored = ignorals.getIgnored(); // no need to check whether a prototype, as per [JACKSON-407] -- allow use a native function.\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n         } else {\n             ignored = Collections.emptySet();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "ignored = ignorals.getIgnored();",
        "fixed_line": "ignored = ignorals.findIgnoredForDeserialization();"
    },
    "Closure-126": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2022-07-19 10:13:11.578753454 +0200\n+++ /tmp/tmp9_kg8bzi.java\t2022-07-19 10:13:11.626753188 +0200\n@@ -136,14 +136,11 @@\n       }\n       /* Don't try to minimize the exits of finally blocks, as this\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); }\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (NodeUtil.hasFinally(parent)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2022-07-19 10:13:58.662488242 +0200\n+++ /tmp/tmp6a1fvwkq.java\t2022-07-19 10:13:58.662488242 +0200\n@@ -136,14 +136,11 @@\n       }\n       /* Don't try to minimize the exits of finally blocks, as this\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+if (NodeUtil.hasFinally(parent)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); }\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (NodeUtil.hasFinally(n)) { Node finallyBlock = n; tryMinimizeExits(finallyBlock, exitType, labelName); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2022-07-19 10:14:02.086468919 +0200\n+++ /tmp/tmpf30mhkbw.java\t2022-07-19 10:14:02.086468919 +0200\n@@ -136,14 +136,11 @@\n       }\n       /* Don't try to minimize the exits of finally blocks, as this\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+if (NodeUtil.hasFinally(n)) { Node finallyBlock = n; tryMinimizeExits(finallyBlock, exitType, labelName); }\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (NodeUtil.hasFinally(n)) { Node finallyBlock = n; if (finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2022-07-19 10:14:47.322213194 +0200\n+++ /tmp/tmpjo761gt3.java\t2022-07-19 10:14:47.322213194 +0200\n@@ -136,14 +136,11 @@\n       }\n       /* Don't try to minimize the exits of finally blocks, as this\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+if (NodeUtil.hasFinally(n)) { Node finallyBlock = n; if (finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); }\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); return; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2022-07-19 10:14:50.946192673 +0200\n+++ /tmp/tmpiks_q_8d.java\t2022-07-19 10:14:50.946192673 +0200\n@@ -136,14 +136,11 @@\n       }\n       /* Don't try to minimize the exits of finally blocks, as this\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); return; }\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (NodeUtil.hasFinally(n)) { Node finallyBlock = n; if (finallyBlock.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2022-07-19 10:15:35.697938875 +0200\n+++ /tmp/tmpdo4_r2yx.java\t2022-07-19 10:15:35.697938875 +0200\n@@ -136,14 +136,11 @@\n       }\n       /* Don't try to minimize the exits of finally blocks, as this\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+if (NodeUtil.hasFinally(n)) { Node finallyBlock = n; if (finallyBlock.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); }\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "ifNodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2022-07-19 10:15:39.105919518 +0200\n+++ /tmp/tmp1lt0upjs.java\t2022-07-19 10:15:39.105919518 +0200\n@@ -136,14 +136,11 @@\n       }\n       /* Don't try to minimize the exits of finally blocks, as this\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+ifNodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); }\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2022-07-19 10:15:42.529900068 +0200\n+++ /tmp/tmpflm5i5lr.java\t2022-07-19 10:15:42.529900068 +0200\n@@ -136,14 +136,11 @@\n       }\n       /* Don't try to minimize the exits of finally blocks, as this\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName);\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); return",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2022-07-19 10:15:45.885880998 +0200\n+++ /tmp/tmpuyaqoe6l.java\t2022-07-19 10:15:45.885880998 +0200\n@@ -136,14 +136,11 @@\n       }\n       /* Don't try to minimize the exits of finally blocks, as this\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); return\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (NodeUtil.hasFinally(parent.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2022-07-19 10:15:49.173862312 +0200\n+++ /tmp/tmptgwj4vfw.java\t2022-07-19 10:15:49.173862312 +0200\n@@ -136,14 +136,11 @@\n       }\n       /* Don't try to minimize the exits of finally blocks, as this\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+if (NodeUtil.hasFinally(parent.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); }\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); }",
        "fixed_line": ""
    },
    "Cli-9": {
        "fixes": [
            {
                "k": 1,
                "patch": "throw new MissingOptionException(buff.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-9/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 10:15:52.653842531 +0200\n+++ /tmp/tmpa49hctj9.java\t2022-07-19 10:15:52.685842350 +0200\n@@ -317,11 +317,11 @@\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n             }\n \n-            throw new MissingOptionException(buff.toString());\n+throw new MissingOptionException(buff.toString());\n         }\n     }\n \n     /**\n      * <p>Process the argument values for the specified Option\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "throw new MissingOptionException(buff.toString().append(buff.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-9/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 10:15:55.453826614 +0200\n+++ /tmp/tmpv9gi7m8w.java\t2022-07-19 10:15:55.453826614 +0200\n@@ -317,11 +317,11 @@\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n             }\n \n-            throw new MissingOptionException(buff.toString());\n+throw new MissingOptionException(buff.toString().append(buff.toString());\n         }\n     }\n \n     /**\n      * <p>Process the argument values for the specified Option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "throw new MissingOptionException(buff.toString(),buff.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-9/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 10:15:56.953818085 +0200\n+++ /tmp/tmp1qmv7_ei.java\t2022-07-19 10:15:56.953818085 +0200\n@@ -317,11 +317,11 @@\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n             }\n \n-            throw new MissingOptionException(buff.toString());\n+throw new MissingOptionException(buff.toString(),buff.toString());\n         }\n     }\n \n     /**\n      * <p>Process the argument values for the specified Option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new MissingOptionException(\"buff.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-9/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 10:15:58.617808623 +0200\n+++ /tmp/tmpbb7t9i8r.java\t2022-07-19 10:15:58.617808623 +0200\n@@ -317,11 +317,11 @@\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n             }\n \n-            throw new MissingOptionException(buff.toString());\n+throw new MissingOptionException(\"buff.toString());\n         }\n     }\n \n     /**\n      * <p>Process the argument values for the specified Option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "throw new MissingOptionException(buff.toString() + 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-9/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 10:16:00.077800320 +0200\n+++ /tmp/tmpd56wuwud.java\t2022-07-19 10:16:00.081800297 +0200\n@@ -317,11 +317,11 @@\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n             }\n \n-            throw new MissingOptionException(buff.toString());\n+throw new MissingOptionException(buff.toString() + 1);\n         }\n     }\n \n     /**\n      * <p>Process the argument values for the specified Option\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "throw new MissingOptionException(buff.toString().toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-9/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 10:16:02.569786147 +0200\n+++ /tmp/tmplt2efc5c.java\t2022-07-19 10:16:02.569786147 +0200\n@@ -317,11 +317,11 @@\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n             }\n \n-            throw new MissingOptionException(buff.toString());\n+throw new MissingOptionException(buff.toString().toString());\n         }\n     }\n \n     /**\n      * <p>Process the argument values for the specified Option\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "throw new MissingOptionException(buff.toString()); // the dataset is to the",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-9/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 10:16:05.133771562 +0200\n+++ /tmp/tmpcfnvod0j.java\t2022-07-19 10:16:05.137771539 +0200\n@@ -317,11 +317,11 @@\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n             }\n \n-            throw new MissingOptionException(buff.toString());\n+throw new MissingOptionException(buff.toString()); // the dataset is to the\n         }\n     }\n \n     /**\n      * <p>Process the argument values for the specified Option\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "throw new MissingOptionException(buff.toString()); // the dataset (buff.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-9/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 10:16:07.469758271 +0200\n+++ /tmp/tmp400yplez.java\t2022-07-19 10:16:07.469758271 +0200\n@@ -317,11 +317,11 @@\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n             }\n \n-            throw new MissingOptionException(buff.toString());\n+throw new MissingOptionException(buff.toString()); // the dataset (buff.\n         }\n     }\n \n     /**\n      * <p>Process the argument values for the specified Option\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "throw new MissingOptionException(buff.toString()); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-9/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 10:16:09.605746118 +0200\n+++ /tmp/tmptr72xvki.java\t2022-07-19 10:16:09.605746118 +0200\n@@ -317,11 +317,11 @@\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n             }\n \n-            throw new MissingOptionException(buff.toString());\n+throw new MissingOptionException(buff.toString()); }\n         }\n     }\n \n     /**\n      * <p>Process the argument values for the specified Option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "throw new MissingOptionException(buff.toString()); // the item (buff.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-9/src/java/org/apache/commons/cli/Parser.java\t2022-07-19 10:16:11.053737878 +0200\n+++ /tmp/tmpxg9d9z5s.java\t2022-07-19 10:16:11.053737878 +0200\n@@ -317,11 +317,11 @@\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n             }\n \n-            throw new MissingOptionException(buff.toString());\n+throw new MissingOptionException(buff.toString()); // the item (buff.\n         }\n     }\n \n     /**\n      * <p>Process the argument values for the specified Option\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "throw new MissingOptionException(buff.toString());",
        "fixed_line": "buff.append(\", \"); } throw new MissingOptionException(buff.substring(0, buff.length() - 2));"
    },
    "Time-16": {
        "fixes": [
            {
                "k": 1,
                "patch": "instantLocal, chrono, iLocale, iPivotYear);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-16/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 10:16:13.369724698 +0200\n+++ /tmp/tmpre7ofroy.java\t2022-07-19 10:16:13.421724401 +0200\n@@ -704,11 +704,11 @@\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+instantLocal, chrono, iLocale, iPivotYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n             int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "instantLocal, chrono = chrono.iZone, iLocale, iPivotYear);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-16/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 10:16:23.729665717 +0200\n+++ /tmp/tmpav9rqs2l.java\t2022-07-19 10:16:23.729665717 +0200\n@@ -704,11 +704,11 @@\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+instantLocal, chrono = chrono.iZone, iLocale, iPivotYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n             int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "instantLocal, chrono, iLocale, iPivotYear = chrono.iPivotYear);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-16/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 10:16:25.365656402 +0200\n+++ /tmp/tmpe_q1r2u8.java\t2022-07-19 10:16:25.369656379 +0200\n@@ -704,11 +704,11 @@\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+instantLocal, chrono, iLocale, iPivotYear = chrono.iPivotYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n             int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "instantLocal, chrono.iLocale, iPivotYear);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-16/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 10:16:27.013647016 +0200\n+++ /tmp/tmpp8da1qwl.java\t2022-07-19 10:16:27.013647016 +0200\n@@ -704,11 +704,11 @@\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+instantLocal, chrono.iLocale, iPivotYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n             int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "instantLocal, chrono = iLocale, iPivotYear);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-16/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 10:16:28.625637833 +0200\n+++ /tmp/tmpirwsjzqn.java\t2022-07-19 10:16:28.629637810 +0200\n@@ -704,11 +704,11 @@\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+instantLocal, chrono = iLocale, iPivotYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n             int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "instantLocal, chrono, iLocale, iPivotYear = chrono.iMonthOfYear);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-16/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 10:16:30.217628764 +0200\n+++ /tmp/tmpmuuuv8_z.java\t2022-07-19 10:16:30.217628764 +0200\n@@ -704,11 +704,11 @@\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+instantLocal, chrono, iLocale, iPivotYear = chrono.iMonthOfYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n             int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "instantLocal, chrono, iLocale, iPivotYear = chrono;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-16/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 10:16:31.873619331 +0200\n+++ /tmp/tmpnp0ov3bw.java\t2022-07-19 10:16:31.873619331 +0200\n@@ -704,11 +704,11 @@\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+instantLocal, chrono, iLocale, iPivotYear = chrono;\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n             int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "instantLocal, chrono, zone, iLocale, iPivotYear);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-16/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 10:16:33.417610534 +0200\n+++ /tmp/tmpmkwfj9i3.java\t2022-07-19 10:16:33.417610534 +0200\n@@ -704,11 +704,11 @@\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+instantLocal, chrono, zone, iLocale, iPivotYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n             int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "instantLocal, chrono, position, iLocale, iPivotYear);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-16/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 10:16:35.037601303 +0200\n+++ /tmp/tmppt6ibc7d.java\t2022-07-19 10:16:35.037601303 +0200\n@@ -704,11 +704,11 @@\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+instantLocal, chrono, position, iLocale, iPivotYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n             int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "instantLocal, chrono, iLocale, iPivotYear); // standardOffset = chrono.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-16/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-19 10:16:36.701591822 +0200\n+++ /tmp/tmp8dk6c4_m.java\t2022-07-19 10:16:36.705591799 +0200\n@@ -704,11 +704,11 @@\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+instantLocal, chrono, iLocale, iPivotYear); // standardOffset = chrono.\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n             int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);",
        "fixed_line": "instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));"
    },
    "JxPath-6": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (l instanceof InitialContext || l instanceof SelfContext || l instanceof SelfContext) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-6/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\t2022-07-19 10:16:46.225537535 +0200\n+++ /tmp/tmpz8va3ib2.java\t2022-07-19 10:16:46.249537397 +0200\n@@ -52,15 +52,11 @@\n \n //        System.err.println(\"COMPARING: \" +\n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext || l instanceof SelfContext) {\n-            l = ((EvalContext) l).getSingleNodePointer();\n-        }\n-\n-        if (r instanceof InitialContext || r instanceof SelfContext) {\n+if (l instanceof InitialContext || l instanceof SelfContext || l instanceof SelfContext) {\n             r = ((EvalContext) r).getSingleNodePointer();\n         }\n \n         if (l instanceof Collection) {\n             l = ((Collection) l).iterator();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (l instanceof InitialContext || l instanceof SelfContext) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-6/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\t2022-07-19 10:16:51.013510233 +0200\n+++ /tmp/tmpl4wd9avj.java\t2022-07-19 10:16:51.013510233 +0200\n@@ -52,15 +52,11 @@\n \n //        System.err.println(\"COMPARING: \" +\n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext || l instanceof SelfContext) {\n-            l = ((EvalContext) l).getSingleNodePointer();\n-        }\n-\n-        if (r instanceof InitialContext || r instanceof SelfContext) {\n+if (l instanceof InitialContext || l instanceof SelfContext) {\n             r = ((EvalContext) r).getSingleNodePointer();\n         }\n \n         if (l instanceof Collection) {\n             l = ((Collection) l).iterator();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (l instanceof InitialContext || r instanceof SelfContext) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-6/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\t2022-07-19 10:16:55.353485479 +0200\n+++ /tmp/tmpo7j1xyh9.java\t2022-07-19 10:16:55.353485479 +0200\n@@ -52,15 +52,11 @@\n \n //        System.err.println(\"COMPARING: \" +\n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext || l instanceof SelfContext) {\n-            l = ((EvalContext) l).getSingleNodePointer();\n-        }\n-\n-        if (r instanceof InitialContext || r instanceof SelfContext) {\n+if (l instanceof InitialContext || r instanceof SelfContext) {\n             r = ((EvalContext) r).getSingleNodePointer();\n         }\n \n         if (l instanceof Collection) {\n             l = ((Collection) l).iterator();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (l instanceof InitialContext || l instanceof SelfContext || l instanceof SelfContext || l instanceof SelfContext) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-6/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\t2022-07-19 10:16:59.665460880 +0200\n+++ /tmp/tmphmv1b7_3.java\t2022-07-19 10:16:59.669460858 +0200\n@@ -52,15 +52,11 @@\n \n //        System.err.println(\"COMPARING: \" +\n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext || l instanceof SelfContext) {\n-            l = ((EvalContext) l).getSingleNodePointer();\n-        }\n-\n-        if (r instanceof InitialContext || r instanceof SelfContext) {\n+if (l instanceof InitialContext || l instanceof SelfContext || l instanceof SelfContext || l instanceof SelfContext) {\n             r = ((EvalContext) r).getSingleNodePointer();\n         }\n \n         if (l instanceof Collection) {\n             l = ((Collection) l).iterator();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (l instanceof InitialContext || r instanceof SelfContext || l instanceof SelfContext) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-6/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\t2022-07-19 10:17:03.893436756 +0200\n+++ /tmp/tmpkhb96z43.java\t2022-07-19 10:17:03.893436756 +0200\n@@ -52,15 +52,11 @@\n \n //        System.err.println(\"COMPARING: \" +\n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext || l instanceof SelfContext) {\n-            l = ((EvalContext) l).getSingleNodePointer();\n-        }\n-\n-        if (r instanceof InitialContext || r instanceof SelfContext) {\n+if (l instanceof InitialContext || r instanceof SelfContext || l instanceof SelfContext) {\n             r = ((EvalContext) r).getSingleNodePointer();\n         }\n \n         if (l instanceof Collection) {\n             l = ((Collection) l).iterator();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (l instanceof InitialContext || l instanceof SelfContext || l instanceof SelfContext) { return ((EvalContext) l).getSingleNodePointer(); } if (r instanceof InitialContext || l instanceof SelfContext) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-6/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\t2022-07-19 10:17:08.137412535 +0200\n+++ /tmp/tmp9onq1meq.java\t2022-07-19 10:17:08.137412535 +0200\n@@ -52,15 +52,11 @@\n \n //        System.err.println(\"COMPARING: \" +\n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext || l instanceof SelfContext) {\n-            l = ((EvalContext) l).getSingleNodePointer();\n-        }\n-\n-        if (r instanceof InitialContext || r instanceof SelfContext) {\n+if (l instanceof InitialContext || l instanceof SelfContext || l instanceof SelfContext) { return ((EvalContext) l).getSingleNodePointer(); } if (r instanceof InitialContext || l instanceof SelfContext) {\n             r = ((EvalContext) r).getSingleNodePointer();\n         }\n \n         if (l instanceof Collection) {\n             l = ((Collection) l).iterator();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (l instanceof InitialContext || l instanceof SelfContext || l instanceof SelfContext) { // ((EvalContext) l).getSingleNodePointer(); } if (r instanceof InitialContext || l instanceof SelfContext) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-6/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\t2022-07-19 10:17:09.813402969 +0200\n+++ /tmp/tmpfa9vomfi.java\t2022-07-19 10:17:09.813402969 +0200\n@@ -52,15 +52,11 @@\n \n //        System.err.println(\"COMPARING: \" +\n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext || l instanceof SelfContext) {\n-            l = ((EvalContext) l).getSingleNodePointer();\n-        }\n-\n-        if (r instanceof InitialContext || r instanceof SelfContext) {\n+if (l instanceof InitialContext || l instanceof SelfContext || l instanceof SelfContext) { // ((EvalContext) l).getSingleNodePointer(); } if (r instanceof InitialContext || l instanceof SelfContext) {\n             r = ((EvalContext) r).getSingleNodePointer();\n         }\n \n         if (l instanceof Collection) {\n             l = ((Collection) l).iterator();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (l instanceof InitialContext || l instanceof SelfContext || l instanceof SelfContext) { return ((EvalContext) l).getSingleNodePointer(); } if (r instanceof InitialContext) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-6/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\t2022-07-19 10:17:13.881379744 +0200\n+++ /tmp/tmpf6if69dv.java\t2022-07-19 10:17:13.885379721 +0200\n@@ -52,15 +52,11 @@\n \n //        System.err.println(\"COMPARING: \" +\n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext || l instanceof SelfContext) {\n-            l = ((EvalContext) l).getSingleNodePointer();\n-        }\n-\n-        if (r instanceof InitialContext || r instanceof SelfContext) {\n+if (l instanceof InitialContext || l instanceof SelfContext || l instanceof SelfContext) { return ((EvalContext) l).getSingleNodePointer(); } if (r instanceof InitialContext) {\n             r = ((EvalContext) r).getSingleNodePointer();\n         }\n \n         if (l instanceof Collection) {\n             l = ((Collection) l).iterator();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (l instanceof InitialContext || l instanceof SelfContext || l instanceof SelfContext) { // ((EvalContext) l).getSingleNodePointer(); } if (r instanceof InitialContext) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-6/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\t2022-07-19 10:17:15.537370290 +0200\n+++ /tmp/tmpn4shrtth.java\t2022-07-19 10:17:15.537370290 +0200\n@@ -52,15 +52,11 @@\n \n //        System.err.println(\"COMPARING: \" +\n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext || l instanceof SelfContext) {\n-            l = ((EvalContext) l).getSingleNodePointer();\n-        }\n-\n-        if (r instanceof InitialContext || r instanceof SelfContext) {\n+if (l instanceof InitialContext || l instanceof SelfContext || l instanceof SelfContext) { // ((EvalContext) l).getSingleNodePointer(); } if (r instanceof InitialContext) {\n             r = ((EvalContext) r).getSingleNodePointer();\n         }\n \n         if (l instanceof Collection) {\n             l = ((Collection) l).iterator();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (l instanceof InitialContext || l instanceof SelfContext || l instanceof SelfContext) { return ((EvalContext) l).getSingleNodePointer(); } if (r instanceof InitialContext || r instanceof InitialContext) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-6/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\t2022-07-19 10:17:19.909345324 +0200\n+++ /tmp/tmp33u552g7.java\t2022-07-19 10:17:19.909345324 +0200\n@@ -52,15 +52,11 @@\n \n //        System.err.println(\"COMPARING: \" +\n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext || l instanceof SelfContext) {\n-            l = ((EvalContext) l).getSingleNodePointer();\n-        }\n-\n-        if (r instanceof InitialContext || r instanceof SelfContext) {\n+if (l instanceof InitialContext || l instanceof SelfContext || l instanceof SelfContext) { return ((EvalContext) l).getSingleNodePointer(); } if (r instanceof InitialContext || r instanceof InitialContext) {\n             r = ((EvalContext) r).getSingleNodePointer();\n         }\n \n         if (l instanceof Collection) {\n             l = ((Collection) l).iterator();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (l instanceof InitialContext || l instanceof SelfContext) { l = ((EvalContext) l).getSingleNodePointer(); } if (r instanceof InitialContext || r instanceof SelfContext) {",
        "fixed_line": "if (l instanceof InitialContext) { ((EvalContext) l).reset(); } if (l instanceof SelfContext) { l = ((EvalContext) l).getSingleNodePointer(); } if (r instanceof InitialContext) { ((EvalContext) r).reset(); } if (r instanceof SelfContext) {"
    },
    "JacksonCore-4": {
        "fixes": [
            {
                "k": 1,
                "patch": "int newLen = (len == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + len) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-4/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 10:17:21.985333467 +0200\n+++ /tmp/tmp05jab137.java\t2022-07-19 10:17:22.021333261 +0200\n@@ -581,11 +581,11 @@\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n         // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+int newLen = (len == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + len) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n     /**\n      * Method called to expand size of the current segment, to\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 2,
                "patch": "int newLen = (len == 0)? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-4/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 10:17:27.005304792 +0200\n+++ /tmp/tmpzgvpae8j.java\t2022-07-19 10:17:27.009304769 +0200\n@@ -581,11 +581,11 @@\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n         // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+int newLen = (len == 0)? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n     /**\n      * Method called to expand size of the current segment, to\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int newLen = (_currentSegment.length == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-4/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 10:17:31.757277639 +0200\n+++ /tmp/tmprpdgddpb.java\t2022-07-19 10:17:31.757277639 +0200\n@@ -581,11 +581,11 @@\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n         // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+int newLen = (_currentSegment.length == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n     /**\n      * Method called to expand size of the current segment, to\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int newLen = (_currentSegment.length == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + len) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-4/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 10:17:36.481250642 +0200\n+++ /tmp/tmpfnxa3fno.java\t2022-07-19 10:17:36.485250619 +0200\n@@ -581,11 +581,11 @@\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n         // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+int newLen = (_currentSegment.length == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + len) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n     /**\n      * Method called to expand size of the current segment, to\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 5,
                "patch": "int newLen = (len == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 5) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-4/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 10:17:41.277223227 +0200\n+++ /tmp/tmp616qwjlh.java\t2022-07-19 10:17:41.277223227 +0200\n@@ -581,11 +581,11 @@\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n         // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+int newLen = (len == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 5) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n     /**\n      * Method called to expand size of the current segment, to\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int newLen = (len == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 0) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-4/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 10:17:45.977196355 +0200\n+++ /tmp/tmpqvwx41ts.java\t2022-07-19 10:17:45.977196355 +0200\n@@ -581,11 +581,11 @@\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n         // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+int newLen = (len == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 0) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n     /**\n      * Method called to expand size of the current segment, to\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int newLen = (len == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-4/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 10:17:50.569170095 +0200\n+++ /tmp/tmpa2k_w7sn.java\t2022-07-19 10:17:50.569170095 +0200\n@@ -581,11 +581,11 @@\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n         // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+int newLen = (len == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n     /**\n      * Method called to expand size of the current segment, to\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int newLen = (len == 0)? (MAX_SEGMENT_LEN + len) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-4/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 10:17:55.249143325 +0200\n+++ /tmp/tmpgcame_jt.java\t2022-07-19 10:17:55.249143325 +0200\n@@ -581,11 +581,11 @@\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n         // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+int newLen = (len == 0)? (MAX_SEGMENT_LEN + len) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n     /**\n      * Method called to expand size of the current segment, to\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int newLen = (len == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 8) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-4/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 10:18:00.053115841 +0200\n+++ /tmp/tmp0xm893xs.java\t2022-07-19 10:18:00.053115841 +0200\n@@ -581,11 +581,11 @@\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n         // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+int newLen = (len == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 8) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n     /**\n      * Method called to expand size of the current segment, to\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int newLen = (_currentSegment.length == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len % 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-4/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-19 10:18:04.765088877 +0200\n+++ /tmp/tmpn0b2stz5.java\t2022-07-19 10:18:04.765088877 +0200\n@@ -581,11 +581,11 @@\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n         // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+int newLen = (_currentSegment.length == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len % 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n     /**\n      * Method called to expand size of the current segment, to\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));",
        "fixed_line": "int newLen = len + (len >> 1); // but above intended maximum, slow to increase by 25% if (newLen > MAX_SEGMENT_LEN) { newLen = len + (len >> 2); }"
    },
    "Jsoup-40": {
        "fixes": [
            {
                "k": 1,
                "patch": "Validate.notEmpty(name);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-40/src/main/java/org/jsoup/nodes/DocumentType.java\t2022-07-19 10:18:09.453062046 +0200\n+++ /tmp/tmpouc27zfr.java\t2022-07-19 10:18:09.473061931 +0200\n@@ -17,11 +17,11 @@\n      * @param baseUri the doctype's base URI\n      */\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+Validate.notEmpty(name);\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "Validate.notEmpty(baseUri);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-40/src/main/java/org/jsoup/nodes/DocumentType.java\t2022-07-19 10:18:15.169029327 +0200\n+++ /tmp/tmppjekkeaf.java\t2022-07-19 10:18:15.169029327 +0200\n@@ -17,11 +17,11 @@\n      * @param baseUri the doctype's base URI\n      */\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+Validate.notEmpty(baseUri);\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "Validate.notEmpty(name); // value is lower case",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-40/src/main/java/org/jsoup/nodes/DocumentType.java\t2022-07-19 10:18:21.116995266 +0200\n+++ /tmp/tmp5byte1d5.java\t2022-07-19 10:18:21.116995266 +0200\n@@ -17,11 +17,11 @@\n      * @param baseUri the doctype's base URI\n      */\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+Validate.notEmpty(name); // value is lower case\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "Validate.notEmpty(value);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-40/src/main/java/org/jsoup/nodes/DocumentType.java\t2022-07-19 10:18:26.724963140 +0200\n+++ /tmp/tmpghqt55sc.java\t2022-07-19 10:18:26.724963140 +0200\n@@ -17,11 +17,11 @@\n      * @param baseUri the doctype's base URI\n      */\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+Validate.notEmpty(value);\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "Validate.notEmpty(signature);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-40/src/main/java/org/jsoup/nodes/DocumentType.java\t2022-07-19 10:18:29.396947836 +0200\n+++ /tmp/tmpnz0vn5io.java\t2022-07-19 10:18:29.396947836 +0200\n@@ -17,11 +17,11 @@\n      * @param baseUri the doctype's base URI\n      */\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+Validate.notEmpty(signature);\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "Validate.notEmpty(name); // name = name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-40/src/main/java/org/jsoup/nodes/DocumentType.java\t2022-07-19 10:18:32.244931515 +0200\n+++ /tmp/tmp99q7izsg.java\t2022-07-19 10:18:32.248931492 +0200\n@@ -17,11 +17,11 @@\n      * @param baseUri the doctype's base URI\n      */\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+Validate.notEmpty(name); // name = name;\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "Validate.notEmpty(name); // TODO: return name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-40/src/main/java/org/jsoup/nodes/DocumentType.java\t2022-07-19 10:18:37.832899494 +0200\n+++ /tmp/tmpn4zkidpp.java\t2022-07-19 10:18:37.832899494 +0200\n@@ -17,11 +17,11 @@\n      * @param baseUri the doctype's base URI\n      */\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+Validate.notEmpty(name); // TODO: return name;\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "Validate.notEmpty(desc);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-40/src/main/java/org/jsoup/nodes/DocumentType.java\t2022-07-19 10:18:43.100869296 +0200\n+++ /tmp/tmpstlneoa1.java\t2022-07-19 10:18:43.100869296 +0200\n@@ -17,11 +17,11 @@\n      * @param baseUri the doctype's base URI\n      */\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+Validate.notEmpty(desc);\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "Validate.notEmpty(index);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-40/src/main/java/org/jsoup/nodes/DocumentType.java\t2022-07-19 10:18:45.828853658 +0200\n+++ /tmp/tmpc76d7i55.java\t2022-07-19 10:18:45.828853658 +0200\n@@ -17,11 +17,11 @@\n      * @param baseUri the doctype's base URI\n      */\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+Validate.notEmpty(index);\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "Validate.notEmpty(name); // name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-40/src/main/java/org/jsoup/nodes/DocumentType.java\t2022-07-19 10:18:48.408838858 +0200\n+++ /tmp/tmpdmnt30i3.java\t2022-07-19 10:18:48.408838858 +0200\n@@ -17,11 +17,11 @@\n      * @param baseUri the doctype's base URI\n      */\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+Validate.notEmpty(name); // name;\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "Validate.notEmpty(name);",
        "fixed_line": ""
    },
    "Jsoup-45": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if ((\"td\".equals(name) && \"td\".equals(name) &&!last)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-45/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2022-07-19 10:18:54.224805517 +0200\n+++ /tmp/tmpq0lkiurw.java\t2022-07-19 10:18:55.076800622 +0200\n@@ -389,11 +389,11 @@\n             }\n             String name = node.nodeName();\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+} else if ((\"td\".equals(name) && \"td\".equals(name) &&!last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InRow);\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if ((\"td\".equals(name) || \"td\".equals(name) &&!last)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-45/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2022-07-19 10:19:01.680762741 +0200\n+++ /tmp/tmp18ha_kvx.java\t2022-07-19 10:19:01.688762695 +0200\n@@ -389,11 +389,11 @@\n             }\n             String name = node.nodeName();\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+} else if ((\"td\".equals(name) || \"td\".equals(name) &&!last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InRow);\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if ((\"td\".equals(name)) && \"td\".equals(name) &&!last)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-45/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2022-07-19 10:19:07.396729957 +0200\n+++ /tmp/tmpclsctx05.java\t2022-07-19 10:19:07.468729544 +0200\n@@ -389,11 +389,11 @@\n             }\n             String name = node.nodeName();\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+} else if ((\"td\".equals(name)) && \"td\".equals(name) &&!last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InRow);\n                 break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if ((\"td\".equals(name) || \"td\".equals(name) ||!last)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-45/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2022-07-19 10:19:09.912715514 +0200\n+++ /tmp/tmpvez5g2lh.java\t2022-07-19 10:19:09.912715514 +0200\n@@ -389,11 +389,11 @@\n             }\n             String name = node.nodeName();\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+} else if ((\"td\".equals(name) || \"td\".equals(name) ||!last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InRow);\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 5,
                "patch": "} else if ((\"td\".equals(name) && \"td\".equals(name) ||!last)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-45/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2022-07-19 10:19:16.064680212 +0200\n+++ /tmp/tmpzkvwq6nj.java\t2022-07-19 10:19:16.064680212 +0200\n@@ -389,11 +389,11 @@\n             }\n             String name = node.nodeName();\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+} else if ((\"td\".equals(name) && \"td\".equals(name) ||!last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InRow);\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 6,
                "patch": "} else if ((\"td\".equals(name)) || \"td\".equals(name) &&!last)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-45/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2022-07-19 10:19:20.484654837 +0200\n+++ /tmp/tmp_7kbneua.java\t2022-07-19 10:19:20.484654837 +0200\n@@ -389,11 +389,11 @@\n             }\n             String name = node.nodeName();\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+} else if ((\"td\".equals(name)) || \"td\".equals(name) &&!last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InRow);\n                 break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if ((\"td\".equals(name) == 'td\".equals(name) &&!last)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-45/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2022-07-19 10:19:22.632642507 +0200\n+++ /tmp/tmp9dmrarcf.java\t2022-07-19 10:19:22.632642507 +0200\n@@ -389,11 +389,11 @@\n             }\n             String name = node.nodeName();\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+} else if ((\"td\".equals(name) == 'td\".equals(name) &&!last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InRow);\n                 break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if ((\"td\".equals(name) && \"td\".equals(name)) &&!last)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-45/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2022-07-19 10:19:25.208627717 +0200\n+++ /tmp/tmpubreltji.java\t2022-07-19 10:19:25.208627717 +0200\n@@ -389,11 +389,11 @@\n             }\n             String name = node.nodeName();\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+} else if ((\"td\".equals(name) && \"td\".equals(name)) &&!last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InRow);\n                 break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if ((\"td\".equals(name) && \"td\".equals(name) == 'last)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-45/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2022-07-19 10:19:27.536614350 +0200\n+++ /tmp/tmp1zpram87.java\t2022-07-19 10:19:28.316609868 +0200\n@@ -389,11 +389,11 @@\n             }\n             String name = node.nodeName();\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+} else if ((\"td\".equals(name) && \"td\".equals(name) == 'last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InRow);\n                 break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if ((\"td\".equals(name) || \"td\".equals(name) == 'last)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-45/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2022-07-19 10:19:31.392592204 +0200\n+++ /tmp/tmpijqorc44.java\t2022-07-19 10:19:31.392592204 +0200\n@@ -389,11 +389,11 @@\n             }\n             String name = node.nodeName();\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+} else if ((\"td\".equals(name) || \"td\".equals(name) == 'last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InRow);\n                 break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "} else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {",
        "fixed_line": "} else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {"
    },
    "Csv-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "final String recordSeparator = format.getRecordSeparator(); newRecord = false; }",
                "patch_diff": "final String recordSeparator = format.getRecordSeparator(); newRecord = false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "final String recordSeparator = format.getRecordSeparator(); newRecord = true; }",
                "patch_diff": "final String recordSeparator = format.getRecordSeparator(); newRecord = true; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "final String recordSeparator = format.getRecordSeparator(); newRecord = false;",
                "patch_diff": "final String recordSeparator = format.getRecordSeparator(); newRecord = false;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "final String recordSeparator = format.getRecordSeparator();",
                "patch_diff": "final String recordSeparator = format.getRecordSeparator();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "final String recordSeparator = format.getRecordSeparator(); newRecord = format.getRecordSeparator();",
                "patch_diff": "final String recordSeparator = format.getRecordSeparator(); newRecord = format.getRecordSeparator();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "final String recordSeparator = format.getRecordSeparator(); newRecord = format; }",
                "patch_diff": "final String recordSeparator = format.getRecordSeparator(); newRecord = format; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "final String recordSeparator = format.getRecordSeparator(); newRecord = true;",
                "patch_diff": "final String recordSeparator = format.getRecordSeparator(); newRecord = true;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "final String recordSeparator = format.getRecordSeparator(); newRecord = format;",
                "patch_diff": "final String recordSeparator = format.getRecordSeparator(); newRecord = format;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "final String recordSeparator = format.getRecordSeparator(); newRecord = format.next; }",
                "patch_diff": "final String recordSeparator = format.getRecordSeparator(); newRecord = format.next; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "final String recordSeparator = format; newRecord = format.getRecordSeparator();",
                "patch_diff": "final String recordSeparator = format; newRecord = format.getRecordSeparator();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (recordSeparator != null) { out.append(recordSeparator); }"
    },
    "JacksonDatabind-2": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int i = 0; i < len; ++i) {",
                "patch_diff": "for (int i = 0; i < len; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = 0; i < _children.length; i++) {",
                "patch_diff": "for (int i = 0; i < _children.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0; i < _children.length; ++i) {",
                "patch_diff": "for (int i = 0; i < _children.length; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = 0; i < _coll.length; i++) {",
                "patch_diff": "for (int i = 0; i < _coll.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = 0; i < len; ++k) {",
                "patch_diff": "for (int i = 0; i < len; ++k) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "_report(JsonToken.VALUE_STRING, value);",
                "patch_diff": "_report(JsonToken.VALUE_STRING, value);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "_report(JsonToken.VALUE_STRING, _nextObject()) {",
                "patch_diff": "_report(JsonToken.VALUE_STRING, _nextObject()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "_report(JsonToken.VALUE_STRING, _writeObject()) {",
                "patch_diff": "_report(JsonToken.VALUE_STRING, _writeObject()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "_report(JsonToken.VALUE_STRING, _nextToken() {",
                "patch_diff": "_report(JsonToken.VALUE_STRING, _nextToken() {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "_report(JsonToken.VALUE_EMBEDDED_OBJECT, should never be valid)",
                "patch_diff": "_report(JsonToken.VALUE_EMBEDDED_OBJECT, should never be valid)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (value == null) { writeNull(); return; } Class<?> raw = value.getClass(); if (raw == byte[].class) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); return; } else if (_objectCodec == null) { /* 28-May-2014, tatu: Tricky choice here; if no codec, should we * err out, or just embed? For now, do latter. */ // throw new JsonMappingException(\"No ObjectCodec configured for TokenBuffer, writeObject() called\"); _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else { _objectCodec.writeValue(this, value); } } @Override public void writeTree(TreeNode node) throws IOException { if (node == null) { writeNull(); return; } if (_objectCodec == null) { // as with 'writeObject()', is codec optional? _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else { _objectCodec.writeTree(this, node); }"
    },
    "Math-88": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (coefficients == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 10:19:38.364552159 +0200\n+++ /tmp/tmpfxagkuy5.java\t2022-07-19 10:19:39.408546161 +0200\n@@ -331,16 +331,11 @@\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n-            if (basicRow != null) {\n-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n-                    }\n-                }\n+if (coefficients == null) {\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (basicRow == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 10:19:50.244483894 +0200\n+++ /tmp/tmpld_a9kr3.java\t2022-07-19 10:19:50.244483894 +0200\n@@ -331,16 +331,11 @@\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n-            if (basicRow != null) {\n-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n-                    }\n-                }\n+if (basicRow == null) {\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (coefficients == null) { throw new IllegalArgumentException(\"Null 'coefficients' argument.\"); j = 0; } else if (basicRow[i] == 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 10:19:56.448448239 +0200\n+++ /tmp/tmpsxr_v7n3.java\t2022-07-19 10:19:56.448448239 +0200\n@@ -331,16 +331,11 @@\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n-            if (basicRow != null) {\n-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n-                    }\n-                }\n+if (coefficients == null) { throw new IllegalArgumentException(\"Null 'coefficients' argument.\"); j = 0; } else if (basicRow[i] == 1) {\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (basicRow == null) { // block == null; non-empty's after name; } else if (basicRow[i] == 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 10:19:58.624435730 +0200\n+++ /tmp/tmp5uylu7n5.java\t2022-07-19 10:19:58.624435730 +0200\n@@ -331,16 +331,11 @@\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n-            if (basicRow != null) {\n-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n-                    }\n-                }\n+if (basicRow == null) { // block == null; non-empty's after name; } else if (basicRow[i] == 1) {\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (coefficients == null) { throw new IllegalArgumentException(\"Null 'coefficients' argument.\"); j++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 10:20:04.768400405 +0200\n+++ /tmp/tmpsd4ubepe.java\t2022-07-19 10:20:04.768400405 +0200\n@@ -331,16 +331,11 @@\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n-            if (basicRow != null) {\n-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n-                    }\n-                }\n+if (coefficients == null) { throw new IllegalArgumentException(\"Null 'coefficients' argument.\"); j++) {\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (basicRow == null) { throw new IllegalArgumentException(\"Null 'coefficients' argument.\"); j = 0; } else if (basicRow[i] == 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 10:20:06.716389203 +0200\n+++ /tmp/tmpbo9epiqf.java\t2022-07-19 10:20:06.716389203 +0200\n@@ -331,16 +331,11 @@\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n-            if (basicRow != null) {\n-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n-                    }\n-                }\n+if (basicRow == null) { throw new IllegalArgumentException(\"Null 'coefficients' argument.\"); j = 0; } else if (basicRow[i] == 1) {\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (basicRow == null) { throw new IllegalArgumentException(\"Null 'coefficients' argument.\"); j++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 10:20:08.788377288 +0200\n+++ /tmp/tmpsr1pcb08.java\t2022-07-19 10:20:08.792377265 +0200\n@@ -331,16 +331,11 @@\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n-            if (basicRow != null) {\n-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n-                    }\n-                }\n+if (basicRow == null) { throw new IllegalArgumentException(\"Null 'coefficients' argument.\"); j++) {\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (coefficients == null) { throw new IllegalArgumentException(\"Null 'coefficients' argument.\"); } else if (basicRow[i] == 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 10:20:10.740366061 +0200\n+++ /tmp/tmpukz8qoyo.java\t2022-07-19 10:20:10.740366061 +0200\n@@ -331,16 +331,11 @@\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n-            if (basicRow != null) {\n-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n-                    }\n-                }\n+if (coefficients == null) { throw new IllegalArgumentException(\"Null 'coefficients' argument.\"); } else if (basicRow[i] == 1) {\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (coefficients == null) { throw new IllegalArgumentException(\"Null 'coefficients' argument.\"); j = 0; } else if (coefficients[i] == 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 10:20:12.812354144 +0200\n+++ /tmp/tmp53jn6wwa.java\t2022-07-19 10:20:12.812354144 +0200\n@@ -331,16 +331,11 @@\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n-            if (basicRow != null) {\n-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n-                    }\n-                }\n+if (coefficients == null) { throw new IllegalArgumentException(\"Null 'coefficients' argument.\"); j = 0; } else if (coefficients[i] == 1) {\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (coefficients == null) { throw new IllegalArgumentException(\"Null 'coefficients' argument.\"); j = 0; } else if (basicRow[i] = 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-19 10:20:14.920342019 +0200\n+++ /tmp/tmptg5jsyg0.java\t2022-07-19 10:20:14.920342019 +0200\n@@ -331,16 +331,11 @@\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n-            if (basicRow != null) {\n-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n-                    }\n-                }\n+if (coefficients == null) { throw new IllegalArgumentException(\"Null 'coefficients' argument.\"); j = 0; } else if (basicRow[i] = 0;\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (basicRow != null) { for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) { if (tableau.getEntry(basicRow, j) == 1) { coefficients[i] = 0; } }",
        "fixed_line": "Set<Integer> basicRows = new HashSet<Integer>(); for (int i = 0; i < coefficients.length; i++) { basicRow = getBasicRow(getNumObjectiveFunctions() + i); if (basicRows.contains(basicRow)) { // if multiple variables can take a given value // then we choose the first and set the rest equal to 0 coefficients[i] = 0; } else { basicRows.add(basicRow);"
    },
    "Gson-10": {
        "fixes": [
            {
                "k": 1,
                "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, callback.getType());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\t2022-07-19 10:20:17.276328464 +0200\n+++ /tmp/tmpvz7qchuw.java\t2022-07-19 10:20:17.328328166 +0200\n@@ -117,12 +117,11 @@\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n+TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, callback.getType());\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, element.getType());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\t2022-07-19 10:20:19.124317835 +0200\n+++ /tmp/tmp341h3rzs.java\t2022-07-19 10:20:19.124317835 +0200\n@@ -117,12 +117,11 @@\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n+TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, element.getType());\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, value, typeAdapter, as per [JACKSON-407] --raw)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\t2022-07-19 10:20:20.808308148 +0200\n+++ /tmp/tmpfnxarg2w.java\t2022-07-19 10:20:20.808308148 +0200\n@@ -117,12 +117,11 @@\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n+TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, value, typeAdapter, as per [JACKSON-407] --raw)\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, as per [JACKSON-407] --raw)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\t2022-07-19 10:20:22.368299171 +0200\n+++ /tmp/tmphu6nbx46.java\t2022-07-19 10:20:22.368299171 +0200\n@@ -117,12 +117,11 @@\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n+TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, as per [JACKSON-407] --raw)\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, value, typeAdapter, as per RFC 46 property name.getType());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\t2022-07-19 10:20:23.964289988 +0200\n+++ /tmp/tmprz3by1p1.java\t2022-07-19 10:20:23.964289988 +0200\n@@ -117,12 +117,11 @@\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n+TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, value, typeAdapter, as per RFC 46 property name.getType());\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, value, typeAdapter, element.getType());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\t2022-07-19 10:20:25.520281036 +0200\n+++ /tmp/tmpeficcj4g.java\t2022-07-19 10:20:25.520281036 +0200\n@@ -117,12 +117,11 @@\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n+TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, value, typeAdapter, element.getType());\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, value, typeAdapter, callback.getType());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\t2022-07-19 10:20:27.152271645 +0200\n+++ /tmp/tmpws25cnse.java\t2022-07-19 10:20:27.152271645 +0200\n@@ -117,12 +117,11 @@\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n+TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, value, typeAdapter, callback.getType());\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, value.getType());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\t2022-07-19 10:20:28.820262046 +0200\n+++ /tmp/tmpn6h3un6q.java\t2022-07-19 10:20:28.820262046 +0200\n@@ -117,12 +117,11 @@\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n+TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, value.getType());\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, value, typeAdapter, as per RFC 46 property name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\t2022-07-19 10:20:30.448252676 +0200\n+++ /tmp/tmp0i4r61kx.java\t2022-07-19 10:20:30.448252676 +0200\n@@ -117,12 +117,11 @@\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n+TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, value, typeAdapter, as per RFC 46 property name;\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, value, typeAdapter, as per [JACKSON-407] --raw == Type.ARRAY) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\t2022-07-19 10:20:32.024243606 +0200\n+++ /tmp/tmpqlyu37r2.java\t2022-07-19 10:20:32.028243583 +0200\n@@ -117,12 +117,11 @@\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n+TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, value, typeAdapter, as per [JACKSON-407] --raw == Type.ARRAY) {\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());",
        "fixed_line": "TypeAdapter t = jsonAdapterPresent ? typeAdapter : new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());"
    },
    "Time-23": {
        "fixes": [
            {
                "k": 1,
                "patch": "map.put(\"IET\", \"America/Inderica/Ind.put(\"PRT\", \"America/Saigon\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-23/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 10:20:33.968232417 +0200\n+++ /tmp/tmpjj9edr56.java\t2022-07-19 10:20:34.040232002 +0200\n@@ -567,27 +567,11 @@\n             map.put(\"PST\", \"America/Los_Angeles\");\n             map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indianapolis\");\n-            map.put(\"PRT\", \"America/Puerto_Rico\");\n-            map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Buenos_Aires\");\n-            map.put(\"BET\", \"America/Sao_Paulo\");\n-            map.put(\"WET\", \"Europe/London\");\n-            map.put(\"ECT\", \"Europe/Paris\");\n-            map.put(\"ART\", \"Africa/Cairo\");\n-            map.put(\"CAT\", \"Africa/Harare\");\n-            map.put(\"EET\", \"Europe/Bucharest\");\n-            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n-            map.put(\"MET\", \"Asia/Tehran\");\n-            map.put(\"NET\", \"Asia/Yerevan\");\n-            map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Calcutta\");\n-            map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Saigon\");\n+map.put(\"IET\", \"America/Inderica/Ind.put(\"PRT\", \"America/Saigon\");\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n             map.put(\"AET\", \"Australia/Sydney\");\n             map.put(\"SST\", \"Pacific/Guadalcanal\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "map.put(\"IET\", \"America/Ind.put(\"PRT\", \"America/Saigon\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-23/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 10:20:35.716222355 +0200\n+++ /tmp/tmppt504wfw.java\t2022-07-19 10:20:35.716222355 +0200\n@@ -567,27 +567,11 @@\n             map.put(\"PST\", \"America/Los_Angeles\");\n             map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indianapolis\");\n-            map.put(\"PRT\", \"America/Puerto_Rico\");\n-            map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Buenos_Aires\");\n-            map.put(\"BET\", \"America/Sao_Paulo\");\n-            map.put(\"WET\", \"Europe/London\");\n-            map.put(\"ECT\", \"Europe/Paris\");\n-            map.put(\"ART\", \"Africa/Cairo\");\n-            map.put(\"CAT\", \"Africa/Harare\");\n-            map.put(\"EET\", \"Europe/Bucharest\");\n-            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n-            map.put(\"MET\", \"Asia/Tehran\");\n-            map.put(\"NET\", \"Asia/Yerevan\");\n-            map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Calcutta\");\n-            map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Saigon\");\n+map.put(\"IET\", \"America/Ind.put(\"PRT\", \"America/Saigon\");\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n             map.put(\"AET\", \"Australia/Sydney\");\n             map.put(\"SST\", \"Pacific/Guadalcanal\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "map.put(\"IET\", \"America/Ind.put(\"PRT\", \"America/Sbigon\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-23/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 10:20:37.324213100 +0200\n+++ /tmp/tmpi26em2kw.java\t2022-07-19 10:20:37.324213100 +0200\n@@ -567,27 +567,11 @@\n             map.put(\"PST\", \"America/Los_Angeles\");\n             map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indianapolis\");\n-            map.put(\"PRT\", \"America/Puerto_Rico\");\n-            map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Buenos_Aires\");\n-            map.put(\"BET\", \"America/Sao_Paulo\");\n-            map.put(\"WET\", \"Europe/London\");\n-            map.put(\"ECT\", \"Europe/Paris\");\n-            map.put(\"ART\", \"Africa/Cairo\");\n-            map.put(\"CAT\", \"Africa/Harare\");\n-            map.put(\"EET\", \"Europe/Bucharest\");\n-            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n-            map.put(\"MET\", \"Asia/Tehran\");\n-            map.put(\"NET\", \"Asia/Yerevan\");\n-            map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Calcutta\");\n-            map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Saigon\");\n+map.put(\"IET\", \"America/Ind.put(\"PRT\", \"America/Sbigon\");\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n             map.put(\"AET\", \"Australia/Sydney\");\n             map.put(\"SST\", \"Pacific/Guadalcanal\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "map.put(\"IET\", \"America/Inderica/Ind.put(\"PRT\", \"America/Sbigon\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-23/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 10:20:38.944203774 +0200\n+++ /tmp/tmpe0mm5age.java\t2022-07-19 10:20:38.948203751 +0200\n@@ -567,27 +567,11 @@\n             map.put(\"PST\", \"America/Los_Angeles\");\n             map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indianapolis\");\n-            map.put(\"PRT\", \"America/Puerto_Rico\");\n-            map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Buenos_Aires\");\n-            map.put(\"BET\", \"America/Sao_Paulo\");\n-            map.put(\"WET\", \"Europe/London\");\n-            map.put(\"ECT\", \"Europe/Paris\");\n-            map.put(\"ART\", \"Africa/Cairo\");\n-            map.put(\"CAT\", \"Africa/Harare\");\n-            map.put(\"EET\", \"Europe/Bucharest\");\n-            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n-            map.put(\"MET\", \"Asia/Tehran\");\n-            map.put(\"NET\", \"Asia/Yerevan\");\n-            map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Calcutta\");\n-            map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Saigon\");\n+map.put(\"IET\", \"America/Inderica/Ind.put(\"PRT\", \"America/Sbigon\");\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n             map.put(\"AET\", \"Australia/Sydney\");\n             map.put(\"SST\", \"Pacific/Guadalcanal\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "map.put(\"IET\", \"America/IndBlock.put(\"PRT\", \"America/Saigon\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-23/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 10:20:40.476194954 +0200\n+++ /tmp/tmpg_hjox55.java\t2022-07-19 10:20:40.480194931 +0200\n@@ -567,27 +567,11 @@\n             map.put(\"PST\", \"America/Los_Angeles\");\n             map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indianapolis\");\n-            map.put(\"PRT\", \"America/Puerto_Rico\");\n-            map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Buenos_Aires\");\n-            map.put(\"BET\", \"America/Sao_Paulo\");\n-            map.put(\"WET\", \"Europe/London\");\n-            map.put(\"ECT\", \"Europe/Paris\");\n-            map.put(\"ART\", \"Africa/Cairo\");\n-            map.put(\"CAT\", \"Africa/Harare\");\n-            map.put(\"EET\", \"Europe/Bucharest\");\n-            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n-            map.put(\"MET\", \"Asia/Tehran\");\n-            map.put(\"NET\", \"Asia/Yerevan\");\n-            map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Calcutta\");\n-            map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Saigon\");\n+map.put(\"IET\", \"America/IndBlock.put(\"PRT\", \"America/Saigon\");\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n             map.put(\"AET\", \"Australia/Sydney\");\n             map.put(\"SST\", \"Pacific/Guadalcanal\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "map.put(\"IET\", \"America/IndBlock.put(\"PRT\", \"America/Sbigon\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-23/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 10:20:42.060185835 +0200\n+++ /tmp/tmp12uz7h3m.java\t2022-07-19 10:20:42.064185812 +0200\n@@ -567,27 +567,11 @@\n             map.put(\"PST\", \"America/Los_Angeles\");\n             map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indianapolis\");\n-            map.put(\"PRT\", \"America/Puerto_Rico\");\n-            map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Buenos_Aires\");\n-            map.put(\"BET\", \"America/Sao_Paulo\");\n-            map.put(\"WET\", \"Europe/London\");\n-            map.put(\"ECT\", \"Europe/Paris\");\n-            map.put(\"ART\", \"Africa/Cairo\");\n-            map.put(\"CAT\", \"Africa/Harare\");\n-            map.put(\"EET\", \"Europe/Bucharest\");\n-            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n-            map.put(\"MET\", \"Asia/Tehran\");\n-            map.put(\"NET\", \"Asia/Yerevan\");\n-            map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Calcutta\");\n-            map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Saigon\");\n+map.put(\"IET\", \"America/IndBlock.put(\"PRT\", \"America/Sbigon\");\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n             map.put(\"AET\", \"Australia/Sydney\");\n             map.put(\"SST\", \"Pacific/Guadalcanal\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "map.put(\"IET\", \"America/Ind.indexOf(\"PRT\", \"America/Saigon\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-23/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 10:20:43.596176992 +0200\n+++ /tmp/tmp8jnpy2yq.java\t2022-07-19 10:20:43.596176992 +0200\n@@ -567,27 +567,11 @@\n             map.put(\"PST\", \"America/Los_Angeles\");\n             map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indianapolis\");\n-            map.put(\"PRT\", \"America/Puerto_Rico\");\n-            map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Buenos_Aires\");\n-            map.put(\"BET\", \"America/Sao_Paulo\");\n-            map.put(\"WET\", \"Europe/London\");\n-            map.put(\"ECT\", \"Europe/Paris\");\n-            map.put(\"ART\", \"Africa/Cairo\");\n-            map.put(\"CAT\", \"Africa/Harare\");\n-            map.put(\"EET\", \"Europe/Bucharest\");\n-            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n-            map.put(\"MET\", \"Asia/Tehran\");\n-            map.put(\"NET\", \"Asia/Yerevan\");\n-            map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Calcutta\");\n-            map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Saigon\");\n+map.put(\"IET\", \"America/Ind.indexOf(\"PRT\", \"America/Saigon\");\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n             map.put(\"AET\", \"Australia/Sydney\");\n             map.put(\"SST\", \"Pacific/Guadalcanal\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "map.put(\"IET\", \"America/Ind.put(\"PRT\", \"America/S_ERROR.put(\"VST\", \"America/Saigon\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-23/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 10:20:45.236167551 +0200\n+++ /tmp/tmproo2181x.java\t2022-07-19 10:20:45.236167551 +0200\n@@ -567,27 +567,11 @@\n             map.put(\"PST\", \"America/Los_Angeles\");\n             map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indianapolis\");\n-            map.put(\"PRT\", \"America/Puerto_Rico\");\n-            map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Buenos_Aires\");\n-            map.put(\"BET\", \"America/Sao_Paulo\");\n-            map.put(\"WET\", \"Europe/London\");\n-            map.put(\"ECT\", \"Europe/Paris\");\n-            map.put(\"ART\", \"Africa/Cairo\");\n-            map.put(\"CAT\", \"Africa/Harare\");\n-            map.put(\"EET\", \"Europe/Bucharest\");\n-            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n-            map.put(\"MET\", \"Asia/Tehran\");\n-            map.put(\"NET\", \"Asia/Yerevan\");\n-            map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Calcutta\");\n-            map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Saigon\");\n+map.put(\"IET\", \"America/Ind.put(\"PRT\", \"America/S_ERROR.put(\"VST\", \"America/Saigon\");\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n             map.put(\"AET\", \"Australia/Sydney\");\n             map.put(\"SST\", \"Pacific/Guadalcanal\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "map.put(\"IET\", \"America/Ind.put(\"PRT());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-23/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 10:20:46.824158405 +0200\n+++ /tmp/tmpop9_46w7.java\t2022-07-19 10:20:46.824158405 +0200\n@@ -567,27 +567,11 @@\n             map.put(\"PST\", \"America/Los_Angeles\");\n             map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indianapolis\");\n-            map.put(\"PRT\", \"America/Puerto_Rico\");\n-            map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Buenos_Aires\");\n-            map.put(\"BET\", \"America/Sao_Paulo\");\n-            map.put(\"WET\", \"Europe/London\");\n-            map.put(\"ECT\", \"Europe/Paris\");\n-            map.put(\"ART\", \"Africa/Cairo\");\n-            map.put(\"CAT\", \"Africa/Harare\");\n-            map.put(\"EET\", \"Europe/Bucharest\");\n-            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n-            map.put(\"MET\", \"Asia/Tehran\");\n-            map.put(\"NET\", \"Asia/Yerevan\");\n-            map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Calcutta\");\n-            map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Saigon\");\n+map.put(\"IET\", \"America/Ind.put(\"PRT());\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n             map.put(\"AET\", \"Australia/Sydney\");\n             map.put(\"SST\", \"Pacific/Guadalcanal\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "map.put(\"IET\", \"America/Ind){",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-23/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-19 10:20:48.388149399 +0200\n+++ /tmp/tmplfuq77pr.java\t2022-07-19 10:20:48.388149399 +0200\n@@ -567,27 +567,11 @@\n             map.put(\"PST\", \"America/Los_Angeles\");\n             map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indianapolis\");\n-            map.put(\"PRT\", \"America/Puerto_Rico\");\n-            map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Buenos_Aires\");\n-            map.put(\"BET\", \"America/Sao_Paulo\");\n-            map.put(\"WET\", \"Europe/London\");\n-            map.put(\"ECT\", \"Europe/Paris\");\n-            map.put(\"ART\", \"Africa/Cairo\");\n-            map.put(\"CAT\", \"Africa/Harare\");\n-            map.put(\"EET\", \"Europe/Bucharest\");\n-            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n-            map.put(\"MET\", \"Asia/Tehran\");\n-            map.put(\"NET\", \"Asia/Yerevan\");\n-            map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Calcutta\");\n-            map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Saigon\");\n+map.put(\"IET\", \"America/Ind){\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n             map.put(\"AET\", \"Australia/Sydney\");\n             map.put(\"SST\", \"Pacific/Guadalcanal\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "map.put(\"IET\", \"America/Indianapolis\"); map.put(\"PRT\", \"America/Puerto_Rico\"); map.put(\"CNT\", \"America/St_Johns\"); map.put(\"AGT\", \"America/Buenos_Aires\"); map.put(\"BET\", \"America/Sao_Paulo\"); map.put(\"WET\", \"Europe/London\"); map.put(\"ECT\", \"Europe/Paris\"); map.put(\"ART\", \"Africa/Cairo\"); map.put(\"CAT\", \"Africa/Harare\"); map.put(\"EET\", \"Europe/Bucharest\"); map.put(\"EAT\", \"Africa/Addis_Ababa\"); map.put(\"MET\", \"Asia/Tehran\"); map.put(\"NET\", \"Asia/Yerevan\"); map.put(\"PLT\", \"Asia/Karachi\"); map.put(\"IST\", \"Asia/Calcutta\"); map.put(\"BST\", \"Asia/Dhaka\"); map.put(\"VST\", \"Asia/Saigon\");",
        "fixed_line": "map.put(\"WET\", \"WET\"); map.put(\"CET\", \"CET\"); map.put(\"MET\", \"CET\"); map.put(\"ECT\", \"CET\"); map.put(\"EET\", \"EET\"); map.put(\"MIT\", \"Pacific/Apia\"); map.put(\"HST\", \"Pacific/Honolulu\"); // JDK 1.1 compatible map.put(\"AST\", \"America/Anchorage\"); map.put(\"PST\", \"America/Los_Angeles\"); map.put(\"MST\", \"America/Denver\"); // JDK 1.1 compatible map.put(\"PNT\", \"America/Phoenix\"); map.put(\"CST\", \"America/Chicago\"); map.put(\"EST\", \"America/New_York\"); // JDK 1.1 compatible map.put(\"IET\", \"America/Indiana/Indianapolis\"); map.put(\"PRT\", \"America/Puerto_Rico\"); map.put(\"CNT\", \"America/St_Johns\"); map.put(\"AGT\", \"America/Argentina/Buenos_Aires\"); map.put(\"BET\", \"America/Sao_Paulo\"); map.put(\"ART\", \"Africa/Cairo\"); map.put(\"CAT\", \"Africa/Harare\"); map.put(\"EAT\", \"Africa/Addis_Ababa\"); map.put(\"NET\", \"Asia/Yerevan\"); map.put(\"PLT\", \"Asia/Karachi\"); map.put(\"IST\", \"Asia/Kolkata\"); map.put(\"BST\", \"Asia/Dhaka\"); map.put(\"VST\", \"Asia/Ho_Chi_Minh\");"
    },
    "JacksonDatabind-34": {
        "fixes": [
            {
                "k": 1,
                "patch": "visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-34/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\t2022-07-19 10:20:50.076139678 +0200\n+++ /tmp/tmp7a4fz_vz.java\t2022-07-19 10:20:50.100139540 +0200\n@@ -76,11 +76,11 @@\n         if (_isInt) {\n             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "visitFloatFormat(visitor, _typeHint, JsonParser.NumberType.BIG_INTEGER);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-34/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\t2022-07-19 10:21:28.283919516 +0200\n+++ /tmp/tmpda8iao42.java\t2022-07-19 10:21:28.283919516 +0200\n@@ -76,11 +76,11 @@\n         if (_isInt) {\n             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+visitFloatFormat(visitor, _typeHint, JsonParser.NumberType.BIG_INTEGER);\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "visitFloatFormat(visitor, typeHint, deser.NumberType.BIG_INTEGER);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-34/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\t2022-07-19 10:21:30.075909183 +0200\n+++ /tmp/tmpmx07q4uf.java\t2022-07-19 10:21:30.075909183 +0200\n@@ -76,11 +76,11 @@\n         if (_isInt) {\n             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+visitFloatFormat(visitor, typeHint, deser.NumberType.BIG_INTEGER);\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "visitFloatFormat(visitor, typeHint,JsonParser.NumberType.BIG_INTEGER);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-34/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\t2022-07-19 10:21:31.983898181 +0200\n+++ /tmp/tmp82t_z54h.java\t2022-07-19 10:21:31.983898181 +0200\n@@ -76,11 +76,11 @@\n         if (_isInt) {\n             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+visitFloatFormat(visitor, typeHint,JsonParser.NumberType.BIG_INTEGER);\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-34/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\t2022-07-19 10:22:07.079695710 +0200\n+++ /tmp/tmpqr1yh04z.java\t2022-07-19 10:22:07.079695710 +0200\n@@ -76,11 +76,11 @@\n         if (_isInt) {\n             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER));\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-34/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\t2022-07-19 10:22:08.703686335 +0200\n+++ /tmp/tmp500b8hii.java\t2022-07-19 10:22:08.703686335 +0200\n@@ -76,11 +76,11 @@\n         if (_isInt) {\n             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER,\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER =",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-34/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\t2022-07-19 10:22:10.207677654 +0200\n+++ /tmp/tmpydk_21cm.java\t2022-07-19 10:22:10.207677654 +0200\n@@ -76,11 +76,11 @@\n         if (_isInt) {\n             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER =\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "visitFloatFormat(visitor, target, JsonParser.NumberType.BIG_INTEGER);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-34/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\t2022-07-19 10:22:11.831668279 +0200\n+++ /tmp/tmp55s18i60.java\t2022-07-19 10:22:11.831668279 +0200\n@@ -76,11 +76,11 @@\n         if (_isInt) {\n             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+visitFloatFormat(visitor, target, JsonParser.NumberType.BIG_INTEGER);\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-34/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\t2022-07-19 10:22:13.579658188 +0200\n+++ /tmp/tmpp1bs1y5f.java\t2022-07-19 10:22:13.579658188 +0200\n@@ -76,11 +76,11 @@\n         if (_isInt) {\n             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER),\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "visitFloatFormat(visitor, typeHint, nullNumber.NumberType.BIG_INTEGER);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-34/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\t2022-07-19 10:22:15.211648766 +0200\n+++ /tmp/tmpjhwjood_.java\t2022-07-19 10:22:15.211648766 +0200\n@@ -76,11 +76,11 @@\n         if (_isInt) {\n             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+visitFloatFormat(visitor, typeHint, nullNumber.NumberType.BIG_INTEGER);\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);",
        "fixed_line": "visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);"
    },
    "Closure-105": {
        "fixes": [
            {
                "k": 1,
                "patch": "StringBuilder sb = new StringBuilder(); int foldedSize = 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-105/src/com/google/javascript/jscomp/FoldConstants.java\t2022-07-19 10:22:17.163637496 +0200\n+++ /tmp/tmpcmbq4iwd.java\t2022-07-19 10:22:17.247637012 +0200\n@@ -1472,34 +1472,11 @@\n       return;\n     }\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n-    int foldedSize = 0;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb.length() > 0) {\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb.length() > 0) {\n+StringBuilder sb = new StringBuilder(); int foldedSize = 0;\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n     }\n     // one for each comma.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "StringBuilder sb = new StringBuilder(); int foldedSize = arrayNode.getFirstChild();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-105/src/com/google/javascript/jscomp/FoldConstants.java\t2022-07-19 10:22:18.855627728 +0200\n+++ /tmp/tmpls7vhpme.java\t2022-07-19 10:22:18.855627728 +0200\n@@ -1472,34 +1472,11 @@\n       return;\n     }\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n-    int foldedSize = 0;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb.length() > 0) {\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb.length() > 0) {\n+StringBuilder sb = new StringBuilder(); int foldedSize = arrayNode.getFirstChild();\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n     }\n     // one for each comma.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "StringBuilder sb = new StringBuilder(); int foldedSize = arrayNode.getFirstChild() > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-105/src/com/google/javascript/jscomp/FoldConstants.java\t2022-07-19 10:22:20.463618445 +0200\n+++ /tmp/tmp_1kywovv.java\t2022-07-19 10:22:20.463618445 +0200\n@@ -1472,34 +1472,11 @@\n       return;\n     }\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n-    int foldedSize = 0;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb.length() > 0) {\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb.length() > 0) {\n+StringBuilder sb = new StringBuilder(); int foldedSize = arrayNode.getFirstChild() > 0) {\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n     }\n     // one for each comma.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "StringBuilder sb = new StringBuilder(); int foldedSize = 0; // Merges adjacent String.length() > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-105/src/com/google/javascript/jscomp/FoldConstants.java\t2022-07-19 10:22:22.031609390 +0200\n+++ /tmp/tmptg9xvawc.java\t2022-07-19 10:22:22.031609390 +0200\n@@ -1472,34 +1472,11 @@\n       return;\n     }\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n-    int foldedSize = 0;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb.length() > 0) {\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb.length() > 0) {\n+StringBuilder sb = new StringBuilder(); int foldedSize = 0; // Merges adjacent String.length() > 0) {\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n     }\n     // one for each comma.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "StringBuilder sb = new StringBuilder(); int foldedSize = 0; // Merges adjacent String.class",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-105/src/com/google/javascript/jscomp/FoldConstants.java\t2022-07-19 10:22:23.591600383 +0200\n+++ /tmp/tmpfzv5gmi5.java\t2022-07-19 10:22:23.591600383 +0200\n@@ -1472,34 +1472,11 @@\n       return;\n     }\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n-    int foldedSize = 0;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb.length() > 0) {\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb.length() > 0) {\n+StringBuilder sb = new StringBuilder(); int foldedSize = 0; // Merges adjacent String.class\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n     }\n     // one for each comma.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "StringBuilder sb = new StringBuilder(); int foldedSize = n.getFirstChild();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-105/src/com/google/javascript/jscomp/FoldConstants.java\t2022-07-19 10:22:25.215591004 +0200\n+++ /tmp/tmpstyadcdh.java\t2022-07-19 10:22:25.215591004 +0200\n@@ -1472,34 +1472,11 @@\n       return;\n     }\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n-    int foldedSize = 0;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb.length() > 0) {\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb.length() > 0) {\n+StringBuilder sb = new StringBuilder(); int foldedSize = n.getFirstChild();\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n     }\n     // one for each comma.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "StringBuilder sb = new StringBuilder(); int clonededSize = 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-105/src/com/google/javascript/jscomp/FoldConstants.java\t2022-07-19 10:22:26.739582205 +0200\n+++ /tmp/tmpoprxvpo_.java\t2022-07-19 10:22:26.739582205 +0200\n@@ -1472,34 +1472,11 @@\n       return;\n     }\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n-    int foldedSize = 0;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb.length() > 0) {\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb.length() > 0) {\n+StringBuilder sb = new StringBuilder(); int clonededSize = 0;\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n     }\n     // one for each comma.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "StringBuilder sb = new StringBuilder(); int foldedSize = arrayNode.getFirstChild() > 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-105/src/com/google/javascript/jscomp/FoldConstants.java\t2022-07-19 10:22:28.331573008 +0200\n+++ /tmp/tmprp_z1lfh.java\t2022-07-19 10:22:28.335572985 +0200\n@@ -1472,34 +1472,11 @@\n       return;\n     }\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n-    int foldedSize = 0;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb.length() > 0) {\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb.length() > 0) {\n+StringBuilder sb = new StringBuilder(); int foldedSize = arrayNode.getFirstChild() > 0;\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n     }\n     // one for each comma.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "StringBuilder sb = new StringBuilder(); int foldedSize = 1; // Merges adjacent String.length() > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-105/src/com/google/javascript/jscomp/FoldConstants.java\t2022-07-19 10:22:29.835564323 +0200\n+++ /tmp/tmp7rll_4g1.java\t2022-07-19 10:22:29.835564323 +0200\n@@ -1472,34 +1472,11 @@\n       return;\n     }\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n-    int foldedSize = 0;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb.length() > 0) {\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb.length() > 0) {\n+StringBuilder sb = new StringBuilder(); int foldedSize = 1; // Merges adjacent String.length() > 0) {\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n     }\n     // one for each comma.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "StringBuilder sb = new StringBuilder(); int foldedSize = arrayNode.getFirstChild() - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-105/src/com/google/javascript/jscomp/FoldConstants.java\t2022-07-19 10:22:31.423555150 +0200\n+++ /tmp/tmpgspvs44o.java\t2022-07-19 10:22:31.423555150 +0200\n@@ -1472,34 +1472,11 @@\n       return;\n     }\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n-    int foldedSize = 0;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb.length() > 0) {\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb.length() > 0) {\n+StringBuilder sb = new StringBuilder(); int foldedSize = arrayNode.getFirstChild() - 1;\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n     }\n     // one for each comma.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "StringBuilder sb = new StringBuilder(); int foldedSize = 0; Node elem = arrayNode.getFirstChild(); // Merges adjacent String nodes. while (elem != null) { if (NodeUtil.isImmutableValue(elem)) { if (sb.length() > 0) { sb.append(joinString); } sb.append(NodeUtil.getStringValue(elem)); } else { if (sb.length() > 0) { // + 2 for the quotes. foldedSize += sb.length() + 2; arrayFoldedChildren.add(Node.newString(sb.toString())); sb = new StringBuilder(); } foldedSize += InlineCostEstimator.getCost(elem); arrayFoldedChildren.add(elem); } elem = elem.getNext(); } if (sb.length() > 0) {",
        "fixed_line": "StringBuilder sb = null; int foldedSize = 0; Node elem = arrayNode.getFirstChild(); // Merges adjacent String nodes. while (elem != null) { if (NodeUtil.isImmutableValue(elem)) { if (sb == null) { sb = new StringBuilder(); } else { sb.append(joinString); } sb.append(NodeUtil.getStringValue(elem)); } else { if (sb != null) { // + 2 for the quotes. foldedSize += sb.length() + 2; arrayFoldedChildren.add(Node.newString(sb.toString())); sb = null; } foldedSize += InlineCostEstimator.getCost(elem); arrayFoldedChildren.add(elem); } elem = elem.getNext(); } if (sb != null) {"
    },
    "Math-60": {
        "fixes": [
            {
                "k": 1,
                "patch": "try { return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * x); } }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-60/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\t2022-07-19 10:22:33.239544662 +0200\n+++ /tmp/tmp4pa5we54.java\t2022-07-19 10:22:33.279544430 +0200\n@@ -121,22 +121,11 @@\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        try {\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n+try { return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * x); } }\n     }\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "try { return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation; } else if (x > 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-60/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\t2022-07-19 10:22:35.419532071 +0200\n+++ /tmp/tmpu121lxu4.java\t2022-07-19 10:22:35.419532071 +0200\n@@ -121,22 +121,11 @@\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        try {\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n+try { return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation; } else if (x > 1) {\n     }\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "try { return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation; } else if (x > 1) { return 0; } }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-60/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\t2022-07-19 10:22:37.479520170 +0200\n+++ /tmp/tmp1fmi3whu.java\t2022-07-19 10:22:37.479520170 +0200\n@@ -121,22 +121,11 @@\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        try {\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n+try { return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation; } else if (x > 1) { return 0; } }\n     }\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "try { return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * sum); } else if (x > 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-60/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\t2022-07-19 10:22:39.507508456 +0200\n+++ /tmp/tmpigz66ziv.java\t2022-07-19 10:22:39.507508456 +0200\n@@ -121,22 +121,11 @@\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        try {\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n+try { return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * sum); } else if (x > 1) {\n     }\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "try { return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * 1.0)); } else if (x > 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-60/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\t2022-07-19 10:22:41.603496347 +0200\n+++ /tmp/tmpup1jcm3i.java\t2022-07-19 10:22:41.603496347 +0200\n@@ -121,22 +121,11 @@\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        try {\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n+try { return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * 1.0)); } else if (x > 1) {\n     }\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "try { return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation; } else if (x > 1) { return 1; } }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-60/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\t2022-07-19 10:22:43.603484792 +0200\n+++ /tmp/tmp3nn1szcx.java\t2022-07-19 10:22:43.603484792 +0200\n@@ -121,22 +121,11 @@\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        try {\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n+try { return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation; } else if (x > 1) { return 1; } }\n     }\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "try { return 0.5 * (1.0 - mean) / (standardDeviation * x); } }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-60/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\t2022-07-19 10:22:45.603473237 +0200\n+++ /tmp/tmpsu74_hq4.java\t2022-07-19 10:22:45.603473237 +0200\n@@ -121,22 +121,11 @@\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        try {\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n+try { return 0.5 * (1.0 - mean) / (standardDeviation * x); } }\n     }\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "try { return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * x); } else if (x > 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-60/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\t2022-07-19 10:22:47.615461611 +0200\n+++ /tmp/tmpowdov0a2.java\t2022-07-19 10:22:47.615461611 +0200\n@@ -121,22 +121,11 @@\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        try {\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n+try { return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * x); } else if (x > 1) {\n     }\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "try { return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * sum); } else if (x > 1) { return 0; } }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-60/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\t2022-07-19 10:22:49.539450494 +0200\n+++ /tmp/tmpf2l5wtsk.java\t2022-07-19 10:22:49.539450494 +0200\n@@ -121,22 +121,11 @@\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        try {\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n+try { return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * sum); } else if (x > 1) { return 0; } }\n     }\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "try { return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * sum); } else if (x > 1) { return 1; } }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-60/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\t2022-07-19 10:22:51.539438937 +0200\n+++ /tmp/tmpun595thr.java\t2022-07-19 10:22:51.539438937 +0200\n@@ -121,22 +121,11 @@\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        try {\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n+try { return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * sum); } else if (x > 1) { return 1; } }\n     }\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "try { return 0.5 * (1.0 + Erf.erf((dev) / (standardDeviation * FastMath.sqrt(2.0)))); } catch (MaxIterationsExceededException ex) { if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38 return 0; } else if (x > (mean + 20 * standardDeviation)) { return 1; } else { throw ex; } }",
        "fixed_line": "if (FastMath.abs(dev) > 40 * standardDeviation) { return dev < 0 ? 0.0d : 1.0d; }"
    },
    "JacksonCore-26": {
        "fixes": [
            {
                "k": 1,
                "patch": "_currInputRowStart = start - _inputPtr; _inputEnd = end;",
                "patch_diff": "_currInputRowStart = start - _inputPtr; _inputEnd = end;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "_currInputRowStart = _inputPtr - start; _inputEnd = end;",
                "patch_diff": "_currInputRowStart = _inputPtr - start; _inputEnd = end;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "_currInputRowStart = end - start; _inputEnd = end;",
                "patch_diff": "_currInputRowStart = end - start; _inputEnd = end;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "_currInputRowStart = _inputEnd - start; _inputPtr = end;",
                "patch_diff": "_currInputRowStart = _inputEnd - start; _inputPtr = end;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "_currInputRowStart = end - start; _inputPtr = end;",
                "patch_diff": "_currInputRowStart = end - start; _inputPtr = end;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "_currInputRowStart = start - _currInputRowStart = end; _inputPtr = end - start;",
                "patch_diff": "_currInputRowStart = start - _currInputRowStart = end; _inputPtr = end - start;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "_currInputRowStart = _inputEnd - _inputPtr; _inputEnd = end;",
                "patch_diff": "_currInputRowStart = _inputEnd - _inputPtr; _inputEnd = end;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "_currInputRowStart = start - _inputPtr; _inputEnd = end - start;",
                "patch_diff": "_currInputRowStart = start - _inputPtr; _inputEnd = end - start;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "_currInputRowStart = start; _inputPtr = end - start;",
                "patch_diff": "_currInputRowStart = start; _inputPtr = end - start;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "_currInputRowStart = start - _currInputRowStart = end; _inputPtr = end;",
                "patch_diff": "_currInputRowStart = start - _currInputRowStart = end; _inputPtr = end;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "_currBufferStart = start;"
    },
    "Jsoup-33": {
        "fixes": [
            {
                "k": 1,
                "patch": "// for (int i = startTag.inExterns.",
                "patch_diff": "// for (int i = startTag.inExterns.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// for (int i = startTag.isAssignable()) {",
                "patch_diff": "// for (int i = startTag.isAssignable()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// for (int i = startTag.inExterns()) {",
                "patch_diff": "// for (int i = startTag.inExterns()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// for (int i = startTag.isWrapper()) {",
                "patch_diff": "// for (int i = startTag.isWrapper()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// for (int i = startTag.inExtern()) {",
                "patch_diff": "// for (int i = startTag.inExtern()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if (el.tagName.isAssignable()) {",
                "patch_diff": "// if (el.tagName.isAssignable()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// if (el.isAssignable()) {",
                "patch_diff": "// if (el.isAssignable()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// for (int i = startTag.inExternterns.",
                "patch_diff": "// for (int i = startTag.inExternterns.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// for (int i = startTag.isAssignable()) { // don't find",
                "patch_diff": "// for (int i = startTag.isAssignable()) { // don't find",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if (el == null) {",
                "patch_diff": "// if (el == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data"
    },
    "Codec-9": {
        "fixes": [
            {
                "k": 1,
                "patch": "long len = getEncodeLength(binaryData, 0, clone_CHUNK_SIZE);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-9/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 10:22:57.135406597 +0200\n+++ /tmp/tmpcodzadca.java\t2022-07-19 10:22:57.203406206 +0200\n@@ -822,11 +822,11 @@\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+long len = getEncodeLength(binaryData, 0, clone_CHUNK_SIZE);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "long len = getEncodeLength(binaryData, 0, byte.length);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-9/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 10:22:59.111395177 +0200\n+++ /tmp/tmpd88f15tg.java\t2022-07-19 10:22:59.111395177 +0200\n@@ -822,11 +822,11 @@\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+long len = getEncodeLength(binaryData, 0, byte.length);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "long len = getEncodeLength(binaryData, 0, encodedData.length);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-9/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 10:23:00.591386623 +0200\n+++ /tmp/tmpe7carmya.java\t2022-07-19 10:23:00.595386602 +0200\n@@ -822,11 +822,11 @@\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+long len = getEncodeLength(binaryData, 0, encodedData.length);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "long len = getEncodeLength(binaryData, 0, 1024_CHUNK_SIZE);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-9/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 10:23:02.239377097 +0200\n+++ /tmp/tmp7kqckk9c.java\t2022-07-19 10:23:02.243377074 +0200\n@@ -822,11 +822,11 @@\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+long len = getEncodeLength(binaryData, 0, 1024_CHUNK_SIZE);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "long len = getEncodeLength(binaryData, 0, CHUNK_CHUNK_SIZE);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-9/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 10:23:03.863367710 +0200\n+++ /tmp/tmptz6dqoig.java\t2022-07-19 10:23:03.867367687 +0200\n@@ -822,11 +822,11 @@\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+long len = getEncodeLength(binaryData, 0, CHUNK_CHUNK_SIZE);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "long len = getEncodeLength(binaryData, 0, byte_CHUNK_SIZE);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-9/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 10:23:05.523358115 +0200\n+++ /tmp/tmpqhbt8bo0.java\t2022-07-19 10:23:05.523358115 +0200\n@@ -822,11 +822,11 @@\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+long len = getEncodeLength(binaryData, 0, byte_CHUNK_SIZE);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "long len = getEncodeLength(binaryData, 0, putBoolean_CHUNK_SIZE);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-9/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 10:23:07.159348656 +0200\n+++ /tmp/tmpfocjiht7.java\t2022-07-19 10:23:07.159348656 +0200\n@@ -822,11 +822,11 @@\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+long len = getEncodeLength(binaryData, 0, putBoolean_CHUNK_SIZE);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "long len = getEncodeLength(binaryData, 0, size);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-9/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 10:23:08.847338899 +0200\n+++ /tmp/tmpnumksb_3.java\t2022-07-19 10:23:08.851338876 +0200\n@@ -822,11 +822,11 @@\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+long len = getEncodeLength(binaryData, 0, size);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "long len = getEncodeLength(binaryData, 0, 0);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-9/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 10:23:10.459329580 +0200\n+++ /tmp/tmpf8fce_6e.java\t2022-07-19 10:23:10.459329580 +0200\n@@ -822,11 +822,11 @@\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+long len = getEncodeLength(binaryData, 0, 0);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "long len = getEncodeLength(binaryData, 0, parseData.length);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-9/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-19 10:23:12.151319797 +0200\n+++ /tmp/tmpxf_rhbb4.java\t2022-07-19 10:23:12.151319797 +0200\n@@ -822,11 +822,11 @@\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+long len = getEncodeLength(binaryData, 0, parseData.length);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);",
        "fixed_line": "long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);"
    },
    "Closure-19": {
        "fixes": [
            {
                "k": 1,
                "patch": "int origType = origType == null? getNativeType(UNKNOWN_TYPE) : origType, type);",
                "patch_diff": "int origType = origType == null? getNativeType(UNKNOWN_TYPE) : origType, type);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "origType = origType == null? getNativeType(UNKNOWN_TYPE) : origType, type);",
                "patch_diff": "origType = origType == null? getNativeType(UNKNOWN_TYPE) : origType, type);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int origType = origType == null? getNativeType(UNKNOWN_TYPE) : origType, type); break;",
                "patch_diff": "int origType = origType == null? getNativeType(UNKNOWN_TYPE) : origType, type); break;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return origType = origType == null? getNativeType(UNKNOWN_TYPE) : origType, type);",
                "patch_diff": "return origType = origType == null? getNativeType(UNKNOWN_TYPE) : origType, type);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "origType = origType == null? getNativeType(UNKNOWN_TYPE) : origType, type); break;",
                "patch_diff": "origType = origType == null? getNativeType(UNKNOWN_TYPE) : origType, type); break;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (origType == null? getNativeType(UNKNOWN_TYPE) : origType, type); break;",
                "patch_diff": "if (origType == null? getNativeType(UNKNOWN_TYPE) : origType, type); break;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int origType = origType == null? getNativeType(UNKNOWN_TYPE) : origType, type); // \"this\" references aren't currently",
                "patch_diff": "int origType = origType == null? getNativeType(UNKNOWN_TYPE) : origType, type); // \"this\" references aren't currently",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "throw new IllegalArgumentException(\"Node cannot be null? getNativeType(UNKNOWN_TYPE, origType, type);",
                "patch_diff": "throw new IllegalArgumentException(\"Node cannot be null? getNativeType(UNKNOWN_TYPE, origType, type);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "(origType = origType == null? getNativeType(UNKNOWN_TYPE) : origType, type);",
                "patch_diff": "(origType = origType == null? getNativeType(UNKNOWN_TYPE) : origType, type);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "origType = origType == null? getNativeType(UNKNOWN_TYPE) : origType, type); // \"this\" references aren't currently",
                "patch_diff": "origType = origType == null? getNativeType(UNKNOWN_TYPE) : origType, type); // \"this\" references aren't currently",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "case Token.THIS: // \"this\" references aren't currently modeled in the CFG. break;"
    },
    "Closure-58": {
        "fixes": [
            {
                "k": 1,
                "patch": "addToSetIfLocal(lhs, kill, conditional);",
                "patch_diff": "addToSetIfLocal(lhs, kill, conditional);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "addToSetIfLocal(lhs, kill, conditional); addToSetIfLocal(lhs, kill);",
                "patch_diff": "addToSetIfLocal(lhs, kill, conditional); addToSetIfLocal(lhs, kill);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "addToSetIfLocal(lhs, kill, conditional); addToSetIfLocal(lhs, kill, conditional);",
                "patch_diff": "addToSetIfLocal(lhs, kill, conditional); addToSetIfLocal(lhs, kill, conditional);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "addToSetIfLocal(lhs, kill, conditional); addToSetIfLocal(lhs);",
                "patch_diff": "addToSetIfLocal(lhs, kill, conditional); addToSetIfLocal(lhs);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "addToSetIfLocal(lhs, kill);",
                "patch_diff": "addToSetIfLocal(lhs, kill);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "addToSetIfLocal(lhs, kill); addToSetIfLocal(lhs, kill);",
                "patch_diff": "addToSetIfLocal(lhs, kill); addToSetIfLocal(lhs, kill);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "addToSetIfLocal(lhs, kill, conditional); addToSetIfLocal(lhs, kill, conditional); addToSetIfLocal(lhs, kill);",
                "patch_diff": "addToSetIfLocal(lhs, kill, conditional); addToSetIfLocal(lhs, kill, conditional); addToSetIfLocal(lhs, kill);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "addToSetIfLocal(lhs, kill, conditional); addToSetIfLocal(lhs, kill); addToSetIfLocal(lhs, kill);",
                "patch_diff": "addToSetIfLocal(lhs, kill, conditional); addToSetIfLocal(lhs, kill); addToSetIfLocal(lhs, kill);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "addToSetIfLocal(lhs, kill, conditional); addToSetIfLocal(rhs, kill);",
                "patch_diff": "addToSetIfLocal(lhs, kill, conditional); addToSetIfLocal(rhs, kill);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "addToSetIfLocal(lhs, kill); computeGenKill(rhs, kill, conditional);",
                "patch_diff": "addToSetIfLocal(lhs, kill); computeGenKill(rhs, kill, conditional);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (NodeUtil.isName(lhs)) { addToSetIfLocal(lhs, kill); addToSetIfLocal(lhs, gen); } else { computeGenKill(lhs, gen, kill, conditional); }"
    },
    "Closure-83": {
        "fixes": [
            {
                "k": 1,
                "patch": "String param = params.getParameter(1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-83/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 10:23:17.479288991 +0200\n+++ /tmp/tmp44ocdye3.java\t2022-07-19 10:23:17.511288802 +0200\n@@ -329,11 +329,11 @@\n         super(parser, option, setter);\n       }\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = params.getParameter(0);\n+String param = params.getParameter(1);\n \n         if (param == null) {\n           setter.addValue(true);\n           return 0;\n         } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "String param = params.getParameter(0);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-83/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 10:23:49.275105067 +0200\n+++ /tmp/tmp71u977sd.java\t2022-07-19 10:23:49.275105067 +0200\n@@ -329,11 +329,11 @@\n         super(parser, option, setter);\n       }\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = params.getParameter(0);\n+String param = params.getParameter(0);\n \n         if (param == null) {\n           setter.addValue(true);\n           return 0;\n         } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "String param = params.getParameter(1); // should never be null or EMPTY",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-83/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 10:24:18.014938709 +0200\n+++ /tmp/tmpe437jm93.java\t2022-07-19 10:24:18.014938709 +0200\n@@ -329,11 +329,11 @@\n         super(parser, option, setter);\n       }\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = params.getParameter(0);\n+String param = params.getParameter(1); // should never be null or EMPTY\n \n         if (param == null) {\n           setter.addValue(true);\n           return 0;\n         } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "String param = params.getParameter(1); // should never be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-83/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 10:24:47.094770279 +0200\n+++ /tmp/tmptteyxf5d.java\t2022-07-19 10:24:47.094770279 +0200\n@@ -329,11 +329,11 @@\n         super(parser, option, setter);\n       }\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = params.getParameter(0);\n+String param = params.getParameter(1); // should never be null!\n \n         if (param == null) {\n           setter.addValue(true);\n           return 0;\n         } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "String param = params.getParameter(0); // should never be null or EMPTY",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-83/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 10:25:15.942603097 +0200\n+++ /tmp/tmpf6neiqpw.java\t2022-07-19 10:25:15.946603074 +0200\n@@ -329,11 +329,11 @@\n         super(parser, option, setter);\n       }\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = params.getParameter(0);\n+String param = params.getParameter(0); // should never be null or EMPTY\n \n         if (param == null) {\n           setter.addValue(true);\n           return 0;\n         } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "String param = params.getParameter();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-83/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 10:25:44.894435221 +0200\n+++ /tmp/tmprwe5zu4f.java\t2022-07-19 10:25:44.894435221 +0200\n@@ -329,11 +329,11 @@\n         super(parser, option, setter);\n       }\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = params.getParameter(0);\n+String param = params.getParameter();\n \n         if (param == null) {\n           setter.addValue(true);\n           return 0;\n         } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "String param = params.getParameter(0); // should never be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-83/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 10:25:47.594419561 +0200\n+++ /tmp/tmpuat898xe.java\t2022-07-19 10:25:47.594419561 +0200\n@@ -329,11 +329,11 @@\n         super(parser, option, setter);\n       }\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = params.getParameter(0);\n+String param = params.getParameter(0); // should never be null!\n \n         if (param == null) {\n           setter.addValue(true);\n           return 0;\n         } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "String param = params.getParameter(params);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-83/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 10:26:16.838249895 +0200\n+++ /tmp/tmp3qrvy6nb.java\t2022-07-19 10:26:16.842249872 +0200\n@@ -329,11 +329,11 @@\n         super(parser, option, setter);\n       }\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = params.getParameter(0);\n+String param = params.getParameter(params);\n \n         if (param == null) {\n           setter.addValue(true);\n           return 0;\n         } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "String param = params.getParameter(1); // should never be null or empty",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-83/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 10:26:19.530234274 +0200\n+++ /tmp/tmpxc0e77qp.java\t2022-07-19 10:26:19.534234252 +0200\n@@ -329,11 +329,11 @@\n         super(parser, option, setter);\n       }\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = params.getParameter(0);\n+String param = params.getParameter(1); // should never be null or empty\n \n         if (param == null) {\n           setter.addValue(true);\n           return 0;\n         } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "String param = params.getParameter(params.getParameter(1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-83/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-19 10:26:48.778064494 +0200\n+++ /tmp/tmppe66fbyi.java\t2022-07-19 10:26:48.782064471 +0200\n@@ -329,11 +329,11 @@\n         super(parser, option, setter);\n       }\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = params.getParameter(0);\n+String param = params.getParameter(params.getParameter(1);\n \n         if (param == null) {\n           setter.addValue(true);\n           return 0;\n         } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "String param = params.getParameter(0);",
        "fixed_line": "String param = null; try { param = params.getParameter(0); } catch (CmdLineException e) {}"
    },
    "Jsoup-35": {
        "fixes": [
            {
                "k": 1,
                "patch": "// } else if (furthestBlock.appendChild(furthestBlock);",
                "patch_diff": "// } else if (furthestBlock.appendChild(furthestBlock);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// } else if (furthestBlock.appendChild(furthestBlock.getBase());",
                "patch_diff": "// } else if (furthestBlock.appendChild(furthestBlock.getBase());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// } else if (furthestBlock.appendChild(furthestBlock.get == null) {",
                "patch_diff": "// } else if (furthestBlock.appendChild(furthestBlock.get == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// } else if (furthestBlock.appendChild(furthestBlock.get();",
                "patch_diff": "// } else if (furthestBlock.appendChild(furthestBlock.get();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// } else if (furthestBlock.appendChild(furthestBlock.get());",
                "patch_diff": "// } else if (furthestBlock.appendChild(furthestBlock.get());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// } else if (furthestBlock.appendChild(furthestBlock == null) {",
                "patch_diff": "// } else if (furthestBlock.appendChild(furthestBlock == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// } else if (furthestBlock.appendChild(furthestBlockNode);",
                "patch_diff": "// } else if (furthestBlock.appendChild(furthestBlockNode);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// } else if (furthestBlock.appendChild( ')urthestBlock);",
                "patch_diff": "// } else if (furthestBlock.appendChild( ')urthestBlock);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// } else if (furthestBlock.appendChild(childNode);",
                "patch_diff": "// } else if (furthestBlock.appendChild(childNode);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// } else if (furthestBlock.appendChild(furthestBlock.get);",
                "patch_diff": "// } else if (furthestBlock.appendChild(furthestBlock.get);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "adopter.attributes().addAll(formatEl.attributes());"
    },
    "Collections-26": {
        "fixes": [
            {
                "k": 1,
                "patch": "private Object readResolve() {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Collections-26/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\t2022-07-19 10:26:53.262038458 +0200\n+++ /tmp/tmpra6njr8k.java\t2022-07-19 10:26:53.318038133 +0200\n@@ -272,10 +272,10 @@\n      * Recalculate the hash code after deserialization. The hash code of some\n      * keys might have change (hash codes based on the system hash code are\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+private Object readResolve() {\n         calculateHashCode(keys);\n         return this;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "private Object readResolve() { // as per [JACKSON-407] -- allow disabling wrapping for the",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Collections-26/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\t2022-07-19 10:27:11.697931394 +0200\n+++ /tmp/tmp9q1vmwk0.java\t2022-07-19 10:27:11.697931394 +0200\n@@ -272,10 +272,10 @@\n      * Recalculate the hash code after deserialization. The hash code of some\n      * keys might have change (hash codes based on the system hash code are\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+private Object readResolve() { // as per [JACKSON-407] -- allow disabling wrapping for the\n         calculateHashCode(keys);\n         return this;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "private Object readResolve() { // as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < size; ++i) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Collections-26/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\t2022-07-19 10:27:28.413834291 +0200\n+++ /tmp/tmpbb9lf7b9.java\t2022-07-19 10:27:28.417834268 +0200\n@@ -272,10 +272,10 @@\n      * Recalculate the hash code after deserialization. The hash code of some\n      * keys might have change (hash codes based on the system hash code are\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+private Object readResolve() { // as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < size; ++i) {\n         calculateHashCode(keys);\n         return this;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "private Object readResolve() { // block == null; can't really modify it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Collections-26/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\t2022-07-19 10:27:45.113737259 +0200\n+++ /tmp/tmpxv4_cy9p.java\t2022-07-19 10:27:45.117737236 +0200\n@@ -272,10 +272,10 @@\n      * Recalculate the hash code after deserialization. The hash code of some\n      * keys might have change (hash codes based on the system hash code are\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+private Object readResolve() { // block == null; can't really modify it's do implicit re-parse\n         calculateHashCode(keys);\n         return this;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private Object readResolve() { // as per [JACKSON-407] -- allow disabling wrapping for this",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Collections-26/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\t2022-07-19 10:28:00.969645110 +0200\n+++ /tmp/tmppiqxv5gv.java\t2022-07-19 10:28:00.969645110 +0200\n@@ -272,10 +272,10 @@\n      * Recalculate the hash code after deserialization. The hash code of some\n      * keys might have change (hash codes based on the system hash code are\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+private Object readResolve() { // as per [JACKSON-407] -- allow disabling wrapping for this\n         calculateHashCode(keys);\n         return this;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "private Object readResolve() { // as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < len; ++i) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Collections-26/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\t2022-07-19 10:28:16.973562892 +0200\n+++ /tmp/tmp389ota7u.java\t2022-07-19 10:28:16.973562892 +0200\n@@ -272,10 +272,10 @@\n      * Recalculate the hash code after deserialization. The hash code of some\n      * keys might have change (hash codes based on the system hash code are\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+private Object readResolve() { // as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < len; ++i) {\n         calculateHashCode(keys);\n         return this;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private Object readResolve() { // as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < size; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Collections-26/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\t2022-07-19 10:28:33.689501353 +0200\n+++ /tmp/tmp62c6pqvt.java\t2022-07-19 10:28:33.689501353 +0200\n@@ -272,10 +272,10 @@\n      * Recalculate the hash code after deserialization. The hash code of some\n      * keys might have change (hash codes based on the system hash code are\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+private Object readResolve() { // as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < size; i++) {\n         calculateHashCode(keys);\n         return this;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "private Object readResolve() { // as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < v.length; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Collections-26/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\t2022-07-19 10:28:49.617441756 +0200\n+++ /tmp/tmpvee_i533.java\t2022-07-19 10:28:49.617441756 +0200\n@@ -272,10 +272,10 @@\n      * Recalculate the hash code after deserialization. The hash code of some\n      * keys might have change (hash codes based on the system hash code are\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+private Object readResolve() { // as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < v.length; i++) {\n         calculateHashCode(keys);\n         return this;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private Object readResolve() { // block only override if it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Collections-26/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\t2022-07-19 10:29:06.161378888 +0200\n+++ /tmp/tmp0qsry856.java\t2022-07-19 10:29:06.161378888 +0200\n@@ -272,10 +272,10 @@\n      * Recalculate the hash code after deserialization. The hash code of some\n      * keys might have change (hash codes based on the system hash code are\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+private Object readResolve() { // block only override if it's do implicit re-parse\n         calculateHashCode(keys);\n         return this;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "private Object readResolve() { // as per [JACKSON-407] --raw)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Collections-26/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\t2022-07-19 10:29:22.125317321 +0200\n+++ /tmp/tmp923nbcjb.java\t2022-07-19 10:29:22.129317307 +0200\n@@ -272,10 +272,10 @@\n      * Recalculate the hash code after deserialization. The hash code of some\n      * keys might have change (hash codes based on the system hash code are\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+private Object readResolve() { // as per [JACKSON-407] --raw)\n         calculateHashCode(keys);\n         return this;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "private Object readResolve() {",
        "fixed_line": "protected Object readResolve() {"
    },
    "Lang-16": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (str.startsWith(\"0x\") || str.startsWith(\"0x\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 10:29:38.125254755 +0200\n+++ /tmp/tmp5jsydv3e.java\t2022-07-19 10:29:38.157254632 +0200\n@@ -453,11 +453,11 @@\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+if (str.startsWith(\"0x\") || str.startsWith(\"0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (str.startsWith(\"0x\") || str.startsWith(\"Lexx\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 10:29:48.229214811 +0200\n+++ /tmp/tmptfbds6ck.java\t2022-07-19 10:29:48.229214811 +0200\n@@ -453,11 +453,11 @@\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+if (str.startsWith(\"0x\") || str.startsWith(\"Lexx\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (str.startsWith(\"0x\") || str.startsWith(\"-5x\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 10:29:57.869176399 +0200\n+++ /tmp/tmpxittvrqx.java\t2022-07-19 10:29:57.873176383 +0200\n@@ -453,11 +453,11 @@\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+if (str.startsWith(\"0x\") || str.startsWith(\"-5x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (str.startsWith(\"0x\") || str.startsWith(\"-1]x\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 10:30:07.489137773 +0200\n+++ /tmp/tmp8aezntki.java\t2022-07-19 10:30:07.489137773 +0200\n@@ -453,11 +453,11 @@\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+if (str.startsWith(\"0x\") || str.startsWith(\"-1]x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (str.startsWith(\"0x\") || str.startsWith(\">x\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 10:30:17.229098379 +0200\n+++ /tmp/tmpbe6ycnug.java\t2022-07-19 10:30:17.229098379 +0200\n@@ -453,11 +453,11 @@\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+if (str.startsWith(\"0x\") || str.startsWith(\">x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 10:30:27.001058565 +0200\n+++ /tmp/tmpkg6k7fn1.java\t2022-07-19 10:30:27.001058565 +0200\n@@ -453,11 +453,11 @@\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (str.startsWith(\"0x\") && str.startsWith(\"-0x\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 10:30:36.841018188 +0200\n+++ /tmp/tmp06pdko4e.java\t2022-07-19 10:30:36.841018188 +0200\n@@ -453,11 +453,11 @@\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+if (str.startsWith(\"0x\") && str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (str.startsWith(\"0x\") || str.startsWith(\"getx\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 10:30:46.576977959 +0200\n+++ /tmp/tmplxbqbrx9.java\t2022-07-19 10:30:46.576977959 +0200\n@@ -453,11 +453,11 @@\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+if (str.startsWith(\"0x\") || str.startsWith(\"getx\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (str.startsWith(\"0x\") && str.startsWith(\"0x\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 10:30:56.212937879 +0200\n+++ /tmp/tmpdvztjqz0.java\t2022-07-19 10:30:56.216937861 +0200\n@@ -453,11 +453,11 @@\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+if (str.startsWith(\"0x\") && str.startsWith(\"0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (str.startsWith(\"0x\") && str.startsWith(\"Lexx\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 10:31:06.060896647 +0200\n+++ /tmp/tmpv14_pzha.java\t2022-07-19 10:31:06.060896647 +0200\n@@ -453,11 +453,11 @@\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+if (str.startsWith(\"0x\") && str.startsWith(\"Lexx\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {",
        "fixed_line": "if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {"
    },
    "Lang-1": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (hexDigits > 18) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-1/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 10:31:16.028854643 +0200\n+++ /tmp/tmpcs6ccwk4.java\t2022-07-19 10:31:16.060854506 +0200\n@@ -463,14 +463,11 @@\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n-                return createBigInteger(str);\n-            }\n-            if (hexDigits > 8) { // too many for an int\n+if (hexDigits > 18) {\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (hexDigits > 16) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-1/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 10:31:30.648792549 +0200\n+++ /tmp/tmpmpvcdf1e.java\t2022-07-19 10:31:30.652792534 +0200\n@@ -463,14 +463,11 @@\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n-                return createBigInteger(str);\n-            }\n-            if (hexDigits > 8) { // too many for an int\n+if (hexDigits > 16) {\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (hexDigits > 31) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-1/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 10:31:44.088734975 +0200\n+++ /tmp/tmpmpy8tkk8.java\t2022-07-19 10:31:44.088734975 +0200\n@@ -463,14 +463,11 @@\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n-                return createBigInteger(str);\n-            }\n-            if (hexDigits > 8) { // too many for an int\n+if (hexDigits > 31) {\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (hexDigits > 127) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-1/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 10:31:57.256678117 +0200\n+++ /tmp/tmpn5kbr2pg.java\t2022-07-19 10:31:57.256678117 +0200\n@@ -463,14 +463,11 @@\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n-                return createBigInteger(str);\n-            }\n-            if (hexDigits > 8) { // too many for an int\n+if (hexDigits > 127) {\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (hexDigits < 16) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-1/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 10:32:10.832619048 +0200\n+++ /tmp/tmpzubkcb69.java\t2022-07-19 10:32:10.836619030 +0200\n@@ -463,14 +463,11 @@\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n-                return createBigInteger(str);\n-            }\n-            if (hexDigits > 8) { // too many for an int\n+if (hexDigits < 16) {\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (hexDigits > 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-1/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 10:32:24.324559903 +0200\n+++ /tmp/tmplvs8y69k.java\t2022-07-19 10:32:24.328559886 +0200\n@@ -463,14 +463,11 @@\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n-                return createBigInteger(str);\n-            }\n-            if (hexDigits > 8) { // too many for an int\n+if (hexDigits > 1) {\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (hexDigits >= 16) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-1/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 10:32:37.796500413 +0200\n+++ /tmp/tmp2gcnirqj.java\t2022-07-19 10:32:37.796500413 +0200\n@@ -463,14 +463,11 @@\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n-                return createBigInteger(str);\n-            }\n-            if (hexDigits > 8) { // too many for an int\n+if (hexDigits >= 16) {\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (hexDigits <= 16) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-1/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 10:32:51.268440509 +0200\n+++ /tmp/tmp4pl_5nx9.java\t2022-07-19 10:32:51.268440509 +0200\n@@ -463,14 +463,11 @@\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n-                return createBigInteger(str);\n-            }\n-            if (hexDigits > 8) { // too many for an int\n+if (hexDigits <= 16) {\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (hexDigits < 18) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-1/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 10:33:04.688380433 +0200\n+++ /tmp/tmp56vjaqny.java\t2022-07-19 10:33:04.688380433 +0200\n@@ -463,14 +463,11 @@\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n-                return createBigInteger(str);\n-            }\n-            if (hexDigits > 8) { // too many for an int\n+if (hexDigits < 18) {\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (hexDigits > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-1/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-19 10:33:18.144319802 +0200\n+++ /tmp/tmpewxqy3g1.java\t2022-07-19 10:33:18.144319802 +0200\n@@ -463,14 +463,11 @@\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n-                return createBigInteger(str);\n-            }\n-            if (hexDigits > 8) { // too many for an int\n+if (hexDigits > 0) {\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (hexDigits > 16) { // too many for Long return createBigInteger(str); } if (hexDigits > 8) { // too many for an int",
        "fixed_line": "char firstSigDigit = 0; // strip leading zeroes for(int i = pfxLen; i < str.length(); i++) { firstSigDigit = str.charAt(i); if (firstSigDigit == '0') { // count leading zeroes pfxLen++; } else { break; } } final int hexDigits = str.length() - pfxLen; if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { // too many for Long return createBigInteger(str); } if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { // too many for an int"
    },
    "Math-105": {
        "fixes": [
            {
                "k": 1,
                "patch": "return sumYY - sumXY * sumXY / sumXX;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-105/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\t2022-07-19 10:33:31.908257386 +0200\n+++ /tmp/tmpsi10ld9a.java\t2022-07-19 10:33:31.964257131 +0200\n@@ -259,11 +259,11 @@\n      * </li></ul>\n      *\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+return sumYY - sumXY * sumXY / sumXX;\n     }\n \n     /**\n      * Returns the sum of squared deviations of the y values about their mean.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return sumYY - sumXY * sumXY / sumXX; // we didn't really gets this.sum = sumYY - sumXY * sumXY / sumXX;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-105/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\t2022-07-19 10:33:39.916220889 +0200\n+++ /tmp/tmpxsjms1hm.java\t2022-07-19 10:33:39.920220872 +0200\n@@ -259,11 +259,11 @@\n      * </li></ul>\n      *\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+return sumYY - sumXY * sumXY / sumXX; // we didn't really gets this.sum = sumYY - sumXY * sumXY / sumXX;\n     }\n \n     /**\n      * Returns the sum of squared deviations of the y values about their mean.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return sumYY - sumXY * sumXY / sumXX; // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-105/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\t2022-07-19 10:33:47.508186169 +0200\n+++ /tmp/tmpeu5akmui.java\t2022-07-19 10:33:47.508186169 +0200\n@@ -259,11 +259,11 @@\n      * </li></ul>\n      *\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+return sumYY - sumXY * sumXY / sumXX; // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n     }\n \n     /**\n      * Returns the sum of squared deviations of the y values about their mean.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return sumYY - sumXY * sumXY / sumXX; // we didn't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-105/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\t2022-07-19 10:33:55.312150361 +0200\n+++ /tmp/tmpiz9tazbk.java\t2022-07-19 10:33:55.312150361 +0200\n@@ -259,11 +259,11 @@\n      * </li></ul>\n      *\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+return sumYY - sumXY * sumXY / sumXX; // we didn't really modify it's totalGJACKSON-notnotnotnot real number\n     }\n \n     /**\n      * Returns the sum of squared deviations of the y values about their mean.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return sumYY - sumXY * sumXY / sumXX; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-105/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\t2022-07-19 10:34:02.912115370 +0200\n+++ /tmp/tmp_jm38hxq.java\t2022-07-19 10:34:02.912115370 +0200\n@@ -259,11 +259,11 @@\n      * </li></ul>\n      *\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+return sumYY - sumXY * sumXY / sumXX; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n     }\n \n     /**\n      * Returns the sum of squared deviations of the y values about their mean.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return sumYY - sumXY * sumXY / sumXX; // we didn't really modify it's sumXX;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-105/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\t2022-07-19 10:34:10.488080379 +0200\n+++ /tmp/tmp0fxwwkux.java\t2022-07-19 10:34:10.488080379 +0200\n@@ -259,11 +259,11 @@\n      * </li></ul>\n      *\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+return sumYY - sumXY * sumXY / sumXX; // we didn't really modify it's sumXX;\n     }\n \n     /**\n      * Returns the sum of squared deviations of the y values about their mean.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return sumYY - sumXY * sumXY / sumXX; // we didn't really modify it's totalGJACKSON-notnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-105/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\t2022-07-19 10:34:18.088045167 +0200\n+++ /tmp/tmppslb_fzj.java\t2022-07-19 10:34:18.088045167 +0200\n@@ -259,11 +259,11 @@\n      * </li></ul>\n      *\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+return sumYY - sumXY * sumXY / sumXX; // we didn't really modify it's totalGJACKSON-notnotnot real number\n     }\n \n     /**\n      * Returns the sum of squared deviations of the y values about their mean.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return sumYY - sumXY * sumXY / sumXX; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-105/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\t2022-07-19 10:34:25.712009736 +0200\n+++ /tmp/tmp84666hue.java\t2022-07-19 10:34:25.716009716 +0200\n@@ -259,11 +259,11 @@\n      * </li></ul>\n      *\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+return sumYY - sumXY * sumXY / sumXX; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n     }\n \n     /**\n      * Returns the sum of squared deviations of the y values about their mean.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return sumYY - sumXY * sumXY / sumXX; // we didn't really gets this. sumXX = sumYY - sumXY * sumXY / sumXX;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-105/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\t2022-07-19 10:34:33.503973411 +0200\n+++ /tmp/tmpwcx8mc2y.java\t2022-07-19 10:34:33.507973390 +0200\n@@ -259,11 +259,11 @@\n      * </li></ul>\n      *\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+return sumYY - sumXY * sumXY / sumXX; // we didn't really gets this. sumXX = sumYY - sumXY * sumXY / sumXX;\n     }\n \n     /**\n      * Returns the sum of squared deviations of the y values about their mean.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return sumYY - sumXY * sumXY / sumXX; // - sumXX;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-105/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\t2022-07-19 10:34:41.163937592 +0200\n+++ /tmp/tmpsxhqj4a7.java\t2022-07-19 10:34:41.163937592 +0200\n@@ -259,11 +259,11 @@\n      * </li></ul>\n      *\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+return sumYY - sumXY * sumXY / sumXX; // - sumXX;\n     }\n \n     /**\n      * Returns the sum of squared deviations of the y values about their mean.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return sumYY - sumXY * sumXY / sumXX;",
        "fixed_line": "return Math.max(0d, sumYY - sumXY * sumXY / sumXX);"
    },
    "Closure-73": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (c >= 0x1f || c <= 0x7f) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-73/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 10:34:49.067900524 +0200\n+++ /tmp/tmpprbuny3n.java\t2022-07-19 10:34:49.099900369 +0200\n@@ -1040,11 +1040,11 @@\n             }\n           } else {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+if (c >= 0x1f || c <= 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n               // or perhaps mangled by proxies along the way,\n               // so we play it safe and unicode escape them.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (c > 0x1f || c < 0x7f) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-73/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 10:35:21.503747250 +0200\n+++ /tmp/tmprq2fblot.java\t2022-07-19 10:35:21.503747250 +0200\n@@ -1040,11 +1040,11 @@\n             }\n           } else {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+if (c > 0x1f || c < 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n               // or perhaps mangled by proxies along the way,\n               // so we play it safe and unicode escape them.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (c >= 0x1f || c < 0x7f) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-73/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 10:35:53.147596028 +0200\n+++ /tmp/tmpp37v6qwa.java\t2022-07-19 10:35:53.147596028 +0200\n@@ -1040,11 +1040,11 @@\n             }\n           } else {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+if (c >= 0x1f || c < 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n               // or perhaps mangled by proxies along the way,\n               // so we play it safe and unicode escape them.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (c > 0x1f && c!= 0x7f) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-73/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 10:36:24.851442943 +0200\n+++ /tmp/tmpopcdyoak.java\t2022-07-19 10:36:24.851442943 +0200\n@@ -1040,11 +1040,11 @@\n             }\n           } else {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+if (c > 0x1f && c!= 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n               // or perhaps mangled by proxies along the way,\n               // so we play it safe and unicode escape them.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (c > 0x1f && c < 0x7f) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-73/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 10:36:56.911286635 +0200\n+++ /tmp/tmp24mz4jpx.java\t2022-07-19 10:36:56.911286635 +0200\n@@ -1040,11 +1040,11 @@\n             }\n           } else {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+if (c > 0x1f && c < 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n               // or perhaps mangled by proxies along the way,\n               // so we play it safe and unicode escape them.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 6,
                "patch": "if (c > 0x1f && c <= 0x7f) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-73/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 10:37:29.223127657 +0200\n+++ /tmp/tmpmhbjeq4s.java\t2022-07-19 10:37:29.223127657 +0200\n@@ -1040,11 +1040,11 @@\n             }\n           } else {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+if (c > 0x1f && c <= 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n               // or perhaps mangled by proxies along the way,\n               // so we play it safe and unicode escape them.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (c < 0x1f || c > 0x7f) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-73/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 10:38:01.246968761 +0200\n+++ /tmp/tmpk4qhms9m.java\t2022-07-19 10:38:01.246968761 +0200\n@@ -1040,11 +1040,11 @@\n             }\n           } else {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+if (c < 0x1f || c > 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n               // or perhaps mangled by proxies along the way,\n               // so we play it safe and unicode escape them.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (c >= 0x1f && c <= 0x7f) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-73/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 10:38:33.638806761 +0200\n+++ /tmp/tmpy_kanp7v.java\t2022-07-19 10:38:33.638806761 +0200\n@@ -1040,11 +1040,11 @@\n             }\n           } else {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+if (c >= 0x1f && c <= 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n               // or perhaps mangled by proxies along the way,\n               // so we play it safe and unicode escape them.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (c >= 0x1f && c < 0x7f) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-73/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 10:39:05.894644248 +0200\n+++ /tmp/tmpevfs56lr.java\t2022-07-19 10:39:05.898644230 +0200\n@@ -1040,11 +1040,11 @@\n             }\n           } else {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+if (c >= 0x1f && c < 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n               // or perhaps mangled by proxies along the way,\n               // so we play it safe and unicode escape them.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 10,
                "patch": "if (c >= 0x0f && c <= 0x7f) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-73/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 10:39:38.086480944 +0200\n+++ /tmp/tmptt0jhofq.java\t2022-07-19 10:39:38.090480921 +0200\n@@ -1040,11 +1040,11 @@\n             }\n           } else {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+if (c >= 0x0f && c <= 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n               // or perhaps mangled by proxies along the way,\n               // so we play it safe and unicode escape them.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (c > 0x1f && c <= 0x7f) {",
        "fixed_line": "if (c > 0x1f && c < 0x7f) {"
    },
    "Math-78": {
        "fixes": [
            {
                "k": 1,
                "patch": "// buf buf. // as per [JACKSON, // - there is a corner // - there is a end of the",
                "patch_diff": "// buf buf. // as per [JACKSON, // - there is a corner // - there is a end of the",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// buf buf. // as per [JACKSON, // - there is a corner // - there is a corner // - there is a end of the",
                "patch_diff": "// buf buf. // as per [JACKSON, // - there is a corner // - there is a corner // - there is a end of the",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// buf buf. // as per [JACKSON, // - there is a corner // - there is a corner, // - there is a corner // - there is a end of the",
                "patch_diff": "// buf buf. // as per [JACKSON, // - there is a corner // - there is a corner, // - there is a corner // - there is a end of the",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// buf buf. // as per [JACKSON, // - there is a corner // - there is a corner // - there is a corner // - there is a end of the",
                "patch_diff": "// buf buf. // as per [JACKSON, // - there is a corner // - there is a corner // - there is a corner // - there is a end of the",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// buf buf. // as per [JACKSON, // - there is a corner // - there is a corner, // - there is a corner // - there is a corner // - there is a end of the",
                "patch_diff": "// buf buf. // as per [JACKSON, // - there is a corner // - there is a corner, // - there is a corner // - there is a corner // - there is a end of the",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// buf buf. // as per [JACKSON, // - there is a corner // - there is a corner // - there is a corner // - there is a corner // - there is a end of the",
                "patch_diff": "// buf buf. // as per [JACKSON, // - there is a corner // - there is a corner // - there is a corner // - there is a corner // - there is a end of the",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// buf buf. // as per [JACKSON, // - there is a corner // - there is a corner, // - there is a corner // - there is a corner // - there is a corner // - there is a end of the",
                "patch_diff": "// buf buf. // as per [JACKSON, // - there is a corner // - there is a corner, // - there is a corner // - there is a corner // - there is a corner // - there is a end of the",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// buf buf. // as per [JACKSON, // - there is a corner // - there is a corner, // - there is a corner // - there is a corner",
                "patch_diff": "// buf buf. // as per [JACKSON, // - there is a corner // - there is a corner, // - there is a corner // - there is a corner",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// buf buf. // as per [JACKSON, // - there is a corner // - there is a corner, // - there is a corner // - there is a corner, // - there is a corner // - there is a end of the",
                "patch_diff": "// buf buf. // as per [JACKSON, // - there is a corner // - there is a corner, // - there is a corner // - there is a corner, // - there is a corner // - there is a end of the",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// buf buf. // as per [JACKSON, // - there is a corner // - there is a corner // - there is a corner",
                "patch_diff": "// buf buf. // as per [JACKSON, // - there is a corner // - there is a corner // - there is a corner",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (ga * gb > 0) { // this is a corner case: // - there was an event near ta, // - there is another event between ta and tb // - when ta was computed, convergence was reached on the \"wrong side\" of the interval // this implies that the real sign of ga is the same as gb, so we need to slightly // shift ta to make sure ga and gb get opposite signs and the solver won't complain // about bracketing final double epsilon = (forward ? 0.25 : -0.25) * convergence; for (int k = 0; (k < 4) && (ga * gb > 0); ++k) { ta += epsilon; interpolator.setInterpolatedTime(ta); ga = handler.g(ta, interpolator.getInterpolatedState()); } if (ga * gb > 0) { // this should never happen throw MathRuntimeException.createInternalError(null); } }"
    },
    "Lang-31": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int i = 0; i < searchChars.length; i++) {",
                "patch_diff": "for (int i = 0; i < searchChars.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = 0; i < searchChars.length; i++) { for (int i = 0; i < searchChars.length; i++) {",
                "patch_diff": "for (int i = 0; i < searchChars.length; i++) { for (int i = 0; i < searchChars.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0; i < searchChars.length; ++i) {",
                "patch_diff": "for (int i = 0; i < searchChars.length; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = 0; i < searchChars.length; i++) { return false; } }",
                "patch_diff": "for (int i = 0; i < searchChars.length; i++) { return false; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int j = 0; i < searchChars.length; i++) {",
                "patch_diff": "for (int j = 0; i < searchChars.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = 0; i < searchChars.length; i++) { if (searchChars[i] == null) {",
                "patch_diff": "for (int i = 0; i < searchChars.length; i++) { if (searchChars[i] == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = 0; i < searchChars.length; i++) { if (searchChars[i] == ch) {",
                "patch_diff": "for (int i = 0; i < searchChars.length; i++) { if (searchChars[i] == ch) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = 0; i < searchChars.length; i++) { for (int i = 0; i < searchChars.length; i++) { for (int i = 0; i < searchChars.length; i++) {",
                "patch_diff": "for (int i = 0; i < searchChars.length; i++) { for (int i = 0; i < searchChars.length; i++) { for (int i = 0; i < searchChars.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int i = 0; i < searchChars.length; i++) { for (int j = 0; i < searchChars.length; i++) {",
                "patch_diff": "for (int i = 0; i < searchChars.length; i++) { for (int j = 0; i < searchChars.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = 0; i < searchChars.length; i++) { for (int i = 0; i < searchChars.length; ++i) {",
                "patch_diff": "for (int i = 0; i < searchChars.length; i++) { for (int i = 0; i < searchChars.length; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "int csLastIndex = csLength - 1; int searchLastIndex = searchLength - 1; for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { if (i < csLastIndex && j < searchLastIndex && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { // ch is a supplementary character if (searchChars[j + 1] == cs.charAt(i + 1)) { return true; } } else { // ch is in the Basic Multilingual Plane return true; }"
    },
    "Time-25": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (nextLocal!= nextLocal) { return offsetLocal; } }",
                "patch_diff": "if (nextLocal!= nextLocal) { return offsetLocal; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (nextLocal!= nextLocal) { return offsetLocal; }",
                "patch_diff": "if (nextLocal!= nextLocal) { return offsetLocal; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (nextLocal!= nextLocal) { return offsetLocal; } else if (nextLocal!= nextLocal) { return offsetLocal; } }",
                "patch_diff": "if (nextLocal!= nextLocal) { return offsetLocal; } else if (nextLocal!= nextLocal) { return offsetLocal; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (nextLocal!= nextLocal) { return offsetLocal; } else if (nextLocal!= nextLocal - offsetLocal) { return offsetLocal; } }",
                "patch_diff": "if (nextLocal!= nextLocal) { return offsetLocal; } else if (nextLocal!= nextLocal - offsetLocal) { return offsetLocal; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (nextLocal!= nextLocal) { return offsetLocal; } else if (nextLocal!= nextLocal) { return offsetLocal; }",
                "patch_diff": "if (nextLocal!= nextLocal) { return offsetLocal; } else if (nextLocal!= nextLocal) { return offsetLocal; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "offsetLocal = nextLocal - offsetLocal; } else if (nextLocal!= nextLocal) { return offsetLocal; } }",
                "patch_diff": "offsetLocal = nextLocal - offsetLocal; } else if (nextLocal!= nextLocal) { return offsetLocal; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (nextLocal!= nextLocal) { return offsetLocal; } else if (nextLocal!= nextLocal) { return offsetLocal; } else if (nextLocal!= nextLocal) { return offsetLocal; } }",
                "patch_diff": "if (nextLocal!= nextLocal) { return offsetLocal; } else if (nextLocal!= nextLocal) { return offsetLocal; } else if (nextLocal!= nextLocal) { return offsetLocal; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (nextLocal!= nextLocal - offsetLocal; } else if (nextLocal!= nextLocal) { return offsetLocal; } }",
                "patch_diff": "if (nextLocal!= nextLocal - offsetLocal; } else if (nextLocal!= nextLocal) { return offsetLocal; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (nextLocal!= nextLocal) { return offsetLocal; } else if (nextLocal!= nextLocal) { return offsetLocal; } else if (nextLocal!= nextLocal - offsetLocal) { return offsetLocal; } }",
                "patch_diff": "if (nextLocal!= nextLocal) { return offsetLocal; } else if (nextLocal!= nextLocal) { return offsetLocal; } else if (nextLocal!= nextLocal - offsetLocal) { return offsetLocal; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (nextLocal!= nextLocal) { return offsetLocal; } else if (nextLocal!= nextLocal - offsetLocal) { return offsetLocal; } else if (nextLocal!= nextLocal) { return offsetLocal; } }",
                "patch_diff": "if (nextLocal!= nextLocal) { return offsetLocal; } else if (nextLocal!= nextLocal - offsetLocal) { return offsetLocal; } else if (nextLocal!= nextLocal) { return offsetLocal; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "} else if (offsetLocal > 0) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; } }"
    },
    "Time-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "years = FieldUtils.safeAdd(years, months / 12; if (years!= 0 || result = result.withYears(months);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-5/src/main/java/org/joda/time/Period.java\t2022-07-19 10:40:15.790288350 +0200\n+++ /tmp/tmpp393x_3k.java\t2022-07-19 10:40:15.866287961 +0200\n@@ -1623,17 +1623,11 @@\n         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+years = FieldUtils.safeAdd(years, months / 12; if (years!= 0 || result = result.withYears(months);\n             }\n         }\n         return result;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "years = FieldUtils.safeAdd(years, months / 12; if (years!= 0) { result = result.withYears(months);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-5/src/main/java/org/joda/time/Period.java\t2022-07-19 10:40:17.434279920 +0200\n+++ /tmp/tmpih199yt_.java\t2022-07-19 10:40:17.450279836 +0200\n@@ -1623,17 +1623,11 @@\n         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+years = FieldUtils.safeAdd(years, months / 12; if (years!= 0) { result = result.withYears(months);\n             }\n         }\n         return result;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "years = FieldUtils.safeAdd(years, months / 12; if (years!= 0 || months > 0) { result = result.withYears(months);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-5/src/main/java/org/joda/time/Period.java\t2022-07-19 10:40:18.990271941 +0200\n+++ /tmp/tmpix8nrh2c.java\t2022-07-19 10:40:18.990271941 +0200\n@@ -1623,17 +1623,11 @@\n         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+years = FieldUtils.safeAdd(years, months / 12; if (years!= 0 || months > 0) { result = result.withYears(months);\n             }\n         }\n         return result;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "years = FieldUtils.safeAdd(years, months / 12; if (years!= 0 || months % 12!= 0) { result = result.withYears(months);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-5/src/main/java/org/joda/time/Period.java\t2022-07-19 10:40:20.546263958 +0200\n+++ /tmp/tmpxb3v5b6u.java\t2022-07-19 10:40:20.546263958 +0200\n@@ -1623,17 +1623,11 @@\n         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+years = FieldUtils.safeAdd(years, months / 12; if (years!= 0 || months % 12!= 0) { result = result.withYears(months);\n             }\n         }\n         return result;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "years = FieldUtils.safeAdd(years, months / 12; if (years!= 0) { result = result.withYears(months); } result = result.withMonths(months);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-5/src/main/java/org/joda/time/Period.java\t2022-07-19 10:40:22.118255889 +0200\n+++ /tmp/tmpnwnpe4ou.java\t2022-07-19 10:40:22.118255889 +0200\n@@ -1623,17 +1623,11 @@\n         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+years = FieldUtils.safeAdd(years, months / 12; if (years!= 0) { result = result.withYears(months); } result = result.withMonths(months);\n             }\n         }\n         return result;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "years = FieldUtils.safeAdd(years, months / 12; if (years!= 0 || months % 12) { result = result.withYears(months);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-5/src/main/java/org/joda/time/Period.java\t2022-07-19 10:40:23.578248398 +0200\n+++ /tmp/tmp28d6l2i7.java\t2022-07-19 10:40:23.582248377 +0200\n@@ -1623,17 +1623,11 @@\n         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+years = FieldUtils.safeAdd(years, months / 12; if (years!= 0 || months % 12) { result = result.withYears(months);\n             }\n         }\n         return result;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "years = FieldUtils.safeAdd(years, months / 12; if (years!= 0) { result = result.withYears(months);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-5/src/main/java/org/joda/time/Period.java\t2022-07-19 10:40:25.126240448 +0200\n+++ /tmp/tmpytudoze8.java\t2022-07-19 10:40:25.126240448 +0200\n@@ -1623,17 +1623,11 @@\n         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+years = FieldUtils.safeAdd(years, months / 12; if (years!= 0) { result = result.withYears(months);\n             }\n         }\n         return result;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "years = FieldUtils.safeAdd(years, months / 12; if (years!= 0 || months > 0) { result = result.withYears(months); } result = result.withMonths(months);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-5/src/main/java/org/joda/time/Period.java\t2022-07-19 10:40:26.650232624 +0200\n+++ /tmp/tmper79t3s1.java\t2022-07-19 10:40:26.650232624 +0200\n@@ -1623,17 +1623,11 @@\n         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+years = FieldUtils.safeAdd(years, months / 12; if (years!= 0 || months > 0) { result = result.withYears(months); } result = result.withMonths(months);\n             }\n         }\n         return result;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "years = FieldUtils.safeAdd(years, months / 12; if (years!= 0 || months % 2!= 0) { result = result.withYears(months);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-5/src/main/java/org/joda/time/Period.java\t2022-07-19 10:40:28.174224795 +0200\n+++ /tmp/tmpvsei2qol.java\t2022-07-19 10:40:28.174224795 +0200\n@@ -1623,17 +1623,11 @@\n         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+years = FieldUtils.safeAdd(years, months / 12; if (years!= 0 || months % 2!= 0) { result = result.withYears(months);\n             }\n         }\n         return result;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "years = FieldUtils.safeAdd(years, months / 12; if (years!= 0 || months % 12 < 0) { result = result.withYears(months);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-5/src/main/java/org/joda/time/Period.java\t2022-07-19 10:40:29.682217046 +0200\n+++ /tmp/tmp6tadyn75.java\t2022-07-19 10:40:29.682217046 +0200\n@@ -1623,17 +1623,11 @@\n         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+years = FieldUtils.safeAdd(years, months / 12; if (years!= 0 || months % 12 < 0) { result = result.withYears(months);\n             }\n         }\n         return result;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "years = FieldUtils.safeAdd(years, months / 12); months = months % 12; if (years != 0) { result = result.withYears(years); } if (months != 0) { result = result.withMonths(months);",
        "fixed_line": "long totalMonths = years * 12L + months; if (type.isSupported(DurationFieldType.YEARS_TYPE)) { int normalizedYears = FieldUtils.safeToInt(totalMonths / 12); result = result.withYears(normalizedYears); totalMonths = totalMonths - (normalizedYears * 12); } if (type.isSupported(DurationFieldType.MONTHS_TYPE)) { int normalizedMonths = FieldUtils.safeToInt(totalMonths); result = result.withMonths(normalizedMonths); totalMonths = totalMonths - normalizedMonths; } if (totalMonths != 0) { throw new UnsupportedOperationException(\"Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: \" + toString());"
    },
    "Math-10": {
        "fixes": [
            {
                "k": 1,
                "patch": "// error value to take special cases(+string+0, +0/-0, -0/-0, -0/-0,",
                "patch_diff": "// error value to take special cases(+string+0, +0/-0, -0/-0, -0/-0,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// error value to take special cases (+string-0, -0/-0, -0/-0, -0/-0,",
                "patch_diff": "// error value to take special cases (+string-0, -0/-0, -0/-0, -0/-0,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// default value to take special cases(+string+0, +0/-0, -0/-0, -0/-0,",
                "patch_diff": "// default value to take special cases(+string+0, +0/-0, -0/-0, -0/-0,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// error value to take special cases (+0/+0, +0/-0, -0/-0, -0/-0,",
                "patch_diff": "// error value to take special cases (+0/+0, +0/-0, -0/-0, -0/-0,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// error value to take special cases(+string-0, -0/-0, -0/-0, -0/-0,",
                "patch_diff": "// error value to take special cases(+string-0, -0/-0, -0/-0, -0/-0,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// error value to take special cases(+string+0, +0/-0, -0/-0,",
                "patch_diff": "// error value to take special cases(+string+0, +0/-0, -0/-0,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// error value to take special cases (+string-0, -0/-0, -0/-0, - ignored+0, -",
                "patch_diff": "// error value to take special cases (+string-0, -0/-0, -0/-0, - ignored+0, -",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// error value to take special cases (+string-0, -0/-0, -0/-0, -0/-0, -0/-0,",
                "patch_diff": "// error value to take special cases (+string-0, -0/-0, -0/-0, -0/-0, -0/-0,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// error value to take special cases (+0/+0, +0/-0, -0/-0, -0/-0, -0/-0,",
                "patch_diff": "// error value to take special cases (+0/+0, +0/-0, -0/-0, -0/-0, -0/-0,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// error value to take special cases(+string+0, +0/-0, -0/-0, -0/-0, -0/-0,",
                "patch_diff": "// error value to take special cases(+string+0, +0/-0, -0/-0, -0/-0, -0/-0,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);"
    },
    "Closure-52": {
        "fixes": [
            {
                "k": 1,
                "patch": "return len > 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-52/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 10:40:33.178199073 +0200\n+++ /tmp/tmphl2rn_k3.java\t2022-07-19 10:40:33.202198951 +0200\n@@ -740,11 +740,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0;\n+return len > 0;\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return len > 0; // let's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-52/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 10:41:13.137992885 +0200\n+++ /tmp/tmplyutaiz_.java\t2022-07-19 10:41:13.137992885 +0200\n@@ -740,11 +740,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0;\n+return len > 0; // let's do implicit re-parse\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return len > 0; // let's do implicit re-literals",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-52/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 10:41:49.337804937 +0200\n+++ /tmp/tmp8_awxeo9.java\t2022-07-19 10:41:49.337804937 +0200\n@@ -740,11 +740,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0;\n+return len > 0; // let's do implicit re-literals\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return len > 0; // let's do implicit rereturnType",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-52/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 10:42:25.981613642 +0200\n+++ /tmp/tmpafrxnpz_.java\t2022-07-19 10:42:25.981613642 +0200\n@@ -740,11 +740,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0;\n+return len > 0; // let's do implicit rereturnType\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return len > 0; // let's do implicit re-closed",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-52/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 10:43:01.981424756 +0200\n+++ /tmp/tmpa_bglaza.java\t2022-07-19 10:43:01.985424734 +0200\n@@ -740,11 +740,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0;\n+return len > 0; // let's do implicit re-closed\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return len > 0; // let's do implicit re-literals do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-52/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 10:43:38.173233976 +0200\n+++ /tmp/tmpce61l6io.java\t2022-07-19 10:43:38.177233955 +0200\n@@ -740,11 +740,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0;\n+return len > 0; // let's do implicit re-literals do implicit re-parse\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return len > 0; // let's do implicit re-returnType",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-52/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 10:44:14.717040500 +0200\n+++ /tmp/tmpbcg00cdr.java\t2022-07-19 10:44:14.717040500 +0200\n@@ -740,11 +740,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0;\n+return len > 0; // let's do implicit re-returnType\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return len > 0; // let's do implicit re-literal characters that might be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-52/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 10:44:51.448845240 +0200\n+++ /tmp/tmpg5mm6j66.java\t2022-07-19 10:44:51.448845240 +0200\n@@ -740,11 +740,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0;\n+return len > 0; // let's do implicit re-literal characters that might be null!\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return len > 0; // let's do implicit re-literals do implicit re-literals",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-52/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 10:45:27.968650375 +0200\n+++ /tmp/tmpm1j5hpnp.java\t2022-07-19 10:45:27.968650375 +0200\n@@ -740,11 +740,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0;\n+return len > 0; // let's do implicit re-literals do implicit re-literals\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return len > 0; // let's do implicit re-literals.charAt(index > 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-52/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-19 10:46:04.796453175 +0200\n+++ /tmp/tmptobixks9.java\t2022-07-19 10:46:04.796453175 +0200\n@@ -740,11 +740,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0;\n+return len > 0; // let's do implicit re-literals.charAt(index > 0;\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return len > 0;",
        "fixed_line": "return len > 0 && s.charAt(0) != '0';"
    },
    "Lang-38": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (mTimeZoneForced) { calendar = (Calendar) calendar.clone(); } return applyRules(calendar); }",
                "patch_diff": "if (mTimeZoneForced) { calendar = (Calendar) calendar.clone(); } return applyRules(calendar); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (mTimeZoneForced) { calendar = (Calendar) calendar.clone(); } else if (mTimeZoneForced == null) {",
                "patch_diff": "if (mTimeZoneForced) { calendar = (Calendar) calendar.clone(); } else if (mTimeZoneForced == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (mTimeZoneForced) { calendar = (Calendar) calendar.clone(); } return applyRules(calendar, buf); }",
                "patch_diff": "if (mTimeZoneForced) { calendar = (Calendar) calendar.clone(); } return applyRules(calendar, buf); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (mTimeZoneForced) { calendar = (Calendar) calendar.clone(); } return applyRules(calendar);",
                "patch_diff": "if (mTimeZoneForced) { calendar = (Calendar) calendar.clone(); } return applyRules(calendar);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (mTimeZoneForced) { calendar = (Calendar) calendar.clone(); } return applyRules(calendar); } else if (mTimeZoneForced == null) {",
                "patch_diff": "if (mTimeZoneForced) { calendar = (Calendar) calendar.clone(); } return applyRules(calendar); } else if (mTimeZoneForced == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (mTimeZoneForced) { calendar = (Calendar) calendar.clone(); if (mTimeZoneForced == null) {",
                "patch_diff": "if (mTimeZoneForced) { calendar = (Calendar) calendar.clone(); if (mTimeZoneForced == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (mTimeZoneForced) { calendar = (Calendar) calendar.clone(); } return applyRules(mTimeZone); }",
                "patch_diff": "if (mTimeZoneForced) { calendar = (Calendar) calendar.clone(); } return applyRules(mTimeZone); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (mTimeZoneForced) { calendar = (Calendar) calendar.clone(); } return applyRules(Calendar.MIN_VALUE; } else if (mTimeZoneForced == null) {",
                "patch_diff": "if (mTimeZoneForced) { calendar = (Calendar) calendar.clone(); } return applyRules(Calendar.MIN_VALUE; } else if (mTimeZoneForced == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (mTimeZoneForced) { calendar = (Calendar) calendar.clone(); } return applyRules(calendar); } else if (mTimeZoneForced; } else if (mTimeZoneForced == null) {",
                "patch_diff": "if (mTimeZoneForced) { calendar = (Calendar) calendar.clone(); } return applyRules(calendar); } else if (mTimeZoneForced; } else if (mTimeZoneForced == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (mTimeZoneForced) { calendar = (Calendar) calendar.clone(); } return applyRules(calendar); } else if (mTimeZoneForced == null) { calendar.get(Calendar.MONTH, buf); } else if (mTimeZoneForced == null) {",
                "patch_diff": "if (mTimeZoneForced) { calendar = (Calendar) calendar.clone(); } return applyRules(calendar); } else if (mTimeZoneForced == null) { calendar.get(Calendar.MONTH, buf); } else if (mTimeZoneForced == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "calendar.getTime(); /// LANG-538"
    },
    "Cli-15": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (valueList == null) || valueList.isEmpty()) { valueList = defaultValues; } // augment the list with the default values if ((valueList == null) || valueList.get(option); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-15/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\t2022-07-19 10:46:43.344246079 +0200\n+++ /tmp/tmpxh0bk3tu.java\t2022-07-19 10:46:43.384245863 +0200\n@@ -112,18 +112,11 @@\n                           List defaultValues) {\n         // initialize the return list\n         List valueList = (List) values.get(option);\n \n         // grab the correct default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = defaultValues;\n-        }\n-\n-        // augment the list with the default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = (List) this.defaultValues.get(option);\n-        }\n+if (valueList == null) || valueList.isEmpty()) { valueList = defaultValues; } // augment the list with the default values if ((valueList == null) || valueList.get(option); }\n                 // if there are more default values as specified, add them to\n                 // the list.\n                     // copy the list first\n         \n         return valueList == null ? Collections.EMPTY_LIST : valueList;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (valueList == null) || valueList.isEmpty()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-15/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\t2022-07-19 10:46:45.068236801 +0200\n+++ /tmp/tmpn7hjnw8l.java\t2022-07-19 10:46:45.068236801 +0200\n@@ -112,18 +112,11 @@\n                           List defaultValues) {\n         // initialize the return list\n         List valueList = (List) values.get(option);\n \n         // grab the correct default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = defaultValues;\n-        }\n-\n-        // augment the list with the default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = (List) this.defaultValues.get(option);\n-        }\n+if (valueList == null) || valueList.isEmpty()) {\n                 // if there are more default values as specified, add them to\n                 // the list.\n                     // copy the list first\n         \n         return valueList == null ? Collections.EMPTY_LIST : valueList;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (valueList == null) || valueList.isEmpty()) { valueList = defaultValues; } // augment the list with the default values = (valueList) || valueList.get(option); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-15/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\t2022-07-19 10:46:46.544228856 +0200\n+++ /tmp/tmpbnlfvk1n.java\t2022-07-19 10:46:46.544228856 +0200\n@@ -112,18 +112,11 @@\n                           List defaultValues) {\n         // initialize the return list\n         List valueList = (List) values.get(option);\n \n         // grab the correct default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = defaultValues;\n-        }\n-\n-        // augment the list with the default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = (List) this.defaultValues.get(option);\n-        }\n+if (valueList == null) || valueList.isEmpty()) { valueList = defaultValues; } // augment the list with the default values = (valueList) || valueList.get(option); }\n                 // if there are more default values as specified, add them to\n                 // the list.\n                     // copy the list first\n         \n         return valueList == null ? Collections.EMPTY_LIST : valueList;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if ((valueList == null) || valueList.isEmpty()) { valueList = defaultValues; } // augment the list with the default values if ((valueList == null) || valueList.get(option); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-15/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\t2022-07-19 10:46:48.112220416 +0200\n+++ /tmp/tmpcgau0zjn.java\t2022-07-19 10:46:48.112220416 +0200\n@@ -112,18 +112,11 @@\n                           List defaultValues) {\n         // initialize the return list\n         List valueList = (List) values.get(option);\n \n         // grab the correct default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = defaultValues;\n-        }\n-\n-        // augment the list with the default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = (List) this.defaultValues.get(option);\n-        }\n+if ((valueList == null) || valueList.isEmpty()) { valueList = defaultValues; } // augment the list with the default values if ((valueList == null) || valueList.get(option); }\n                 // if there are more default values as specified, add them to\n                 // the list.\n                     // copy the list first\n         \n         return valueList == null ? Collections.EMPTY_LIST : valueList;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (valueList!= null) || valueList.isEmpty()) { valueList = defaultValues; } // augment the list with the default values if ((valueList == null) || valueList.get(option); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-15/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\t2022-07-19 10:46:51.464202369 +0200\n+++ /tmp/tmp0ihnakyd.java\t2022-07-19 10:46:51.468202348 +0200\n@@ -112,18 +112,11 @@\n                           List defaultValues) {\n         // initialize the return list\n         List valueList = (List) values.get(option);\n \n         // grab the correct default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = defaultValues;\n-        }\n-\n-        // augment the list with the default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = (List) this.defaultValues.get(option);\n-        }\n+if (valueList!= null) || valueList.isEmpty()) { valueList = defaultValues; } // augment the list with the default values if ((valueList == null) || valueList.get(option); }\n                 // if there are more default values as specified, add them to\n                 // the list.\n                     // copy the list first\n         \n         return valueList == null ? Collections.EMPTY_LIST : valueList;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (valueList == null) || valueList.isEmpty()) { valueList = defaultValues; } // augment the list with the default valueList.get(option); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-15/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\t2022-07-19 10:46:52.988194163 +0200\n+++ /tmp/tmpg5xvccn9.java\t2022-07-19 10:46:52.988194163 +0200\n@@ -112,18 +112,11 @@\n                           List defaultValues) {\n         // initialize the return list\n         List valueList = (List) values.get(option);\n \n         // grab the correct default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = defaultValues;\n-        }\n-\n-        // augment the list with the default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = (List) this.defaultValues.get(option);\n-        }\n+if (valueList == null) || valueList.isEmpty()) { valueList = defaultValues; } // augment the list with the default valueList.get(option); }\n                 // if there are more default values as specified, add them to\n                 // the list.\n                     // copy the list first\n         \n         return valueList == null ? Collections.EMPTY_LIST : valueList;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (valueList == null) || valueList.isEmpty()) { valueList = defaultValues; } // augment the list with the default values if ((valueList == null) || valueList.isEmpty()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-15/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\t2022-07-19 10:46:54.568185653 +0200\n+++ /tmp/tmpxa3atwdv.java\t2022-07-19 10:46:54.568185653 +0200\n@@ -112,18 +112,11 @@\n                           List defaultValues) {\n         // initialize the return list\n         List valueList = (List) values.get(option);\n \n         // grab the correct default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = defaultValues;\n-        }\n-\n-        // augment the list with the default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = (List) this.defaultValues.get(option);\n-        }\n+if (valueList == null) || valueList.isEmpty()) { valueList = defaultValues; } // augment the list with the default values if ((valueList == null) || valueList.isEmpty()) {\n                 // if there are more default values as specified, add them to\n                 // the list.\n                     // copy the list first\n         \n         return valueList == null ? Collections.EMPTY_LIST : valueList;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (valueList == null) || valueList.isEmpty()) { valueList = defaultValues; if (valueList == null) || valueList.get(option); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-15/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\t2022-07-19 10:46:56.100177401 +0200\n+++ /tmp/tmpruqhtaz5.java\t2022-07-19 10:46:56.100177401 +0200\n@@ -112,18 +112,11 @@\n                           List defaultValues) {\n         // initialize the return list\n         List valueList = (List) values.get(option);\n \n         // grab the correct default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = defaultValues;\n-        }\n-\n-        // augment the list with the default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = (List) this.defaultValues.get(option);\n-        }\n+if (valueList == null) || valueList.isEmpty()) { valueList = defaultValues; if (valueList == null) || valueList.get(option); }\n                 // if there are more default values as specified, add them to\n                 // the list.\n                     // copy the list first\n         \n         return valueList == null ? Collections.EMPTY_LIST : valueList;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (valueList == null) || valueList.isEmpty()) { valueList = defaultValues; } // augment the list with the default values.get(option); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-15/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\t2022-07-19 10:46:57.620169212 +0200\n+++ /tmp/tmpv1iebv0m.java\t2022-07-19 10:46:57.620169212 +0200\n@@ -112,18 +112,11 @@\n                           List defaultValues) {\n         // initialize the return list\n         List valueList = (List) values.get(option);\n \n         // grab the correct default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = defaultValues;\n-        }\n-\n-        // augment the list with the default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = (List) this.defaultValues.get(option);\n-        }\n+if (valueList == null) || valueList.isEmpty()) { valueList = defaultValues; } // augment the list with the default values.get(option); }\n                 // if there are more default values as specified, add them to\n                 // the list.\n                     // copy the list first\n         \n         return valueList == null ? Collections.EMPTY_LIST : valueList;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (valueList == null) || valueList.isEmpty()) { valueList = defaultValues; } // augment the list with the default values if ((valueList) == null) || valueList.get(option); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-15/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\t2022-07-19 10:46:59.152160961 +0200\n+++ /tmp/tmp1qyspvcj.java\t2022-07-19 10:46:59.152160961 +0200\n@@ -112,18 +112,11 @@\n                           List defaultValues) {\n         // initialize the return list\n         List valueList = (List) values.get(option);\n \n         // grab the correct default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = defaultValues;\n-        }\n-\n-        // augment the list with the default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = (List) this.defaultValues.get(option);\n-        }\n+if (valueList == null) || valueList.isEmpty()) { valueList = defaultValues; } // augment the list with the default values if ((valueList) == null) || valueList.get(option); }\n                 // if there are more default values as specified, add them to\n                 // the list.\n                     // copy the list first\n         \n         return valueList == null ? Collections.EMPTY_LIST : valueList;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if ((valueList == null) || valueList.isEmpty()) { valueList = defaultValues; } // augment the list with the default values if ((valueList == null) || valueList.isEmpty()) { valueList = (List) this.defaultValues.get(option); }",
        "fixed_line": "if (defaultValues == null || defaultValues.isEmpty()) { defaultValues = (List) this.defaultValues.get(option); } // augment the list with the default values if (defaultValues != null && !defaultValues.isEmpty()) { if (valueList == null || valueList.isEmpty()) { valueList = defaultValues; } else { // if there are more default values as specified, add them to // the list. if (defaultValues.size() > valueList.size()) { // copy the list first valueList = new ArrayList(valueList); for (int i=valueList.size(); i<defaultValues.size(); i++) { valueList.add(defaultValues.get(i)); } } } }"
    }
}